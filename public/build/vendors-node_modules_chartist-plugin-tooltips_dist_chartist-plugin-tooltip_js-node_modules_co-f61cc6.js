(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_chartist-plugin-tooltips_dist_chartist-plugin-tooltip_js-node_modules_co-f61cc6"],{

/***/ "./node_modules/chartist-plugin-tooltips/dist/chartist-plugin-tooltip.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/chartist-plugin-tooltips/dist/chartist-plugin-tooltip.js ***!
  \*******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! chartist */ "./node_modules/chartist/dist/chartist.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Chartist) {
      return (root.returnExportsGlobal = factory(Chartist));
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(this, function (Chartist) {

  /**
   * Chartist.js plugin to display a data label on top of the points in a line chart.
   *
   */
  /* global Chartist */
  (function (window, document, Chartist) {
    'use strict';

    var defaultOptions = {
      currency: undefined,
      currencyFormatCallback: undefined,
      tooltipOffset: {
        x: 0,
        y: -20
      },
      anchorToPoint: false,
      appendToBody: false,
      class: undefined,
      pointClass: 'ct-point'
    };

    Chartist.plugins = Chartist.plugins || {};
    Chartist.plugins.tooltip = function (options) {
      options = Chartist.extend({}, defaultOptions, options);

      return function tooltip(chart) {
        var tooltipSelector = options.pointClass;
        if (chart instanceof Chartist.Bar) {
          tooltipSelector = 'ct-bar';
        } else if (chart instanceof Chartist.Pie) {
          // Added support for donut graph
          if (chart.options.donut) {
            tooltipSelector = 'ct-slice-donut';
          } else {
            tooltipSelector = 'ct-slice-pie';
          }
        }

        var $chart = chart.container;
        var $toolTip = $chart.querySelector('.chartist-tooltip');
        if (!$toolTip) {
          $toolTip = document.createElement('div');
          $toolTip.className = (!options.class) ? 'chartist-tooltip' : 'chartist-tooltip ' + options.class;
          if (!options.appendToBody) {
            $chart.appendChild($toolTip);
          } else {
            document.body.appendChild($toolTip);
          }
        }
        var height = $toolTip.offsetHeight;
        var width = $toolTip.offsetWidth;

        hide($toolTip);

        function on(event, selector, callback) {
          $chart.addEventListener(event, function (e) {
            if (!selector || hasClass(e.target, selector))
              callback(e);
          });
        }

        on('mouseover', tooltipSelector, function (event) {
          var $point = event.target;
          var tooltipText = '';

          var isPieChart = (chart instanceof Chartist.Pie) ? $point : $point.parentNode;
          var seriesName = (isPieChart) ? $point.parentNode.getAttribute('ct:meta') || $point.parentNode.getAttribute('ct:series-name') : '';
          var meta = $point.getAttribute('ct:meta') || seriesName || '';
          var hasMeta = !!meta;
          var value = $point.getAttribute('ct:value');

          if (options.transformTooltipTextFnc && typeof options.transformTooltipTextFnc === 'function') {
            value = options.transformTooltipTextFnc(value);
          }

          if (options.tooltipFnc && typeof options.tooltipFnc === 'function') {
            tooltipText = options.tooltipFnc(meta, value);
          } else {
            if (options.metaIsHTML) {
              var txt = document.createElement('textarea');
              txt.innerHTML = meta;
              meta = txt.value;
            }

            meta = '<span class="chartist-tooltip-meta">' + meta + '</span>';

            if (hasMeta) {
              tooltipText += meta + '<br>';
            } else {
              // For Pie Charts also take the labels into account
              // Could add support for more charts here as well!
              if (chart instanceof Chartist.Pie) {
                var label = next($point, 'ct-label');
                if (label) {
                  tooltipText += text(label) + '<br>';
                }
              }
            }

            if (value) {
              if (options.currency) {
                if (options.currencyFormatCallback != undefined) {
                  value = options.currencyFormatCallback(value, options);
                } else {
                  value = options.currency + value.replace(/(\d)(?=(\d{3})+(?:\.\d+)?$)/g, '$1,');
                }
              }
              value = '<span class="chartist-tooltip-value">' + value + '</span>';
              tooltipText += value;
            }
          }

          if(tooltipText) {
            $toolTip.innerHTML = tooltipText;
            setPosition(event);
            show($toolTip);

            // Remember height and width to avoid wrong position in IE
            height = $toolTip.offsetHeight;
            width = $toolTip.offsetWidth;
          }
        });

        on('mouseout', tooltipSelector, function () {
          hide($toolTip);
        });

        on('mousemove', null, function (event) {
          if (false === options.anchorToPoint)
            setPosition(event);
        });

        function setPosition(event) {
          height = height || $toolTip.offsetHeight;
          width = width || $toolTip.offsetWidth;
          var offsetX = - width / 2 + options.tooltipOffset.x
          var offsetY = - height + options.tooltipOffset.y;
          var anchorX, anchorY;

          if (!options.appendToBody) {
            var box = $chart.getBoundingClientRect();
            var left = event.pageX - box.left - window.pageXOffset ;
            var top = event.pageY - box.top - window.pageYOffset ;

            if (true === options.anchorToPoint && event.target.x2 && event.target.y2) {
              anchorX = parseInt(event.target.x2.baseVal.value);
              anchorY = parseInt(event.target.y2.baseVal.value);
            }

            $toolTip.style.top = (anchorY || top) + offsetY + 'px';
            $toolTip.style.left = (anchorX || left) + offsetX + 'px';
          } else {
            $toolTip.style.top = event.pageY + offsetY + 'px';
            $toolTip.style.left = event.pageX + offsetX + 'px';
          }
        }
      }
    };

    function show(element) {
      if(!hasClass(element, 'tooltip-show')) {
        element.className = element.className + ' tooltip-show';
      }
    }

    function hide(element) {
      var regex = new RegExp('tooltip-show' + '\\s*', 'gi');
      element.className = element.className.replace(regex, '').trim();
    }

    function hasClass(element, className) {
      return (' ' + element.getAttribute('class') + ' ').indexOf(' ' + className + ' ') > -1;
    }

    function next(element, className) {
      do {
        element = element.nextSibling;
      } while (element && !hasClass(element, className));
      return element;
    }

    function text(element) {
      return element.innerText || element.textContent;
    }

  } (window, document, Chartist));

  return Chartist.plugins.tooltips;

}));


/***/ }),

/***/ "./node_modules/chartist/dist/chartist.js":
/*!************************************************!*\
  !*** ./node_modules/chartist/dist/chartist.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
  if (true) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return (root['Chartist'] = factory());
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(this, function () {

/* Chartist.js 0.11.4
 * Copyright Â© 2019 Gion Kunz
 * Free to use under either the WTFPL license or the MIT license.
 * https://raw.githubusercontent.com/gionkunz/chartist-js/master/LICENSE-WTFPL
 * https://raw.githubusercontent.com/gionkunz/chartist-js/master/LICENSE-MIT
 */
/**
 * The core module of Chartist that is mainly providing static functions and higher level functions for chart modules.
 *
 * @module Chartist.Core
 */
var Chartist = {
  version: '0.11.4'
};

(function (globalRoot, Chartist) {
  'use strict';

  var window = globalRoot.window;
  var document = globalRoot.document;

  /**
   * This object contains all namespaces used within Chartist.
   *
   * @memberof Chartist.Core
   * @type {{svg: string, xmlns: string, xhtml: string, xlink: string, ct: string}}
   */
  Chartist.namespaces = {
    svg: 'http://www.w3.org/2000/svg',
    xmlns: 'http://www.w3.org/2000/xmlns/',
    xhtml: 'http://www.w3.org/1999/xhtml',
    xlink: 'http://www.w3.org/1999/xlink',
    ct: 'http://gionkunz.github.com/chartist-js/ct'
  };

  /**
   * Helps to simplify functional style code
   *
   * @memberof Chartist.Core
   * @param {*} n This exact value will be returned by the noop function
   * @return {*} The same value that was provided to the n parameter
   */
  Chartist.noop = function (n) {
    return n;
  };

  /**
   * Generates a-z from a number 0 to 26
   *
   * @memberof Chartist.Core
   * @param {Number} n A number from 0 to 26 that will result in a letter a-z
   * @return {String} A character from a-z based on the input number n
   */
  Chartist.alphaNumerate = function (n) {
    // Limit to a-z
    return String.fromCharCode(97 + n % 26);
  };

  /**
   * Simple recursive object extend
   *
   * @memberof Chartist.Core
   * @param {Object} target Target object where the source will be merged into
   * @param {Object...} sources This object (objects) will be merged into target and then target is returned
   * @return {Object} An object that has the same reference as target but is extended and merged with the properties of source
   */
  Chartist.extend = function (target) {
    var i, source, sourceProp;
    target = target || {};

    for (i = 1; i < arguments.length; i++) {
      source = arguments[i];
      for (var prop in source) {
        sourceProp = source[prop];
        if (typeof sourceProp === 'object' && sourceProp !== null && !(sourceProp instanceof Array)) {
          target[prop] = Chartist.extend(target[prop], sourceProp);
        } else {
          target[prop] = sourceProp;
        }
      }
    }

    return target;
  };

  /**
   * Replaces all occurrences of subStr in str with newSubStr and returns a new string.
   *
   * @memberof Chartist.Core
   * @param {String} str
   * @param {String} subStr
   * @param {String} newSubStr
   * @return {String}
   */
  Chartist.replaceAll = function(str, subStr, newSubStr) {
    return str.replace(new RegExp(subStr, 'g'), newSubStr);
  };

  /**
   * Converts a number to a string with a unit. If a string is passed then this will be returned unmodified.
   *
   * @memberof Chartist.Core
   * @param {Number} value
   * @param {String} unit
   * @return {String} Returns the passed number value with unit.
   */
  Chartist.ensureUnit = function(value, unit) {
    if(typeof value === 'number') {
      value = value + unit;
    }

    return value;
  };

  /**
   * Converts a number or string to a quantity object.
   *
   * @memberof Chartist.Core
   * @param {String|Number} input
   * @return {Object} Returns an object containing the value as number and the unit as string.
   */
  Chartist.quantity = function(input) {
    if (typeof input === 'string') {
      var match = (/^(\d+)\s*(.*)$/g).exec(input);
      return {
        value : +match[1],
        unit: match[2] || undefined
      };
    }
    return { value: input };
  };

  /**
   * This is a wrapper around document.querySelector that will return the query if it's already of type Node
   *
   * @memberof Chartist.Core
   * @param {String|Node} query The query to use for selecting a Node or a DOM node that will be returned directly
   * @return {Node}
   */
  Chartist.querySelector = function(query) {
    return query instanceof Node ? query : document.querySelector(query);
  };

  /**
   * Functional style helper to produce array with given length initialized with undefined values
   *
   * @memberof Chartist.Core
   * @param length
   * @return {Array}
   */
  Chartist.times = function(length) {
    return Array.apply(null, new Array(length));
  };

  /**
   * Sum helper to be used in reduce functions
   *
   * @memberof Chartist.Core
   * @param previous
   * @param current
   * @return {*}
   */
  Chartist.sum = function(previous, current) {
    return previous + (current ? current : 0);
  };

  /**
   * Multiply helper to be used in `Array.map` for multiplying each value of an array with a factor.
   *
   * @memberof Chartist.Core
   * @param {Number} factor
   * @returns {Function} Function that can be used in `Array.map` to multiply each value in an array
   */
  Chartist.mapMultiply = function(factor) {
    return function(num) {
      return num * factor;
    };
  };

  /**
   * Add helper to be used in `Array.map` for adding a addend to each value of an array.
   *
   * @memberof Chartist.Core
   * @param {Number} addend
   * @returns {Function} Function that can be used in `Array.map` to add a addend to each value in an array
   */
  Chartist.mapAdd = function(addend) {
    return function(num) {
      return num + addend;
    };
  };

  /**
   * Map for multi dimensional arrays where their nested arrays will be mapped in serial. The output array will have the length of the largest nested array. The callback function is called with variable arguments where each argument is the nested array value (or undefined if there are no more values).
   *
   * @memberof Chartist.Core
   * @param arr
   * @param cb
   * @return {Array}
   */
  Chartist.serialMap = function(arr, cb) {
    var result = [],
        length = Math.max.apply(null, arr.map(function(e) {
          return e.length;
        }));

    Chartist.times(length).forEach(function(e, index) {
      var args = arr.map(function(e) {
        return e[index];
      });

      result[index] = cb.apply(null, args);
    });

    return result;
  };

  /**
   * This helper function can be used to round values with certain precision level after decimal. This is used to prevent rounding errors near float point precision limit.
   *
   * @memberof Chartist.Core
   * @param {Number} value The value that should be rounded with precision
   * @param {Number} [digits] The number of digits after decimal used to do the rounding
   * @returns {number} Rounded value
   */
  Chartist.roundWithPrecision = function(value, digits) {
    var precision = Math.pow(10, digits || Chartist.precision);
    return Math.round(value * precision) / precision;
  };

  /**
   * Precision level used internally in Chartist for rounding. If you require more decimal places you can increase this number.
   *
   * @memberof Chartist.Core
   * @type {number}
   */
  Chartist.precision = 8;

  /**
   * A map with characters to escape for strings to be safely used as attribute values.
   *
   * @memberof Chartist.Core
   * @type {Object}
   */
  Chartist.escapingMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&#039;'
  };

  /**
   * This function serializes arbitrary data to a string. In case of data that can't be easily converted to a string, this function will create a wrapper object and serialize the data using JSON.stringify. The outcoming string will always be escaped using Chartist.escapingMap.
   * If called with null or undefined the function will return immediately with null or undefined.
   *
   * @memberof Chartist.Core
   * @param {Number|String|Object} data
   * @return {String}
   */
  Chartist.serialize = function(data) {
    if(data === null || data === undefined) {
      return data;
    } else if(typeof data === 'number') {
      data = ''+data;
    } else if(typeof data === 'object') {
      data = JSON.stringify({data: data});
    }

    return Object.keys(Chartist.escapingMap).reduce(function(result, key) {
      return Chartist.replaceAll(result, key, Chartist.escapingMap[key]);
    }, data);
  };

  /**
   * This function de-serializes a string previously serialized with Chartist.serialize. The string will always be unescaped using Chartist.escapingMap before it's returned. Based on the input value the return type can be Number, String or Object. JSON.parse is used with try / catch to see if the unescaped string can be parsed into an Object and this Object will be returned on success.
   *
   * @memberof Chartist.Core
   * @param {String} data
   * @return {String|Number|Object}
   */
  Chartist.deserialize = function(data) {
    if(typeof data !== 'string') {
      return data;
    }

    data = Object.keys(Chartist.escapingMap).reduce(function(result, key) {
      return Chartist.replaceAll(result, Chartist.escapingMap[key], key);
    }, data);

    try {
      data = JSON.parse(data);
      data = data.data !== undefined ? data.data : data;
    } catch(e) {}

    return data;
  };

  /**
   * Create or reinitialize the SVG element for the chart
   *
   * @memberof Chartist.Core
   * @param {Node} container The containing DOM Node object that will be used to plant the SVG element
   * @param {String} width Set the width of the SVG element. Default is 100%
   * @param {String} height Set the height of the SVG element. Default is 100%
   * @param {String} className Specify a class to be added to the SVG element
   * @return {Object} The created/reinitialized SVG element
   */
  Chartist.createSvg = function (container, width, height, className) {
    var svg;

    width = width || '100%';
    height = height || '100%';

    // Check if there is a previous SVG element in the container that contains the Chartist XML namespace and remove it
    // Since the DOM API does not support namespaces we need to manually search the returned list http://www.w3.org/TR/selectors-api/
    Array.prototype.slice.call(container.querySelectorAll('svg')).filter(function filterChartistSvgObjects(svg) {
      return svg.getAttributeNS(Chartist.namespaces.xmlns, 'ct');
    }).forEach(function removePreviousElement(svg) {
      container.removeChild(svg);
    });

    // Create svg object with width and height or use 100% as default
    svg = new Chartist.Svg('svg').attr({
      width: width,
      height: height
    }).addClass(className);

    svg._node.style.width = width;
    svg._node.style.height = height;

    // Add the DOM node to our container
    container.appendChild(svg._node);

    return svg;
  };

  /**
   * Ensures that the data object passed as second argument to the charts is present and correctly initialized.
   *
   * @param  {Object} data The data object that is passed as second argument to the charts
   * @return {Object} The normalized data object
   */
  Chartist.normalizeData = function(data, reverse, multi) {
    var labelCount;
    var output = {
      raw: data,
      normalized: {}
    };

    // Check if we should generate some labels based on existing series data
    output.normalized.series = Chartist.getDataArray({
      series: data.series || []
    }, reverse, multi);

    // If all elements of the normalized data array are arrays we're dealing with
    // multi series data and we need to find the largest series if they are un-even
    if (output.normalized.series.every(function(value) {
        return value instanceof Array;
      })) {
      // Getting the series with the the most elements
      labelCount = Math.max.apply(null, output.normalized.series.map(function(series) {
        return series.length;
      }));
    } else {
      // We're dealing with Pie data so we just take the normalized array length
      labelCount = output.normalized.series.length;
    }

    output.normalized.labels = (data.labels || []).slice();
    // Padding the labels to labelCount with empty strings
    Array.prototype.push.apply(
      output.normalized.labels,
      Chartist.times(Math.max(0, labelCount - output.normalized.labels.length)).map(function() {
        return '';
      })
    );

    if(reverse) {
      Chartist.reverseData(output.normalized);
    }

    return output;
  };

  /**
   * This function safely checks if an objects has an owned property.
   *
   * @param {Object} object The object where to check for a property
   * @param {string} property The property name
   * @returns {boolean} Returns true if the object owns the specified property
   */
  Chartist.safeHasProperty = function(object, property) {
    return object !== null &&
      typeof object === 'object' &&
      object.hasOwnProperty(property);
  };

  /**
   * Checks if a value is considered a hole in the data series.
   *
   * @param {*} value
   * @returns {boolean} True if the value is considered a data hole
   */
  Chartist.isDataHoleValue = function(value) {
    return value === null ||
      value === undefined ||
      (typeof value === 'number' && isNaN(value));
  };

  /**
   * Reverses the series, labels and series data arrays.
   *
   * @memberof Chartist.Core
   * @param data
   */
  Chartist.reverseData = function(data) {
    data.labels.reverse();
    data.series.reverse();
    for (var i = 0; i < data.series.length; i++) {
      if(typeof(data.series[i]) === 'object' && data.series[i].data !== undefined) {
        data.series[i].data.reverse();
      } else if(data.series[i] instanceof Array) {
        data.series[i].reverse();
      }
    }
  };

  /**
   * Convert data series into plain array
   *
   * @memberof Chartist.Core
   * @param {Object} data The series object that contains the data to be visualized in the chart
   * @param {Boolean} [reverse] If true the whole data is reversed by the getDataArray call. This will modify the data object passed as first parameter. The labels as well as the series order is reversed. The whole series data arrays are reversed too.
   * @param {Boolean} [multi] Create a multi dimensional array from a series data array where a value object with `x` and `y` values will be created.
   * @return {Array} A plain array that contains the data to be visualized in the chart
   */
  Chartist.getDataArray = function(data, reverse, multi) {
    // Recursively walks through nested arrays and convert string values to numbers and objects with value properties
    // to values. Check the tests in data core -> data normalization for a detailed specification of expected values
    function recursiveConvert(value) {
      if(Chartist.safeHasProperty(value, 'value')) {
        // We are dealing with value object notation so we need to recurse on value property
        return recursiveConvert(value.value);
      } else if(Chartist.safeHasProperty(value, 'data')) {
        // We are dealing with series object notation so we need to recurse on data property
        return recursiveConvert(value.data);
      } else if(value instanceof Array) {
        // Data is of type array so we need to recurse on the series
        return value.map(recursiveConvert);
      } else if(Chartist.isDataHoleValue(value)) {
        // We're dealing with a hole in the data and therefore need to return undefined
        // We're also returning undefined for multi value output
        return undefined;
      } else {
        // We need to prepare multi value output (x and y data)
        if(multi) {
          var multiValue = {};

          // Single series value arrays are assumed to specify the Y-Axis value
          // For example: [1, 2] => [{x: undefined, y: 1}, {x: undefined, y: 2}]
          // If multi is a string then it's assumed that it specified which dimension should be filled as default
          if(typeof multi === 'string') {
            multiValue[multi] = Chartist.getNumberOrUndefined(value);
          } else {
            multiValue.y = Chartist.getNumberOrUndefined(value);
          }

          multiValue.x = value.hasOwnProperty('x') ? Chartist.getNumberOrUndefined(value.x) : multiValue.x;
          multiValue.y = value.hasOwnProperty('y') ? Chartist.getNumberOrUndefined(value.y) : multiValue.y;

          return multiValue;

        } else {
          // We can return simple data
          return Chartist.getNumberOrUndefined(value);
        }
      }
    }

    return data.series.map(recursiveConvert);
  };

  /**
   * Converts a number into a padding object.
   *
   * @memberof Chartist.Core
   * @param {Object|Number} padding
   * @param {Number} [fallback] This value is used to fill missing values if a incomplete padding object was passed
   * @returns {Object} Returns a padding object containing top, right, bottom, left properties filled with the padding number passed in as argument. If the argument is something else than a number (presumably already a correct padding object) then this argument is directly returned.
   */
  Chartist.normalizePadding = function(padding, fallback) {
    fallback = fallback || 0;

    return typeof padding === 'number' ? {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    } : {
      top: typeof padding.top === 'number' ? padding.top : fallback,
      right: typeof padding.right === 'number' ? padding.right : fallback,
      bottom: typeof padding.bottom === 'number' ? padding.bottom : fallback,
      left: typeof padding.left === 'number' ? padding.left : fallback
    };
  };

  Chartist.getMetaData = function(series, index) {
    var value = series.data ? series.data[index] : series[index];
    return value ? value.meta : undefined;
  };

  /**
   * Calculate the order of magnitude for the chart scale
   *
   * @memberof Chartist.Core
   * @param {Number} value The value Range of the chart
   * @return {Number} The order of magnitude
   */
  Chartist.orderOfMagnitude = function (value) {
    return Math.floor(Math.log(Math.abs(value)) / Math.LN10);
  };

  /**
   * Project a data length into screen coordinates (pixels)
   *
   * @memberof Chartist.Core
   * @param {Object} axisLength The svg element for the chart
   * @param {Number} length Single data value from a series array
   * @param {Object} bounds All the values to set the bounds of the chart
   * @return {Number} The projected data length in pixels
   */
  Chartist.projectLength = function (axisLength, length, bounds) {
    return length / bounds.range * axisLength;
  };

  /**
   * Get the height of the area in the chart for the data series
   *
   * @memberof Chartist.Core
   * @param {Object} svg The svg element for the chart
   * @param {Object} options The Object that contains all the optional values for the chart
   * @return {Number} The height of the area in the chart for the data series
   */
  Chartist.getAvailableHeight = function (svg, options) {
    return Math.max((Chartist.quantity(options.height).value || svg.height()) - (options.chartPadding.top +  options.chartPadding.bottom) - options.axisX.offset, 0);
  };

  /**
   * Get highest and lowest value of data array. This Array contains the data that will be visualized in the chart.
   *
   * @memberof Chartist.Core
   * @param {Array} data The array that contains the data to be visualized in the chart
   * @param {Object} options The Object that contains the chart options
   * @param {String} dimension Axis dimension 'x' or 'y' used to access the correct value and high / low configuration
   * @return {Object} An object that contains the highest and lowest value that will be visualized on the chart.
   */
  Chartist.getHighLow = function (data, options, dimension) {
    // TODO: Remove workaround for deprecated global high / low config. Axis high / low configuration is preferred
    options = Chartist.extend({}, options, dimension ? options['axis' + dimension.toUpperCase()] : {});

    var highLow = {
        high: options.high === undefined ? -Number.MAX_VALUE : +options.high,
        low: options.low === undefined ? Number.MAX_VALUE : +options.low
      };
    var findHigh = options.high === undefined;
    var findLow = options.low === undefined;

    // Function to recursively walk through arrays and find highest and lowest number
    function recursiveHighLow(data) {
      if(data === undefined) {
        return undefined;
      } else if(data instanceof Array) {
        for (var i = 0; i < data.length; i++) {
          recursiveHighLow(data[i]);
        }
      } else {
        var value = dimension ? +data[dimension] : +data;

        if (findHigh && value > highLow.high) {
          highLow.high = value;
        }

        if (findLow && value < highLow.low) {
          highLow.low = value;
        }
      }
    }

    // Start to find highest and lowest number recursively
    if(findHigh || findLow) {
      recursiveHighLow(data);
    }

    // Overrides of high / low based on reference value, it will make sure that the invisible reference value is
    // used to generate the chart. This is useful when the chart always needs to contain the position of the
    // invisible reference value in the view i.e. for bipolar scales.
    if (options.referenceValue || options.referenceValue === 0) {
      highLow.high = Math.max(options.referenceValue, highLow.high);
      highLow.low = Math.min(options.referenceValue, highLow.low);
    }

    // If high and low are the same because of misconfiguration or flat data (only the same value) we need
    // to set the high or low to 0 depending on the polarity
    if (highLow.high <= highLow.low) {
      // If both values are 0 we set high to 1
      if (highLow.low === 0) {
        highLow.high = 1;
      } else if (highLow.low < 0) {
        // If we have the same negative value for the bounds we set bounds.high to 0
        highLow.high = 0;
      } else if (highLow.high > 0) {
        // If we have the same positive value for the bounds we set bounds.low to 0
        highLow.low = 0;
      } else {
        // If data array was empty, values are Number.MAX_VALUE and -Number.MAX_VALUE. Set bounds to prevent errors
        highLow.high = 1;
        highLow.low = 0;
      }
    }

    return highLow;
  };

  /**
   * Checks if a value can be safely coerced to a number. This includes all values except null which result in finite numbers when coerced. This excludes NaN, since it's not finite.
   *
   * @memberof Chartist.Core
   * @param value
   * @returns {Boolean}
   */
  Chartist.isNumeric = function(value) {
    return value === null ? false : isFinite(value);
  };

  /**
   * Returns true on all falsey values except the numeric value 0.
   *
   * @memberof Chartist.Core
   * @param value
   * @returns {boolean}
   */
  Chartist.isFalseyButZero = function(value) {
    return !value && value !== 0;
  };

  /**
   * Returns a number if the passed parameter is a valid number or the function will return undefined. On all other values than a valid number, this function will return undefined.
   *
   * @memberof Chartist.Core
   * @param value
   * @returns {*}
   */
  Chartist.getNumberOrUndefined = function(value) {
    return Chartist.isNumeric(value) ? +value : undefined;
  };

  /**
   * Checks if provided value object is multi value (contains x or y properties)
   *
   * @memberof Chartist.Core
   * @param value
   */
  Chartist.isMultiValue = function(value) {
    return typeof value === 'object' && ('x' in value || 'y' in value);
  };

  /**
   * Gets a value from a dimension `value.x` or `value.y` while returning value directly if it's a valid numeric value. If the value is not numeric and it's falsey this function will return `defaultValue`.
   *
   * @memberof Chartist.Core
   * @param value
   * @param dimension
   * @param defaultValue
   * @returns {*}
   */
  Chartist.getMultiValue = function(value, dimension) {
    if(Chartist.isMultiValue(value)) {
      return Chartist.getNumberOrUndefined(value[dimension || 'y']);
    } else {
      return Chartist.getNumberOrUndefined(value);
    }
  };

  /**
   * Pollard Rho Algorithm to find smallest factor of an integer value. There are more efficient algorithms for factorization, but this one is quite efficient and not so complex.
   *
   * @memberof Chartist.Core
   * @param {Number} num An integer number where the smallest factor should be searched for
   * @returns {Number} The smallest integer factor of the parameter num.
   */
  Chartist.rho = function(num) {
    if(num === 1) {
      return num;
    }

    function gcd(p, q) {
      if (p % q === 0) {
        return q;
      } else {
        return gcd(q, p % q);
      }
    }

    function f(x) {
      return x * x + 1;
    }

    var x1 = 2, x2 = 2, divisor;
    if (num % 2 === 0) {
      return 2;
    }

    do {
      x1 = f(x1) % num;
      x2 = f(f(x2)) % num;
      divisor = gcd(Math.abs(x1 - x2), num);
    } while (divisor === 1);

    return divisor;
  };

  /**
   * Calculate and retrieve all the bounds for the chart and return them in one array
   *
   * @memberof Chartist.Core
   * @param {Number} axisLength The length of the Axis used for
   * @param {Object} highLow An object containing a high and low property indicating the value range of the chart.
   * @param {Number} scaleMinSpace The minimum projected length a step should result in
   * @param {Boolean} onlyInteger
   * @return {Object} All the values to set the bounds of the chart
   */
  Chartist.getBounds = function (axisLength, highLow, scaleMinSpace, onlyInteger) {
    var i,
      optimizationCounter = 0,
      newMin,
      newMax,
      bounds = {
        high: highLow.high,
        low: highLow.low
      };

    bounds.valueRange = bounds.high - bounds.low;
    bounds.oom = Chartist.orderOfMagnitude(bounds.valueRange);
    bounds.step = Math.pow(10, bounds.oom);
    bounds.min = Math.floor(bounds.low / bounds.step) * bounds.step;
    bounds.max = Math.ceil(bounds.high / bounds.step) * bounds.step;
    bounds.range = bounds.max - bounds.min;
    bounds.numberOfSteps = Math.round(bounds.range / bounds.step);

    // Optimize scale step by checking if subdivision is possible based on horizontalGridMinSpace
    // If we are already below the scaleMinSpace value we will scale up
    var length = Chartist.projectLength(axisLength, bounds.step, bounds);
    var scaleUp = length < scaleMinSpace;
    var smallestFactor = onlyInteger ? Chartist.rho(bounds.range) : 0;

    // First check if we should only use integer steps and if step 1 is still larger than scaleMinSpace so we can use 1
    if(onlyInteger && Chartist.projectLength(axisLength, 1, bounds) >= scaleMinSpace) {
      bounds.step = 1;
    } else if(onlyInteger && smallestFactor < bounds.step && Chartist.projectLength(axisLength, smallestFactor, bounds) >= scaleMinSpace) {
      // If step 1 was too small, we can try the smallest factor of range
      // If the smallest factor is smaller than the current bounds.step and the projected length of smallest factor
      // is larger than the scaleMinSpace we should go for it.
      bounds.step = smallestFactor;
    } else {
      // Trying to divide or multiply by 2 and find the best step value
      while (true) {
        if (scaleUp && Chartist.projectLength(axisLength, bounds.step, bounds) <= scaleMinSpace) {
          bounds.step *= 2;
        } else if (!scaleUp && Chartist.projectLength(axisLength, bounds.step / 2, bounds) >= scaleMinSpace) {
          bounds.step /= 2;
          if(onlyInteger && bounds.step % 1 !== 0) {
            bounds.step *= 2;
            break;
          }
        } else {
          break;
        }

        if(optimizationCounter++ > 1000) {
          throw new Error('Exceeded maximum number of iterations while optimizing scale step!');
        }
      }
    }

    var EPSILON = 2.221E-16;
    bounds.step = Math.max(bounds.step, EPSILON);
    function safeIncrement(value, increment) {
      // If increment is too small use *= (1+EPSILON) as a simple nextafter
      if (value === (value += increment)) {
      	value *= (1 + (increment > 0 ? EPSILON : -EPSILON));
      }
      return value;
    }

    // Narrow min and max based on new step
    newMin = bounds.min;
    newMax = bounds.max;
    while (newMin + bounds.step <= bounds.low) {
    	newMin = safeIncrement(newMin, bounds.step);
    }
    while (newMax - bounds.step >= bounds.high) {
    	newMax = safeIncrement(newMax, -bounds.step);
    }
    bounds.min = newMin;
    bounds.max = newMax;
    bounds.range = bounds.max - bounds.min;

    var values = [];
    for (i = bounds.min; i <= bounds.max; i = safeIncrement(i, bounds.step)) {
      var value = Chartist.roundWithPrecision(i);
      if (value !== values[values.length - 1]) {
        values.push(value);
      }
    }
    bounds.values = values;
    return bounds;
  };

  /**
   * Calculate cartesian coordinates of polar coordinates
   *
   * @memberof Chartist.Core
   * @param {Number} centerX X-axis coordinates of center point of circle segment
   * @param {Number} centerY X-axis coordinates of center point of circle segment
   * @param {Number} radius Radius of circle segment
   * @param {Number} angleInDegrees Angle of circle segment in degrees
   * @return {{x:Number, y:Number}} Coordinates of point on circumference
   */
  Chartist.polarToCartesian = function (centerX, centerY, radius, angleInDegrees) {
    var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;

    return {
      x: centerX + (radius * Math.cos(angleInRadians)),
      y: centerY + (radius * Math.sin(angleInRadians))
    };
  };

  /**
   * Initialize chart drawing rectangle (area where chart is drawn) x1,y1 = bottom left / x2,y2 = top right
   *
   * @memberof Chartist.Core
   * @param {Object} svg The svg element for the chart
   * @param {Object} options The Object that contains all the optional values for the chart
   * @param {Number} [fallbackPadding] The fallback padding if partial padding objects are used
   * @return {Object} The chart rectangles coordinates inside the svg element plus the rectangles measurements
   */
  Chartist.createChartRect = function (svg, options, fallbackPadding) {
    var hasAxis = !!(options.axisX || options.axisY);
    var yAxisOffset = hasAxis ? options.axisY.offset : 0;
    var xAxisOffset = hasAxis ? options.axisX.offset : 0;
    // If width or height results in invalid value (including 0) we fallback to the unitless settings or even 0
    var width = svg.width() || Chartist.quantity(options.width).value || 0;
    var height = svg.height() || Chartist.quantity(options.height).value || 0;
    var normalizedPadding = Chartist.normalizePadding(options.chartPadding, fallbackPadding);

    // If settings were to small to cope with offset (legacy) and padding, we'll adjust
    width = Math.max(width, yAxisOffset + normalizedPadding.left + normalizedPadding.right);
    height = Math.max(height, xAxisOffset + normalizedPadding.top + normalizedPadding.bottom);

    var chartRect = {
      padding: normalizedPadding,
      width: function () {
        return this.x2 - this.x1;
      },
      height: function () {
        return this.y1 - this.y2;
      }
    };

    if(hasAxis) {
      if (options.axisX.position === 'start') {
        chartRect.y2 = normalizedPadding.top + xAxisOffset;
        chartRect.y1 = Math.max(height - normalizedPadding.bottom, chartRect.y2 + 1);
      } else {
        chartRect.y2 = normalizedPadding.top;
        chartRect.y1 = Math.max(height - normalizedPadding.bottom - xAxisOffset, chartRect.y2 + 1);
      }

      if (options.axisY.position === 'start') {
        chartRect.x1 = normalizedPadding.left + yAxisOffset;
        chartRect.x2 = Math.max(width - normalizedPadding.right, chartRect.x1 + 1);
      } else {
        chartRect.x1 = normalizedPadding.left;
        chartRect.x2 = Math.max(width - normalizedPadding.right - yAxisOffset, chartRect.x1 + 1);
      }
    } else {
      chartRect.x1 = normalizedPadding.left;
      chartRect.x2 = Math.max(width - normalizedPadding.right, chartRect.x1 + 1);
      chartRect.y2 = normalizedPadding.top;
      chartRect.y1 = Math.max(height - normalizedPadding.bottom, chartRect.y2 + 1);
    }

    return chartRect;
  };

  /**
   * Creates a grid line based on a projected value.
   *
   * @memberof Chartist.Core
   * @param position
   * @param index
   * @param axis
   * @param offset
   * @param length
   * @param group
   * @param classes
   * @param eventEmitter
   */
  Chartist.createGrid = function(position, index, axis, offset, length, group, classes, eventEmitter) {
    var positionalData = {};
    positionalData[axis.units.pos + '1'] = position;
    positionalData[axis.units.pos + '2'] = position;
    positionalData[axis.counterUnits.pos + '1'] = offset;
    positionalData[axis.counterUnits.pos + '2'] = offset + length;

    var gridElement = group.elem('line', positionalData, classes.join(' '));

    // Event for grid draw
    eventEmitter.emit('draw',
      Chartist.extend({
        type: 'grid',
        axis: axis,
        index: index,
        group: group,
        element: gridElement
      }, positionalData)
    );
  };

  /**
   * Creates a grid background rect and emits the draw event.
   *
   * @memberof Chartist.Core
   * @param gridGroup
   * @param chartRect
   * @param className
   * @param eventEmitter
   */
  Chartist.createGridBackground = function (gridGroup, chartRect, className, eventEmitter) {
    var gridBackground = gridGroup.elem('rect', {
        x: chartRect.x1,
        y: chartRect.y2,
        width: chartRect.width(),
        height: chartRect.height(),
      }, className, true);

      // Event for grid background draw
      eventEmitter.emit('draw', {
        type: 'gridBackground',
        group: gridGroup,
        element: gridBackground
      });
  };

  /**
   * Creates a label based on a projected value and an axis.
   *
   * @memberof Chartist.Core
   * @param position
   * @param length
   * @param index
   * @param labels
   * @param axis
   * @param axisOffset
   * @param labelOffset
   * @param group
   * @param classes
   * @param useForeignObject
   * @param eventEmitter
   */
  Chartist.createLabel = function(position, length, index, labels, axis, axisOffset, labelOffset, group, classes, useForeignObject, eventEmitter) {
    var labelElement;
    var positionalData = {};

    positionalData[axis.units.pos] = position + labelOffset[axis.units.pos];
    positionalData[axis.counterUnits.pos] = labelOffset[axis.counterUnits.pos];
    positionalData[axis.units.len] = length;
    positionalData[axis.counterUnits.len] = Math.max(0, axisOffset - 10);

    if(useForeignObject) {
      // We need to set width and height explicitly to px as span will not expand with width and height being
      // 100% in all browsers
      var content = document.createElement('span');
      content.className = classes.join(' ');
      content.setAttribute('xmlns', Chartist.namespaces.xhtml);
      content.innerText = labels[index];
      content.style[axis.units.len] = Math.round(positionalData[axis.units.len]) + 'px';
      content.style[axis.counterUnits.len] = Math.round(positionalData[axis.counterUnits.len]) + 'px';

      labelElement = group.foreignObject(content, Chartist.extend({
        style: 'overflow: visible;'
      }, positionalData));
    } else {
      labelElement = group.elem('text', positionalData, classes.join(' ')).text(labels[index]);
    }

    eventEmitter.emit('draw', Chartist.extend({
      type: 'label',
      axis: axis,
      index: index,
      group: group,
      element: labelElement,
      text: labels[index]
    }, positionalData));
  };

  /**
   * Helper to read series specific options from options object. It automatically falls back to the global option if
   * there is no option in the series options.
   *
   * @param {Object} series Series object
   * @param {Object} options Chartist options object
   * @param {string} key The options key that should be used to obtain the options
   * @returns {*}
   */
  Chartist.getSeriesOption = function(series, options, key) {
    if(series.name && options.series && options.series[series.name]) {
      var seriesOptions = options.series[series.name];
      return seriesOptions.hasOwnProperty(key) ? seriesOptions[key] : options[key];
    } else {
      return options[key];
    }
  };

  /**
   * Provides options handling functionality with callback for options changes triggered by responsive options and media query matches
   *
   * @memberof Chartist.Core
   * @param {Object} options Options set by user
   * @param {Array} responsiveOptions Optional functions to add responsive behavior to chart
   * @param {Object} eventEmitter The event emitter that will be used to emit the options changed events
   * @return {Object} The consolidated options object from the defaults, base and matching responsive options
   */
  Chartist.optionsProvider = function (options, responsiveOptions, eventEmitter) {
    var baseOptions = Chartist.extend({}, options),
      currentOptions,
      mediaQueryListeners = [],
      i;

    function updateCurrentOptions(mediaEvent) {
      var previousOptions = currentOptions;
      currentOptions = Chartist.extend({}, baseOptions);

      if (responsiveOptions) {
        for (i = 0; i < responsiveOptions.length; i++) {
          var mql = window.matchMedia(responsiveOptions[i][0]);
          if (mql.matches) {
            currentOptions = Chartist.extend(currentOptions, responsiveOptions[i][1]);
          }
        }
      }

      if(eventEmitter && mediaEvent) {
        eventEmitter.emit('optionsChanged', {
          previousOptions: previousOptions,
          currentOptions: currentOptions
        });
      }
    }

    function removeMediaQueryListeners() {
      mediaQueryListeners.forEach(function(mql) {
        mql.removeListener(updateCurrentOptions);
      });
    }

    if (!window.matchMedia) {
      throw 'window.matchMedia not found! Make sure you\'re using a polyfill.';
    } else if (responsiveOptions) {

      for (i = 0; i < responsiveOptions.length; i++) {
        var mql = window.matchMedia(responsiveOptions[i][0]);
        mql.addListener(updateCurrentOptions);
        mediaQueryListeners.push(mql);
      }
    }
    // Execute initially without an event argument so we get the correct options
    updateCurrentOptions();

    return {
      removeMediaQueryListeners: removeMediaQueryListeners,
      getCurrentOptions: function getCurrentOptions() {
        return Chartist.extend({}, currentOptions);
      }
    };
  };


  /**
   * Splits a list of coordinates and associated values into segments. Each returned segment contains a pathCoordinates
   * valueData property describing the segment.
   *
   * With the default options, segments consist of contiguous sets of points that do not have an undefined value. Any
   * points with undefined values are discarded.
   *
   * **Options**
   * The following options are used to determine how segments are formed
   * ```javascript
   * var options = {
   *   // If fillHoles is true, undefined values are simply discarded without creating a new segment. Assuming other options are default, this returns single segment.
   *   fillHoles: false,
   *   // If increasingX is true, the coordinates in all segments have strictly increasing x-values.
   *   increasingX: false
   * };
   * ```
   *
   * @memberof Chartist.Core
   * @param {Array} pathCoordinates List of point coordinates to be split in the form [x1, y1, x2, y2 ... xn, yn]
   * @param {Array} values List of associated point values in the form [v1, v2 .. vn]
   * @param {Object} options Options set by user
   * @return {Array} List of segments, each containing a pathCoordinates and valueData property.
   */
  Chartist.splitIntoSegments = function(pathCoordinates, valueData, options) {
    var defaultOptions = {
      increasingX: false,
      fillHoles: false
    };

    options = Chartist.extend({}, defaultOptions, options);

    var segments = [];
    var hole = true;

    for(var i = 0; i < pathCoordinates.length; i += 2) {
      // If this value is a "hole" we set the hole flag
      if(Chartist.getMultiValue(valueData[i / 2].value) === undefined) {
      // if(valueData[i / 2].value === undefined) {
        if(!options.fillHoles) {
          hole = true;
        }
      } else {
        if(options.increasingX && i >= 2 && pathCoordinates[i] <= pathCoordinates[i-2]) {
          // X is not increasing, so we need to make sure we start a new segment
          hole = true;
        }


        // If it's a valid value we need to check if we're coming out of a hole and create a new empty segment
        if(hole) {
          segments.push({
            pathCoordinates: [],
            valueData: []
          });
          // As we have a valid value now, we are not in a "hole" anymore
          hole = false;
        }

        // Add to the segment pathCoordinates and valueData
        segments[segments.length - 1].pathCoordinates.push(pathCoordinates[i], pathCoordinates[i + 1]);
        segments[segments.length - 1].valueData.push(valueData[i / 2]);
      }
    }

    return segments;
  };
}(this || __webpack_require__.g, Chartist));
;/**
 * Chartist path interpolation functions.
 *
 * @module Chartist.Interpolation
 */
/* global Chartist */
(function(globalRoot, Chartist) {
  'use strict';

  Chartist.Interpolation = {};

  /**
   * This interpolation function does not smooth the path and the result is only containing lines and no curves.
   *
   * @example
   * var chart = new Chartist.Line('.ct-chart', {
   *   labels: [1, 2, 3, 4, 5],
   *   series: [[1, 2, 8, 1, 7]]
   * }, {
   *   lineSmooth: Chartist.Interpolation.none({
   *     fillHoles: false
   *   })
   * });
   *
   *
   * @memberof Chartist.Interpolation
   * @return {Function}
   */
  Chartist.Interpolation.none = function(options) {
    var defaultOptions = {
      fillHoles: false
    };
    options = Chartist.extend({}, defaultOptions, options);
    return function none(pathCoordinates, valueData) {
      var path = new Chartist.Svg.Path();
      var hole = true;

      for(var i = 0; i < pathCoordinates.length; i += 2) {
        var currX = pathCoordinates[i];
        var currY = pathCoordinates[i + 1];
        var currData = valueData[i / 2];

        if(Chartist.getMultiValue(currData.value) !== undefined) {

          if(hole) {
            path.move(currX, currY, false, currData);
          } else {
            path.line(currX, currY, false, currData);
          }

          hole = false;
        } else if(!options.fillHoles) {
          hole = true;
        }
      }

      return path;
    };
  };

  /**
   * Simple smoothing creates horizontal handles that are positioned with a fraction of the length between two data points. You can use the divisor option to specify the amount of smoothing.
   *
   * Simple smoothing can be used instead of `Chartist.Smoothing.cardinal` if you'd like to get rid of the artifacts it produces sometimes. Simple smoothing produces less flowing lines but is accurate by hitting the points and it also doesn't swing below or above the given data point.
   *
   * All smoothing functions within Chartist are factory functions that accept an options parameter. The simple interpolation function accepts one configuration parameter `divisor`, between 1 and â, which controls the smoothing characteristics.
   *
   * @example
   * var chart = new Chartist.Line('.ct-chart', {
   *   labels: [1, 2, 3, 4, 5],
   *   series: [[1, 2, 8, 1, 7]]
   * }, {
   *   lineSmooth: Chartist.Interpolation.simple({
   *     divisor: 2,
   *     fillHoles: false
   *   })
   * });
   *
   *
   * @memberof Chartist.Interpolation
   * @param {Object} options The options of the simple interpolation factory function.
   * @return {Function}
   */
  Chartist.Interpolation.simple = function(options) {
    var defaultOptions = {
      divisor: 2,
      fillHoles: false
    };
    options = Chartist.extend({}, defaultOptions, options);

    var d = 1 / Math.max(1, options.divisor);

    return function simple(pathCoordinates, valueData) {
      var path = new Chartist.Svg.Path();
      var prevX, prevY, prevData;

      for(var i = 0; i < pathCoordinates.length; i += 2) {
        var currX = pathCoordinates[i];
        var currY = pathCoordinates[i + 1];
        var length = (currX - prevX) * d;
        var currData = valueData[i / 2];

        if(currData.value !== undefined) {

          if(prevData === undefined) {
            path.move(currX, currY, false, currData);
          } else {
            path.curve(
              prevX + length,
              prevY,
              currX - length,
              currY,
              currX,
              currY,
              false,
              currData
            );
          }

          prevX = currX;
          prevY = currY;
          prevData = currData;
        } else if(!options.fillHoles) {
          prevX = currX = prevData = undefined;
        }
      }

      return path;
    };
  };

  /**
   * Cardinal / Catmull-Rome spline interpolation is the default smoothing function in Chartist. It produces nice results where the splines will always meet the points. It produces some artifacts though when data values are increased or decreased rapidly. The line may not follow a very accurate path and if the line should be accurate this smoothing function does not produce the best results.
   *
   * Cardinal splines can only be created if there are more than two data points. If this is not the case this smoothing will fallback to `Chartist.Smoothing.none`.
   *
   * All smoothing functions within Chartist are factory functions that accept an options parameter. The cardinal interpolation function accepts one configuration parameter `tension`, between 0 and 1, which controls the smoothing intensity.
   *
   * @example
   * var chart = new Chartist.Line('.ct-chart', {
   *   labels: [1, 2, 3, 4, 5],
   *   series: [[1, 2, 8, 1, 7]]
   * }, {
   *   lineSmooth: Chartist.Interpolation.cardinal({
   *     tension: 1,
   *     fillHoles: false
   *   })
   * });
   *
   * @memberof Chartist.Interpolation
   * @param {Object} options The options of the cardinal factory function.
   * @return {Function}
   */
  Chartist.Interpolation.cardinal = function(options) {
    var defaultOptions = {
      tension: 1,
      fillHoles: false
    };

    options = Chartist.extend({}, defaultOptions, options);

    var t = Math.min(1, Math.max(0, options.tension)),
      c = 1 - t;

    return function cardinal(pathCoordinates, valueData) {
      // First we try to split the coordinates into segments
      // This is necessary to treat "holes" in line charts
      var segments = Chartist.splitIntoSegments(pathCoordinates, valueData, {
        fillHoles: options.fillHoles
      });

      if(!segments.length) {
        // If there were no segments return 'Chartist.Interpolation.none'
        return Chartist.Interpolation.none()([]);
      } else if(segments.length > 1) {
        // If the split resulted in more that one segment we need to interpolate each segment individually and join them
        // afterwards together into a single path.
          var paths = [];
        // For each segment we will recurse the cardinal function
        segments.forEach(function(segment) {
          paths.push(cardinal(segment.pathCoordinates, segment.valueData));
        });
        // Join the segment path data into a single path and return
        return Chartist.Svg.Path.join(paths);
      } else {
        // If there was only one segment we can proceed regularly by using pathCoordinates and valueData from the first
        // segment
        pathCoordinates = segments[0].pathCoordinates;
        valueData = segments[0].valueData;

        // If less than two points we need to fallback to no smoothing
        if(pathCoordinates.length <= 4) {
          return Chartist.Interpolation.none()(pathCoordinates, valueData);
        }

        var path = new Chartist.Svg.Path().move(pathCoordinates[0], pathCoordinates[1], false, valueData[0]),
          z;

        for (var i = 0, iLen = pathCoordinates.length; iLen - 2 * !z > i; i += 2) {
          var p = [
            {x: +pathCoordinates[i - 2], y: +pathCoordinates[i - 1]},
            {x: +pathCoordinates[i], y: +pathCoordinates[i + 1]},
            {x: +pathCoordinates[i + 2], y: +pathCoordinates[i + 3]},
            {x: +pathCoordinates[i + 4], y: +pathCoordinates[i + 5]}
          ];
          if (z) {
            if (!i) {
              p[0] = {x: +pathCoordinates[iLen - 2], y: +pathCoordinates[iLen - 1]};
            } else if (iLen - 4 === i) {
              p[3] = {x: +pathCoordinates[0], y: +pathCoordinates[1]};
            } else if (iLen - 2 === i) {
              p[2] = {x: +pathCoordinates[0], y: +pathCoordinates[1]};
              p[3] = {x: +pathCoordinates[2], y: +pathCoordinates[3]};
            }
          } else {
            if (iLen - 4 === i) {
              p[3] = p[2];
            } else if (!i) {
              p[0] = {x: +pathCoordinates[i], y: +pathCoordinates[i + 1]};
            }
          }

          path.curve(
            (t * (-p[0].x + 6 * p[1].x + p[2].x) / 6) + (c * p[2].x),
            (t * (-p[0].y + 6 * p[1].y + p[2].y) / 6) + (c * p[2].y),
            (t * (p[1].x + 6 * p[2].x - p[3].x) / 6) + (c * p[2].x),
            (t * (p[1].y + 6 * p[2].y - p[3].y) / 6) + (c * p[2].y),
            p[2].x,
            p[2].y,
            false,
            valueData[(i + 2) / 2]
          );
        }

        return path;
      }
    };
  };

  /**
   * Monotone Cubic spline interpolation produces a smooth curve which preserves monotonicity. Unlike cardinal splines, the curve will not extend beyond the range of y-values of the original data points.
   *
   * Monotone Cubic splines can only be created if there are more than two data points. If this is not the case this smoothing will fallback to `Chartist.Smoothing.none`.
   *
   * The x-values of subsequent points must be increasing to fit a Monotone Cubic spline. If this condition is not met for a pair of adjacent points, then there will be a break in the curve between those data points.
   *
   * All smoothing functions within Chartist are factory functions that accept an options parameter.
   *
   * @example
   * var chart = new Chartist.Line('.ct-chart', {
   *   labels: [1, 2, 3, 4, 5],
   *   series: [[1, 2, 8, 1, 7]]
   * }, {
   *   lineSmooth: Chartist.Interpolation.monotoneCubic({
   *     fillHoles: false
   *   })
   * });
   *
   * @memberof Chartist.Interpolation
   * @param {Object} options The options of the monotoneCubic factory function.
   * @return {Function}
   */
  Chartist.Interpolation.monotoneCubic = function(options) {
    var defaultOptions = {
      fillHoles: false
    };

    options = Chartist.extend({}, defaultOptions, options);

    return function monotoneCubic(pathCoordinates, valueData) {
      // First we try to split the coordinates into segments
      // This is necessary to treat "holes" in line charts
      var segments = Chartist.splitIntoSegments(pathCoordinates, valueData, {
        fillHoles: options.fillHoles,
        increasingX: true
      });

      if(!segments.length) {
        // If there were no segments return 'Chartist.Interpolation.none'
        return Chartist.Interpolation.none()([]);
      } else if(segments.length > 1) {
        // If the split resulted in more that one segment we need to interpolate each segment individually and join them
        // afterwards together into a single path.
          var paths = [];
        // For each segment we will recurse the monotoneCubic fn function
        segments.forEach(function(segment) {
          paths.push(monotoneCubic(segment.pathCoordinates, segment.valueData));
        });
        // Join the segment path data into a single path and return
        return Chartist.Svg.Path.join(paths);
      } else {
        // If there was only one segment we can proceed regularly by using pathCoordinates and valueData from the first
        // segment
        pathCoordinates = segments[0].pathCoordinates;
        valueData = segments[0].valueData;

        // If less than three points we need to fallback to no smoothing
        if(pathCoordinates.length <= 4) {
          return Chartist.Interpolation.none()(pathCoordinates, valueData);
        }

        var xs = [],
          ys = [],
          i,
          n = pathCoordinates.length / 2,
          ms = [],
          ds = [], dys = [], dxs = [],
          path;

        // Populate x and y coordinates into separate arrays, for readability

        for(i = 0; i < n; i++) {
          xs[i] = pathCoordinates[i * 2];
          ys[i] = pathCoordinates[i * 2 + 1];
        }

        // Calculate deltas and derivative

        for(i = 0; i < n - 1; i++) {
          dys[i] = ys[i + 1] - ys[i];
          dxs[i] = xs[i + 1] - xs[i];
          ds[i] = dys[i] / dxs[i];
        }

        // Determine desired slope (m) at each point using Fritsch-Carlson method
        // See: http://math.stackexchange.com/questions/45218/implementation-of-monotone-cubic-interpolation

        ms[0] = ds[0];
        ms[n - 1] = ds[n - 2];

        for(i = 1; i < n - 1; i++) {
          if(ds[i] === 0 || ds[i - 1] === 0 || (ds[i - 1] > 0) !== (ds[i] > 0)) {
            ms[i] = 0;
          } else {
            ms[i] = 3 * (dxs[i - 1] + dxs[i]) / (
              (2 * dxs[i] + dxs[i - 1]) / ds[i - 1] +
              (dxs[i] + 2 * dxs[i - 1]) / ds[i]);

            if(!isFinite(ms[i])) {
              ms[i] = 0;
            }
          }
        }

        // Now build a path from the slopes

        path = new Chartist.Svg.Path().move(xs[0], ys[0], false, valueData[0]);

        for(i = 0; i < n - 1; i++) {
          path.curve(
            // First control point
            xs[i] + dxs[i] / 3,
            ys[i] + ms[i] * dxs[i] / 3,
            // Second control point
            xs[i + 1] - dxs[i] / 3,
            ys[i + 1] - ms[i + 1] * dxs[i] / 3,
            // End point
            xs[i + 1],
            ys[i + 1],

            false,
            valueData[i + 1]
          );
        }

        return path;
      }
    };
  };

  /**
   * Step interpolation will cause the line chart to move in steps rather than diagonal or smoothed lines. This interpolation will create additional points that will also be drawn when the `showPoint` option is enabled.
   *
   * All smoothing functions within Chartist are factory functions that accept an options parameter. The step interpolation function accepts one configuration parameter `postpone`, that can be `true` or `false`. The default value is `true` and will cause the step to occur where the value actually changes. If a different behaviour is needed where the step is shifted to the left and happens before the actual value, this option can be set to `false`.
   *
   * @example
   * var chart = new Chartist.Line('.ct-chart', {
   *   labels: [1, 2, 3, 4, 5],
   *   series: [[1, 2, 8, 1, 7]]
   * }, {
   *   lineSmooth: Chartist.Interpolation.step({
   *     postpone: true,
   *     fillHoles: false
   *   })
   * });
   *
   * @memberof Chartist.Interpolation
   * @param options
   * @returns {Function}
   */
  Chartist.Interpolation.step = function(options) {
    var defaultOptions = {
      postpone: true,
      fillHoles: false
    };

    options = Chartist.extend({}, defaultOptions, options);

    return function step(pathCoordinates, valueData) {
      var path = new Chartist.Svg.Path();

      var prevX, prevY, prevData;

      for (var i = 0; i < pathCoordinates.length; i += 2) {
        var currX = pathCoordinates[i];
        var currY = pathCoordinates[i + 1];
        var currData = valueData[i / 2];

        // If the current point is also not a hole we can draw the step lines
        if(currData.value !== undefined) {
          if(prevData === undefined) {
            path.move(currX, currY, false, currData);
          } else {
            if(options.postpone) {
              // If postponed we should draw the step line with the value of the previous value
              path.line(currX, prevY, false, prevData);
            } else {
              // If not postponed we should draw the step line with the value of the current value
              path.line(prevX, currY, false, currData);
            }
            // Line to the actual point (this should only be a Y-Axis movement
            path.line(currX, currY, false, currData);
          }

          prevX = currX;
          prevY = currY;
          prevData = currData;
        } else if(!options.fillHoles) {
          prevX = prevY = prevData = undefined;
        }
      }

      return path;
    };
  };

}(this || __webpack_require__.g, Chartist));
;/**
 * A very basic event module that helps to generate and catch events.
 *
 * @module Chartist.Event
 */
/* global Chartist */
(function (globalRoot, Chartist) {
  'use strict';

  Chartist.EventEmitter = function () {
    var handlers = [];

    /**
     * Add an event handler for a specific event
     *
     * @memberof Chartist.Event
     * @param {String} event The event name
     * @param {Function} handler A event handler function
     */
    function addEventHandler(event, handler) {
      handlers[event] = handlers[event] || [];
      handlers[event].push(handler);
    }

    /**
     * Remove an event handler of a specific event name or remove all event handlers for a specific event.
     *
     * @memberof Chartist.Event
     * @param {String} event The event name where a specific or all handlers should be removed
     * @param {Function} [handler] An optional event handler function. If specified only this specific handler will be removed and otherwise all handlers are removed.
     */
    function removeEventHandler(event, handler) {
      // Only do something if there are event handlers with this name existing
      if(handlers[event]) {
        // If handler is set we will look for a specific handler and only remove this
        if(handler) {
          handlers[event].splice(handlers[event].indexOf(handler), 1);
          if(handlers[event].length === 0) {
            delete handlers[event];
          }
        } else {
          // If no handler is specified we remove all handlers for this event
          delete handlers[event];
        }
      }
    }

    /**
     * Use this function to emit an event. All handlers that are listening for this event will be triggered with the data parameter.
     *
     * @memberof Chartist.Event
     * @param {String} event The event name that should be triggered
     * @param {*} data Arbitrary data that will be passed to the event handler callback functions
     */
    function emit(event, data) {
      // Only do something if there are event handlers with this name existing
      if(handlers[event]) {
        handlers[event].forEach(function(handler) {
          handler(data);
        });
      }

      // Emit event to star event handlers
      if(handlers['*']) {
        handlers['*'].forEach(function(starHandler) {
          starHandler(event, data);
        });
      }
    }

    return {
      addEventHandler: addEventHandler,
      removeEventHandler: removeEventHandler,
      emit: emit
    };
  };

}(this || __webpack_require__.g, Chartist));
;/**
 * This module provides some basic prototype inheritance utilities.
 *
 * @module Chartist.Class
 */
/* global Chartist */
(function(globalRoot, Chartist) {
  'use strict';

  function listToArray(list) {
    var arr = [];
    if (list.length) {
      for (var i = 0; i < list.length; i++) {
        arr.push(list[i]);
      }
    }
    return arr;
  }

  /**
   * Method to extend from current prototype.
   *
   * @memberof Chartist.Class
   * @param {Object} properties The object that serves as definition for the prototype that gets created for the new class. This object should always contain a constructor property that is the desired constructor for the newly created class.
   * @param {Object} [superProtoOverride] By default extens will use the current class prototype or Chartist.class. With this parameter you can specify any super prototype that will be used.
   * @return {Function} Constructor function of the new class
   *
   * @example
   * var Fruit = Class.extend({
     * color: undefined,
     *   sugar: undefined,
     *
     *   constructor: function(color, sugar) {
     *     this.color = color;
     *     this.sugar = sugar;
     *   },
     *
     *   eat: function() {
     *     this.sugar = 0;
     *     return this;
     *   }
     * });
   *
   * var Banana = Fruit.extend({
     *   length: undefined,
     *
     *   constructor: function(length, sugar) {
     *     Banana.super.constructor.call(this, 'Yellow', sugar);
     *     this.length = length;
     *   }
     * });
   *
   * var banana = new Banana(20, 40);
   * console.log('banana instanceof Fruit', banana instanceof Fruit);
   * console.log('Fruit is prototype of banana', Fruit.prototype.isPrototypeOf(banana));
   * console.log('bananas prototype is Fruit', Object.getPrototypeOf(banana) === Fruit.prototype);
   * console.log(banana.sugar);
   * console.log(banana.eat().sugar);
   * console.log(banana.color);
   */
  function extend(properties, superProtoOverride) {
    var superProto = superProtoOverride || this.prototype || Chartist.Class;
    var proto = Object.create(superProto);

    Chartist.Class.cloneDefinitions(proto, properties);

    var constr = function() {
      var fn = proto.constructor || function () {},
        instance;

      // If this is linked to the Chartist namespace the constructor was not called with new
      // To provide a fallback we will instantiate here and return the instance
      instance = this === Chartist ? Object.create(proto) : this;
      fn.apply(instance, Array.prototype.slice.call(arguments, 0));

      // If this constructor was not called with new we need to return the instance
      // This will not harm when the constructor has been called with new as the returned value is ignored
      return instance;
    };

    constr.prototype = proto;
    constr.super = superProto;
    constr.extend = this.extend;

    return constr;
  }

  // Variable argument list clones args > 0 into args[0] and retruns modified args[0]
  function cloneDefinitions() {
    var args = listToArray(arguments);
    var target = args[0];

    args.splice(1, args.length - 1).forEach(function (source) {
      Object.getOwnPropertyNames(source).forEach(function (propName) {
        // If this property already exist in target we delete it first
        delete target[propName];
        // Define the property with the descriptor from source
        Object.defineProperty(target, propName,
          Object.getOwnPropertyDescriptor(source, propName));
      });
    });

    return target;
  }

  Chartist.Class = {
    extend: extend,
    cloneDefinitions: cloneDefinitions
  };

}(this || __webpack_require__.g, Chartist));
;/**
 * Base for all chart types. The methods in Chartist.Base are inherited to all chart types.
 *
 * @module Chartist.Base
 */
/* global Chartist */
(function(globalRoot, Chartist) {
  'use strict';

  var window = globalRoot.window;

  // TODO: Currently we need to re-draw the chart on window resize. This is usually very bad and will affect performance.
  // This is done because we can't work with relative coordinates when drawing the chart because SVG Path does not
  // work with relative positions yet. We need to check if we can do a viewBox hack to switch to percentage.
  // See http://mozilla.6506.n7.nabble.com/Specyfing-paths-with-percentages-unit-td247474.html
  // Update: can be done using the above method tested here: http://codepen.io/gionkunz/pen/KDvLj
  // The problem is with the label offsets that can't be converted into percentage and affecting the chart container
  /**
   * Updates the chart which currently does a full reconstruction of the SVG DOM
   *
   * @param {Object} [data] Optional data you'd like to set for the chart before it will update. If not specified the update method will use the data that is already configured with the chart.
   * @param {Object} [options] Optional options you'd like to add to the previous options for the chart before it will update. If not specified the update method will use the options that have been already configured with the chart.
   * @param {Boolean} [override] If set to true, the passed options will be used to extend the options that have been configured already. Otherwise the chart default options will be used as the base
   * @memberof Chartist.Base
   */
  function update(data, options, override) {
    if(data) {
      this.data = data || {};
      this.data.labels = this.data.labels || [];
      this.data.series = this.data.series || [];
      // Event for data transformation that allows to manipulate the data before it gets rendered in the charts
      this.eventEmitter.emit('data', {
        type: 'update',
        data: this.data
      });
    }

    if(options) {
      this.options = Chartist.extend({}, override ? this.options : this.defaultOptions, options);

      // If chartist was not initialized yet, we just set the options and leave the rest to the initialization
      // Otherwise we re-create the optionsProvider at this point
      if(!this.initializeTimeoutId) {
        this.optionsProvider.removeMediaQueryListeners();
        this.optionsProvider = Chartist.optionsProvider(this.options, this.responsiveOptions, this.eventEmitter);
      }
    }

    // Only re-created the chart if it has been initialized yet
    if(!this.initializeTimeoutId) {
      this.createChart(this.optionsProvider.getCurrentOptions());
    }

    // Return a reference to the chart object to chain up calls
    return this;
  }

  /**
   * This method can be called on the API object of each chart and will un-register all event listeners that were added to other components. This currently includes a window.resize listener as well as media query listeners if any responsive options have been provided. Use this function if you need to destroy and recreate Chartist charts dynamically.
   *
   * @memberof Chartist.Base
   */
  function detach() {
    // Only detach if initialization already occurred on this chart. If this chart still hasn't initialized (therefore
    // the initializationTimeoutId is still a valid timeout reference, we will clear the timeout
    if(!this.initializeTimeoutId) {
      window.removeEventListener('resize', this.resizeListener);
      this.optionsProvider.removeMediaQueryListeners();
    } else {
      window.clearTimeout(this.initializeTimeoutId);
    }

    return this;
  }

  /**
   * Use this function to register event handlers. The handler callbacks are synchronous and will run in the main thread rather than the event loop.
   *
   * @memberof Chartist.Base
   * @param {String} event Name of the event. Check the examples for supported events.
   * @param {Function} handler The handler function that will be called when an event with the given name was emitted. This function will receive a data argument which contains event data. See the example for more details.
   */
  function on(event, handler) {
    this.eventEmitter.addEventHandler(event, handler);
    return this;
  }

  /**
   * Use this function to un-register event handlers. If the handler function parameter is omitted all handlers for the given event will be un-registered.
   *
   * @memberof Chartist.Base
   * @param {String} event Name of the event for which a handler should be removed
   * @param {Function} [handler] The handler function that that was previously used to register a new event handler. This handler will be removed from the event handler list. If this parameter is omitted then all event handlers for the given event are removed from the list.
   */
  function off(event, handler) {
    this.eventEmitter.removeEventHandler(event, handler);
    return this;
  }

  function initialize() {
    // Add window resize listener that re-creates the chart
    window.addEventListener('resize', this.resizeListener);

    // Obtain current options based on matching media queries (if responsive options are given)
    // This will also register a listener that is re-creating the chart based on media changes
    this.optionsProvider = Chartist.optionsProvider(this.options, this.responsiveOptions, this.eventEmitter);
    // Register options change listener that will trigger a chart update
    this.eventEmitter.addEventHandler('optionsChanged', function() {
      this.update();
    }.bind(this));

    // Before the first chart creation we need to register us with all plugins that are configured
    // Initialize all relevant plugins with our chart object and the plugin options specified in the config
    if(this.options.plugins) {
      this.options.plugins.forEach(function(plugin) {
        if(plugin instanceof Array) {
          plugin[0](this, plugin[1]);
        } else {
          plugin(this);
        }
      }.bind(this));
    }

    // Event for data transformation that allows to manipulate the data before it gets rendered in the charts
    this.eventEmitter.emit('data', {
      type: 'initial',
      data: this.data
    });

    // Create the first chart
    this.createChart(this.optionsProvider.getCurrentOptions());

    // As chart is initialized from the event loop now we can reset our timeout reference
    // This is important if the chart gets initialized on the same element twice
    this.initializeTimeoutId = undefined;
  }

  /**
   * Constructor of chart base class.
   *
   * @param query
   * @param data
   * @param defaultOptions
   * @param options
   * @param responsiveOptions
   * @constructor
   */
  function Base(query, data, defaultOptions, options, responsiveOptions) {
    this.container = Chartist.querySelector(query);
    this.data = data || {};
    this.data.labels = this.data.labels || [];
    this.data.series = this.data.series || [];
    this.defaultOptions = defaultOptions;
    this.options = options;
    this.responsiveOptions = responsiveOptions;
    this.eventEmitter = Chartist.EventEmitter();
    this.supportsForeignObject = Chartist.Svg.isSupported('Extensibility');
    this.supportsAnimations = Chartist.Svg.isSupported('AnimationEventsAttribute');
    this.resizeListener = function resizeListener(){
      this.update();
    }.bind(this);

    if(this.container) {
      // If chartist was already initialized in this container we are detaching all event listeners first
      if(this.container.__chartist__) {
        this.container.__chartist__.detach();
      }

      this.container.__chartist__ = this;
    }

    // Using event loop for first draw to make it possible to register event listeners in the same call stack where
    // the chart was created.
    this.initializeTimeoutId = setTimeout(initialize.bind(this), 0);
  }

  // Creating the chart base class
  Chartist.Base = Chartist.Class.extend({
    constructor: Base,
    optionsProvider: undefined,
    container: undefined,
    svg: undefined,
    eventEmitter: undefined,
    createChart: function() {
      throw new Error('Base chart type can\'t be instantiated!');
    },
    update: update,
    detach: detach,
    on: on,
    off: off,
    version: Chartist.version,
    supportsForeignObject: false
  });

}(this || __webpack_require__.g, Chartist));
;/**
 * Chartist SVG module for simple SVG DOM abstraction
 *
 * @module Chartist.Svg
 */
/* global Chartist */
(function(globalRoot, Chartist) {
  'use strict';

  var document = globalRoot.document;

  /**
   * Chartist.Svg creates a new SVG object wrapper with a starting element. You can use the wrapper to fluently create sub-elements and modify them.
   *
   * @memberof Chartist.Svg
   * @constructor
   * @param {String|Element} name The name of the SVG element to create or an SVG dom element which should be wrapped into Chartist.Svg
   * @param {Object} attributes An object with properties that will be added as attributes to the SVG element that is created. Attributes with undefined values will not be added.
   * @param {String} className This class or class list will be added to the SVG element
   * @param {Object} parent The parent SVG wrapper object where this newly created wrapper and it's element will be attached to as child
   * @param {Boolean} insertFirst If this param is set to true in conjunction with a parent element the newly created element will be added as first child element in the parent element
   */
  function Svg(name, attributes, className, parent, insertFirst) {
    // If Svg is getting called with an SVG element we just return the wrapper
    if(name instanceof Element) {
      this._node = name;
    } else {
      this._node = document.createElementNS(Chartist.namespaces.svg, name);

      // If this is an SVG element created then custom namespace
      if(name === 'svg') {
        this.attr({
          'xmlns:ct': Chartist.namespaces.ct
        });
      }
    }

    if(attributes) {
      this.attr(attributes);
    }

    if(className) {
      this.addClass(className);
    }

    if(parent) {
      if (insertFirst && parent._node.firstChild) {
        parent._node.insertBefore(this._node, parent._node.firstChild);
      } else {
        parent._node.appendChild(this._node);
      }
    }
  }

  /**
   * Set attributes on the current SVG element of the wrapper you're currently working on.
   *
   * @memberof Chartist.Svg
   * @param {Object|String} attributes An object with properties that will be added as attributes to the SVG element that is created. Attributes with undefined values will not be added. If this parameter is a String then the function is used as a getter and will return the attribute value.
   * @param {String} [ns] If specified, the attribute will be obtained using getAttributeNs. In order to write namepsaced attributes you can use the namespace:attribute notation within the attributes object.
   * @return {Object|String} The current wrapper object will be returned so it can be used for chaining or the attribute value if used as getter function.
   */
  function attr(attributes, ns) {
    if(typeof attributes === 'string') {
      if(ns) {
        return this._node.getAttributeNS(ns, attributes);
      } else {
        return this._node.getAttribute(attributes);
      }
    }

    Object.keys(attributes).forEach(function(key) {
      // If the attribute value is undefined we can skip this one
      if(attributes[key] === undefined) {
        return;
      }

      if (key.indexOf(':') !== -1) {
        var namespacedAttribute = key.split(':');
        this._node.setAttributeNS(Chartist.namespaces[namespacedAttribute[0]], key, attributes[key]);
      } else {
        this._node.setAttribute(key, attributes[key]);
      }
    }.bind(this));

    return this;
  }

  /**
   * Create a new SVG element whose wrapper object will be selected for further operations. This way you can also create nested groups easily.
   *
   * @memberof Chartist.Svg
   * @param {String} name The name of the SVG element that should be created as child element of the currently selected element wrapper
   * @param {Object} [attributes] An object with properties that will be added as attributes to the SVG element that is created. Attributes with undefined values will not be added.
   * @param {String} [className] This class or class list will be added to the SVG element
   * @param {Boolean} [insertFirst] If this param is set to true in conjunction with a parent element the newly created element will be added as first child element in the parent element
   * @return {Chartist.Svg} Returns a Chartist.Svg wrapper object that can be used to modify the containing SVG data
   */
  function elem(name, attributes, className, insertFirst) {
    return new Chartist.Svg(name, attributes, className, this, insertFirst);
  }

  /**
   * Returns the parent Chartist.SVG wrapper object
   *
   * @memberof Chartist.Svg
   * @return {Chartist.Svg} Returns a Chartist.Svg wrapper around the parent node of the current node. If the parent node is not existing or it's not an SVG node then this function will return null.
   */
  function parent() {
    return this._node.parentNode instanceof SVGElement ? new Chartist.Svg(this._node.parentNode) : null;
  }

  /**
   * This method returns a Chartist.Svg wrapper around the root SVG element of the current tree.
   *
   * @memberof Chartist.Svg
   * @return {Chartist.Svg} The root SVG element wrapped in a Chartist.Svg element
   */
  function root() {
    var node = this._node;
    while(node.nodeName !== 'svg') {
      node = node.parentNode;
    }
    return new Chartist.Svg(node);
  }

  /**
   * Find the first child SVG element of the current element that matches a CSS selector. The returned object is a Chartist.Svg wrapper.
   *
   * @memberof Chartist.Svg
   * @param {String} selector A CSS selector that is used to query for child SVG elements
   * @return {Chartist.Svg} The SVG wrapper for the element found or null if no element was found
   */
  function querySelector(selector) {
    var foundNode = this._node.querySelector(selector);
    return foundNode ? new Chartist.Svg(foundNode) : null;
  }

  /**
   * Find the all child SVG elements of the current element that match a CSS selector. The returned object is a Chartist.Svg.List wrapper.
   *
   * @memberof Chartist.Svg
   * @param {String} selector A CSS selector that is used to query for child SVG elements
   * @return {Chartist.Svg.List} The SVG wrapper list for the element found or null if no element was found
   */
  function querySelectorAll(selector) {
    var foundNodes = this._node.querySelectorAll(selector);
    return foundNodes.length ? new Chartist.Svg.List(foundNodes) : null;
  }

  /**
   * Returns the underlying SVG node for the current element.
   *
   * @memberof Chartist.Svg
   * @returns {Node}
   */
  function getNode() {
    return this._node;
  }

  /**
   * This method creates a foreignObject (see https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject) that allows to embed HTML content into a SVG graphic. With the help of foreignObjects you can enable the usage of regular HTML elements inside of SVG where they are subject for SVG positioning and transformation but the Browser will use the HTML rendering capabilities for the containing DOM.
   *
   * @memberof Chartist.Svg
   * @param {Node|String} content The DOM Node, or HTML string that will be converted to a DOM Node, that is then placed into and wrapped by the foreignObject
   * @param {String} [attributes] An object with properties that will be added as attributes to the foreignObject element that is created. Attributes with undefined values will not be added.
   * @param {String} [className] This class or class list will be added to the SVG element
   * @param {Boolean} [insertFirst] Specifies if the foreignObject should be inserted as first child
   * @return {Chartist.Svg} New wrapper object that wraps the foreignObject element
   */
  function foreignObject(content, attributes, className, insertFirst) {
    // If content is string then we convert it to DOM
    // TODO: Handle case where content is not a string nor a DOM Node
    if(typeof content === 'string') {
      var container = document.createElement('div');
      container.innerHTML = content;
      content = container.firstChild;
    }

    // Adding namespace to content element
    content.setAttribute('xmlns', Chartist.namespaces.xmlns);

    // Creating the foreignObject without required extension attribute (as described here
    // http://www.w3.org/TR/SVG/extend.html#ForeignObjectElement)
    var fnObj = this.elem('foreignObject', attributes, className, insertFirst);

    // Add content to foreignObjectElement
    fnObj._node.appendChild(content);

    return fnObj;
  }

  /**
   * This method adds a new text element to the current Chartist.Svg wrapper.
   *
   * @memberof Chartist.Svg
   * @param {String} t The text that should be added to the text element that is created
   * @return {Chartist.Svg} The same wrapper object that was used to add the newly created element
   */
  function text(t) {
    this._node.appendChild(document.createTextNode(t));
    return this;
  }

  /**
   * This method will clear all child nodes of the current wrapper object.
   *
   * @memberof Chartist.Svg
   * @return {Chartist.Svg} The same wrapper object that got emptied
   */
  function empty() {
    while (this._node.firstChild) {
      this._node.removeChild(this._node.firstChild);
    }

    return this;
  }

  /**
   * This method will cause the current wrapper to remove itself from its parent wrapper. Use this method if you'd like to get rid of an element in a given DOM structure.
   *
   * @memberof Chartist.Svg
   * @return {Chartist.Svg} The parent wrapper object of the element that got removed
   */
  function remove() {
    this._node.parentNode.removeChild(this._node);
    return this.parent();
  }

  /**
   * This method will replace the element with a new element that can be created outside of the current DOM.
   *
   * @memberof Chartist.Svg
   * @param {Chartist.Svg} newElement The new Chartist.Svg object that will be used to replace the current wrapper object
   * @return {Chartist.Svg} The wrapper of the new element
   */
  function replace(newElement) {
    this._node.parentNode.replaceChild(newElement._node, this._node);
    return newElement;
  }

  /**
   * This method will append an element to the current element as a child.
   *
   * @memberof Chartist.Svg
   * @param {Chartist.Svg} element The Chartist.Svg element that should be added as a child
   * @param {Boolean} [insertFirst] Specifies if the element should be inserted as first child
   * @return {Chartist.Svg} The wrapper of the appended object
   */
  function append(element, insertFirst) {
    if(insertFirst && this._node.firstChild) {
      this._node.insertBefore(element._node, this._node.firstChild);
    } else {
      this._node.appendChild(element._node);
    }

    return this;
  }

  /**
   * Returns an array of class names that are attached to the current wrapper element. This method can not be chained further.
   *
   * @memberof Chartist.Svg
   * @return {Array} A list of classes or an empty array if there are no classes on the current element
   */
  function classes() {
    return this._node.getAttribute('class') ? this._node.getAttribute('class').trim().split(/\s+/) : [];
  }

  /**
   * Adds one or a space separated list of classes to the current element and ensures the classes are only existing once.
   *
   * @memberof Chartist.Svg
   * @param {String} names A white space separated list of class names
   * @return {Chartist.Svg} The wrapper of the current element
   */
  function addClass(names) {
    this._node.setAttribute('class',
      this.classes(this._node)
        .concat(names.trim().split(/\s+/))
        .filter(function(elem, pos, self) {
          return self.indexOf(elem) === pos;
        }).join(' ')
    );

    return this;
  }

  /**
   * Removes one or a space separated list of classes from the current element.
   *
   * @memberof Chartist.Svg
   * @param {String} names A white space separated list of class names
   * @return {Chartist.Svg} The wrapper of the current element
   */
  function removeClass(names) {
    var removedClasses = names.trim().split(/\s+/);

    this._node.setAttribute('class', this.classes(this._node).filter(function(name) {
      return removedClasses.indexOf(name) === -1;
    }).join(' '));

    return this;
  }

  /**
   * Removes all classes from the current element.
   *
   * @memberof Chartist.Svg
   * @return {Chartist.Svg} The wrapper of the current element
   */
  function removeAllClasses() {
    this._node.setAttribute('class', '');

    return this;
  }

  /**
   * Get element height using `getBoundingClientRect`
   *
   * @memberof Chartist.Svg
   * @return {Number} The elements height in pixels
   */
  function height() {
    return this._node.getBoundingClientRect().height;
  }

  /**
   * Get element width using `getBoundingClientRect`
   *
   * @memberof Chartist.Core
   * @return {Number} The elements width in pixels
   */
  function width() {
    return this._node.getBoundingClientRect().width;
  }

  /**
   * The animate function lets you animate the current element with SMIL animations. You can add animations for multiple attributes at the same time by using an animation definition object. This object should contain SMIL animation attributes. Please refer to http://www.w3.org/TR/SVG/animate.html for a detailed specification about the available animation attributes. Additionally an easing property can be passed in the animation definition object. This can be a string with a name of an easing function in `Chartist.Svg.Easing` or an array with four numbers specifying a cubic BÃ©zier curve.
   * **An animations object could look like this:**
   * ```javascript
   * element.animate({
   *   opacity: {
   *     dur: 1000,
   *     from: 0,
   *     to: 1
   *   },
   *   x1: {
   *     dur: '1000ms',
   *     from: 100,
   *     to: 200,
   *     easing: 'easeOutQuart'
   *   },
   *   y1: {
   *     dur: '2s',
   *     from: 0,
   *     to: 100
   *   }
   * });
   * ```
   * **Automatic unit conversion**
   * For the `dur` and the `begin` animate attribute you can also omit a unit by passing a number. The number will automatically be converted to milli seconds.
   * **Guided mode**
   * The default behavior of SMIL animations with offset using the `begin` attribute is that the attribute will keep it's original value until the animation starts. Mostly this behavior is not desired as you'd like to have your element attributes already initialized with the animation `from` value even before the animation starts. Also if you don't specify `fill="freeze"` on an animate element or if you delete the animation after it's done (which is done in guided mode) the attribute will switch back to the initial value. This behavior is also not desired when performing simple one-time animations. For one-time animations you'd want to trigger animations immediately instead of relative to the document begin time. That's why in guided mode Chartist.Svg will also use the `begin` property to schedule a timeout and manually start the animation after the timeout. If you're using multiple SMIL definition objects for an attribute (in an array), guided mode will be disabled for this attribute, even if you explicitly enabled it.
   * If guided mode is enabled the following behavior is added:
   * - Before the animation starts (even when delayed with `begin`) the animated attribute will be set already to the `from` value of the animation
   * - `begin` is explicitly set to `indefinite` so it can be started manually without relying on document begin time (creation)
   * - The animate element will be forced to use `fill="freeze"`
   * - The animation will be triggered with `beginElement()` in a timeout where `begin` of the definition object is interpreted in milli seconds. If no `begin` was specified the timeout is triggered immediately.
   * - After the animation the element attribute value will be set to the `to` value of the animation
   * - The animate element is deleted from the DOM
   *
   * @memberof Chartist.Svg
   * @param {Object} animations An animations object where the property keys are the attributes you'd like to animate. The properties should be objects again that contain the SMIL animation attributes (usually begin, dur, from, and to). The property begin and dur is auto converted (see Automatic unit conversion). You can also schedule multiple animations for the same attribute by passing an Array of SMIL definition objects. Attributes that contain an array of SMIL definition objects will not be executed in guided mode.
   * @param {Boolean} guided Specify if guided mode should be activated for this animation (see Guided mode). If not otherwise specified, guided mode will be activated.
   * @param {Object} eventEmitter If specified, this event emitter will be notified when an animation starts or ends.
   * @return {Chartist.Svg} The current element where the animation was added
   */
  function animate(animations, guided, eventEmitter) {
    if(guided === undefined) {
      guided = true;
    }

    Object.keys(animations).forEach(function createAnimateForAttributes(attribute) {

      function createAnimate(animationDefinition, guided) {
        var attributeProperties = {},
          animate,
          timeout,
          easing;

        // Check if an easing is specified in the definition object and delete it from the object as it will not
        // be part of the animate element attributes.
        if(animationDefinition.easing) {
          // If already an easing BÃ©zier curve array we take it or we lookup a easing array in the Easing object
          easing = animationDefinition.easing instanceof Array ?
            animationDefinition.easing :
            Chartist.Svg.Easing[animationDefinition.easing];
          delete animationDefinition.easing;
        }

        // If numeric dur or begin was provided we assume milli seconds
        animationDefinition.begin = Chartist.ensureUnit(animationDefinition.begin, 'ms');
        animationDefinition.dur = Chartist.ensureUnit(animationDefinition.dur, 'ms');

        if(easing) {
          animationDefinition.calcMode = 'spline';
          animationDefinition.keySplines = easing.join(' ');
          animationDefinition.keyTimes = '0;1';
        }

        // Adding "fill: freeze" if we are in guided mode and set initial attribute values
        if(guided) {
          animationDefinition.fill = 'freeze';
          // Animated property on our element should already be set to the animation from value in guided mode
          attributeProperties[attribute] = animationDefinition.from;
          this.attr(attributeProperties);

          // In guided mode we also set begin to indefinite so we can trigger the start manually and put the begin
          // which needs to be in ms aside
          timeout = Chartist.quantity(animationDefinition.begin || 0).value;
          animationDefinition.begin = 'indefinite';
        }

        animate = this.elem('animate', Chartist.extend({
          attributeName: attribute
        }, animationDefinition));

        if(guided) {
          // If guided we take the value that was put aside in timeout and trigger the animation manually with a timeout
          setTimeout(function() {
            // If beginElement fails we set the animated attribute to the end position and remove the animate element
            // This happens if the SMIL ElementTimeControl interface is not supported or any other problems occured in
            // the browser. (Currently FF 34 does not support animate elements in foreignObjects)
            try {
              animate._node.beginElement();
            } catch(err) {
              // Set animated attribute to current animated value
              attributeProperties[attribute] = animationDefinition.to;
              this.attr(attributeProperties);
              // Remove the animate element as it's no longer required
              animate.remove();
            }
          }.bind(this), timeout);
        }

        if(eventEmitter) {
          animate._node.addEventListener('beginEvent', function handleBeginEvent() {
            eventEmitter.emit('animationBegin', {
              element: this,
              animate: animate._node,
              params: animationDefinition
            });
          }.bind(this));
        }

        animate._node.addEventListener('endEvent', function handleEndEvent() {
          if(eventEmitter) {
            eventEmitter.emit('animationEnd', {
              element: this,
              animate: animate._node,
              params: animationDefinition
            });
          }

          if(guided) {
            // Set animated attribute to current animated value
            attributeProperties[attribute] = animationDefinition.to;
            this.attr(attributeProperties);
            // Remove the animate element as it's no longer required
            animate.remove();
          }
        }.bind(this));
      }

      // If current attribute is an array of definition objects we create an animate for each and disable guided mode
      if(animations[attribute] instanceof Array) {
        animations[attribute].forEach(function(animationDefinition) {
          createAnimate.bind(this)(animationDefinition, false);
        }.bind(this));
      } else {
        createAnimate.bind(this)(animations[attribute], guided);
      }

    }.bind(this));

    return this;
  }

  Chartist.Svg = Chartist.Class.extend({
    constructor: Svg,
    attr: attr,
    elem: elem,
    parent: parent,
    root: root,
    querySelector: querySelector,
    querySelectorAll: querySelectorAll,
    getNode: getNode,
    foreignObject: foreignObject,
    text: text,
    empty: empty,
    remove: remove,
    replace: replace,
    append: append,
    classes: classes,
    addClass: addClass,
    removeClass: removeClass,
    removeAllClasses: removeAllClasses,
    height: height,
    width: width,
    animate: animate
  });

  /**
   * This method checks for support of a given SVG feature like Extensibility, SVG-animation or the like. Check http://www.w3.org/TR/SVG11/feature for a detailed list.
   *
   * @memberof Chartist.Svg
   * @param {String} feature The SVG 1.1 feature that should be checked for support.
   * @return {Boolean} True of false if the feature is supported or not
   */
  Chartist.Svg.isSupported = function(feature) {
    return document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#' + feature, '1.1');
  };

  /**
   * This Object contains some standard easing cubic bezier curves. Then can be used with their name in the `Chartist.Svg.animate`. You can also extend the list and use your own name in the `animate` function. Click the show code button to see the available bezier functions.
   *
   * @memberof Chartist.Svg
   */
  var easingCubicBeziers = {
    easeInSine: [0.47, 0, 0.745, 0.715],
    easeOutSine: [0.39, 0.575, 0.565, 1],
    easeInOutSine: [0.445, 0.05, 0.55, 0.95],
    easeInQuad: [0.55, 0.085, 0.68, 0.53],
    easeOutQuad: [0.25, 0.46, 0.45, 0.94],
    easeInOutQuad: [0.455, 0.03, 0.515, 0.955],
    easeInCubic: [0.55, 0.055, 0.675, 0.19],
    easeOutCubic: [0.215, 0.61, 0.355, 1],
    easeInOutCubic: [0.645, 0.045, 0.355, 1],
    easeInQuart: [0.895, 0.03, 0.685, 0.22],
    easeOutQuart: [0.165, 0.84, 0.44, 1],
    easeInOutQuart: [0.77, 0, 0.175, 1],
    easeInQuint: [0.755, 0.05, 0.855, 0.06],
    easeOutQuint: [0.23, 1, 0.32, 1],
    easeInOutQuint: [0.86, 0, 0.07, 1],
    easeInExpo: [0.95, 0.05, 0.795, 0.035],
    easeOutExpo: [0.19, 1, 0.22, 1],
    easeInOutExpo: [1, 0, 0, 1],
    easeInCirc: [0.6, 0.04, 0.98, 0.335],
    easeOutCirc: [0.075, 0.82, 0.165, 1],
    easeInOutCirc: [0.785, 0.135, 0.15, 0.86],
    easeInBack: [0.6, -0.28, 0.735, 0.045],
    easeOutBack: [0.175, 0.885, 0.32, 1.275],
    easeInOutBack: [0.68, -0.55, 0.265, 1.55]
  };

  Chartist.Svg.Easing = easingCubicBeziers;

  /**
   * This helper class is to wrap multiple `Chartist.Svg` elements into a list where you can call the `Chartist.Svg` functions on all elements in the list with one call. This is helpful when you'd like to perform calls with `Chartist.Svg` on multiple elements.
   * An instance of this class is also returned by `Chartist.Svg.querySelectorAll`.
   *
   * @memberof Chartist.Svg
   * @param {Array<Node>|NodeList} nodeList An Array of SVG DOM nodes or a SVG DOM NodeList (as returned by document.querySelectorAll)
   * @constructor
   */
  function SvgList(nodeList) {
    var list = this;

    this.svgElements = [];
    for(var i = 0; i < nodeList.length; i++) {
      this.svgElements.push(new Chartist.Svg(nodeList[i]));
    }

    // Add delegation methods for Chartist.Svg
    Object.keys(Chartist.Svg.prototype).filter(function(prototypeProperty) {
      return ['constructor',
          'parent',
          'querySelector',
          'querySelectorAll',
          'replace',
          'append',
          'classes',
          'height',
          'width'].indexOf(prototypeProperty) === -1;
    }).forEach(function(prototypeProperty) {
      list[prototypeProperty] = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        list.svgElements.forEach(function(element) {
          Chartist.Svg.prototype[prototypeProperty].apply(element, args);
        });
        return list;
      };
    });
  }

  Chartist.Svg.List = Chartist.Class.extend({
    constructor: SvgList
  });
}(this || __webpack_require__.g, Chartist));
;/**
 * Chartist SVG path module for SVG path description creation and modification.
 *
 * @module Chartist.Svg.Path
 */
/* global Chartist */
(function(globalRoot, Chartist) {
  'use strict';

  /**
   * Contains the descriptors of supported element types in a SVG path. Currently only move, line and curve are supported.
   *
   * @memberof Chartist.Svg.Path
   * @type {Object}
   */
  var elementDescriptions = {
    m: ['x', 'y'],
    l: ['x', 'y'],
    c: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],
    a: ['rx', 'ry', 'xAr', 'lAf', 'sf', 'x', 'y']
  };

  /**
   * Default options for newly created SVG path objects.
   *
   * @memberof Chartist.Svg.Path
   * @type {Object}
   */
  var defaultOptions = {
    // The accuracy in digit count after the decimal point. This will be used to round numbers in the SVG path. If this option is set to false then no rounding will be performed.
    accuracy: 3
  };

  function element(command, params, pathElements, pos, relative, data) {
    var pathElement = Chartist.extend({
      command: relative ? command.toLowerCase() : command.toUpperCase()
    }, params, data ? { data: data } : {} );

    pathElements.splice(pos, 0, pathElement);
  }

  function forEachParam(pathElements, cb) {
    pathElements.forEach(function(pathElement, pathElementIndex) {
      elementDescriptions[pathElement.command.toLowerCase()].forEach(function(paramName, paramIndex) {
        cb(pathElement, paramName, pathElementIndex, paramIndex, pathElements);
      });
    });
  }

  /**
   * Used to construct a new path object.
   *
   * @memberof Chartist.Svg.Path
   * @param {Boolean} close If set to true then this path will be closed when stringified (with a Z at the end)
   * @param {Object} options Options object that overrides the default objects. See default options for more details.
   * @constructor
   */
  function SvgPath(close, options) {
    this.pathElements = [];
    this.pos = 0;
    this.close = close;
    this.options = Chartist.extend({}, defaultOptions, options);
  }

  /**
   * Gets or sets the current position (cursor) inside of the path. You can move around the cursor freely but limited to 0 or the count of existing elements. All modifications with element functions will insert new elements at the position of this cursor.
   *
   * @memberof Chartist.Svg.Path
   * @param {Number} [pos] If a number is passed then the cursor is set to this position in the path element array.
   * @return {Chartist.Svg.Path|Number} If the position parameter was passed then the return value will be the path object for easy call chaining. If no position parameter was passed then the current position is returned.
   */
  function position(pos) {
    if(pos !== undefined) {
      this.pos = Math.max(0, Math.min(this.pathElements.length, pos));
      return this;
    } else {
      return this.pos;
    }
  }

  /**
   * Removes elements from the path starting at the current position.
   *
   * @memberof Chartist.Svg.Path
   * @param {Number} count Number of path elements that should be removed from the current position.
   * @return {Chartist.Svg.Path} The current path object for easy call chaining.
   */
  function remove(count) {
    this.pathElements.splice(this.pos, count);
    return this;
  }

  /**
   * Use this function to add a new move SVG path element.
   *
   * @memberof Chartist.Svg.Path
   * @param {Number} x The x coordinate for the move element.
   * @param {Number} y The y coordinate for the move element.
   * @param {Boolean} [relative] If set to true the move element will be created with relative coordinates (lowercase letter)
   * @param {*} [data] Any data that should be stored with the element object that will be accessible in pathElement
   * @return {Chartist.Svg.Path} The current path object for easy call chaining.
   */
  function move(x, y, relative, data) {
    element('M', {
      x: +x,
      y: +y
    }, this.pathElements, this.pos++, relative, data);
    return this;
  }

  /**
   * Use this function to add a new line SVG path element.
   *
   * @memberof Chartist.Svg.Path
   * @param {Number} x The x coordinate for the line element.
   * @param {Number} y The y coordinate for the line element.
   * @param {Boolean} [relative] If set to true the line element will be created with relative coordinates (lowercase letter)
   * @param {*} [data] Any data that should be stored with the element object that will be accessible in pathElement
   * @return {Chartist.Svg.Path} The current path object for easy call chaining.
   */
  function line(x, y, relative, data) {
    element('L', {
      x: +x,
      y: +y
    }, this.pathElements, this.pos++, relative, data);
    return this;
  }

  /**
   * Use this function to add a new curve SVG path element.
   *
   * @memberof Chartist.Svg.Path
   * @param {Number} x1 The x coordinate for the first control point of the bezier curve.
   * @param {Number} y1 The y coordinate for the first control point of the bezier curve.
   * @param {Number} x2 The x coordinate for the second control point of the bezier curve.
   * @param {Number} y2 The y coordinate for the second control point of the bezier curve.
   * @param {Number} x The x coordinate for the target point of the curve element.
   * @param {Number} y The y coordinate for the target point of the curve element.
   * @param {Boolean} [relative] If set to true the curve element will be created with relative coordinates (lowercase letter)
   * @param {*} [data] Any data that should be stored with the element object that will be accessible in pathElement
   * @return {Chartist.Svg.Path} The current path object for easy call chaining.
   */
  function curve(x1, y1, x2, y2, x, y, relative, data) {
    element('C', {
      x1: +x1,
      y1: +y1,
      x2: +x2,
      y2: +y2,
      x: +x,
      y: +y
    }, this.pathElements, this.pos++, relative, data);
    return this;
  }

  /**
   * Use this function to add a new non-bezier curve SVG path element.
   *
   * @memberof Chartist.Svg.Path
   * @param {Number} rx The radius to be used for the x-axis of the arc.
   * @param {Number} ry The radius to be used for the y-axis of the arc.
   * @param {Number} xAr Defines the orientation of the arc
   * @param {Number} lAf Large arc flag
   * @param {Number} sf Sweep flag
   * @param {Number} x The x coordinate for the target point of the curve element.
   * @param {Number} y The y coordinate for the target point of the curve element.
   * @param {Boolean} [relative] If set to true the curve element will be created with relative coordinates (lowercase letter)
   * @param {*} [data] Any data that should be stored with the element object that will be accessible in pathElement
   * @return {Chartist.Svg.Path} The current path object for easy call chaining.
   */
  function arc(rx, ry, xAr, lAf, sf, x, y, relative, data) {
    element('A', {
      rx: +rx,
      ry: +ry,
      xAr: +xAr,
      lAf: +lAf,
      sf: +sf,
      x: +x,
      y: +y
    }, this.pathElements, this.pos++, relative, data);
    return this;
  }

  /**
   * Parses an SVG path seen in the d attribute of path elements, and inserts the parsed elements into the existing path object at the current cursor position. Any closing path indicators (Z at the end of the path) will be ignored by the parser as this is provided by the close option in the options of the path object.
   *
   * @memberof Chartist.Svg.Path
   * @param {String} path Any SVG path that contains move (m), line (l) or curve (c) components.
   * @return {Chartist.Svg.Path} The current path object for easy call chaining.
   */
  function parse(path) {
    // Parsing the SVG path string into an array of arrays [['M', '10', '10'], ['L', '100', '100']]
    var chunks = path.replace(/([A-Za-z])([0-9])/g, '$1 $2')
      .replace(/([0-9])([A-Za-z])/g, '$1 $2')
      .split(/[\s,]+/)
      .reduce(function(result, element) {
        if(element.match(/[A-Za-z]/)) {
          result.push([]);
        }

        result[result.length - 1].push(element);
        return result;
      }, []);

    // If this is a closed path we remove the Z at the end because this is determined by the close option
    if(chunks[chunks.length - 1][0].toUpperCase() === 'Z') {
      chunks.pop();
    }

    // Using svgPathElementDescriptions to map raw path arrays into objects that contain the command and the parameters
    // For example {command: 'M', x: '10', y: '10'}
    var elements = chunks.map(function(chunk) {
        var command = chunk.shift(),
          description = elementDescriptions[command.toLowerCase()];

        return Chartist.extend({
          command: command
        }, description.reduce(function(result, paramName, index) {
          result[paramName] = +chunk[index];
          return result;
        }, {}));
      });

    // Preparing a splice call with the elements array as var arg params and insert the parsed elements at the current position
    var spliceArgs = [this.pos, 0];
    Array.prototype.push.apply(spliceArgs, elements);
    Array.prototype.splice.apply(this.pathElements, spliceArgs);
    // Increase the internal position by the element count
    this.pos += elements.length;

    return this;
  }

  /**
   * This function renders to current SVG path object into a final SVG string that can be used in the d attribute of SVG path elements. It uses the accuracy option to round big decimals. If the close parameter was set in the constructor of this path object then a path closing Z will be appended to the output string.
   *
   * @memberof Chartist.Svg.Path
   * @return {String}
   */
  function stringify() {
    var accuracyMultiplier = Math.pow(10, this.options.accuracy);

    return this.pathElements.reduce(function(path, pathElement) {
        var params = elementDescriptions[pathElement.command.toLowerCase()].map(function(paramName) {
          return this.options.accuracy ?
            (Math.round(pathElement[paramName] * accuracyMultiplier) / accuracyMultiplier) :
            pathElement[paramName];
        }.bind(this));

        return path + pathElement.command + params.join(',');
      }.bind(this), '') + (this.close ? 'Z' : '');
  }

  /**
   * Scales all elements in the current SVG path object. There is an individual parameter for each coordinate. Scaling will also be done for control points of curves, affecting the given coordinate.
   *
   * @memberof Chartist.Svg.Path
   * @param {Number} x The number which will be used to scale the x, x1 and x2 of all path elements.
   * @param {Number} y The number which will be used to scale the y, y1 and y2 of all path elements.
   * @return {Chartist.Svg.Path} The current path object for easy call chaining.
   */
  function scale(x, y) {
    forEachParam(this.pathElements, function(pathElement, paramName) {
      pathElement[paramName] *= paramName[0] === 'x' ? x : y;
    });
    return this;
  }

  /**
   * Translates all elements in the current SVG path object. The translation is relative and there is an individual parameter for each coordinate. Translation will also be done for control points of curves, affecting the given coordinate.
   *
   * @memberof Chartist.Svg.Path
   * @param {Number} x The number which will be used to translate the x, x1 and x2 of all path elements.
   * @param {Number} y The number which will be used to translate the y, y1 and y2 of all path elements.
   * @return {Chartist.Svg.Path} The current path object for easy call chaining.
   */
  function translate(x, y) {
    forEachParam(this.pathElements, function(pathElement, paramName) {
      pathElement[paramName] += paramName[0] === 'x' ? x : y;
    });
    return this;
  }

  /**
   * This function will run over all existing path elements and then loop over their attributes. The callback function will be called for every path element attribute that exists in the current path.
   * The method signature of the callback function looks like this:
   * ```javascript
   * function(pathElement, paramName, pathElementIndex, paramIndex, pathElements)
   * ```
   * If something else than undefined is returned by the callback function, this value will be used to replace the old value. This allows you to build custom transformations of path objects that can't be achieved using the basic transformation functions scale and translate.
   *
   * @memberof Chartist.Svg.Path
   * @param {Function} transformFnc The callback function for the transformation. Check the signature in the function description.
   * @return {Chartist.Svg.Path} The current path object for easy call chaining.
   */
  function transform(transformFnc) {
    forEachParam(this.pathElements, function(pathElement, paramName, pathElementIndex, paramIndex, pathElements) {
      var transformed = transformFnc(pathElement, paramName, pathElementIndex, paramIndex, pathElements);
      if(transformed || transformed === 0) {
        pathElement[paramName] = transformed;
      }
    });
    return this;
  }

  /**
   * This function clones a whole path object with all its properties. This is a deep clone and path element objects will also be cloned.
   *
   * @memberof Chartist.Svg.Path
   * @param {Boolean} [close] Optional option to set the new cloned path to closed. If not specified or false, the original path close option will be used.
   * @return {Chartist.Svg.Path}
   */
  function clone(close) {
    var c = new Chartist.Svg.Path(close || this.close);
    c.pos = this.pos;
    c.pathElements = this.pathElements.slice().map(function cloneElements(pathElement) {
      return Chartist.extend({}, pathElement);
    });
    c.options = Chartist.extend({}, this.options);
    return c;
  }

  /**
   * Split a Svg.Path object by a specific command in the path chain. The path chain will be split and an array of newly created paths objects will be returned. This is useful if you'd like to split an SVG path by it's move commands, for example, in order to isolate chunks of drawings.
   *
   * @memberof Chartist.Svg.Path
   * @param {String} command The command you'd like to use to split the path
   * @return {Array<Chartist.Svg.Path>}
   */
  function splitByCommand(command) {
    var split = [
      new Chartist.Svg.Path()
    ];

    this.pathElements.forEach(function(pathElement) {
      if(pathElement.command === command.toUpperCase() && split[split.length - 1].pathElements.length !== 0) {
        split.push(new Chartist.Svg.Path());
      }

      split[split.length - 1].pathElements.push(pathElement);
    });

    return split;
  }

  /**
   * This static function on `Chartist.Svg.Path` is joining multiple paths together into one paths.
   *
   * @memberof Chartist.Svg.Path
   * @param {Array<Chartist.Svg.Path>} paths A list of paths to be joined together. The order is important.
   * @param {boolean} close If the newly created path should be a closed path
   * @param {Object} options Path options for the newly created path.
   * @return {Chartist.Svg.Path}
   */

  function join(paths, close, options) {
    var joinedPath = new Chartist.Svg.Path(close, options);
    for(var i = 0; i < paths.length; i++) {
      var path = paths[i];
      for(var j = 0; j < path.pathElements.length; j++) {
        joinedPath.pathElements.push(path.pathElements[j]);
      }
    }
    return joinedPath;
  }

  Chartist.Svg.Path = Chartist.Class.extend({
    constructor: SvgPath,
    position: position,
    remove: remove,
    move: move,
    line: line,
    curve: curve,
    arc: arc,
    scale: scale,
    translate: translate,
    transform: transform,
    parse: parse,
    stringify: stringify,
    clone: clone,
    splitByCommand: splitByCommand
  });

  Chartist.Svg.Path.elementDescriptions = elementDescriptions;
  Chartist.Svg.Path.join = join;
}(this || __webpack_require__.g, Chartist));
;/* global Chartist */
(function (globalRoot, Chartist) {
  'use strict';

  var window = globalRoot.window;
  var document = globalRoot.document;

  var axisUnits = {
    x: {
      pos: 'x',
      len: 'width',
      dir: 'horizontal',
      rectStart: 'x1',
      rectEnd: 'x2',
      rectOffset: 'y2'
    },
    y: {
      pos: 'y',
      len: 'height',
      dir: 'vertical',
      rectStart: 'y2',
      rectEnd: 'y1',
      rectOffset: 'x1'
    }
  };

  function Axis(units, chartRect, ticks, options) {
    this.units = units;
    this.counterUnits = units === axisUnits.x ? axisUnits.y : axisUnits.x;
    this.chartRect = chartRect;
    this.axisLength = chartRect[units.rectEnd] - chartRect[units.rectStart];
    this.gridOffset = chartRect[units.rectOffset];
    this.ticks = ticks;
    this.options = options;
  }

  function createGridAndLabels(gridGroup, labelGroup, useForeignObject, chartOptions, eventEmitter) {
    var axisOptions = chartOptions['axis' + this.units.pos.toUpperCase()];
    var projectedValues = this.ticks.map(this.projectValue.bind(this));
    var labelValues = this.ticks.map(axisOptions.labelInterpolationFnc);

    projectedValues.forEach(function(projectedValue, index) {
      var labelOffset = {
        x: 0,
        y: 0
      };

      // TODO: Find better solution for solving this problem
      // Calculate how much space we have available for the label
      var labelLength;
      if(projectedValues[index + 1]) {
        // If we still have one label ahead, we can calculate the distance to the next tick / label
        labelLength = projectedValues[index + 1] - projectedValue;
      } else {
        // If we don't have a label ahead and we have only two labels in total, we just take the remaining distance to
        // on the whole axis length. We limit that to a minimum of 30 pixel, so that labels close to the border will
        // still be visible inside of the chart padding.
        labelLength = Math.max(this.axisLength - projectedValue, 30);
      }

      // Skip grid lines and labels where interpolated label values are falsey (execpt for 0)
      if(Chartist.isFalseyButZero(labelValues[index]) && labelValues[index] !== '') {
        return;
      }

      // Transform to global coordinates using the chartRect
      // We also need to set the label offset for the createLabel function
      if(this.units.pos === 'x') {
        projectedValue = this.chartRect.x1 + projectedValue;
        labelOffset.x = chartOptions.axisX.labelOffset.x;

        // If the labels should be positioned in start position (top side for vertical axis) we need to set a
        // different offset as for positioned with end (bottom)
        if(chartOptions.axisX.position === 'start') {
          labelOffset.y = this.chartRect.padding.top + chartOptions.axisX.labelOffset.y + (useForeignObject ? 5 : 20);
        } else {
          labelOffset.y = this.chartRect.y1 + chartOptions.axisX.labelOffset.y + (useForeignObject ? 5 : 20);
        }
      } else {
        projectedValue = this.chartRect.y1 - projectedValue;
        labelOffset.y = chartOptions.axisY.labelOffset.y - (useForeignObject ? labelLength : 0);

        // If the labels should be positioned in start position (left side for horizontal axis) we need to set a
        // different offset as for positioned with end (right side)
        if(chartOptions.axisY.position === 'start') {
          labelOffset.x = useForeignObject ? this.chartRect.padding.left + chartOptions.axisY.labelOffset.x : this.chartRect.x1 - 10;
        } else {
          labelOffset.x = this.chartRect.x2 + chartOptions.axisY.labelOffset.x + 10;
        }
      }

      if(axisOptions.showGrid) {
        Chartist.createGrid(projectedValue, index, this, this.gridOffset, this.chartRect[this.counterUnits.len](), gridGroup, [
          chartOptions.classNames.grid,
          chartOptions.classNames[this.units.dir]
        ], eventEmitter);
      }

      if(axisOptions.showLabel) {
        Chartist.createLabel(projectedValue, labelLength, index, labelValues, this, axisOptions.offset, labelOffset, labelGroup, [
          chartOptions.classNames.label,
          chartOptions.classNames[this.units.dir],
          (axisOptions.position === 'start' ? chartOptions.classNames[axisOptions.position] : chartOptions.classNames['end'])
        ], useForeignObject, eventEmitter);
      }
    }.bind(this));
  }

  Chartist.Axis = Chartist.Class.extend({
    constructor: Axis,
    createGridAndLabels: createGridAndLabels,
    projectValue: function(value, index, data) {
      throw new Error('Base axis can\'t be instantiated!');
    }
  });

  Chartist.Axis.units = axisUnits;

}(this || __webpack_require__.g, Chartist));
;/**
 * The auto scale axis uses standard linear scale projection of values along an axis. It uses order of magnitude to find a scale automatically and evaluates the available space in order to find the perfect amount of ticks for your chart.
 * **Options**
 * The following options are used by this axis in addition to the default axis options outlined in the axis configuration of the chart default settings.
 * ```javascript
 * var options = {
 *   // If high is specified then the axis will display values explicitly up to this value and the computed maximum from the data is ignored
 *   high: 100,
 *   // If low is specified then the axis will display values explicitly down to this value and the computed minimum from the data is ignored
 *   low: 0,
 *   // This option will be used when finding the right scale division settings. The amount of ticks on the scale will be determined so that as many ticks as possible will be displayed, while not violating this minimum required space (in pixel).
 *   scaleMinSpace: 20,
 *   // Can be set to true or false. If set to true, the scale will be generated with whole numbers only.
 *   onlyInteger: true,
 *   // The reference value can be used to make sure that this value will always be on the chart. This is especially useful on bipolar charts where the bipolar center always needs to be part of the chart.
 *   referenceValue: 5
 * };
 * ```
 *
 * @module Chartist.AutoScaleAxis
 */
/* global Chartist */
(function (globalRoot, Chartist) {
  'use strict';

  var window = globalRoot.window;
  var document = globalRoot.document;

  function AutoScaleAxis(axisUnit, data, chartRect, options) {
    // Usually we calculate highLow based on the data but this can be overriden by a highLow object in the options
    var highLow = options.highLow || Chartist.getHighLow(data, options, axisUnit.pos);
    this.bounds = Chartist.getBounds(chartRect[axisUnit.rectEnd] - chartRect[axisUnit.rectStart], highLow, options.scaleMinSpace || 20, options.onlyInteger);
    this.range = {
      min: this.bounds.min,
      max: this.bounds.max
    };

    Chartist.AutoScaleAxis.super.constructor.call(this,
      axisUnit,
      chartRect,
      this.bounds.values,
      options);
  }

  function projectValue(value) {
    return this.axisLength * (+Chartist.getMultiValue(value, this.units.pos) - this.bounds.min) / this.bounds.range;
  }

  Chartist.AutoScaleAxis = Chartist.Axis.extend({
    constructor: AutoScaleAxis,
    projectValue: projectValue
  });

}(this || __webpack_require__.g, Chartist));
;/**
 * The fixed scale axis uses standard linear projection of values along an axis. It makes use of a divisor option to divide the range provided from the minimum and maximum value or the options high and low that will override the computed minimum and maximum.
 * **Options**
 * The following options are used by this axis in addition to the default axis options outlined in the axis configuration of the chart default settings.
 * ```javascript
 * var options = {
 *   // If high is specified then the axis will display values explicitly up to this value and the computed maximum from the data is ignored
 *   high: 100,
 *   // If low is specified then the axis will display values explicitly down to this value and the computed minimum from the data is ignored
 *   low: 0,
 *   // If specified then the value range determined from minimum to maximum (or low and high) will be divided by this number and ticks will be generated at those division points. The default divisor is 1.
 *   divisor: 4,
 *   // If ticks is explicitly set, then the axis will not compute the ticks with the divisor, but directly use the data in ticks to determine at what points on the axis a tick need to be generated.
 *   ticks: [1, 10, 20, 30]
 * };
 * ```
 *
 * @module Chartist.FixedScaleAxis
 */
/* global Chartist */
(function (globalRoot, Chartist) {
  'use strict';

  var window = globalRoot.window;
  var document = globalRoot.document;

  function FixedScaleAxis(axisUnit, data, chartRect, options) {
    var highLow = options.highLow || Chartist.getHighLow(data, options, axisUnit.pos);
    this.divisor = options.divisor || 1;
    this.ticks = options.ticks || Chartist.times(this.divisor).map(function(value, index) {
      return highLow.low + (highLow.high - highLow.low) / this.divisor * index;
    }.bind(this));
    this.ticks.sort(function(a, b) {
      return a - b;
    });
    this.range = {
      min: highLow.low,
      max: highLow.high
    };

    Chartist.FixedScaleAxis.super.constructor.call(this,
      axisUnit,
      chartRect,
      this.ticks,
      options);

    this.stepLength = this.axisLength / this.divisor;
  }

  function projectValue(value) {
    return this.axisLength * (+Chartist.getMultiValue(value, this.units.pos) - this.range.min) / (this.range.max - this.range.min);
  }

  Chartist.FixedScaleAxis = Chartist.Axis.extend({
    constructor: FixedScaleAxis,
    projectValue: projectValue
  });

}(this || __webpack_require__.g, Chartist));
;/**
 * The step axis for step based charts like bar chart or step based line charts. It uses a fixed amount of ticks that will be equally distributed across the whole axis length. The projection is done using the index of the data value rather than the value itself and therefore it's only useful for distribution purpose.
 * **Options**
 * The following options are used by this axis in addition to the default axis options outlined in the axis configuration of the chart default settings.
 * ```javascript
 * var options = {
 *   // Ticks to be used to distribute across the axis length. As this axis type relies on the index of the value rather than the value, arbitrary data that can be converted to a string can be used as ticks.
 *   ticks: ['One', 'Two', 'Three'],
 *   // If set to true the full width will be used to distribute the values where the last value will be at the maximum of the axis length. If false the spaces between the ticks will be evenly distributed instead.
 *   stretch: true
 * };
 * ```
 *
 * @module Chartist.StepAxis
 */
/* global Chartist */
(function (globalRoot, Chartist) {
  'use strict';

  var window = globalRoot.window;
  var document = globalRoot.document;

  function StepAxis(axisUnit, data, chartRect, options) {
    Chartist.StepAxis.super.constructor.call(this,
      axisUnit,
      chartRect,
      options.ticks,
      options);

    var calc = Math.max(1, options.ticks.length - (options.stretch ? 1 : 0));
    this.stepLength = this.axisLength / calc;
  }

  function projectValue(value, index) {
    return this.stepLength * index;
  }

  Chartist.StepAxis = Chartist.Axis.extend({
    constructor: StepAxis,
    projectValue: projectValue
  });

}(this || __webpack_require__.g, Chartist));
;/**
 * The Chartist line chart can be used to draw Line or Scatter charts. If used in the browser you can access the global `Chartist` namespace where you find the `Line` function as a main entry point.
 *
 * For examples on how to use the line chart please check the examples of the `Chartist.Line` method.
 *
 * @module Chartist.Line
 */
/* global Chartist */
(function(globalRoot, Chartist){
  'use strict';

  var window = globalRoot.window;
  var document = globalRoot.document;

  /**
   * Default options in line charts. Expand the code view to see a detailed list of options with comments.
   *
   * @memberof Chartist.Line
   */
  var defaultOptions = {
    // Options for X-Axis
    axisX: {
      // The offset of the labels to the chart area
      offset: 30,
      // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.
      position: 'end',
      // Allows you to correct label positioning on this axis by positive or negative x and y offset.
      labelOffset: {
        x: 0,
        y: 0
      },
      // If labels should be shown or not
      showLabel: true,
      // If the axis grid should be drawn or not
      showGrid: true,
      // Interpolation function that allows you to intercept the value from the axis label
      labelInterpolationFnc: Chartist.noop,
      // Set the axis type to be used to project values on this axis. If not defined, Chartist.StepAxis will be used for the X-Axis, where the ticks option will be set to the labels in the data and the stretch option will be set to the global fullWidth option. This type can be changed to any axis constructor available (e.g. Chartist.FixedScaleAxis), where all axis options should be present here.
      type: undefined
    },
    // Options for Y-Axis
    axisY: {
      // The offset of the labels to the chart area
      offset: 40,
      // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.
      position: 'start',
      // Allows you to correct label positioning on this axis by positive or negative x and y offset.
      labelOffset: {
        x: 0,
        y: 0
      },
      // If labels should be shown or not
      showLabel: true,
      // If the axis grid should be drawn or not
      showGrid: true,
      // Interpolation function that allows you to intercept the value from the axis label
      labelInterpolationFnc: Chartist.noop,
      // Set the axis type to be used to project values on this axis. If not defined, Chartist.AutoScaleAxis will be used for the Y-Axis, where the high and low options will be set to the global high and low options. This type can be changed to any axis constructor available (e.g. Chartist.FixedScaleAxis), where all axis options should be present here.
      type: undefined,
      // This value specifies the minimum height in pixel of the scale steps
      scaleMinSpace: 20,
      // Use only integer values (whole numbers) for the scale steps
      onlyInteger: false
    },
    // Specify a fixed width for the chart as a string (i.e. '100px' or '50%')
    width: undefined,
    // Specify a fixed height for the chart as a string (i.e. '100px' or '50%')
    height: undefined,
    // If the line should be drawn or not
    showLine: true,
    // If dots should be drawn or not
    showPoint: true,
    // If the line chart should draw an area
    showArea: false,
    // The base for the area chart that will be used to close the area shape (is normally 0)
    areaBase: 0,
    // Specify if the lines should be smoothed. This value can be true or false where true will result in smoothing using the default smoothing interpolation function Chartist.Interpolation.cardinal and false results in Chartist.Interpolation.none. You can also choose other smoothing / interpolation functions available in the Chartist.Interpolation module, or write your own interpolation function. Check the examples for a brief description.
    lineSmooth: true,
    // If the line chart should add a background fill to the .ct-grids group.
    showGridBackground: false,
    // Overriding the natural low of the chart allows you to zoom in or limit the charts lowest displayed value
    low: undefined,
    // Overriding the natural high of the chart allows you to zoom in or limit the charts highest displayed value
    high: undefined,
    // Padding of the chart drawing area to the container element and labels as a number or padding object {top: 5, right: 5, bottom: 5, left: 5}
    chartPadding: {
      top: 15,
      right: 15,
      bottom: 5,
      left: 10
    },
    // When set to true, the last grid line on the x-axis is not drawn and the chart elements will expand to the full available width of the chart. For the last label to be drawn correctly you might need to add chart padding or offset the last label with a draw event handler.
    fullWidth: false,
    // If true the whole data is reversed including labels, the series order as well as the whole series data arrays.
    reverseData: false,
    // Override the class names that get used to generate the SVG structure of the chart
    classNames: {
      chart: 'ct-chart-line',
      label: 'ct-label',
      labelGroup: 'ct-labels',
      series: 'ct-series',
      line: 'ct-line',
      point: 'ct-point',
      area: 'ct-area',
      grid: 'ct-grid',
      gridGroup: 'ct-grids',
      gridBackground: 'ct-grid-background',
      vertical: 'ct-vertical',
      horizontal: 'ct-horizontal',
      start: 'ct-start',
      end: 'ct-end'
    }
  };

  /**
   * Creates a new chart
   *
   */
  function createChart(options) {
    var data = Chartist.normalizeData(this.data, options.reverseData, true);

    // Create new svg object
    this.svg = Chartist.createSvg(this.container, options.width, options.height, options.classNames.chart);
    // Create groups for labels, grid and series
    var gridGroup = this.svg.elem('g').addClass(options.classNames.gridGroup);
    var seriesGroup = this.svg.elem('g');
    var labelGroup = this.svg.elem('g').addClass(options.classNames.labelGroup);

    var chartRect = Chartist.createChartRect(this.svg, options, defaultOptions.padding);
    var axisX, axisY;

    if(options.axisX.type === undefined) {
      axisX = new Chartist.StepAxis(Chartist.Axis.units.x, data.normalized.series, chartRect, Chartist.extend({}, options.axisX, {
        ticks: data.normalized.labels,
        stretch: options.fullWidth
      }));
    } else {
      axisX = options.axisX.type.call(Chartist, Chartist.Axis.units.x, data.normalized.series, chartRect, options.axisX);
    }

    if(options.axisY.type === undefined) {
      axisY = new Chartist.AutoScaleAxis(Chartist.Axis.units.y, data.normalized.series, chartRect, Chartist.extend({}, options.axisY, {
        high: Chartist.isNumeric(options.high) ? options.high : options.axisY.high,
        low: Chartist.isNumeric(options.low) ? options.low : options.axisY.low
      }));
    } else {
      axisY = options.axisY.type.call(Chartist, Chartist.Axis.units.y, data.normalized.series, chartRect, options.axisY);
    }

    axisX.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);
    axisY.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);

    if (options.showGridBackground) {
      Chartist.createGridBackground(gridGroup, chartRect, options.classNames.gridBackground, this.eventEmitter);
    }

    // Draw the series
    data.raw.series.forEach(function(series, seriesIndex) {
      var seriesElement = seriesGroup.elem('g');

      // Write attributes to series group element. If series name or meta is undefined the attributes will not be written
      seriesElement.attr({
        'ct:series-name': series.name,
        'ct:meta': Chartist.serialize(series.meta)
      });

      // Use series class from series data or if not set generate one
      seriesElement.addClass([
        options.classNames.series,
        (series.className || options.classNames.series + '-' + Chartist.alphaNumerate(seriesIndex))
      ].join(' '));

      var pathCoordinates = [],
        pathData = [];

      data.normalized.series[seriesIndex].forEach(function(value, valueIndex) {
        var p = {
          x: chartRect.x1 + axisX.projectValue(value, valueIndex, data.normalized.series[seriesIndex]),
          y: chartRect.y1 - axisY.projectValue(value, valueIndex, data.normalized.series[seriesIndex])
        };
        pathCoordinates.push(p.x, p.y);
        pathData.push({
          value: value,
          valueIndex: valueIndex,
          meta: Chartist.getMetaData(series, valueIndex)
        });
      }.bind(this));

      var seriesOptions = {
        lineSmooth: Chartist.getSeriesOption(series, options, 'lineSmooth'),
        showPoint: Chartist.getSeriesOption(series, options, 'showPoint'),
        showLine: Chartist.getSeriesOption(series, options, 'showLine'),
        showArea: Chartist.getSeriesOption(series, options, 'showArea'),
        areaBase: Chartist.getSeriesOption(series, options, 'areaBase')
      };

      var smoothing = typeof seriesOptions.lineSmooth === 'function' ?
        seriesOptions.lineSmooth : (seriesOptions.lineSmooth ? Chartist.Interpolation.monotoneCubic() : Chartist.Interpolation.none());
      // Interpolating path where pathData will be used to annotate each path element so we can trace back the original
      // index, value and meta data
      var path = smoothing(pathCoordinates, pathData);

      // If we should show points we need to create them now to avoid secondary loop
      // Points are drawn from the pathElements returned by the interpolation function
      // Small offset for Firefox to render squares correctly
      if (seriesOptions.showPoint) {

        path.pathElements.forEach(function(pathElement) {
          var point = seriesElement.elem('line', {
            x1: pathElement.x,
            y1: pathElement.y,
            x2: pathElement.x + 0.01,
            y2: pathElement.y
          }, options.classNames.point).attr({
            'ct:value': [pathElement.data.value.x, pathElement.data.value.y].filter(Chartist.isNumeric).join(','),
            'ct:meta': Chartist.serialize(pathElement.data.meta)
          });

          this.eventEmitter.emit('draw', {
            type: 'point',
            value: pathElement.data.value,
            index: pathElement.data.valueIndex,
            meta: pathElement.data.meta,
            series: series,
            seriesIndex: seriesIndex,
            axisX: axisX,
            axisY: axisY,
            group: seriesElement,
            element: point,
            x: pathElement.x,
            y: pathElement.y
          });
        }.bind(this));
      }

      if(seriesOptions.showLine) {
        var line = seriesElement.elem('path', {
          d: path.stringify()
        }, options.classNames.line, true);

        this.eventEmitter.emit('draw', {
          type: 'line',
          values: data.normalized.series[seriesIndex],
          path: path.clone(),
          chartRect: chartRect,
          index: seriesIndex,
          series: series,
          seriesIndex: seriesIndex,
          seriesMeta: series.meta,
          axisX: axisX,
          axisY: axisY,
          group: seriesElement,
          element: line
        });
      }

      // Area currently only works with axes that support a range!
      if(seriesOptions.showArea && axisY.range) {
        // If areaBase is outside the chart area (< min or > max) we need to set it respectively so that
        // the area is not drawn outside the chart area.
        var areaBase = Math.max(Math.min(seriesOptions.areaBase, axisY.range.max), axisY.range.min);

        // We project the areaBase value into screen coordinates
        var areaBaseProjected = chartRect.y1 - axisY.projectValue(areaBase);

        // In order to form the area we'll first split the path by move commands so we can chunk it up into segments
        path.splitByCommand('M').filter(function onlySolidSegments(pathSegment) {
          // We filter only "solid" segments that contain more than one point. Otherwise there's no need for an area
          return pathSegment.pathElements.length > 1;
        }).map(function convertToArea(solidPathSegments) {
          // Receiving the filtered solid path segments we can now convert those segments into fill areas
          var firstElement = solidPathSegments.pathElements[0];
          var lastElement = solidPathSegments.pathElements[solidPathSegments.pathElements.length - 1];

          // Cloning the solid path segment with closing option and removing the first move command from the clone
          // We then insert a new move that should start at the area base and draw a straight line up or down
          // at the end of the path we add an additional straight line to the projected area base value
          // As the closing option is set our path will be automatically closed
          return solidPathSegments.clone(true)
            .position(0)
            .remove(1)
            .move(firstElement.x, areaBaseProjected)
            .line(firstElement.x, firstElement.y)
            .position(solidPathSegments.pathElements.length + 1)
            .line(lastElement.x, areaBaseProjected);

        }).forEach(function createArea(areaPath) {
          // For each of our newly created area paths, we'll now create path elements by stringifying our path objects
          // and adding the created DOM elements to the correct series group
          var area = seriesElement.elem('path', {
            d: areaPath.stringify()
          }, options.classNames.area, true);

          // Emit an event for each area that was drawn
          this.eventEmitter.emit('draw', {
            type: 'area',
            values: data.normalized.series[seriesIndex],
            path: areaPath.clone(),
            series: series,
            seriesIndex: seriesIndex,
            axisX: axisX,
            axisY: axisY,
            chartRect: chartRect,
            index: seriesIndex,
            group: seriesElement,
            element: area
          });
        }.bind(this));
      }
    }.bind(this));

    this.eventEmitter.emit('created', {
      bounds: axisY.bounds,
      chartRect: chartRect,
      axisX: axisX,
      axisY: axisY,
      svg: this.svg,
      options: options
    });
  }

  /**
   * This method creates a new line chart.
   *
   * @memberof Chartist.Line
   * @param {String|Node} query A selector query string or directly a DOM element
   * @param {Object} data The data object that needs to consist of a labels and a series array
   * @param {Object} [options] The options object with options that override the default options. Check the examples for a detailed list.
   * @param {Array} [responsiveOptions] Specify an array of responsive option arrays which are a media query and options object pair => [[mediaQueryString, optionsObject],[more...]]
   * @return {Object} An object which exposes the API for the created chart
   *
   * @example
   * // Create a simple line chart
   * var data = {
   *   // A labels array that can contain any sort of values
   *   labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],
   *   // Our series array that contains series objects or in this case series data arrays
   *   series: [
   *     [5, 2, 4, 2, 0]
   *   ]
   * };
   *
   * // As options we currently only set a static size of 300x200 px
   * var options = {
   *   width: '300px',
   *   height: '200px'
   * };
   *
   * // In the global name space Chartist we call the Line function to initialize a line chart. As a first parameter we pass in a selector where we would like to get our chart created. Second parameter is the actual data object and as a third parameter we pass in our options
   * new Chartist.Line('.ct-chart', data, options);
   *
   * @example
   * // Use specific interpolation function with configuration from the Chartist.Interpolation module
   *
   * var chart = new Chartist.Line('.ct-chart', {
   *   labels: [1, 2, 3, 4, 5],
   *   series: [
   *     [1, 1, 8, 1, 7]
   *   ]
   * }, {
   *   lineSmooth: Chartist.Interpolation.cardinal({
   *     tension: 0.2
   *   })
   * });
   *
   * @example
   * // Create a line chart with responsive options
   *
   * var data = {
   *   // A labels array that can contain any sort of values
   *   labels: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],
   *   // Our series array that contains series objects or in this case series data arrays
   *   series: [
   *     [5, 2, 4, 2, 0]
   *   ]
   * };
   *
   * // In addition to the regular options we specify responsive option overrides that will override the default configutation based on the matching media queries.
   * var responsiveOptions = [
   *   ['screen and (min-width: 641px) and (max-width: 1024px)', {
   *     showPoint: false,
   *     axisX: {
   *       labelInterpolationFnc: function(value) {
   *         // Will return Mon, Tue, Wed etc. on medium screens
   *         return value.slice(0, 3);
   *       }
   *     }
   *   }],
   *   ['screen and (max-width: 640px)', {
   *     showLine: false,
   *     axisX: {
   *       labelInterpolationFnc: function(value) {
   *         // Will return M, T, W etc. on small screens
   *         return value[0];
   *       }
   *     }
   *   }]
   * ];
   *
   * new Chartist.Line('.ct-chart', data, null, responsiveOptions);
   *
   */
  function Line(query, data, options, responsiveOptions) {
    Chartist.Line.super.constructor.call(this,
      query,
      data,
      defaultOptions,
      Chartist.extend({}, defaultOptions, options),
      responsiveOptions);
  }

  // Creating line chart type in Chartist namespace
  Chartist.Line = Chartist.Base.extend({
    constructor: Line,
    createChart: createChart
  });

}(this || __webpack_require__.g, Chartist));
;/**
 * The bar chart module of Chartist that can be used to draw unipolar or bipolar bar and grouped bar charts.
 *
 * @module Chartist.Bar
 */
/* global Chartist */
(function(globalRoot, Chartist){
  'use strict';

  var window = globalRoot.window;
  var document = globalRoot.document;

  /**
   * Default options in bar charts. Expand the code view to see a detailed list of options with comments.
   *
   * @memberof Chartist.Bar
   */
  var defaultOptions = {
    // Options for X-Axis
    axisX: {
      // The offset of the chart drawing area to the border of the container
      offset: 30,
      // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.
      position: 'end',
      // Allows you to correct label positioning on this axis by positive or negative x and y offset.
      labelOffset: {
        x: 0,
        y: 0
      },
      // If labels should be shown or not
      showLabel: true,
      // If the axis grid should be drawn or not
      showGrid: true,
      // Interpolation function that allows you to intercept the value from the axis label
      labelInterpolationFnc: Chartist.noop,
      // This value specifies the minimum width in pixel of the scale steps
      scaleMinSpace: 30,
      // Use only integer values (whole numbers) for the scale steps
      onlyInteger: false
    },
    // Options for Y-Axis
    axisY: {
      // The offset of the chart drawing area to the border of the container
      offset: 40,
      // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.
      position: 'start',
      // Allows you to correct label positioning on this axis by positive or negative x and y offset.
      labelOffset: {
        x: 0,
        y: 0
      },
      // If labels should be shown or not
      showLabel: true,
      // If the axis grid should be drawn or not
      showGrid: true,
      // Interpolation function that allows you to intercept the value from the axis label
      labelInterpolationFnc: Chartist.noop,
      // This value specifies the minimum height in pixel of the scale steps
      scaleMinSpace: 20,
      // Use only integer values (whole numbers) for the scale steps
      onlyInteger: false
    },
    // Specify a fixed width for the chart as a string (i.e. '100px' or '50%')
    width: undefined,
    // Specify a fixed height for the chart as a string (i.e. '100px' or '50%')
    height: undefined,
    // Overriding the natural high of the chart allows you to zoom in or limit the charts highest displayed value
    high: undefined,
    // Overriding the natural low of the chart allows you to zoom in or limit the charts lowest displayed value
    low: undefined,
    // Unless low/high are explicitly set, bar chart will be centered at zero by default. Set referenceValue to null to auto scale.
    referenceValue: 0,
    // Padding of the chart drawing area to the container element and labels as a number or padding object {top: 5, right: 5, bottom: 5, left: 5}
    chartPadding: {
      top: 15,
      right: 15,
      bottom: 5,
      left: 10
    },
    // Specify the distance in pixel of bars in a group
    seriesBarDistance: 15,
    // If set to true this property will cause the series bars to be stacked. Check the `stackMode` option for further stacking options.
    stackBars: false,
    // If set to 'overlap' this property will force the stacked bars to draw from the zero line.
    // If set to 'accumulate' this property will form a total for each series point. This will also influence the y-axis and the overall bounds of the chart. In stacked mode the seriesBarDistance property will have no effect.
    stackMode: 'accumulate',
    // Inverts the axes of the bar chart in order to draw a horizontal bar chart. Be aware that you also need to invert your axis settings as the Y Axis will now display the labels and the X Axis the values.
    horizontalBars: false,
    // If set to true then each bar will represent a series and the data array is expected to be a one dimensional array of data values rather than a series array of series. This is useful if the bar chart should represent a profile rather than some data over time.
    distributeSeries: false,
    // If true the whole data is reversed including labels, the series order as well as the whole series data arrays.
    reverseData: false,
    // If the bar chart should add a background fill to the .ct-grids group.
    showGridBackground: false,
    // Override the class names that get used to generate the SVG structure of the chart
    classNames: {
      chart: 'ct-chart-bar',
      horizontalBars: 'ct-horizontal-bars',
      label: 'ct-label',
      labelGroup: 'ct-labels',
      series: 'ct-series',
      bar: 'ct-bar',
      grid: 'ct-grid',
      gridGroup: 'ct-grids',
      gridBackground: 'ct-grid-background',
      vertical: 'ct-vertical',
      horizontal: 'ct-horizontal',
      start: 'ct-start',
      end: 'ct-end'
    }
  };

  /**
   * Creates a new chart
   *
   */
  function createChart(options) {
    var data;
    var highLow;

    if(options.distributeSeries) {
      data = Chartist.normalizeData(this.data, options.reverseData, options.horizontalBars ? 'x' : 'y');
      data.normalized.series = data.normalized.series.map(function(value) {
        return [value];
      });
    } else {
      data = Chartist.normalizeData(this.data, options.reverseData, options.horizontalBars ? 'x' : 'y');
    }

    // Create new svg element
    this.svg = Chartist.createSvg(
      this.container,
      options.width,
      options.height,
      options.classNames.chart + (options.horizontalBars ? ' ' + options.classNames.horizontalBars : '')
    );

    // Drawing groups in correct order
    var gridGroup = this.svg.elem('g').addClass(options.classNames.gridGroup);
    var seriesGroup = this.svg.elem('g');
    var labelGroup = this.svg.elem('g').addClass(options.classNames.labelGroup);

    if(options.stackBars && data.normalized.series.length !== 0) {

      // If stacked bars we need to calculate the high low from stacked values from each series
      var serialSums = Chartist.serialMap(data.normalized.series, function serialSums() {
        return Array.prototype.slice.call(arguments).map(function(value) {
          return value;
        }).reduce(function(prev, curr) {
          return {
            x: prev.x + (curr && curr.x) || 0,
            y: prev.y + (curr && curr.y) || 0
          };
        }, {x: 0, y: 0});
      });

      highLow = Chartist.getHighLow([serialSums], options, options.horizontalBars ? 'x' : 'y');

    } else {

      highLow = Chartist.getHighLow(data.normalized.series, options, options.horizontalBars ? 'x' : 'y');
    }

    // Overrides of high / low from settings
    highLow.high = +options.high || (options.high === 0 ? 0 : highLow.high);
    highLow.low = +options.low || (options.low === 0 ? 0 : highLow.low);

    var chartRect = Chartist.createChartRect(this.svg, options, defaultOptions.padding);

    var valueAxis,
      labelAxisTicks,
      labelAxis,
      axisX,
      axisY;

    // We need to set step count based on some options combinations
    if(options.distributeSeries && options.stackBars) {
      // If distributed series are enabled and bars need to be stacked, we'll only have one bar and therefore should
      // use only the first label for the step axis
      labelAxisTicks = data.normalized.labels.slice(0, 1);
    } else {
      // If distributed series are enabled but stacked bars aren't, we should use the series labels
      // If we are drawing a regular bar chart with two dimensional series data, we just use the labels array
      // as the bars are normalized
      labelAxisTicks = data.normalized.labels;
    }

    // Set labelAxis and valueAxis based on the horizontalBars setting. This setting will flip the axes if necessary.
    if(options.horizontalBars) {
      if(options.axisX.type === undefined) {
        valueAxis = axisX = new Chartist.AutoScaleAxis(Chartist.Axis.units.x, data.normalized.series, chartRect, Chartist.extend({}, options.axisX, {
          highLow: highLow,
          referenceValue: 0
        }));
      } else {
        valueAxis = axisX = options.axisX.type.call(Chartist, Chartist.Axis.units.x, data.normalized.series, chartRect, Chartist.extend({}, options.axisX, {
          highLow: highLow,
          referenceValue: 0
        }));
      }

      if(options.axisY.type === undefined) {
        labelAxis = axisY = new Chartist.StepAxis(Chartist.Axis.units.y, data.normalized.series, chartRect, {
          ticks: labelAxisTicks
        });
      } else {
        labelAxis = axisY = options.axisY.type.call(Chartist, Chartist.Axis.units.y, data.normalized.series, chartRect, options.axisY);
      }
    } else {
      if(options.axisX.type === undefined) {
        labelAxis = axisX = new Chartist.StepAxis(Chartist.Axis.units.x, data.normalized.series, chartRect, {
          ticks: labelAxisTicks
        });
      } else {
        labelAxis = axisX = options.axisX.type.call(Chartist, Chartist.Axis.units.x, data.normalized.series, chartRect, options.axisX);
      }

      if(options.axisY.type === undefined) {
        valueAxis = axisY = new Chartist.AutoScaleAxis(Chartist.Axis.units.y, data.normalized.series, chartRect, Chartist.extend({}, options.axisY, {
          highLow: highLow,
          referenceValue: 0
        }));
      } else {
        valueAxis = axisY = options.axisY.type.call(Chartist, Chartist.Axis.units.y, data.normalized.series, chartRect, Chartist.extend({}, options.axisY, {
          highLow: highLow,
          referenceValue: 0
        }));
      }
    }

    // Projected 0 point
    var zeroPoint = options.horizontalBars ? (chartRect.x1 + valueAxis.projectValue(0)) : (chartRect.y1 - valueAxis.projectValue(0));
    // Used to track the screen coordinates of stacked bars
    var stackedBarValues = [];

    labelAxis.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);
    valueAxis.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);

    if (options.showGridBackground) {
      Chartist.createGridBackground(gridGroup, chartRect, options.classNames.gridBackground, this.eventEmitter);
    }

    // Draw the series
    data.raw.series.forEach(function(series, seriesIndex) {
      // Calculating bi-polar value of index for seriesOffset. For i = 0..4 biPol will be -1.5, -0.5, 0.5, 1.5 etc.
      var biPol = seriesIndex - (data.raw.series.length - 1) / 2;
      // Half of the period width between vertical grid lines used to position bars
      var periodHalfLength;
      // Current series SVG element
      var seriesElement;

      // We need to set periodHalfLength based on some options combinations
      if(options.distributeSeries && !options.stackBars) {
        // If distributed series are enabled but stacked bars aren't, we need to use the length of the normaizedData array
        // which is the series count and divide by 2
        periodHalfLength = labelAxis.axisLength / data.normalized.series.length / 2;
      } else if(options.distributeSeries && options.stackBars) {
        // If distributed series and stacked bars are enabled we'll only get one bar so we should just divide the axis
        // length by 2
        periodHalfLength = labelAxis.axisLength / 2;
      } else {
        // On regular bar charts we should just use the series length
        periodHalfLength = labelAxis.axisLength / data.normalized.series[seriesIndex].length / 2;
      }

      // Adding the series group to the series element
      seriesElement = seriesGroup.elem('g');

      // Write attributes to series group element. If series name or meta is undefined the attributes will not be written
      seriesElement.attr({
        'ct:series-name': series.name,
        'ct:meta': Chartist.serialize(series.meta)
      });

      // Use series class from series data or if not set generate one
      seriesElement.addClass([
        options.classNames.series,
        (series.className || options.classNames.series + '-' + Chartist.alphaNumerate(seriesIndex))
      ].join(' '));

      data.normalized.series[seriesIndex].forEach(function(value, valueIndex) {
        var projected,
          bar,
          previousStack,
          labelAxisValueIndex;

        // We need to set labelAxisValueIndex based on some options combinations
        if(options.distributeSeries && !options.stackBars) {
          // If distributed series are enabled but stacked bars aren't, we can use the seriesIndex for later projection
          // on the step axis for label positioning
          labelAxisValueIndex = seriesIndex;
        } else if(options.distributeSeries && options.stackBars) {
          // If distributed series and stacked bars are enabled, we will only get one bar and therefore always use
          // 0 for projection on the label step axis
          labelAxisValueIndex = 0;
        } else {
          // On regular bar charts we just use the value index to project on the label step axis
          labelAxisValueIndex = valueIndex;
        }

        // We need to transform coordinates differently based on the chart layout
        if(options.horizontalBars) {
          projected = {
            x: chartRect.x1 + valueAxis.projectValue(value && value.x ? value.x : 0, valueIndex, data.normalized.series[seriesIndex]),
            y: chartRect.y1 - labelAxis.projectValue(value && value.y ? value.y : 0, labelAxisValueIndex, data.normalized.series[seriesIndex])
          };
        } else {
          projected = {
            x: chartRect.x1 + labelAxis.projectValue(value && value.x ? value.x : 0, labelAxisValueIndex, data.normalized.series[seriesIndex]),
            y: chartRect.y1 - valueAxis.projectValue(value && value.y ? value.y : 0, valueIndex, data.normalized.series[seriesIndex])
          }
        }

        // If the label axis is a step based axis we will offset the bar into the middle of between two steps using
        // the periodHalfLength value. Also we do arrange the different series so that they align up to each other using
        // the seriesBarDistance. If we don't have a step axis, the bar positions can be chosen freely so we should not
        // add any automated positioning.
        if(labelAxis instanceof Chartist.StepAxis) {
          // Offset to center bar between grid lines, but only if the step axis is not stretched
          if(!labelAxis.options.stretch) {
            projected[labelAxis.units.pos] += periodHalfLength * (options.horizontalBars ? -1 : 1);
          }
          // Using bi-polar offset for multiple series if no stacked bars or series distribution is used
          projected[labelAxis.units.pos] += (options.stackBars || options.distributeSeries) ? 0 : biPol * options.seriesBarDistance * (options.horizontalBars ? -1 : 1);
        }

        // Enter value in stacked bar values used to remember previous screen value for stacking up bars
        previousStack = stackedBarValues[valueIndex] || zeroPoint;
        stackedBarValues[valueIndex] = previousStack - (zeroPoint - projected[labelAxis.counterUnits.pos]);

        // Skip if value is undefined
        if(value === undefined) {
          return;
        }

        var positions = {};
        positions[labelAxis.units.pos + '1'] = projected[labelAxis.units.pos];
        positions[labelAxis.units.pos + '2'] = projected[labelAxis.units.pos];

        if(options.stackBars && (options.stackMode === 'accumulate' || !options.stackMode)) {
          // Stack mode: accumulate (default)
          // If bars are stacked we use the stackedBarValues reference and otherwise base all bars off the zero line
          // We want backwards compatibility, so the expected fallback without the 'stackMode' option
          // to be the original behaviour (accumulate)
          positions[labelAxis.counterUnits.pos + '1'] = previousStack;
          positions[labelAxis.counterUnits.pos + '2'] = stackedBarValues[valueIndex];
        } else {
          // Draw from the zero line normally
          // This is also the same code for Stack mode: overlap
          positions[labelAxis.counterUnits.pos + '1'] = zeroPoint;
          positions[labelAxis.counterUnits.pos + '2'] = projected[labelAxis.counterUnits.pos];
        }

        // Limit x and y so that they are within the chart rect
        positions.x1 = Math.min(Math.max(positions.x1, chartRect.x1), chartRect.x2);
        positions.x2 = Math.min(Math.max(positions.x2, chartRect.x1), chartRect.x2);
        positions.y1 = Math.min(Math.max(positions.y1, chartRect.y2), chartRect.y1);
        positions.y2 = Math.min(Math.max(positions.y2, chartRect.y2), chartRect.y1);

        var metaData = Chartist.getMetaData(series, valueIndex);

        // Create bar element
        bar = seriesElement.elem('line', positions, options.classNames.bar).attr({
          'ct:value': [value.x, value.y].filter(Chartist.isNumeric).join(','),
          'ct:meta': Chartist.serialize(metaData)
        });

        this.eventEmitter.emit('draw', Chartist.extend({
          type: 'bar',
          value: value,
          index: valueIndex,
          meta: metaData,
          series: series,
          seriesIndex: seriesIndex,
          axisX: axisX,
          axisY: axisY,
          chartRect: chartRect,
          group: seriesElement,
          element: bar
        }, positions));
      }.bind(this));
    }.bind(this));

    this.eventEmitter.emit('created', {
      bounds: valueAxis.bounds,
      chartRect: chartRect,
      axisX: axisX,
      axisY: axisY,
      svg: this.svg,
      options: options
    });
  }

  /**
   * This method creates a new bar chart and returns API object that you can use for later changes.
   *
   * @memberof Chartist.Bar
   * @param {String|Node} query A selector query string or directly a DOM element
   * @param {Object} data The data object that needs to consist of a labels and a series array
   * @param {Object} [options] The options object with options that override the default options. Check the examples for a detailed list.
   * @param {Array} [responsiveOptions] Specify an array of responsive option arrays which are a media query and options object pair => [[mediaQueryString, optionsObject],[more...]]
   * @return {Object} An object which exposes the API for the created chart
   *
   * @example
   * // Create a simple bar chart
   * var data = {
   *   labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],
   *   series: [
   *     [5, 2, 4, 2, 0]
   *   ]
   * };
   *
   * // In the global name space Chartist we call the Bar function to initialize a bar chart. As a first parameter we pass in a selector where we would like to get our chart created and as a second parameter we pass our data object.
   * new Chartist.Bar('.ct-chart', data);
   *
   * @example
   * // This example creates a bipolar grouped bar chart where the boundaries are limitted to -10 and 10
   * new Chartist.Bar('.ct-chart', {
   *   labels: [1, 2, 3, 4, 5, 6, 7],
   *   series: [
   *     [1, 3, 2, -5, -3, 1, -6],
   *     [-5, -2, -4, -1, 2, -3, 1]
   *   ]
   * }, {
   *   seriesBarDistance: 12,
   *   low: -10,
   *   high: 10
   * });
   *
   */
  function Bar(query, data, options, responsiveOptions) {
    Chartist.Bar.super.constructor.call(this,
      query,
      data,
      defaultOptions,
      Chartist.extend({}, defaultOptions, options),
      responsiveOptions);
  }

  // Creating bar chart type in Chartist namespace
  Chartist.Bar = Chartist.Base.extend({
    constructor: Bar,
    createChart: createChart
  });

}(this || __webpack_require__.g, Chartist));
;/**
 * The pie chart module of Chartist that can be used to draw pie, donut or gauge charts
 *
 * @module Chartist.Pie
 */
/* global Chartist */
(function(globalRoot, Chartist) {
  'use strict';

  var window = globalRoot.window;
  var document = globalRoot.document;

  /**
   * Default options in line charts. Expand the code view to see a detailed list of options with comments.
   *
   * @memberof Chartist.Pie
   */
  var defaultOptions = {
    // Specify a fixed width for the chart as a string (i.e. '100px' or '50%')
    width: undefined,
    // Specify a fixed height for the chart as a string (i.e. '100px' or '50%')
    height: undefined,
    // Padding of the chart drawing area to the container element and labels as a number or padding object {top: 5, right: 5, bottom: 5, left: 5}
    chartPadding: 5,
    // Override the class names that are used to generate the SVG structure of the chart
    classNames: {
      chartPie: 'ct-chart-pie',
      chartDonut: 'ct-chart-donut',
      series: 'ct-series',
      slicePie: 'ct-slice-pie',
      sliceDonut: 'ct-slice-donut',
      sliceDonutSolid: 'ct-slice-donut-solid',
      label: 'ct-label'
    },
    // The start angle of the pie chart in degrees where 0 points north. A higher value offsets the start angle clockwise.
    startAngle: 0,
    // An optional total you can specify. By specifying a total value, the sum of the values in the series must be this total in order to draw a full pie. You can use this parameter to draw only parts of a pie or gauge charts.
    total: undefined,
    // If specified the donut CSS classes will be used and strokes will be drawn instead of pie slices.
    donut: false,
    // If specified the donut segments will be drawn as shapes instead of strokes.
    donutSolid: false,
    // Specify the donut stroke width, currently done in javascript for convenience. May move to CSS styles in the future.
    // This option can be set as number or string to specify a relative width (i.e. 100 or '30%').
    donutWidth: 60,
    // If a label should be shown or not
    showLabel: true,
    // Label position offset from the standard position which is half distance of the radius. This value can be either positive or negative. Positive values will position the label away from the center.
    labelOffset: 0,
    // This option can be set to 'inside', 'outside' or 'center'. Positioned with 'inside' the labels will be placed on half the distance of the radius to the border of the Pie by respecting the 'labelOffset'. The 'outside' option will place the labels at the border of the pie and 'center' will place the labels in the absolute center point of the chart. The 'center' option only makes sense in conjunction with the 'labelOffset' option.
    labelPosition: 'inside',
    // An interpolation function for the label value
    labelInterpolationFnc: Chartist.noop,
    // Label direction can be 'neutral', 'explode' or 'implode'. The labels anchor will be positioned based on those settings as well as the fact if the labels are on the right or left side of the center of the chart. Usually explode is useful when labels are positioned far away from the center.
    labelDirection: 'neutral',
    // If true the whole data is reversed including labels, the series order as well as the whole series data arrays.
    reverseData: false,
    // If true empty values will be ignored to avoid drawing unncessary slices and labels
    ignoreEmptyValues: false
  };

  /**
   * Determines SVG anchor position based on direction and center parameter
   *
   * @param center
   * @param label
   * @param direction
   * @return {string}
   */
  function determineAnchorPosition(center, label, direction) {
    var toTheRight = label.x > center.x;

    if(toTheRight && direction === 'explode' ||
      !toTheRight && direction === 'implode') {
      return 'start';
    } else if(toTheRight && direction === 'implode' ||
      !toTheRight && direction === 'explode') {
      return 'end';
    } else {
      return 'middle';
    }
  }

  /**
   * Creates the pie chart
   *
   * @param options
   */
  function createChart(options) {
    var data = Chartist.normalizeData(this.data);
    var seriesGroups = [],
      labelsGroup,
      chartRect,
      radius,
      labelRadius,
      totalDataSum,
      startAngle = options.startAngle;

    // Create SVG.js draw
    this.svg = Chartist.createSvg(this.container, options.width, options.height,options.donut ? options.classNames.chartDonut : options.classNames.chartPie);
    // Calculate charting rect
    chartRect = Chartist.createChartRect(this.svg, options, defaultOptions.padding);
    // Get biggest circle radius possible within chartRect
    radius = Math.min(chartRect.width() / 2, chartRect.height() / 2);
    // Calculate total of all series to get reference value or use total reference from optional options
    totalDataSum = options.total || data.normalized.series.reduce(function(previousValue, currentValue) {
      return previousValue + currentValue;
    }, 0);

    var donutWidth = Chartist.quantity(options.donutWidth);
    if (donutWidth.unit === '%') {
      donutWidth.value *= radius / 100;
    }

    // If this is a donut chart we need to adjust our radius to enable strokes to be drawn inside
    // Unfortunately this is not possible with the current SVG Spec
    // See this proposal for more details: http://lists.w3.org/Archives/Public/www-svg/2003Oct/0000.html
    radius -= options.donut && !options.donutSolid ? donutWidth.value / 2  : 0;

    // If labelPosition is set to `outside` or a donut chart is drawn then the label position is at the radius,
    // if regular pie chart it's half of the radius
    if(options.labelPosition === 'outside' || options.donut && !options.donutSolid) {
      labelRadius = radius;
    } else if(options.labelPosition === 'center') {
      // If labelPosition is center we start with 0 and will later wait for the labelOffset
      labelRadius = 0;
    } else if(options.donutSolid) {
      labelRadius = radius - donutWidth.value / 2;
    } else {
      // Default option is 'inside' where we use half the radius so the label will be placed in the center of the pie
      // slice
      labelRadius = radius / 2;
    }
    // Add the offset to the labelRadius where a negative offset means closed to the center of the chart
    labelRadius += options.labelOffset;

    // Calculate end angle based on total sum and current data value and offset with padding
    var center = {
      x: chartRect.x1 + chartRect.width() / 2,
      y: chartRect.y2 + chartRect.height() / 2
    };

    // Check if there is only one non-zero value in the series array.
    var hasSingleValInSeries = data.raw.series.filter(function(val) {
      return val.hasOwnProperty('value') ? val.value !== 0 : val !== 0;
    }).length === 1;

    // Creating the series groups
    data.raw.series.forEach(function(series, index) {
      seriesGroups[index] = this.svg.elem('g', null, null);
    }.bind(this));
    //if we need to show labels we create the label group now
    if(options.showLabel) {
      labelsGroup = this.svg.elem('g', null, null);
    }

    // Draw the series
    // initialize series groups
    data.raw.series.forEach(function(series, index) {
      // If current value is zero and we are ignoring empty values then skip to next value
      if (data.normalized.series[index] === 0 && options.ignoreEmptyValues) return;

      // If the series is an object and contains a name or meta data we add a custom attribute
      seriesGroups[index].attr({
        'ct:series-name': series.name
      });

      // Use series class from series data or if not set generate one
      seriesGroups[index].addClass([
        options.classNames.series,
        (series.className || options.classNames.series + '-' + Chartist.alphaNumerate(index))
      ].join(' '));

      // If the whole dataset is 0 endAngle should be zero. Can't divide by 0.
      var endAngle = (totalDataSum > 0 ? startAngle + data.normalized.series[index] / totalDataSum * 360 : 0);

      // Use slight offset so there are no transparent hairline issues
      var overlappigStartAngle = Math.max(0, startAngle - (index === 0 || hasSingleValInSeries ? 0 : 0.2));

      // If we need to draw the arc for all 360 degrees we need to add a hack where we close the circle
      // with Z and use 359.99 degrees
      if(endAngle - overlappigStartAngle >= 359.99) {
        endAngle = overlappigStartAngle + 359.99;
      }

      var start = Chartist.polarToCartesian(center.x, center.y, radius, overlappigStartAngle),
        end = Chartist.polarToCartesian(center.x, center.y, radius, endAngle);

      var innerStart,
        innerEnd,
        donutSolidRadius;

      // Create a new path element for the pie chart. If this isn't a donut chart we should close the path for a correct stroke
      var path = new Chartist.Svg.Path(!options.donut || options.donutSolid)
        .move(end.x, end.y)
        .arc(radius, radius, 0, endAngle - startAngle > 180, 0, start.x, start.y);

      // If regular pie chart (no donut) we add a line to the center of the circle for completing the pie
      if(!options.donut) {
        path.line(center.x, center.y);
      } else if (options.donutSolid) {
        donutSolidRadius = radius - donutWidth.value;
        innerStart = Chartist.polarToCartesian(center.x, center.y, donutSolidRadius, startAngle - (index === 0 || hasSingleValInSeries ? 0 : 0.2));
        innerEnd = Chartist.polarToCartesian(center.x, center.y, donutSolidRadius, endAngle);
        path.line(innerStart.x, innerStart.y);
        path.arc(donutSolidRadius, donutSolidRadius, 0, endAngle - startAngle  > 180, 1, innerEnd.x, innerEnd.y);
      }

      // Create the SVG path
      // If this is a donut chart we add the donut class, otherwise just a regular slice
      var pathClassName = options.classNames.slicePie;
      if (options.donut) {
        pathClassName = options.classNames.sliceDonut;
        if (options.donutSolid) {
          pathClassName = options.classNames.sliceDonutSolid;
        }
      }
      var pathElement = seriesGroups[index].elem('path', {
        d: path.stringify()
      }, pathClassName);

      // Adding the pie series value to the path
      pathElement.attr({
        'ct:value': data.normalized.series[index],
        'ct:meta': Chartist.serialize(series.meta)
      });

      // If this is a donut, we add the stroke-width as style attribute
      if(options.donut && !options.donutSolid) {
        pathElement._node.style.strokeWidth = donutWidth.value + 'px';
      }

      // Fire off draw event
      this.eventEmitter.emit('draw', {
        type: 'slice',
        value: data.normalized.series[index],
        totalDataSum: totalDataSum,
        index: index,
        meta: series.meta,
        series: series,
        group: seriesGroups[index],
        element: pathElement,
        path: path.clone(),
        center: center,
        radius: radius,
        startAngle: startAngle,
        endAngle: endAngle
      });

      // If we need to show labels we need to add the label for this slice now
      if(options.showLabel) {
        var labelPosition;
        if(data.raw.series.length === 1) {
          // If we have only 1 series, we can position the label in the center of the pie
          labelPosition = {
            x: center.x,
            y: center.y
          };
        } else {
          // Position at the labelRadius distance from center and between start and end angle
          labelPosition = Chartist.polarToCartesian(
            center.x,
            center.y,
            labelRadius,
            startAngle + (endAngle - startAngle) / 2
          );
        }

        var rawValue;
        if(data.normalized.labels && !Chartist.isFalseyButZero(data.normalized.labels[index])) {
          rawValue = data.normalized.labels[index];
        } else {
          rawValue = data.normalized.series[index];
        }

        var interpolatedValue = options.labelInterpolationFnc(rawValue, index);

        if(interpolatedValue || interpolatedValue === 0) {
          var labelElement = labelsGroup.elem('text', {
            dx: labelPosition.x,
            dy: labelPosition.y,
            'text-anchor': determineAnchorPosition(center, labelPosition, options.labelDirection)
          }, options.classNames.label).text('' + interpolatedValue);

          // Fire off draw event
          this.eventEmitter.emit('draw', {
            type: 'label',
            index: index,
            group: labelsGroup,
            element: labelElement,
            text: '' + interpolatedValue,
            x: labelPosition.x,
            y: labelPosition.y
          });
        }
      }

      // Set next startAngle to current endAngle.
      // (except for last slice)
      startAngle = endAngle;
    }.bind(this));

    this.eventEmitter.emit('created', {
      chartRect: chartRect,
      svg: this.svg,
      options: options
    });
  }

  /**
   * This method creates a new pie chart and returns an object that can be used to redraw the chart.
   *
   * @memberof Chartist.Pie
   * @param {String|Node} query A selector query string or directly a DOM element
   * @param {Object} data The data object in the pie chart needs to have a series property with a one dimensional data array. The values will be normalized against each other and don't necessarily need to be in percentage. The series property can also be an array of value objects that contain a value property and a className property to override the CSS class name for the series group.
   * @param {Object} [options] The options object with options that override the default options. Check the examples for a detailed list.
   * @param {Array} [responsiveOptions] Specify an array of responsive option arrays which are a media query and options object pair => [[mediaQueryString, optionsObject],[more...]]
   * @return {Object} An object with a version and an update method to manually redraw the chart
   *
   * @example
   * // Simple pie chart example with four series
   * new Chartist.Pie('.ct-chart', {
   *   series: [10, 2, 4, 3]
   * });
   *
   * @example
   * // Drawing a donut chart
   * new Chartist.Pie('.ct-chart', {
   *   series: [10, 2, 4, 3]
   * }, {
   *   donut: true
   * });
   *
   * @example
   * // Using donut, startAngle and total to draw a gauge chart
   * new Chartist.Pie('.ct-chart', {
   *   series: [20, 10, 30, 40]
   * }, {
   *   donut: true,
   *   donutWidth: 20,
   *   startAngle: 270,
   *   total: 200
   * });
   *
   * @example
   * // Drawing a pie chart with padding and labels that are outside the pie
   * new Chartist.Pie('.ct-chart', {
   *   series: [20, 10, 30, 40]
   * }, {
   *   chartPadding: 30,
   *   labelOffset: 50,
   *   labelDirection: 'explode'
   * });
   *
   * @example
   * // Overriding the class names for individual series as well as a name and meta data.
   * // The name will be written as ct:series-name attribute and the meta data will be serialized and written
   * // to a ct:meta attribute.
   * new Chartist.Pie('.ct-chart', {
   *   series: [{
   *     value: 20,
   *     name: 'Series 1',
   *     className: 'my-custom-class-one',
   *     meta: 'Meta One'
   *   }, {
   *     value: 10,
   *     name: 'Series 2',
   *     className: 'my-custom-class-two',
   *     meta: 'Meta Two'
   *   }, {
   *     value: 70,
   *     name: 'Series 3',
   *     className: 'my-custom-class-three',
   *     meta: 'Meta Three'
   *   }]
   * });
   */
  function Pie(query, data, options, responsiveOptions) {
    Chartist.Pie.super.constructor.call(this,
      query,
      data,
      defaultOptions,
      Chartist.extend({}, defaultOptions, options),
      responsiveOptions);
  }

  // Creating pie chart type in Chartist namespace
  Chartist.Pie = Chartist.Base.extend({
    constructor: Pie,
    createChart: createChart,
    determineAnchorPosition: determineAnchorPosition
  });

}(this || __webpack_require__.g, Chartist));

return Chartist;

}));


/***/ }),

/***/ "./node_modules/core-js/internals/array-from.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/array-from.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = getIterator(O, iteratorMethod);
    next = iterator.next;
    result = new C();
    for (;!(step = next.call(iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose(iterator, 'throw', error);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/check-correctness-of-iteration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator-method.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

module.exports = function (it, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(it) : usingIterator;
  if (typeof iteratorMethod != 'function') {
    throw TypeError(String(it) + ' is not iterable');
  } return anObject(iteratorMethod.call(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array-iterator-method.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterator-close.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-close.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = iterator['return'];
    if (innerResult === undefined) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = innerResult.call(iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/math-sign.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/math-sign.js ***!
  \*****************************************************/
/***/ (function(module) {

// `Math.sign` method implementation
// https://tc39.es/ecma262/#sec-math.sign
// eslint-disable-next-line es/no-math-sign -- safe
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare -- NaN check
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.find.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.find.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $find = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").find;
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

var FIND = 'find';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.from.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.from.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var from = __webpack_require__(/*! ../internals/array-from */ "./node_modules/core-js/internals/array-from.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  // eslint-disable-next-line es/no-array-from -- required for testing
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.slice.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.slice.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');

var SPECIES = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.splice.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.splice.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');

var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

// `Array.prototype.splice` method
// https://tc39.es/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
    }
    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.sign.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.sign.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var sign = __webpack_require__(/*! ../internals/math-sign */ "./node_modules/core-js/internals/math-sign.js");

// `Math.sign` method
// https://tc39.es/ecma262/#sec-math.sign
$({ target: 'Math', stat: true }, {
  sign: sign
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-own-property-descriptor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-own-property-descriptor.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var nativeGetOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor(1); });
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-own-property-descriptors.js":
/*!********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-own-property-descriptors.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");

// `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});


/***/ }),

/***/ "./node_modules/vue-chartist/index.js":
/*!********************************************!*\
  !*** ./node_modules/vue-chartist/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.install = function (Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


  Vue.chartist = __webpack_require__(/*! chartist */ "./node_modules/chartist/dist/chartist.js");
  Vue.prototype.$chartist = __webpack_require__(/*! chartist */ "./node_modules/chartist/dist/chartist.js");

  Vue.component('Chartist', {
    props: {
      ratio: {
        type: String,
        default: 'ct-square'
      },
      data: {
        type: Object,
        default: function _default() {
          return {
            series: [],
            labels: []
          };
        }
      },
      options: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      type: {
        type: String,
        required: true,
        validator: function validator(val) {
          return val === 'Pie' || val === 'Line' || val === 'Bar';
        }
      },
      eventHandlers: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      responsiveOptions: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      noData: {
        type: Object,
        default: function _default() {
          return {
            message: '',
            class: 'ct-nodata'
          };
        }
      }
    },
    data: function data() {
      return {
        chart: null,
        message: ''
      };
    },

    watch: {
      ratio: 'redraw',
      options: { handler: 'redraw', deep: true },
      responsiveOptions: { handler: 'redraw', deep: true },
      data: { handler: 'redraw', deep: true },
      type: 'draw',
      eventHandlers: 'resetEventHandlers',
      hasNoData: {
        immediate: true,
        handler: function handler(val) {
          if (val) {
            this.setNoData();
          } else {
            this.clear();
          }
        }
      }
    },
    mounted: function mounted() {
      this.draw();
    },

    computed: {
      hasNoData: function hasNoData() {
        return !this.data || !this.data.series || this.data.series.length < 1 || this.type !== 'Pie' && !this.options.distributeSeries && this.data.series.every(function (series) {
          if (Array.isArray(series)) {
            return !series.length;
          }
          return !series.data.length;
        });
      },
      noDataOptions: function noDataOptions() {
        return {
          message: options.messageNoData || this.noData.message,
          class: options.classNoData || this.noData.class
        };
      }
    },
    methods: {
      clear: function clear() {
        this.message = '';
      },
      draw: function draw() {
        this.chart = this.hasNoData ? null : new this.$chartist[this.type](this.$refs.chart, this.data, this.options, this.responsiveOptions);
        this.setEventHandlers();
      },
      redraw: function redraw() {
        this.chart ? this.chart.update(this.data, this.options) : this.draw();
      },
      resetEventHandlers: function resetEventHandlers(eventHandlers, oldEventHandler) {
        if (!this.chart) {
          return;
        }
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = oldEventHandler[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;

            this.chart.off(item.event, item.fn);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = eventHandlers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _item = _step2.value;

            this.chart.on(_item.event, _item.fn);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      },
      setEventHandlers: function setEventHandlers() {
        if (this.chart && this.eventHandlers) {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = this.eventHandlers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var item = _step3.value;

              this.chart.on(item.event, item.fn);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      },
      setNoData: function setNoData() {
        this.message = this.noDataOptions.message;
      }
    },
    render: function render(h) {
      var children = this.message || this.$slots.default || [];

      return h('div', {
        ref: 'chart',
        'class': [this.ratio, _defineProperty({}, this.noDataOptions.class, this.hasNoData)]
      }, children);
    }
  });
};


/***/ }),

/***/ "./node_modules/vue-click-outside/index.js":
/*!*************************************************!*\
  !*** ./node_modules/vue-click-outside/index.js ***!
  \*************************************************/
/***/ (function(module, exports) {

function validate(binding) {
  if (typeof binding.value !== 'function') {
    console.warn('[Vue-click-outside:] provided expression', binding.expression, 'is not a function.')
    return false
  }

  return true
}

function isPopup(popupItem, elements) {
  if (!popupItem || !elements)
    return false

  for (var i = 0, len = elements.length; i < len; i++) {
    try {
      if (popupItem.contains(elements[i])) {
        return true
      }
      if (elements[i].contains(popupItem)) {
        return false
      }
    } catch(e) {
      return false
    }
  }

  return false
}

function isServer(vNode) {
  return typeof vNode.componentInstance !== 'undefined' && vNode.componentInstance.$isServer
}

exports = module.exports = {
  bind: function (el, binding, vNode) {
    if (!validate(binding)) return

    // Define Handler and cache it on the element
    function handler(e) {
      if (!vNode.context) return

      // some components may have related popup item, on which we shall prevent the click outside event handler.
      var elements = e.path || (e.composedPath && e.composedPath())
      elements && elements.length > 0 && elements.unshift(e.target)

      if (el.contains(e.target) || isPopup(vNode.context.popupItem, elements)) return

      el.__vueClickOutside__.callback(e)
    }

    // add Event Listeners
    el.__vueClickOutside__ = {
      handler: handler,
      callback: binding.value
    }
    const clickHandler = 'ontouchstart' in document.documentElement ? 'touchstart' : 'click';
    !isServer(vNode) && document.addEventListener(clickHandler, handler)
  },

  update: function (el, binding) {
    if (validate(binding)) el.__vueClickOutside__.callback = binding.value
  },

  unbind: function (el, binding, vNode) {
    // Remove Event Listeners
    const clickHandler = 'ontouchstart' in document.documentElement ? 'touchstart' : 'click';
    !isServer(vNode) && el.__vueClickOutside__ && document.removeEventListener(clickHandler, el.__vueClickOutside__.handler)
    delete el.__vueClickOutside__
  }
}


/***/ }),

/***/ "./node_modules/vue-ellipse-progress/dist/vue-ellipse-progress.umd.min.js":
/*!********************************************************************************!*\
  !*** ./node_modules/vue-ellipse-progress/dist/vue-ellipse-progress.umd.min.js ***!
  \********************************************************************************/
/***/ (function(module) {

(function(t,e){ true?module.exports=e():0})("undefined"!==typeof self?self:this,(function(){return function(t){var e={};function r(n){if(e[n])return e[n].exports;var i=e[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},r.r=function(t){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"===typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)r.d(n,i,function(e){return t[e]}.bind(null,i));return n},r.n=function(t){var e=t&&t.__esModule?function(){return t["default"]}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s="fb15")}({"00ee":function(t,e,r){var n=r("b622"),i=n("toStringTag"),o={};o[i]="z",t.exports="[object z]"===String(o)},"01f3":function(t,e,r){"use strict";var n=r("6d40"),i=r.n(n);i.a},"02d4":function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,"@-webkit-keyframes ep-dot--init__loop{0%{-webkit-transform:rotate(var(--ep-dot-start));transform:rotate(var(--ep-dot-start))}33%{-webkit-transform:rotate(var(--ep-dot-360));transform:rotate(var(--ep-dot-360))}66%{-webkit-transform:rotate(var(--ep-dot-360));transform:rotate(var(--ep-dot-360))}to{-webkit-transform:rotate(var(--ep-dot-loop-end));transform:rotate(var(--ep-dot-loop-end))}}@keyframes ep-dot--init__loop{0%{-webkit-transform:rotate(var(--ep-dot-start));transform:rotate(var(--ep-dot-start))}33%{-webkit-transform:rotate(var(--ep-dot-360));transform:rotate(var(--ep-dot-360))}66%{-webkit-transform:rotate(var(--ep-dot-360));transform:rotate(var(--ep-dot-360))}to{-webkit-transform:rotate(var(--ep-dot-loop-end));transform:rotate(var(--ep-dot-loop-end))}}@-webkit-keyframes ep-dot--init__reverse{0%{-webkit-transform:rotate(var(--ep-dot-360));transform:rotate(var(--ep-dot-360))}50%{-webkit-transform:rotate(var(--ep-dot-360));transform:rotate(var(--ep-dot-360))}to{-webkit-transform:rotate(var(--ep-dot-end));transform:rotate(var(--ep-dot-end))}}@keyframes ep-dot--init__reverse{0%{-webkit-transform:rotate(var(--ep-dot-360));transform:rotate(var(--ep-dot-360))}50%{-webkit-transform:rotate(var(--ep-dot-360));transform:rotate(var(--ep-dot-360))}to{-webkit-transform:rotate(var(--ep-dot-end));transform:rotate(var(--ep-dot-end))}}@-webkit-keyframes ep-dot--init__bounce{0%{opacity:0}90%{opacity:0}to{opacity:1}}@keyframes ep-dot--init__bounce{0%{opacity:0}90%{opacity:0}to{opacity:1}}@-webkit-keyframes ep-dot--init__disabled{0%{opacity:0}90%{opacity:0}to{opacity:1}}@keyframes ep-dot--init__disabled{0%{opacity:0}90%{opacity:0}to{opacity:1}}.ep-circle--progress{-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}.ep-circle--progress.animation__default{-webkit-animation-name:ep-progress--init__default;animation-name:ep-progress--init__default}.ep-circle--progress.animation__rs{-webkit-animation-name:ep-progress--init__rs;animation-name:ep-progress--init__rs}.ep-circle--progress.animation__bounce{-webkit-animation-name:ep-progress--init__bounce;animation-name:ep-progress--init__bounce}.ep-circle--progress.animation__reverse{-webkit-animation-name:ep-progress--init__reverse;animation-name:ep-progress--init__reverse}.ep-circle--progress.animation__loop{-webkit-animation-name:ep-progress--init__loop;animation-name:ep-progress--init__loop}.ep-circle--loading.animation__loading{-webkit-animation-name:ep-progress--loading,ep-progress--loading__rotation;animation-name:ep-progress--loading,ep-progress--loading__rotation;-webkit-animation-iteration-count:infinite!important;animation-iteration-count:infinite!important;-webkit-animation-duration:2s,1s!important;animation-duration:2s,1s!important;-webkit-animation-timing-function:ease-in-out,linear;animation-timing-function:ease-in-out,linear}.ep-half-circle--loading.animation__loading{-webkit-animation-name:ep-half-progress--loading;animation-name:ep-half-progress--loading;-webkit-animation-iteration-count:infinite!important;animation-iteration-count:infinite!important;-webkit-animation-duration:2s!important;animation-duration:2s!important;-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}.ep-circle--empty.ep-circle--nodata,.ep-half-circle--empty.ep-circle--nodata{opacity:.5}.ep-circle--progress__dot-container{-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}.ep-circle--progress__dot-container.animation__rs{-webkit-animation-name:ep-dot--init__rs;animation-name:ep-dot--init__rs}.ep-circle--progress__dot-container.animation__bounce{-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards;-webkit-animation-name:ep-dot--init__disabled;animation-name:ep-dot--init__disabled}.ep-circle--progress__dot-container.animation__reverse{-webkit-animation-name:ep-dot--init__reverse;animation-name:ep-dot--init__reverse}.ep-circle--progress__dot-container.animation__loop{-webkit-animation-name:ep-dot--init__loop;animation-name:ep-dot--init__loop}.ep-circle--progress__dot-container.ep-half-circle-progress__dot.animation__bounce,.ep-circle--progress__dot-container.ep-half-circle-progress__dot.animation__loop{-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards;-webkit-animation-name:ep-dot--init__disabled;animation-name:ep-dot--init__disabled}@-webkit-keyframes ep-progress--init__default{0%{stroke-dashoffset:var(--ep-circumference)}to{stroke-dashoffset:var(--ep-stroke-offset)}}@keyframes ep-progress--init__default{0%{stroke-dashoffset:var(--ep-circumference)}to{stroke-dashoffset:var(--ep-stroke-offset)}}@-webkit-keyframes ep-progress--init__rs{0%{stroke-dashoffset:var(--ep-circumference)}50%{stroke-dashoffset:0}to{stroke-dashoffset:var(--ep-stroke-offset)}}@keyframes ep-progress--init__rs{0%{stroke-dashoffset:var(--ep-circumference)}50%{stroke-dashoffset:0}to{stroke-dashoffset:var(--ep-stroke-offset)}}@-webkit-keyframes ep-progress--init__bounce{0%{-webkit-animation-timing-function:linear;animation-timing-function:linear;stroke-dashoffset:var(--ep-circumference)}33%{stroke-dashoffset:var(--ep-bounce-out-stroke-offset)}66%{stroke-dashoffset:var(--ep-bounce-in-stroke-offset)}to{stroke-dashoffset:var(--ep-stroke-offset)}}@keyframes ep-progress--init__bounce{0%{-webkit-animation-timing-function:linear;animation-timing-function:linear;stroke-dashoffset:var(--ep-circumference)}33%{stroke-dashoffset:var(--ep-bounce-out-stroke-offset)}66%{stroke-dashoffset:var(--ep-bounce-in-stroke-offset)}to{stroke-dashoffset:var(--ep-stroke-offset)}}@-webkit-keyframes ep-progress--init__reverse{0%{stroke-dashoffset:var(--ep-circumference)}50%{stroke-dashoffset:var(--ep-double-circumference)}to{stroke-dashoffset:var(--ep-reverse-stroke-offset)}}@keyframes ep-progress--init__reverse{0%{stroke-dashoffset:var(--ep-circumference)}50%{stroke-dashoffset:var(--ep-double-circumference)}to{stroke-dashoffset:var(--ep-reverse-stroke-offset)}}@-webkit-keyframes ep-progress--init__loop{0%{stroke-dashoffset:var(--ep-circumference)}33%{stroke-dashoffset:0}66%{stroke-dashoffset:var(--ep-negative-circumference)}to{stroke-dashoffset:var(--ep-loop-stroke-offset)}}@keyframes ep-progress--init__loop{0%{stroke-dashoffset:var(--ep-circumference)}33%{stroke-dashoffset:0}66%{stroke-dashoffset:var(--ep-negative-circumference)}to{stroke-dashoffset:var(--ep-loop-stroke-offset)}}@-webkit-keyframes ep-progress--loading{0%{opacity:.5;stroke-dashoffset:var(--ep-circumference)}50%{opacity:.8;stroke-dashoffset:var(--ep-loading-stroke-offset)}to{opacity:.5;stroke-dashoffset:var(--ep-circumference)}}@keyframes ep-progress--loading{0%{opacity:.5;stroke-dashoffset:var(--ep-circumference)}50%{opacity:.8;stroke-dashoffset:var(--ep-loading-stroke-offset)}to{opacity:.5;stroke-dashoffset:var(--ep-circumference)}}@-webkit-keyframes ep-half-progress--loading{0%{opacity:.5;stroke-dashoffset:var(--ep-circumference)}50%{opacity:.8;stroke-dashoffset:0}to{opacity:.5;stroke-dashoffset:var(--ep-circumference)}}@keyframes ep-half-progress--loading{0%{opacity:.5;stroke-dashoffset:var(--ep-circumference)}50%{opacity:.8;stroke-dashoffset:0}to{opacity:.5;stroke-dashoffset:var(--ep-circumference)}}@-webkit-keyframes ep-progress--loading__rotation{to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes ep-progress--loading__rotation{to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@-webkit-keyframes ep-dot--init__rs{0%{-webkit-transform:rotate(var(--ep-dot-start));transform:rotate(var(--ep-dot-start))}50%{-webkit-transform:rotate(var(--ep-dot-360));transform:rotate(var(--ep-dot-360))}to{-webkit-transform:rotate(var(--ep-dot-end));transform:rotate(var(--ep-dot-end))}}@keyframes ep-dot--init__rs{0%{-webkit-transform:rotate(var(--ep-dot-start));transform:rotate(var(--ep-dot-start))}50%{-webkit-transform:rotate(var(--ep-dot-360));transform:rotate(var(--ep-dot-360))}to{-webkit-transform:rotate(var(--ep-dot-end));transform:rotate(var(--ep-dot-end))}}.ep-svg-container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;position:absolute}.ep-svg-container.ep-reverse{-webkit-transform:scaleX(-1);transform:scaleX(-1)}g.ep-circle--container{-webkit-transition:inherit;-o-transition:inherit;transition:inherit;-webkit-transform-origin:50% 50%;transform-origin:50% 50%}",""]),t.exports=e},"0366":function(t,e,r){var n=r("1c0b");t.exports=function(t,e,r){if(n(t),void 0===e)return t;switch(r){case 0:return function(){return t.call(e)};case 1:return function(r){return t.call(e,r)};case 2:return function(r,n){return t.call(e,r,n)};case 3:return function(r,n,i){return t.call(e,r,n,i)}}return function(){return t.apply(e,arguments)}}},"054f":function(t,e,r){"use strict";var n=r("a231"),i=r.n(n);i.a},"057f":function(t,e,r){var n=r("fc6a"),i=r("241c").f,o={}.toString,a="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],s=function(t){try{return i(t)}catch(e){return a.slice()}};t.exports.f=function(t){return a&&"[object Window]"==o.call(t)?s(t):i(n(t))}},"06cf":function(t,e,r){var n=r("83ab"),i=r("d1e7"),o=r("5c6c"),a=r("fc6a"),s=r("c04e"),c=r("5135"),u=r("0cfb"),f=Object.getOwnPropertyDescriptor;e.f=n?f:function(t,e){if(t=a(t),e=s(e,!0),u)try{return f(t,e)}catch(r){}if(c(t,e))return o(!i.f.call(t,e),t[e])}},"0cfb":function(t,e,r){var n=r("83ab"),i=r("d039"),o=r("cc12");t.exports=!n&&!i((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},1148:function(t,e,r){"use strict";var n=r("a691"),i=r("1d80");t.exports="".repeat||function(t){var e=String(i(this)),r="",o=n(t);if(o<0||o==1/0)throw RangeError("Wrong number of repetitions");for(;o>0;(o>>>=1)&&(e+=e))1&o&&(r+=e);return r}},"11ae":function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".ep-container[data-v-59d6a78d]{display:inline-block;overflow:hidden}.ep-content[data-v-59d6a78d]{max-width:inherit;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;position:relative;height:100%;width:100%}.ep-content[data-v-59d6a78d],.ep-legend--container[data-v-59d6a78d]{-webkit-transition:inherit;-o-transition:inherit;transition:inherit}.ep-legend--container[data-v-59d6a78d]{position:absolute;text-align:center}.ep-legend--value[data-v-59d6a78d]{-webkit-transition:.3s;-o-transition:.3s;transition:.3s;text-align:center;opacity:1}.ep-hidden[data-v-59d6a78d]{opacity:0}svg.ep-svg[data-v-59d6a78d]{-webkit-transition:inherit;-o-transition:inherit;transition:inherit;-webkit-transform-origin:50% 50%;transform-origin:50% 50%}",""]),t.exports=e},1276:function(t,e,r){"use strict";var n=r("d784"),i=r("44e7"),o=r("825a"),a=r("1d80"),s=r("4840"),c=r("8aa5"),u=r("50c4"),f=r("14c3"),l=r("9263"),p=r("d039"),d=[].push,h=Math.min,v=4294967295,m=!p((function(){return!RegExp(v,"y")}));n("split",2,(function(t,e,r){var n;return n="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(t,r){var n=String(a(this)),o=void 0===r?v:r>>>0;if(0===o)return[];if(void 0===t)return[n];if(!i(t))return e.call(n,t,o);var s,c,u,f=[],p=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),h=0,m=new RegExp(t.source,p+"g");while(s=l.call(m,n)){if(c=m.lastIndex,c>h&&(f.push(n.slice(h,s.index)),s.length>1&&s.index<n.length&&d.apply(f,s.slice(1)),u=s[0].length,h=c,f.length>=o))break;m.lastIndex===s.index&&m.lastIndex++}return h===n.length?!u&&m.test("")||f.push(""):f.push(n.slice(h)),f.length>o?f.slice(0,o):f}:"0".split(void 0,0).length?function(t,r){return void 0===t&&0===r?[]:e.call(this,t,r)}:e,[function(e,r){var i=a(this),o=void 0==e?void 0:e[t];return void 0!==o?o.call(e,i,r):n.call(String(i),e,r)},function(t,i){var a=r(n,t,this,i,n!==e);if(a.done)return a.value;var l=o(t),p=String(this),d=s(l,RegExp),g=l.unicode,y=(l.ignoreCase?"i":"")+(l.multiline?"m":"")+(l.unicode?"u":"")+(m?"y":"g"),b=new d(m?l:"^(?:"+l.source+")",y),x=void 0===i?v:i>>>0;if(0===x)return[];if(0===p.length)return null===f(b,p)?[p]:[];var k=0,w=0,_=[];while(w<p.length){b.lastIndex=m?w:0;var S,E=f(b,m?p:p.slice(w));if(null===E||(S=h(u(b.lastIndex+(m?0:w)),p.length))===k)w=c(p,w,g);else{if(_.push(p.slice(k,w)),_.length===x)return _;for(var T=1;T<=E.length-1;T++)if(_.push(E[T]),_.length===x)return _;w=k=S}}return _.push(p.slice(k)),_}]}),!m)},"129f":function(t,e){t.exports=Object.is||function(t,e){return t===e?0!==t||1/t===1/e:t!=t&&e!=e}},"13d5":function(t,e,r){"use strict";var n=r("23e7"),i=r("d58f").left,o=r("a640"),a=r("ae40"),s=o("reduce"),c=a("reduce",{1:0});n({target:"Array",proto:!0,forced:!s||!c},{reduce:function(t){return i(this,t,arguments.length,arguments.length>1?arguments[1]:void 0)}})},"14c3":function(t,e,r){var n=r("c6b6"),i=r("9263");t.exports=function(t,e){var r=t.exec;if("function"===typeof r){var o=r.call(t,e);if("object"!==typeof o)throw TypeError("RegExp exec method returned something other than an Object or null");return o}if("RegExp"!==n(t))throw TypeError("RegExp#exec called on incompatible receiver");return i.call(t,e)}},"159b":function(t,e,r){var n=r("da84"),i=r("fdbc"),o=r("17c2"),a=r("9112");for(var s in i){var c=n[s],u=c&&c.prototype;if(u&&u.forEach!==o)try{a(u,"forEach",o)}catch(f){u.forEach=o}}},"17c2":function(t,e,r){"use strict";var n=r("b727").forEach,i=r("a640"),o=r("ae40"),a=i("forEach"),s=o("forEach");t.exports=a&&s?[].forEach:function(t){return n(this,t,arguments.length>1?arguments[1]:void 0)}},"19aa":function(t,e){t.exports=function(t,e,r){if(!(t instanceof e))throw TypeError("Incorrect "+(r?r+" ":"")+"invocation");return t}},"1be4":function(t,e,r){var n=r("d066");t.exports=n("document","documentElement")},"1c0b":function(t,e){t.exports=function(t){if("function"!=typeof t)throw TypeError(String(t)+" is not a function");return t}},"1c7e":function(t,e,r){var n=r("b622"),i=n("iterator"),o=!1;try{var a=0,s={next:function(){return{done:!!a++}},return:function(){o=!0}};s[i]=function(){return this},Array.from(s,(function(){throw 2}))}catch(c){}t.exports=function(t,e){if(!e&&!o)return!1;var r=!1;try{var n={};n[i]=function(){return{next:function(){return{done:r=!0}}}},t(n)}catch(c){}return r}},"1cdc":function(t,e,r){var n=r("342f");t.exports=/(iphone|ipod|ipad).*applewebkit/i.test(n)},"1d1a":function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,"g.ep-half-circle[data-v-5b37ebc3]{-webkit-transform-origin:50% 50%;transform-origin:50% 50%}",""]),t.exports=e},"1d80":function(t,e){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on "+t);return t}},"1dde":function(t,e,r){var n=r("d039"),i=r("b622"),o=r("2d00"),a=i("species");t.exports=function(t){return o>=51||!n((function(){var e=[],r=e.constructor={};return r[a]=function(){return{foo:1}},1!==e[t](Boolean).foo}))}},2266:function(t,e,r){var n=r("825a"),i=r("e95a"),o=r("50c4"),a=r("0366"),s=r("35a1"),c=r("9bdd"),u=function(t,e){this.stopped=t,this.result=e},f=t.exports=function(t,e,r,f,l){var p,d,h,v,m,g,y,b=a(e,r,f?2:1);if(l)p=t;else{if(d=s(t),"function"!=typeof d)throw TypeError("Target is not iterable");if(i(d)){for(h=0,v=o(t.length);v>h;h++)if(m=f?b(n(y=t[h])[0],y[1]):b(t[h]),m&&m instanceof u)return m;return new u(!1)}p=d.call(t)}g=p.next;while(!(y=g.call(p)).done)if(m=c(p,b,y.value,f),"object"==typeof m&&m&&m instanceof u)return m;return new u(!1)};f.stop=function(t){return new u(!0,t)}},"23cb":function(t,e,r){var n=r("a691"),i=Math.max,o=Math.min;t.exports=function(t,e){var r=n(t);return r<0?i(r+e,0):o(r,e)}},"23e7":function(t,e,r){var n=r("da84"),i=r("06cf").f,o=r("9112"),a=r("6eeb"),s=r("ce4e"),c=r("e893"),u=r("94ca");t.exports=function(t,e){var r,f,l,p,d,h,v=t.target,m=t.global,g=t.stat;if(f=m?n:g?n[v]||s(v,{}):(n[v]||{}).prototype,f)for(l in e){if(d=e[l],t.noTargetGet?(h=i(f,l),p=h&&h.value):p=f[l],r=u(m?l:v+(g?".":"#")+l,t.forced),!r&&void 0!==p){if(typeof d===typeof p)continue;c(d,p)}(t.sham||p&&p.sham)&&o(d,"sham",!0),a(f,l,d,t)}}},"241c":function(t,e,r){var n=r("ca84"),i=r("7839"),o=i.concat("length","prototype");e.f=Object.getOwnPropertyNames||function(t){return n(t,o)}},2474:function(t,e,r){"use strict";var n=r("d07f"),i=r.n(n);i.a},"24fb":function(t,e,r){"use strict";function n(t,e){var r=t[1]||"",n=t[3];if(!n)return r;if(e&&"function"===typeof btoa){var o=i(n),a=n.sources.map((function(t){return"/*# sourceURL=".concat(n.sourceRoot||"").concat(t," */")}));return[r].concat(a).concat([o]).join("\n")}return[r].join("\n")}function i(t){var e=btoa(unescape(encodeURIComponent(JSON.stringify(t)))),r="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(e);return"/*# ".concat(r," */")}t.exports=function(t){var e=[];return e.toString=function(){return this.map((function(e){var r=n(e,t);return e[2]?"@media ".concat(e[2]," {").concat(r,"}"):r})).join("")},e.i=function(t,r,n){"string"===typeof t&&(t=[[null,t,""]]);var i={};if(n)for(var o=0;o<this.length;o++){var a=this[o][0];null!=a&&(i[a]=!0)}for(var s=0;s<t.length;s++){var c=[].concat(t[s]);n&&i[c[0]]||(r&&(c[2]?c[2]="".concat(r," and ").concat(c[2]):c[2]=r),e.push(c))}},e}},2532:function(t,e,r){"use strict";var n=r("23e7"),i=r("5a34"),o=r("1d80"),a=r("ab13");n({target:"String",proto:!0,forced:!a("includes")},{includes:function(t){return!!~String(o(this)).indexOf(i(t),arguments.length>1?arguments[1]:void 0)}})},"25f0":function(t,e,r){"use strict";var n=r("6eeb"),i=r("825a"),o=r("d039"),a=r("ad6d"),s="toString",c=RegExp.prototype,u=c[s],f=o((function(){return"/a/b"!=u.call({source:"a",flags:"b"})})),l=u.name!=s;(f||l)&&n(RegExp.prototype,s,(function(){var t=i(this),e=String(t.source),r=t.flags,n=String(void 0===r&&t instanceof RegExp&&!("flags"in c)?a.call(t):r);return"/"+e+"/"+n}),{unsafe:!0})},2626:function(t,e,r){"use strict";var n=r("d066"),i=r("9bf2"),o=r("b622"),a=r("83ab"),s=o("species");t.exports=function(t){var e=n(t),r=i.f;a&&e&&!e[s]&&r(e,s,{configurable:!0,get:function(){return this}})}},"273a":function(t,e,r){"use strict";var n=r("d30c"),i=r.n(n);i.a},"28ab":function(t,e,r){"use strict";var n=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"ep-container",style:{width:t.size+"px",height:t.size+"px"}},[r("div",{staticClass:"ep-content"},[t._l(t.circlesData,(function(e,n){return r("circle-container",t._b({key:n,attrs:{multiple:t.isMultiple,index:n,globalThickness:t.thickness,globalGap:t.gap,globalDot:t.dot}},"circle-container",e,!1))})),r("div",{staticClass:"ep-legend--container",style:{maxWidth:t.size+"px"}},[t.legend&&!t.isMultiple?r("div",{staticClass:"ep-legend--value",class:[t.legendClass,{"ep-hidden":t.shouldHideLegendValue}],style:{fontSize:t.fontSize,color:t.fontColor}},[r("counter",{attrs:{value:t.legendVal,animation:t.animation,loading:t.loading},scopedSlots:t._u([{key:"default",fn:function(e){var n=e.counterTick;return[t.$scopedSlots.default?t._t("default",null,{counterTick:n}):t._e(),t.legendFormatter?r("span",[t.isHTML?r("span",{domProps:{innerHTML:t._s(t.legendFormatter(n))}}):r("span",[t._v(t._s(t.legendFormatter(n)))])]):t.$scopedSlots.default?t._e():r("span",[t._v(t._s(n.currentFormattedValue))])]}}],null,!0)}),t._t("legend-value")],2):t._e(),t._t("legend-caption")],2)],2)])},i=[];r("d81d"),r("d3b7"),r("25f0"),r("498a"),r("a4d3"),r("4de4"),r("4160"),r("e439"),r("dbb4"),r("b64b"),r("159b");function o(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function a(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function s(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?a(Object(r),!0).forEach((function(e){o(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}r("a9e3"),r("9129");var c=function(t){return void 0!==t&&""!==t&&null!==t&&!Number.isNaN(parseFloat(t))},u=function(t){return!!c(t)&&parseFloat(t)};r("a623"),r("caad"),r("45fc"),r("ac1f"),r("5319"),r("1276"),r("2ca0"),r("e01a"),r("d28b"),r("e260"),r("3ca3"),r("ddb0");function f(t){return f="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"===typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},f(t)}var l=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"transparent";return{type:[String,Object],required:!1,default:t,validator:function(t){return!("string"!==typeof t||!t)||!("object"!==f(t)||!t.colors)&&t.colors.every((function(t){return t.color&&t.offset}))}}},p={data:{type:Array,required:!1,default:function(){return[]}},progress:{type:Number,require:!0,validator:function(t){return t>=-100&&t<=100}},legendValue:{type:[Number,String],required:!1,validator:function(t){return!Number.isNaN(parseFloat(t.toString().replace(",",".")))}},size:{type:Number,required:!1,default:200,validator:function(t){return t>=0}},thickness:{type:[Number,String],required:!1,default:"5%",validator:function(t){return parseFloat(t)>=0}},emptyThickness:{type:[Number,String],required:!1,default:"5%",validator:function(t){return parseFloat(t)>=0}},line:{type:String,required:!1,default:"round",validator:function(t){return["round","butt","square"].includes(t)}},lineMode:{type:String,required:!1,default:"normal",validator:function(t){var e=t.split(" "),r=["normal","out","out-over","in","in-over","top","bottom"].includes(e[0]),n=!e[1]||!Number.isNaN(parseFloat(e[1]));return r&&n}},color:l("#3f79ff"),emptyColor:l("#e6e9f0"),colorFill:l(),emptyColorFill:l(),fontSize:{type:String,required:!1},fontColor:{type:String,required:!1},animation:{type:String,required:!1,default:"default 1000 400",validator:function(t){var e=t.split(" "),r=["default","rs","loop","reverse","bounce"].some((function(t){return t===e[0]})),n=!e[1]||parseFloat(e[1])>=0,i=!e[2]||parseFloat(e[2])>=0;return r&&n&&i}},legend:{type:Boolean,required:!1,default:!0},legendClass:{type:String,required:!1},angle:{type:[String,Number],required:!1,default:-90},loading:{type:Boolean,required:!1,default:!1},noData:{type:Boolean,required:!1,default:!1},dash:{type:String,required:!1,default:"",validator:function(t){if(t.startsWith("strict")){var e=t.split(" ");return parseFloat(e[1])>=0&&parseFloat(e[2])>=0}return!0}},half:{type:Boolean,required:!1,default:!1},gap:{type:Number,required:!1,default:0,validator:function(t){return!Number.isNaN(parseInt(t,10))}},determinate:{type:Boolean,required:!1,default:!1},dot:{type:[String,Number,Object],required:!1,default:0,validator:function(t){return"object"===f(t)?void 0!==t.size&&!Number.isNaN(parseFloat(t.size)):!Number.isNaN(parseFloat(t))}},reverse:{type:Boolean,required:!1,default:!1}},d={};for(var h in p)d[h]={type:p[h].type,default:p[h].default};var v=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"ep-svg-container",class:{"ep-reverse":t.reverse}},[r("svg",{staticClass:"ep-svg",attrs:{height:t.size,width:t.size,xmlns:"http://www.w3.org/2000/svg"}},[r("g",{staticClass:"ep-circle--container"},[r("defs",[t.isColorGradient?r("gradient",{attrs:{color:t.color,type:"progress",id:t._uid}}):t._e(),t.isColorFillGradient?r("gradient",{attrs:{color:t.colorFill,type:"progress-fill",id:t._uid}}):t._e(),t.isEmptyColorGradient?r("gradient",{attrs:{color:t.emptyColor,type:"empty",id:t._uid}}):t._e(),t.isEmptyColorFillGradient?r("gradient",{attrs:{color:t.emptyColorFill,type:"empty-fill",id:t._uid}}):t._e()],1),r(t.circleType,t._b({tag:"component",attrs:{id:t._uid}},"component",t.$props,!1))],1)]),t.dot?r("circle-dot",t._b({attrs:{id:t._uid}},"circle-dot",t.$props,!1)):t._e()],1)},m=[],g=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r(t.gradientComponent,{tag:"component",attrs:{id:"ep-"+t.type+"-gradient-"+t.id,x1:"0%",y1:"100%",x2:"0%",y2:"0%","area-hidden":"true"}},t._l(t.color.colors,(function(e,n){return r("stop",{key:n,attrs:{offset:e.offset+"%","stop-color":""+e.color,"stop-opacity":""+(t.isValidNumber(e.opacity)?e.opacity:1)}})})),1)},y=[],b={name:"Gradient",props:{color:{type:Object,required:!0},type:{type:String,required:!0},id:{type:Number,required:!0}},methods:{isValidNumber:function(t){return c(t)}},computed:{gradientComponent:function(){return this.color.radial?"radialGradient":"linearGradient"}}},x=b;function k(t,e,r,n,i,o,a,s){var c,u="function"===typeof t?t.options:t;if(e&&(u.render=e,u.staticRenderFns=r,u._compiled=!0),n&&(u.functional=!0),o&&(u._scopeId="data-v-"+o),a?(c=function(t){t=t||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,t||"undefined"===typeof __VUE_SSR_CONTEXT__||(t=__VUE_SSR_CONTEXT__),i&&i.call(this,t),t&&t._registeredComponents&&t._registeredComponents.add(a)},u._ssrRegister=c):i&&(c=s?function(){i.call(this,(u.functional?this.parent:this).$root.$options.shadowRoot)}:i),c)if(u.functional){u._injectStyles=c;var f=u.render;u.render=function(t,e){return c.call(e),f(t,e)}}else{var l=u.beforeCreate;u.beforeCreate=l?[].concat(l,c):[c]}return{exports:t,options:u}}var w=k(x,g,y,!1,null,null,null),_=w.exports,S=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("g",{staticClass:"ep-half-circle",style:{transitionDuration:t.styles.transitionDuration,transitionTimingFunction:t.styles.transitionTimingFunction,transform:"rotate("+t.computedAngle+"deg)"}},[r("path",{staticClass:"ep-half-circle--empty",class:{"ep-circle--nodata":!t.dataIsAvailable},style:{transitionDuration:t.animationDuration,transitionTimingFunction:t.styles.transitionTimingFunction},attrs:{"stroke-width":t.computedEmptyThickness,fill:t.computedColorFill,stroke:t.computedEmptyColor,d:t.emptyPath,"stroke-linecap":t.line,"stroke-dasharray":t.emptyDasharray}}),r("fade-in-transition",[t.isLoading?r("g",[r("g",{style:{opacity:""+(t.loading?1:.45)}},[r("path",{staticClass:"ep-half-circle--loading animation__loading",style:{transitionTimingFunction:t.styles.transitionTimingFunction,transformOrigin:t.styles.transformOrigin,"--ep-loading-stroke-offset":t.styles["--ep-loading-stroke-offset"],"--ep-circumference":t.styles["--ep-circumference"],"--ep-negative-circumference":t.styles["--ep-negative-circumference"]},attrs:{"stroke-width":t.computedThickness,d:t.path,fill:t.computedColorFill,stroke:t.computedColor,"stroke-dasharray":t.circumference,"stroke-linecap":t.line}})])]):t._e()]),r("path",{staticClass:"ep-half-circle--progress ep-circle--progress",class:t.animationClass,style:t.styles,attrs:{"stroke-width":t.computedThickness,d:t.path,fill:t.computedColorFill,stroke:t.computedColor,"stroke-dasharray":t.circumference,"stroke-linecap":t.line}})],1)},E=[];r("99af"),r("13d5"),r("e6cf"),r("2532"),r("4795"),r("96cf");function T(t,e,r,n,i,o,a){try{var s=t[o](a),c=s.value}catch(u){return void r(u)}s.done?e(c):Promise.resolve(c).then(n,i)}function O(t){return function(){var e=this,r=arguments;return new Promise((function(n,i){var o=t.apply(e,r);function a(t){T(o,n,i,a,s,"next",t)}function s(t){T(o,n,i,a,s,"throw",t)}a(void 0)}))}}var C=function(t){var e=t.trim().split(" ");return{mode:e[0],offset:u(e[1])||0}},j=function(t){var e=t.trim().split(" ");return{type:e[0],duration:c(e[1])?parseFloat(e[1]):1e3,delay:c(e[2])?parseFloat(e[2]):400}},A=function(t){var e=t.trim().split(" "),r="strict"===e[0];return r?{count:parseInt(e[1],10),spacing:parseFloat(e[2])}:t},P=function(t){var e=0,r="white",n={};if("object"!==f(t)){var i=t.toString().trim().split(" ");e=c(i[0])?i[0]:0,r=i[1]||"white"}else e=t.size||0,n=t;return s(s({},n),{},{size:e,color:r})},R=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:400;return new Promise((function(e){return setTimeout((function(){return e()}),t)}))},F={name:"CircleMixin",props:s(s({},d),{},{multiple:{type:Boolean,required:!0},id:{type:Number,required:!0},index:{type:Number,required:!0},globalThickness:{type:[Number,String],required:!1,default:"5%"},globalGap:{type:Number,required:!1},globalDot:{type:[Number,String,Object],required:!1}}),data:function(){return{isInitialized:!1}},computed:{computedProgress:function(){return parseFloat(this.progress||0)},progressOffset:function(){var t=this.circumference-this.computedProgress/100*this.circumference;return Math.abs(this.circumference-t)<1?this.circumference-.5:t},radius:function(){var t=this.parsedLineMode.offset;if(this.multiple)return this.baseRadius-this.previousCirclesThickness;switch(this.parsedLineMode.mode){case"normal":return this.normalLineModeRadius;case"in":return this.emptyRadius-(this.computedEmptyThickness/2+this.computedThickness/2+t);case"out-over":return this.computedEmptyThickness<=this.computedThickness?this.baseRadius:this.emptyRadius-this.computedEmptyThickness/2+this.computedThickness/2;case"bottom":return this.emptyRadius-this.computedEmptyThickness/2;case"top":return this.emptyRadius+this.computedEmptyThickness/2;default:return this.baseRadius}},emptyRadius:function(){var t=this.parsedLineMode.offset;if(this.multiple)return this.baseRadius-this.previousCirclesThickness;switch(this.parsedLineMode.mode){case"normal":return this.normalLineModeRadius;case"in":var e=this.computedThickness/2+this.computedEmptyThickness+t;return this.dotSize/2>e?this.emptyBaseRadius-(this.dotSize/2-e):this.emptyBaseRadius;case"in-over":return this.dotToThicknessDifference>0?this.emptyBaseRadius-this.dotToThicknessDifference/2:this.emptyBaseRadius;case"out":return this.baseRadius-(this.computedThickness/2+this.computedEmptyThickness/2+t);case"out-over":return this.computedEmptyThickness<=this.computedThickness?this.baseRadius-this.computedThickness/2+this.computedEmptyThickness/2:this.emptyBaseRadius;case"bottom":return this.computedEmptyThickness<this.thicknessWithDot/2?this.emptyBaseRadius-(this.thicknessWithDot/2-this.computedEmptyThickness):this.emptyBaseRadius;case"top":return this.emptyBaseRadius-this.thicknessWithDot/2;default:return this.emptyBaseRadius}},baseRadius:function(){return this.size/2-this.thicknessWithDot/2},emptyBaseRadius:function(){return this.size/2-this.computedEmptyThickness/2},normalLineModeRadius:function(){return this.thicknessWithDot<this.computedEmptyThickness?this.emptyBaseRadius:this.baseRadius},parsedLineMode:function(){return C(this.lineMode)},parsedAnimation:function(){return j(this.animation)},parsedDash:function(){return A(this.dash)},dataIsAvailable:function(){return c(this.computedProgress)&&!this.noData},animationClass:function(){return["animation__".concat(!this.loading&&this.dataIsAvailable&&this.isInitialized?this.parsedAnimation.type:"none")]},animationDuration:function(){return"".concat(this.parsedAnimation.duration,"ms")},computedColor:function(){return Array.isArray(this.color.colors)?"url(#ep-progress-gradient-".concat(this.id,")"):this.color},computedEmptyColor:function(){return Array.isArray(this.emptyColor.colors)?"url(#ep-empty-gradient-".concat(this.id,")"):this.emptyColor},computedColorFill:function(){return Array.isArray(this.colorFill.colors)?"url(#ep-progress-fill-gradient-".concat(this.id,")"):this.colorFill},computedEmptyColorFill:function(){return Array.isArray(this.emptyColorFill.colors)?"url(#ep-empty-fill-gradient-".concat(this.id,")"):this.emptyColorFill},computedThickness:function(){return this.calculateThickness(this.thickness.toString())},thicknessWithDot:function(){return this.computedThickness<this.dotSize?this.dotSize:this.computedThickness},computedGlobalThickness:function(){return this.calculateThickness(this.globalThickness)},computedEmptyThickness:function(){return this.calculateThickness(this.emptyThickness)},computedAngle:function(){return c(this.angle)?this.angle:-90},transformOrigin:function(){return"50% 50%"},emptyDasharray:function(){return this.parsedDash.count&&this.parsedDash.spacing?"".concat(2*Math.PI*this.emptyRadius*this.getDashPercent(),",\n              ").concat(2*Math.PI*this.emptyRadius*this.getDashSpacingPercent()).trim():this.parsedDash},strokeDashOffset:function(){return this.dataIsAvailable&&!this.loading&&this.isInitialized?this.progressOffset:this.circumference},previousCirclesThickness:function(){if(0===this.index)return 0;for(var t=c(this.gap)?this.gap:this.globalGap,e=[],r=0;r<this.index;r++){var n=this.data[r],i=n.dot?this.calculateThickness(P(n.dot).size):this.globalDotSize,o=c(n.thickness)?this.calculateThickness(n.thickness):this.computedGlobalThickness,a=c(n.gap)?n.gap:this.globalGap,s=Math.max(i,o);e.push(r>0?s+a:s)}return e.reduce((function(t,e){return t+e}))+t},parsedDot:function(){return P(this.dot)},dotSize:function(){return this.calculateThickness(this.parsedDot.size)},dotColor:function(){return this.parsedDot.color},dotToThicknessDifference:function(){return this.dotSize-this.computedThickness},globalDotSize:function(){return this.calculateThickness(P(this.globalDot).size)},styles:function(){return{transition:"".concat(this.animationDuration,", opacity 0.3s"),strokeDashoffset:this.strokeDashOffset,transitionTimingFunction:"ease-in-out",transformOrigin:this.transformOrigin,opacity:this.loading||!this.dataIsAvailable?0:1,"--ep-circumference":this.circumference,"--ep-negative-circumference":this.getNegativeCircumference(),"--ep-double-circumference":this.getDoubleCircumference(),"--ep-stroke-offset":this.progressOffset,"--ep-loop-stroke-offset":this.getLoopOffset(),"--ep-bounce-out-stroke-offset":this.getBounceOutOffset(),"--ep-bounce-in-stroke-offset":this.getBounceInOffset(),"--ep-reverse-stroke-offset":this.getReverseOffset(),"--ep-loading-stroke-offset":.2*this.circumference,"animation-duration":this.animationDuration}},isLoading:function(){return(this.determinate||this.loading)&&this.dataIsAvailable}},methods:{calculateThickness:function(t){var e=parseFloat(t);switch(!0){case t.toString().includes("%"):return e*this.size/100;default:return e}},getDashSpacingPercent:function(){return this.parsedDash.spacing/this.parsedDash.count},getDashPercent:function(){return(1-this.parsedDash.spacing)/this.parsedDash.count},getNegativeCircumference:function(){return-1*this.circumference},getDoubleCircumference:function(){return 2*this.circumference},getLoopOffset:function(){return this.getNegativeCircumference()-(this.circumference-this.progressOffset)},getReverseOffset:function(){return this.getDoubleCircumference()+this.progressOffset},getBounceOutOffset:function(){return this.progressOffset<100?0:this.progressOffset-100},getBounceInOffset:function(){return this.circumference-this.progressOffset<100?this.progressOffset:this.progressOffset+100}},mounted:function(){var t=this;return O(regeneratorRuntime.mark((function e(){return regeneratorRuntime.wrap((function(e){while(1)switch(e.prev=e.next){case 0:if(t.loading){e.next=3;break}return e.next=3,R(t.parsedAnimation.delay);case 3:t.isInitialized=!0;case 4:case"end":return e.stop()}}),e)})))()}},I=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("transition",{attrs:{mode:"out-in",name:"fade",appear:""}},[t._t("default")],2)},N=[],D={name:"FadeInTransition"},L=D,M=(r("53c8"),k(L,I,N,!1,null,"873ef638",null)),z=M.exports,q={name:"HalfCircleProgress",components:{FadeInTransition:z},mixins:[F],computed:{circumference:function(){return 2*this.radius*Math.PI/2},path:function(){return" M ".concat(this.position,", ").concat(this.size/2," a ").concat(this.radius,",").concat(this.radius," 0 1,1 ").concat(2*this.radius,",0")},emptyPath:function(){return" M ".concat(this.emptyPosition,", ").concat(this.size/2," a ").concat(this.emptyRadius,",").concat(this.emptyRadius," 0 1,1 ").concat(2*this.emptyRadius,",0")},position:function(){return this.size/2-this.radius},emptyPosition:function(){return this.size/2-this.emptyRadius}}},V=q,G=(r("054f"),k(V,S,E,!1,null,"5b37ebc3",null)),$=G.exports,B=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("g",{staticClass:"ep-circle",style:{transitionDuration:t.styles.transitionDuration,transitionTimingFunction:t.styles.transitionTimingFunction,transform:"rotate("+t.computedAngle+"deg)"}},[r("circle",{staticClass:"ep-circle--empty",class:{"ep-circle--nodata":!t.dataIsAvailable},style:{transitionDuration:t.animationDuration,transitionTimingFunction:t.styles.transitionTimingFunction},attrs:{r:t.emptyRadius,cx:t.position,cy:t.position,stroke:t.computedEmptyColor,"stroke-dasharray":t.emptyDasharray,fill:t.computedEmptyColorFill,"stroke-width":t.computedEmptyThickness}}),r("fade-in-transition",[t.isLoading?r("g",[r("g",{staticClass:"ep-circle--loading__container",style:{opacity:""+(t.loading?1:.45)}},[r("circle",{staticClass:"ep-circle--loading animation__loading",style:{transitionTimingFunction:t.styles.transitionTimingFunction,transformOrigin:t.styles.transformOrigin,"--ep-loading-stroke-offset":t.styles["--ep-loading-stroke-offset"],"--ep-circumference":t.styles["--ep-circumference"]},attrs:{r:t.radius,cx:t.position,cy:t.position,fill:"transparent",stroke:t.computedColor,"stroke-width":t.computedThickness,"stroke-linecap":t.line,"stroke-dasharray":t.circumference}})])]):t._e()]),r("circle",{staticClass:"ep-circle--progress",class:t.animationClass,style:t.styles,attrs:{r:t.radius,cx:t.position,cy:t.position,fill:t.computedColorFill,stroke:t.computedColor,"stroke-width":t.computedThickness,"stroke-linecap":t.line,"stroke-dasharray":t.circumference}})],1)},U=[],W={name:"CircleProgress",components:{FadeInTransition:z},mixins:[F],computed:{position:function(){return this.size/2},circumference:function(){return 2*this.radius*Math.PI}}},H=W,X=(r("273a"),k(H,B,U,!1,null,"7d0a0fbb",null)),Y=X.exports,K=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"ep-circle--progress__dot-container",class:t.dotContainerClasses,style:t.dotContainerStyle},[r("div",[r("span",{staticClass:"ep-circle--progress__dot",class:{"ep-hidden":t.isHidden},style:t.dotStyle})])])},J=[],Q={props:s({},d),name:"CircleDot",mixins:[F],computed:{dotContainerSize:function(){return 2*this.radius+this.dotSize},dotContainerRotation:function(){return this.isInitialized&&!this.loading&&this.dataIsAvailable?this.dotEnd:this.dotStart},dotContainerFullRotationDeg:function(){return this.half?180:360},dotContainerStyle:function(){return s({width:"".concat(this.dotContainerSize,"px"),height:"".concat(this.dotContainerSize,"px"),transform:"rotate(".concat(this.dotContainerRotation,"deg)"),transitionDuration:this.loading||!this.dataIsAvailable?"0s":this.animationDuration,transitionTimingFunction:"ease-in-out","animation-duration":this.animationDuration,"--ep-dot-start":"".concat(this.dotStart,"deg"),"--ep-dot-end":"".concat(this.dotEnd,"deg"),"--ep-dot-360":"".concat(this.dotStart+this.dotContainerFullRotationDeg,"deg")},this.dotContainerAnimationStyle)},dotContainerClasses:function(){return[this.animationClass,!this.half||"ep-half-circle-progress__dot"]},dotContainerAnimationStyle:function(){var t={loop:{opacity:this.half?0:1,"--ep-dot-loop-end":"".concat(this.dotStart+this.dotContainerFullRotationDeg+this.dotEnd,"deg")},bounce:{opacity:0,"animation-duration":"".concat(this.parsedAnimation.duration+500,"ms")}};return t[this.parsedAnimation.type]},dotStyle:function(){return s(s({borderRadius:"".concat(this.dotSize/2,"px"),width:"".concat(this.dotSize,"px"),backgroundColor:this.dotColor},this.dot),{},{transitionDuration:this.loading||!this.dataIsAvailable?"0s":this.animationDuration,height:"".concat(this.dotSize,"px")})},dotStart:function(){return this.half?this.angle-90:this.angle+90},dotEnd:function(){var t=this.calculateProgress();return this.dotStart+t*this.dotContainerFullRotationDeg/100},isHidden:function(){return!this.isInitialized||this.loading||!this.dataIsAvailable}},methods:{calculateProgress:function(){return this.half&&this.computedProgress<0?this.computedProgress-100:this.computedProgress}}},Z=Q,tt=(r("2474"),k(Z,K,J,!1,null,"38ca167f",null)),et=tt.exports,rt={name:"EpCircleContainer",components:{CircleDot:et,CircleProgress:Y,HalfCircleProgress:$,Gradient:_},props:s(s({},d),{},{index:{type:Number,required:!0},multiple:{type:Boolean,required:!0},globalThickness:{type:[Number,String],required:!1,default:"5%"},globalGap:{type:Number,required:!1},globalDot:{type:[Number,String,Object],required:!1}}),computed:{circleType:function(){return this.half?"half-circle-progress":"circle-progress"},isColorGradient:function(){return Array.isArray(this.color.colors)},isColorFillGradient:function(){return Array.isArray(this.colorFill.colors)},isEmptyColorGradient:function(){return Array.isArray(this.emptyColor.colors)},isEmptyColorFillGradient:function(){return Array.isArray(this.emptyColorFill.colors)}}},nt=rt,it=(r("c49e"),k(nt,v,m,!1,null,null,null)),ot=it.exports,at=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("span",{staticClass:"ep-legend--value__counter"},[t._t("default",null,{counterTick:t.counterProps}),t.$scopedSlots.default?t._e():r("span",[t._v(t._s(t.formattedValue))])],2)},st=[],ct=(r("b680"),r("841c"),{name:"Counter",props:{value:{type:[Number,String],required:!0},animation:{type:String,required:!0},loading:{type:Boolean,required:!0}},data:function(){return{start:0,startTime:0,currentValue:0,raf:null,previousCountStepValue:0}},watch:{value:function(){this.start=this.currentValue,this.reset(),this.raf=requestAnimationFrame(this.count)}},computed:{end:function(){return parseFloat(this.value.toString().replace(",","."))},difference:function(){return Math.abs(this.end-this.start)},oneStepDifference:function(){return 0===this.duration?this.difference:this.difference/this.duration},delimiter:function(){return this.value.toString().search(",")>=0?",":"."},formattedValue:function(){return this.currentValue.toFixed(this.countDecimals()).replace(".",this.delimiter)},delay:function(){return j(this.animation).delay},duration:function(){return j(this.animation).duration},counterProps:function(){return{currentValue:parseFloat(this.formattedValue),currentFormattedValue:this.formattedValue,currentRawValue:this.currentValue,duration:this.duration,previousCountStepValue:this.previousCountStepValue,start:this.start,end:this.end,difference:this.difference,oneStepDifference:this.oneStepDifference,startTime:this.startTime,elapsed:0}}},methods:{countDecimals:function(){return this.value%1===0?0:this.value.toString().split(this.delimiter)[1].length},count:function(t){this.startTime||(this.startTime=t);var e=t-this.startTime;this.end>=this.start?this.countUp(e):this.countDown(e),e<this.duration&&this.difference>.1&&(cancelAnimationFrame(this.raf),this.raf=requestAnimationFrame(this.count)),e>=this.duration&&(this.currentValue=this.end,this.reset())},countDown:function(t){var e=Math.min(this.oneStepDifference*(t||1),this.difference);this.currentValue-=e-this.previousCountStepValue,this.previousCountStepValue=e},countUp:function(t){var e=Math.min(this.oneStepDifference*(t||1),this.difference);this.currentValue+=e-this.previousCountStepValue,this.previousCountStepValue=e},reset:function(){this.startTime=0,this.previousCountStepValue=0,cancelAnimationFrame(this.raf)}},mounted:function(){var t=this;this.loading?this.raf=requestAnimationFrame(this.count):setTimeout((function(){t.raf=requestAnimationFrame(t.count)}),this.delay)}}),ut=ct,ft=k(ut,at,st,!1,null,null,null),lt=ft.exports,pt={name:"VueEllipseProgress",components:{Counter:lt,CircleContainer:ot},props:s(s({},p),{},{legendFormatter:{type:Function,required:!1}}),data:function(){return{counterTick:{}}},computed:{legendVal:function(){return this.loading||this.noData?0:this.legendValue?this.legendValue:u(this.progress)||0},shouldHideLegendValue:function(){return!this.isDataAvailable||this.loading},isDataAvailable:function(){return c(this.progress)&&!this.noData},isMultiple:function(){return this.data.length>1},isHTML:function(){return/<[a-z/][\s\S]*>/i.test(this.legendFormatter({currentValue:0}).toString().trim())},circlesData:function(){var t=this;return this.isMultiple?this.data.map((function(e){return s(s(s({},t.$props),e),{},{emptyThickness:c(e.thickness)?e.thickness:t.$props.thickness})})):[this.$props]}}},dt=pt,ht=(r("01f3"),k(dt,n,i,!1,null,"59d6a78d",null));e["a"]=ht.exports},"2ca0":function(t,e,r){"use strict";var n=r("23e7"),i=r("06cf").f,o=r("50c4"),a=r("5a34"),s=r("1d80"),c=r("ab13"),u=r("c430"),f="".startsWith,l=Math.min,p=c("startsWith"),d=!u&&!p&&!!function(){var t=i(String.prototype,"startsWith");return t&&!t.writable}();n({target:"String",proto:!0,forced:!d&&!p},{startsWith:function(t){var e=String(s(this));a(t);var r=o(l(arguments.length>1?arguments[1]:void 0,e.length)),n=String(t);return f?f.call(e,n,r):e.slice(r,r+n.length)===n}})},"2cf4":function(t,e,r){var n,i,o,a=r("da84"),s=r("d039"),c=r("c6b6"),u=r("0366"),f=r("1be4"),l=r("cc12"),p=r("1cdc"),d=a.location,h=a.setImmediate,v=a.clearImmediate,m=a.process,g=a.MessageChannel,y=a.Dispatch,b=0,x={},k="onreadystatechange",w=function(t){if(x.hasOwnProperty(t)){var e=x[t];delete x[t],e()}},_=function(t){return function(){w(t)}},S=function(t){w(t.data)},E=function(t){a.postMessage(t+"",d.protocol+"//"+d.host)};h&&v||(h=function(t){var e=[],r=1;while(arguments.length>r)e.push(arguments[r++]);return x[++b]=function(){("function"==typeof t?t:Function(t)).apply(void 0,e)},n(b),b},v=function(t){delete x[t]},"process"==c(m)?n=function(t){m.nextTick(_(t))}:y&&y.now?n=function(t){y.now(_(t))}:g&&!p?(i=new g,o=i.port2,i.port1.onmessage=S,n=u(o.postMessage,o,1)):!a.addEventListener||"function"!=typeof postMessage||a.importScripts||s(E)||"file:"===d.protocol?n=k in l("script")?function(t){f.appendChild(l("script"))[k]=function(){f.removeChild(this),w(t)}}:function(t){setTimeout(_(t),0)}:(n=E,a.addEventListener("message",S,!1))),t.exports={set:h,clear:v}},"2d00":function(t,e,r){var n,i,o=r("da84"),a=r("342f"),s=o.process,c=s&&s.versions,u=c&&c.v8;u?(n=u.split("."),i=n[0]+n[1]):a&&(n=a.match(/Edge\/(\d+)/),(!n||n[1]>=74)&&(n=a.match(/Chrome\/(\d+)/),n&&(i=n[1]))),t.exports=i&&+i},"342f":function(t,e,r){var n=r("d066");t.exports=n("navigator","userAgent")||""},"35a1":function(t,e,r){var n=r("f5df"),i=r("3f8c"),o=r("b622"),a=o("iterator");t.exports=function(t){if(void 0!=t)return t[a]||t["@@iterator"]||i[n(t)]}},"37e8":function(t,e,r){var n=r("83ab"),i=r("9bf2"),o=r("825a"),a=r("df75");t.exports=n?Object.defineProperties:function(t,e){o(t);var r,n=a(e),s=n.length,c=0;while(s>c)i.f(t,r=n[c++],e[r]);return t}},"3bbe":function(t,e,r){var n=r("861d");t.exports=function(t){if(!n(t)&&null!==t)throw TypeError("Can't set "+String(t)+" as a prototype");return t}},"3ca3":function(t,e,r){"use strict";var n=r("6547").charAt,i=r("69f3"),o=r("7dd0"),a="String Iterator",s=i.set,c=i.getterFor(a);o(String,"String",(function(t){s(this,{type:a,string:String(t),index:0})}),(function(){var t,e=c(this),r=e.string,i=e.index;return i>=r.length?{value:void 0,done:!0}:(t=n(r,i),e.index+=t.length,{value:t,done:!1})}))},"3f8c":function(t,e){t.exports={}},"403e":function(t,e,r){var n=r("648b");"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var i=r("499e").default;i("3d3d86fd",n,!0,{sourceMap:!1,shadowMode:!1})},"408a":function(t,e,r){var n=r("c6b6");t.exports=function(t){if("number"!=typeof t&&"Number"!=n(t))throw TypeError("Incorrect invocation");return+t}},4160:function(t,e,r){"use strict";var n=r("23e7"),i=r("17c2");n({target:"Array",proto:!0,forced:[].forEach!=i},{forEach:i})},"428f":function(t,e,r){var n=r("da84");t.exports=n},"44ad":function(t,e,r){var n=r("d039"),i=r("c6b6"),o="".split;t.exports=n((function(){return!Object("z").propertyIsEnumerable(0)}))?function(t){return"String"==i(t)?o.call(t,""):Object(t)}:Object},"44d2":function(t,e,r){var n=r("b622"),i=r("7c73"),o=r("9bf2"),a=n("unscopables"),s=Array.prototype;void 0==s[a]&&o.f(s,a,{configurable:!0,value:i(null)}),t.exports=function(t){s[a][t]=!0}},"44de":function(t,e,r){var n=r("da84");t.exports=function(t,e){var r=n.console;r&&r.error&&(1===arguments.length?r.error(t):r.error(t,e))}},"44e7":function(t,e,r){var n=r("861d"),i=r("c6b6"),o=r("b622"),a=o("match");t.exports=function(t){var e;return n(t)&&(void 0!==(e=t[a])?!!e:"RegExp"==i(t))}},"45fc":function(t,e,r){"use strict";var n=r("23e7"),i=r("b727").some,o=r("a640"),a=r("ae40"),s=o("some"),c=a("some");n({target:"Array",proto:!0,forced:!s||!c},{some:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},4795:function(t,e,r){var n=r("23e7"),i=r("da84"),o=r("342f"),a=[].slice,s=/MSIE .\./.test(o),c=function(t){return function(e,r){var n=arguments.length>2,i=n?a.call(arguments,2):void 0;return t(n?function(){("function"==typeof e?e:Function(e)).apply(this,i)}:e,r)}};n({global:!0,bind:!0,forced:s},{setTimeout:c(i.setTimeout),setInterval:c(i.setInterval)})},4840:function(t,e,r){var n=r("825a"),i=r("1c0b"),o=r("b622"),a=o("species");t.exports=function(t,e){var r,o=n(t).constructor;return void 0===o||void 0==(r=n(o)[a])?e:i(r)}},4930:function(t,e,r){var n=r("d039");t.exports=!!Object.getOwnPropertySymbols&&!n((function(){return!String(Symbol())}))},"498a":function(t,e,r){"use strict";var n=r("23e7"),i=r("58a8").trim,o=r("c8d2");n({target:"String",proto:!0,forced:o("trim")},{trim:function(){return i(this)}})},"499e":function(t,e,r){"use strict";function n(t,e){for(var r=[],n={},i=0;i<e.length;i++){var o=e[i],a=o[0],s=o[1],c=o[2],u=o[3],f={id:t+":"+i,css:s,media:c,sourceMap:u};n[a]?n[a].parts.push(f):r.push(n[a]={id:a,parts:[f]})}return r}r.r(e),r.d(e,"default",(function(){return h}));var i="undefined"!==typeof document;if("undefined"!==typeof DEBUG&&DEBUG&&!i)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var o={},a=i&&(document.head||document.getElementsByTagName("head")[0]),s=null,c=0,u=!1,f=function(){},l=null,p="data-vue-ssr-id",d="undefined"!==typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function h(t,e,r,i){u=r,l=i||{};var a=n(t,e);return v(a),function(e){for(var r=[],i=0;i<a.length;i++){var s=a[i],c=o[s.id];c.refs--,r.push(c)}e?(a=n(t,e),v(a)):a=[];for(i=0;i<r.length;i++){c=r[i];if(0===c.refs){for(var u=0;u<c.parts.length;u++)c.parts[u]();delete o[c.id]}}}}function v(t){for(var e=0;e<t.length;e++){var r=t[e],n=o[r.id];if(n){n.refs++;for(var i=0;i<n.parts.length;i++)n.parts[i](r.parts[i]);for(;i<r.parts.length;i++)n.parts.push(g(r.parts[i]));n.parts.length>r.parts.length&&(n.parts.length=r.parts.length)}else{var a=[];for(i=0;i<r.parts.length;i++)a.push(g(r.parts[i]));o[r.id]={id:r.id,refs:1,parts:a}}}}function m(){var t=document.createElement("style");return t.type="text/css",a.appendChild(t),t}function g(t){var e,r,n=document.querySelector("style["+p+'~="'+t.id+'"]');if(n){if(u)return f;n.parentNode.removeChild(n)}if(d){var i=c++;n=s||(s=m()),e=b.bind(null,n,i,!1),r=b.bind(null,n,i,!0)}else n=m(),e=x.bind(null,n),r=function(){n.parentNode.removeChild(n)};return e(t),function(n){if(n){if(n.css===t.css&&n.media===t.media&&n.sourceMap===t.sourceMap)return;e(t=n)}else r()}}var y=function(){var t=[];return function(e,r){return t[e]=r,t.filter(Boolean).join("\n")}}();function b(t,e,r,n){var i=r?"":n.css;if(t.styleSheet)t.styleSheet.cssText=y(e,i);else{var o=document.createTextNode(i),a=t.childNodes;a[e]&&t.removeChild(a[e]),a.length?t.insertBefore(o,a[e]):t.appendChild(o)}}function x(t,e){var r=e.css,n=e.media,i=e.sourceMap;if(n&&t.setAttribute("media",n),l.ssrId&&t.setAttribute(p,e.id),i&&(r+="\n/*# sourceURL="+i.sources[0]+" */",r+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */"),t.styleSheet)t.styleSheet.cssText=r;else{while(t.firstChild)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(r))}}},"4d64":function(t,e,r){var n=r("fc6a"),i=r("50c4"),o=r("23cb"),a=function(t){return function(e,r,a){var s,c=n(e),u=i(c.length),f=o(a,u);if(t&&r!=r){while(u>f)if(s=c[f++],s!=s)return!0}else for(;u>f;f++)if((t||f in c)&&c[f]===r)return t||f||0;return!t&&-1}};t.exports={includes:a(!0),indexOf:a(!1)}},"4de4":function(t,e,r){"use strict";var n=r("23e7"),i=r("b727").filter,o=r("1dde"),a=r("ae40"),s=o("filter"),c=a("filter");n({target:"Array",proto:!0,forced:!s||!c},{filter:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},"50c4":function(t,e,r){var n=r("a691"),i=Math.min;t.exports=function(t){return t>0?i(n(t),9007199254740991):0}},5135:function(t,e){var r={}.hasOwnProperty;t.exports=function(t,e){return r.call(t,e)}},5319:function(t,e,r){"use strict";var n=r("d784"),i=r("825a"),o=r("7b0b"),a=r("50c4"),s=r("a691"),c=r("1d80"),u=r("8aa5"),f=r("14c3"),l=Math.max,p=Math.min,d=Math.floor,h=/\$([$&'`]|\d\d?|<[^>]*>)/g,v=/\$([$&'`]|\d\d?)/g,m=function(t){return void 0===t?t:String(t)};n("replace",2,(function(t,e,r,n){var g=n.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE,y=n.REPLACE_KEEPS_$0,b=g?"$":"$0";return[function(r,n){var i=c(this),o=void 0==r?void 0:r[t];return void 0!==o?o.call(r,i,n):e.call(String(i),r,n)},function(t,n){if(!g&&y||"string"===typeof n&&-1===n.indexOf(b)){var o=r(e,t,this,n);if(o.done)return o.value}var c=i(t),d=String(this),h="function"===typeof n;h||(n=String(n));var v=c.global;if(v){var k=c.unicode;c.lastIndex=0}var w=[];while(1){var _=f(c,d);if(null===_)break;if(w.push(_),!v)break;var S=String(_[0]);""===S&&(c.lastIndex=u(d,a(c.lastIndex),k))}for(var E="",T=0,O=0;O<w.length;O++){_=w[O];for(var C=String(_[0]),j=l(p(s(_.index),d.length),0),A=[],P=1;P<_.length;P++)A.push(m(_[P]));var R=_.groups;if(h){var F=[C].concat(A,j,d);void 0!==R&&F.push(R);var I=String(n.apply(void 0,F))}else I=x(C,d,j,A,R,n);j>=T&&(E+=d.slice(T,j)+I,T=j+C.length)}return E+d.slice(T)}];function x(t,r,n,i,a,s){var c=n+t.length,u=i.length,f=v;return void 0!==a&&(a=o(a),f=h),e.call(s,f,(function(e,o){var s;switch(o.charAt(0)){case"$":return"$";case"&":return t;case"`":return r.slice(0,n);case"'":return r.slice(c);case"<":s=a[o.slice(1,-1)];break;default:var f=+o;if(0===f)return e;if(f>u){var l=d(f/10);return 0===l?e:l<=u?void 0===i[l-1]?o.charAt(1):i[l-1]+o.charAt(1):e}s=i[f-1]}return void 0===s?"":s}))}}))},"53c8":function(t,e,r){"use strict";var n=r("403e"),i=r.n(n);i.a},5692:function(t,e,r){var n=r("c430"),i=r("c6cd");(t.exports=function(t,e){return i[t]||(i[t]=void 0!==e?e:{})})("versions",[]).push({version:"3.6.5",mode:n?"pure":"global",copyright:"Â© 2020 Denis Pushkarev (zloirock.ru)"})},"56ef":function(t,e,r){var n=r("d066"),i=r("241c"),o=r("7418"),a=r("825a");t.exports=n("Reflect","ownKeys")||function(t){var e=i.f(a(t)),r=o.f;return r?e.concat(r(t)):e}},5899:function(t,e){t.exports="\t\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\ufeff"},"58a8":function(t,e,r){var n=r("1d80"),i=r("5899"),o="["+i+"]",a=RegExp("^"+o+o+"*"),s=RegExp(o+o+"*$"),c=function(t){return function(e){var r=String(n(e));return 1&t&&(r=r.replace(a,"")),2&t&&(r=r.replace(s,"")),r}};t.exports={start:c(1),end:c(2),trim:c(3)}},"5a34":function(t,e,r){var n=r("44e7");t.exports=function(t){if(n(t))throw TypeError("The method doesn't accept regular expressions");return t}},"5c6c":function(t,e){t.exports=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}}},"648b":function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".fade-enter-active[data-v-873ef638],.fade-leave-active[data-v-873ef638]{-webkit-transition:opacity .3s;-o-transition:opacity .3s;transition:opacity .3s}.fade-enter[data-v-873ef638],.fade-leave-active[data-v-873ef638]{-webkit-transition:.3s;-o-transition:.3s;transition:.3s;opacity:0}",""]),t.exports=e},6547:function(t,e,r){var n=r("a691"),i=r("1d80"),o=function(t){return function(e,r){var o,a,s=String(i(e)),c=n(r),u=s.length;return c<0||c>=u?t?"":void 0:(o=s.charCodeAt(c),o<55296||o>56319||c+1===u||(a=s.charCodeAt(c+1))<56320||a>57343?t?s.charAt(c):o:t?s.slice(c,c+2):a-56320+(o-55296<<10)+65536)}};t.exports={codeAt:o(!1),charAt:o(!0)}},"65f0":function(t,e,r){var n=r("861d"),i=r("e8b5"),o=r("b622"),a=o("species");t.exports=function(t,e){var r;return i(t)&&(r=t.constructor,"function"!=typeof r||r!==Array&&!i(r.prototype)?n(r)&&(r=r[a],null===r&&(r=void 0)):r=void 0),new(void 0===r?Array:r)(0===e?0:e)}},"69f3":function(t,e,r){var n,i,o,a=r("7f9a"),s=r("da84"),c=r("861d"),u=r("9112"),f=r("5135"),l=r("f772"),p=r("d012"),d=s.WeakMap,h=function(t){return o(t)?i(t):n(t,{})},v=function(t){return function(e){var r;if(!c(e)||(r=i(e)).type!==t)throw TypeError("Incompatible receiver, "+t+" required");return r}};if(a){var m=new d,g=m.get,y=m.has,b=m.set;n=function(t,e){return b.call(m,t,e),e},i=function(t){return g.call(m,t)||{}},o=function(t){return y.call(m,t)}}else{var x=l("state");p[x]=!0,n=function(t,e){return u(t,x,e),e},i=function(t){return f(t,x)?t[x]:{}},o=function(t){return f(t,x)}}t.exports={set:n,get:i,has:o,enforce:h,getterFor:v}},"6d40":function(t,e,r){var n=r("11ae");"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var i=r("499e").default;i("78b49b6e",n,!0,{sourceMap:!1,shadowMode:!1})},"6eeb":function(t,e,r){var n=r("da84"),i=r("9112"),o=r("5135"),a=r("ce4e"),s=r("8925"),c=r("69f3"),u=c.get,f=c.enforce,l=String(String).split("String");(t.exports=function(t,e,r,s){var c=!!s&&!!s.unsafe,u=!!s&&!!s.enumerable,p=!!s&&!!s.noTargetGet;"function"==typeof r&&("string"!=typeof e||o(r,"name")||i(r,"name",e),f(r).source=l.join("string"==typeof e?e:"")),t!==n?(c?!p&&t[e]&&(u=!0):delete t[e],u?t[e]=r:i(t,e,r)):u?t[e]=r:a(e,r)})(Function.prototype,"toString",(function(){return"function"==typeof this&&u(this).source||s(this)}))},7156:function(t,e,r){var n=r("861d"),i=r("d2bb");t.exports=function(t,e,r){var o,a;return i&&"function"==typeof(o=e.constructor)&&o!==r&&n(a=o.prototype)&&a!==r.prototype&&i(t,a),t}},7418:function(t,e){e.f=Object.getOwnPropertySymbols},"746f":function(t,e,r){var n=r("428f"),i=r("5135"),o=r("e538"),a=r("9bf2").f;t.exports=function(t){var e=n.Symbol||(n.Symbol={});i(e,t)||a(e,t,{value:o.f(t)})}},7839:function(t,e){t.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},"7b0b":function(t,e,r){var n=r("1d80");t.exports=function(t){return Object(n(t))}},"7c73":function(t,e,r){var n,i=r("825a"),o=r("37e8"),a=r("7839"),s=r("d012"),c=r("1be4"),u=r("cc12"),f=r("f772"),l=">",p="<",d="prototype",h="script",v=f("IE_PROTO"),m=function(){},g=function(t){return p+h+l+t+p+"/"+h+l},y=function(t){t.write(g("")),t.close();var e=t.parentWindow.Object;return t=null,e},b=function(){var t,e=u("iframe"),r="java"+h+":";return e.style.display="none",c.appendChild(e),e.src=String(r),t=e.contentWindow.document,t.open(),t.write(g("document.F=Object")),t.close(),t.F},x=function(){try{n=document.domain&&new ActiveXObject("htmlfile")}catch(e){}x=n?y(n):b();var t=a.length;while(t--)delete x[d][a[t]];return x()};s[v]=!0,t.exports=Object.create||function(t,e){var r;return null!==t?(m[d]=i(t),r=new m,m[d]=null,r[v]=t):r=x(),void 0===e?r:o(r,e)}},"7dd0":function(t,e,r){"use strict";var n=r("23e7"),i=r("9ed3"),o=r("e163"),a=r("d2bb"),s=r("d44e"),c=r("9112"),u=r("6eeb"),f=r("b622"),l=r("c430"),p=r("3f8c"),d=r("ae93"),h=d.IteratorPrototype,v=d.BUGGY_SAFARI_ITERATORS,m=f("iterator"),g="keys",y="values",b="entries",x=function(){return this};t.exports=function(t,e,r,f,d,k,w){i(r,e,f);var _,S,E,T=function(t){if(t===d&&P)return P;if(!v&&t in j)return j[t];switch(t){case g:return function(){return new r(this,t)};case y:return function(){return new r(this,t)};case b:return function(){return new r(this,t)}}return function(){return new r(this)}},O=e+" Iterator",C=!1,j=t.prototype,A=j[m]||j["@@iterator"]||d&&j[d],P=!v&&A||T(d),R="Array"==e&&j.entries||A;if(R&&(_=o(R.call(new t)),h!==Object.prototype&&_.next&&(l||o(_)===h||(a?a(_,h):"function"!=typeof _[m]&&c(_,m,x)),s(_,O,!0,!0),l&&(p[O]=x))),d==y&&A&&A.name!==y&&(C=!0,P=function(){return A.call(this)}),l&&!w||j[m]===P||c(j,m,P),p[e]=P,d)if(S={values:T(y),keys:k?P:T(g),entries:T(b)},w)for(E in S)(v||C||!(E in j))&&u(j,E,S[E]);else n({target:e,proto:!0,forced:v||C},S);return S}},"7f9a":function(t,e,r){var n=r("da84"),i=r("8925"),o=n.WeakMap;t.exports="function"===typeof o&&/native code/.test(i(o))},"825a":function(t,e,r){var n=r("861d");t.exports=function(t){if(!n(t))throw TypeError(String(t)+" is not an object");return t}},"83ab":function(t,e,r){var n=r("d039");t.exports=!n((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},8418:function(t,e,r){"use strict";var n=r("c04e"),i=r("9bf2"),o=r("5c6c");t.exports=function(t,e,r){var a=n(e);a in t?i.f(t,a,o(0,r)):t[a]=r}},"841c":function(t,e,r){"use strict";var n=r("d784"),i=r("825a"),o=r("1d80"),a=r("129f"),s=r("14c3");n("search",1,(function(t,e,r){return[function(e){var r=o(this),n=void 0==e?void 0:e[t];return void 0!==n?n.call(e,r):new RegExp(e)[t](String(r))},function(t){var n=r(e,t,this);if(n.done)return n.value;var o=i(t),c=String(this),u=o.lastIndex;a(u,0)||(o.lastIndex=0);var f=s(o,c);return a(o.lastIndex,u)||(o.lastIndex=u),null===f?-1:f.index}]}))},"861d":function(t,e){t.exports=function(t){return"object"===typeof t?null!==t:"function"===typeof t}},8875:function(t,e,r){var n,i,o;(function(r,a){i=[],n=a,o="function"===typeof n?n.apply(e,i):n,void 0===o||(t.exports=o)})("undefined"!==typeof self&&self,(function(){function t(){var e=Object.getOwnPropertyDescriptor(document,"currentScript");if(!e&&"currentScript"in document&&document.currentScript)return document.currentScript;if(e&&e.get!==t&&document.currentScript)return document.currentScript;try{throw new Error}catch(d){var r,n,i,o=/.*at [^(]*\((.*):(.+):(.+)\)$/gi,a=/@([^@]*):(\d+):(\d+)\s*$/gi,s=o.exec(d.stack)||a.exec(d.stack),c=s&&s[1]||!1,u=s&&s[2]||!1,f=document.location.href.replace(document.location.hash,""),l=document.getElementsByTagName("script");c===f&&(r=document.documentElement.outerHTML,n=new RegExp("(?:[^\\n]+?\\n){0,"+(u-2)+"}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*","i"),i=r.replace(n,"$1").trim());for(var p=0;p<l.length;p++){if("interactive"===l[p].readyState)return l[p];if(l[p].src===c)return l[p];if(c===f&&l[p].innerHTML&&l[p].innerHTML.trim()===i)return l[p]}return null}}return t}))},8925:function(t,e,r){var n=r("c6cd"),i=Function.toString;"function"!=typeof n.inspectSource&&(n.inspectSource=function(t){return i.call(t)}),t.exports=n.inspectSource},"8aa5":function(t,e,r){"use strict";var n=r("6547").charAt;t.exports=function(t,e,r){return e+(r?n(t,e).length:1)}},"90e3":function(t,e){var r=0,n=Math.random();t.exports=function(t){return"Symbol("+String(void 0===t?"":t)+")_"+(++r+n).toString(36)}},9112:function(t,e,r){var n=r("83ab"),i=r("9bf2"),o=r("5c6c");t.exports=n?function(t,e,r){return i.f(t,e,o(1,r))}:function(t,e,r){return t[e]=r,t}},9129:function(t,e,r){var n=r("23e7");n({target:"Number",stat:!0},{isNaN:function(t){return t!=t}})},9263:function(t,e,r){"use strict";var n=r("ad6d"),i=r("9f7f"),o=RegExp.prototype.exec,a=String.prototype.replace,s=o,c=function(){var t=/a/,e=/b*/g;return o.call(t,"a"),o.call(e,"a"),0!==t.lastIndex||0!==e.lastIndex}(),u=i.UNSUPPORTED_Y||i.BROKEN_CARET,f=void 0!==/()??/.exec("")[1],l=c||f||u;l&&(s=function(t){var e,r,i,s,l=this,p=u&&l.sticky,d=n.call(l),h=l.source,v=0,m=t;return p&&(d=d.replace("y",""),-1===d.indexOf("g")&&(d+="g"),m=String(t).slice(l.lastIndex),l.lastIndex>0&&(!l.multiline||l.multiline&&"\n"!==t[l.lastIndex-1])&&(h="(?: "+h+")",m=" "+m,v++),r=new RegExp("^(?:"+h+")",d)),f&&(r=new RegExp("^"+h+"$(?!\\s)",d)),c&&(e=l.lastIndex),i=o.call(p?r:l,m),p?i?(i.input=i.input.slice(v),i[0]=i[0].slice(v),i.index=l.lastIndex,l.lastIndex+=i[0].length):l.lastIndex=0:c&&i&&(l.lastIndex=l.global?i.index+i[0].length:e),f&&i&&i.length>1&&a.call(i[0],r,(function(){for(s=1;s<arguments.length-2;s++)void 0===arguments[s]&&(i[s]=void 0)})),i}),t.exports=s},"94ca":function(t,e,r){var n=r("d039"),i=/#|\.prototype\./,o=function(t,e){var r=s[a(t)];return r==u||r!=c&&("function"==typeof e?n(e):!!e)},a=o.normalize=function(t){return String(t).replace(i,".").toLowerCase()},s=o.data={},c=o.NATIVE="N",u=o.POLYFILL="P";t.exports=o},"96cf":function(t,e,r){var n=function(t){"use strict";var e,r=Object.prototype,n=r.hasOwnProperty,i="function"===typeof Symbol?Symbol:{},o=i.iterator||"@@iterator",a=i.asyncIterator||"@@asyncIterator",s=i.toStringTag||"@@toStringTag";function c(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{c({},"")}catch(R){c=function(t,e,r){return t[e]=r}}function u(t,e,r,n){var i=e&&e.prototype instanceof m?e:m,o=Object.create(i.prototype),a=new j(n||[]);return o._invoke=E(t,r,a),o}function f(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(R){return{type:"throw",arg:R}}}t.wrap=u;var l="suspendedStart",p="suspendedYield",d="executing",h="completed",v={};function m(){}function g(){}function y(){}var b={};b[o]=function(){return this};var x=Object.getPrototypeOf,k=x&&x(x(A([])));k&&k!==r&&n.call(k,o)&&(b=k);var w=y.prototype=m.prototype=Object.create(b);function _(t){["next","throw","return"].forEach((function(e){c(t,e,(function(t){return this._invoke(e,t)}))}))}function S(t,e){function r(i,o,a,s){var c=f(t[i],t,o);if("throw"!==c.type){var u=c.arg,l=u.value;return l&&"object"===typeof l&&n.call(l,"__await")?e.resolve(l.__await).then((function(t){r("next",t,a,s)}),(function(t){r("throw",t,a,s)})):e.resolve(l).then((function(t){u.value=t,a(u)}),(function(t){return r("throw",t,a,s)}))}s(c.arg)}var i;function o(t,n){function o(){return new e((function(e,i){r(t,n,e,i)}))}return i=i?i.then(o,o):o()}this._invoke=o}function E(t,e,r){var n=l;return function(i,o){if(n===d)throw new Error("Generator is already running");if(n===h){if("throw"===i)throw o;return P()}r.method=i,r.arg=o;while(1){var a=r.delegate;if(a){var s=T(a,r);if(s){if(s===v)continue;return s}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===l)throw n=h,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=d;var c=f(t,e,r);if("normal"===c.type){if(n=r.done?h:p,c.arg===v)continue;return{value:c.arg,done:r.done}}"throw"===c.type&&(n=h,r.method="throw",r.arg=c.arg)}}}function T(t,r){var n=t.iterator[r.method];if(n===e){if(r.delegate=null,"throw"===r.method){if(t.iterator["return"]&&(r.method="return",r.arg=e,T(t,r),"throw"===r.method))return v;r.method="throw",r.arg=new TypeError("The iterator does not provide a 'throw' method")}return v}var i=f(n,t.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,v;var o=i.arg;return o?o.done?(r[t.resultName]=o.value,r.next=t.nextLoc,"return"!==r.method&&(r.method="next",r.arg=e),r.delegate=null,v):o:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,v)}function O(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function C(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function j(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(O,this),this.reset(!0)}function A(t){if(t){var r=t[o];if(r)return r.call(t);if("function"===typeof t.next)return t;if(!isNaN(t.length)){var i=-1,a=function r(){while(++i<t.length)if(n.call(t,i))return r.value=t[i],r.done=!1,r;return r.value=e,r.done=!0,r};return a.next=a}}return{next:P}}function P(){return{value:e,done:!0}}return g.prototype=w.constructor=y,y.constructor=g,g.displayName=c(y,s,"GeneratorFunction"),t.isGeneratorFunction=function(t){var e="function"===typeof t&&t.constructor;return!!e&&(e===g||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,y):(t.__proto__=y,c(t,s,"GeneratorFunction")),t.prototype=Object.create(w),t},t.awrap=function(t){return{__await:t}},_(S.prototype),S.prototype[a]=function(){return this},t.AsyncIterator=S,t.async=function(e,r,n,i,o){void 0===o&&(o=Promise);var a=new S(u(e,r,n,i),o);return t.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},_(w),c(w,s,"Generator"),w[o]=function(){return this},w.toString=function(){return"[object Generator]"},t.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){while(e.length){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},t.values=A,j.prototype={constructor:j,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(C),!t)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=e)},stop:function(){this.done=!0;var t=this.tryEntries[0],e=t.completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var r=this;function i(n,i){return s.type="throw",s.arg=t,r.next=n,i&&(r.method="next",r.arg=e),!!i}for(var o=this.tryEntries.length-1;o>=0;--o){var a=this.tryEntries[o],s=a.completion;if("root"===a.tryLoc)return i("end");if(a.tryLoc<=this.prev){var c=n.call(a,"catchLoc"),u=n.call(a,"finallyLoc");if(c&&u){if(this.prev<a.catchLoc)return i(a.catchLoc,!0);if(this.prev<a.finallyLoc)return i(a.finallyLoc)}else if(c){if(this.prev<a.catchLoc)return i(a.catchLoc,!0)}else{if(!u)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return i(a.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r];if(i.tryLoc<=this.prev&&n.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var o=i;break}}o&&("break"===t||"continue"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var a=o?o.completion:{};return a.type=t,a.arg=e,o?(this.method="next",this.next=o.finallyLoc,v):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),v},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),C(r),v}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var i=n.arg;C(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,r,n){return this.delegate={iterator:A(t),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=e),v}},t}(t.exports);try{regeneratorRuntime=n}catch(i){Function("r","regeneratorRuntime = r")(n)}},"99af":function(t,e,r){"use strict";var n=r("23e7"),i=r("d039"),o=r("e8b5"),a=r("861d"),s=r("7b0b"),c=r("50c4"),u=r("8418"),f=r("65f0"),l=r("1dde"),p=r("b622"),d=r("2d00"),h=p("isConcatSpreadable"),v=9007199254740991,m="Maximum allowed index exceeded",g=d>=51||!i((function(){var t=[];return t[h]=!1,t.concat()[0]!==t})),y=l("concat"),b=function(t){if(!a(t))return!1;var e=t[h];return void 0!==e?!!e:o(t)},x=!g||!y;n({target:"Array",proto:!0,forced:x},{concat:function(t){var e,r,n,i,o,a=s(this),l=f(a,0),p=0;for(e=-1,n=arguments.length;e<n;e++)if(o=-1===e?a:arguments[e],b(o)){if(i=c(o.length),p+i>v)throw TypeError(m);for(r=0;r<i;r++,p++)r in o&&u(l,p,o[r])}else{if(p>=v)throw TypeError(m);u(l,p++,o)}return l.length=p,l}})},"9bdd":function(t,e,r){var n=r("825a");t.exports=function(t,e,r,i){try{return i?e(n(r)[0],r[1]):e(r)}catch(a){var o=t["return"];throw void 0!==o&&n(o.call(t)),a}}},"9bf2":function(t,e,r){var n=r("83ab"),i=r("0cfb"),o=r("825a"),a=r("c04e"),s=Object.defineProperty;e.f=n?s:function(t,e,r){if(o(t),e=a(e,!0),o(r),i)try{return s(t,e,r)}catch(n){}if("get"in r||"set"in r)throw TypeError("Accessors not supported");return"value"in r&&(t[e]=r.value),t}},"9ed3":function(t,e,r){"use strict";var n=r("ae93").IteratorPrototype,i=r("7c73"),o=r("5c6c"),a=r("d44e"),s=r("3f8c"),c=function(){return this};t.exports=function(t,e,r){var u=e+" Iterator";return t.prototype=i(n,{next:o(1,r)}),a(t,u,!1,!0),s[u]=c,t}},"9f7f":function(t,e,r){"use strict";var n=r("d039");function i(t,e){return RegExp(t,e)}e.UNSUPPORTED_Y=n((function(){var t=i("a","y");return t.lastIndex=2,null!=t.exec("abcd")})),e.BROKEN_CARET=n((function(){var t=i("^r","gy");return t.lastIndex=2,null!=t.exec("str")}))},a231:function(t,e,r){var n=r("1d1a");"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var i=r("499e").default;i("1ef95f13",n,!0,{sourceMap:!1,shadowMode:!1})},a4d3:function(t,e,r){"use strict";var n=r("23e7"),i=r("da84"),o=r("d066"),a=r("c430"),s=r("83ab"),c=r("4930"),u=r("fdbf"),f=r("d039"),l=r("5135"),p=r("e8b5"),d=r("861d"),h=r("825a"),v=r("7b0b"),m=r("fc6a"),g=r("c04e"),y=r("5c6c"),b=r("7c73"),x=r("df75"),k=r("241c"),w=r("057f"),_=r("7418"),S=r("06cf"),E=r("9bf2"),T=r("d1e7"),O=r("9112"),C=r("6eeb"),j=r("5692"),A=r("f772"),P=r("d012"),R=r("90e3"),F=r("b622"),I=r("e538"),N=r("746f"),D=r("d44e"),L=r("69f3"),M=r("b727").forEach,z=A("hidden"),q="Symbol",V="prototype",G=F("toPrimitive"),$=L.set,B=L.getterFor(q),U=Object[V],W=i.Symbol,H=o("JSON","stringify"),X=S.f,Y=E.f,K=w.f,J=T.f,Q=j("symbols"),Z=j("op-symbols"),tt=j("string-to-symbol-registry"),et=j("symbol-to-string-registry"),rt=j("wks"),nt=i.QObject,it=!nt||!nt[V]||!nt[V].findChild,ot=s&&f((function(){return 7!=b(Y({},"a",{get:function(){return Y(this,"a",{value:7}).a}})).a}))?function(t,e,r){var n=X(U,e);n&&delete U[e],Y(t,e,r),n&&t!==U&&Y(U,e,n)}:Y,at=function(t,e){var r=Q[t]=b(W[V]);return $(r,{type:q,tag:t,description:e}),s||(r.description=e),r},st=u?function(t){return"symbol"==typeof t}:function(t){return Object(t)instanceof W},ct=function(t,e,r){t===U&&ct(Z,e,r),h(t);var n=g(e,!0);return h(r),l(Q,n)?(r.enumerable?(l(t,z)&&t[z][n]&&(t[z][n]=!1),r=b(r,{enumerable:y(0,!1)})):(l(t,z)||Y(t,z,y(1,{})),t[z][n]=!0),ot(t,n,r)):Y(t,n,r)},ut=function(t,e){h(t);var r=m(e),n=x(r).concat(ht(r));return M(n,(function(e){s&&!lt.call(r,e)||ct(t,e,r[e])})),t},ft=function(t,e){return void 0===e?b(t):ut(b(t),e)},lt=function(t){var e=g(t,!0),r=J.call(this,e);return!(this===U&&l(Q,e)&&!l(Z,e))&&(!(r||!l(this,e)||!l(Q,e)||l(this,z)&&this[z][e])||r)},pt=function(t,e){var r=m(t),n=g(e,!0);if(r!==U||!l(Q,n)||l(Z,n)){var i=X(r,n);return!i||!l(Q,n)||l(r,z)&&r[z][n]||(i.enumerable=!0),i}},dt=function(t){var e=K(m(t)),r=[];return M(e,(function(t){l(Q,t)||l(P,t)||r.push(t)})),r},ht=function(t){var e=t===U,r=K(e?Z:m(t)),n=[];return M(r,(function(t){!l(Q,t)||e&&!l(U,t)||n.push(Q[t])})),n};if(c||(W=function(){if(this instanceof W)throw TypeError("Symbol is not a constructor");var t=arguments.length&&void 0!==arguments[0]?String(arguments[0]):void 0,e=R(t),r=function(t){this===U&&r.call(Z,t),l(this,z)&&l(this[z],e)&&(this[z][e]=!1),ot(this,e,y(1,t))};return s&&it&&ot(U,e,{configurable:!0,set:r}),at(e,t)},C(W[V],"toString",(function(){return B(this).tag})),C(W,"withoutSetter",(function(t){return at(R(t),t)})),T.f=lt,E.f=ct,S.f=pt,k.f=w.f=dt,_.f=ht,I.f=function(t){return at(F(t),t)},s&&(Y(W[V],"description",{configurable:!0,get:function(){return B(this).description}}),a||C(U,"propertyIsEnumerable",lt,{unsafe:!0}))),n({global:!0,wrap:!0,forced:!c,sham:!c},{Symbol:W}),M(x(rt),(function(t){N(t)})),n({target:q,stat:!0,forced:!c},{for:function(t){var e=String(t);if(l(tt,e))return tt[e];var r=W(e);return tt[e]=r,et[r]=e,r},keyFor:function(t){if(!st(t))throw TypeError(t+" is not a symbol");if(l(et,t))return et[t]},useSetter:function(){it=!0},useSimple:function(){it=!1}}),n({target:"Object",stat:!0,forced:!c,sham:!s},{create:ft,defineProperty:ct,defineProperties:ut,getOwnPropertyDescriptor:pt}),n({target:"Object",stat:!0,forced:!c},{getOwnPropertyNames:dt,getOwnPropertySymbols:ht}),n({target:"Object",stat:!0,forced:f((function(){_.f(1)}))},{getOwnPropertySymbols:function(t){return _.f(v(t))}}),H){var vt=!c||f((function(){var t=W();return"[null]"!=H([t])||"{}"!=H({a:t})||"{}"!=H(Object(t))}));n({target:"JSON",stat:!0,forced:vt},{stringify:function(t,e,r){var n,i=[t],o=1;while(arguments.length>o)i.push(arguments[o++]);if(n=e,(d(e)||void 0!==t)&&!st(t))return p(e)||(e=function(t,e){if("function"==typeof n&&(e=n.call(this,t,e)),!st(e))return e}),i[1]=e,H.apply(null,i)}})}W[V][G]||O(W[V],G,W[V].valueOf),D(W,q),P[z]=!0},a623:function(t,e,r){"use strict";var n=r("23e7"),i=r("b727").every,o=r("a640"),a=r("ae40"),s=o("every"),c=a("every");n({target:"Array",proto:!0,forced:!s||!c},{every:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},a640:function(t,e,r){"use strict";var n=r("d039");t.exports=function(t,e){var r=[][t];return!!r&&n((function(){r.call(null,e||function(){throw 1},1)}))}},a691:function(t,e){var r=Math.ceil,n=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?n:r)(t)}},a91a:function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".ep-circle--progress__dot-container[data-v-38ca167f]{position:absolute;-webkit-transform-origin:center center;transform-origin:center center}.ep-circle--progress__dot-container.hidden[data-v-38ca167f]{-webkit-transition-duration:0s;-o-transition-duration:0s;transition-duration:0s}.ep-circle--progress__dot-container>div[data-v-38ca167f]{position:relative}.ep-circle--progress__dot[data-v-38ca167f]{-webkit-transition-duration:.2s;-o-transition-duration:.2s;transition-duration:.2s;-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;margin:auto;right:0;left:0}.ep-circle--progress__dot.ep-hidden[data-v-38ca167f]{-webkit-transform:scale(0);transform:scale(0)}",""]),t.exports=e},a9e3:function(t,e,r){"use strict";var n=r("83ab"),i=r("da84"),o=r("94ca"),a=r("6eeb"),s=r("5135"),c=r("c6b6"),u=r("7156"),f=r("c04e"),l=r("d039"),p=r("7c73"),d=r("241c").f,h=r("06cf").f,v=r("9bf2").f,m=r("58a8").trim,g="Number",y=i[g],b=y.prototype,x=c(p(b))==g,k=function(t){var e,r,n,i,o,a,s,c,u=f(t,!1);if("string"==typeof u&&u.length>2)if(u=m(u),e=u.charCodeAt(0),43===e||45===e){if(r=u.charCodeAt(2),88===r||120===r)return NaN}else if(48===e){switch(u.charCodeAt(1)){case 66:case 98:n=2,i=49;break;case 79:case 111:n=8,i=55;break;default:return+u}for(o=u.slice(2),a=o.length,s=0;s<a;s++)if(c=o.charCodeAt(s),c<48||c>i)return NaN;return parseInt(o,n)}return+u};if(o(g,!y(" 0o1")||!y("0b1")||y("+0x1"))){for(var w,_=function(t){var e=arguments.length<1?0:t,r=this;return r instanceof _&&(x?l((function(){b.valueOf.call(r)})):c(r)!=g)?u(new y(k(e)),r,_):k(e)},S=n?d(y):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),E=0;S.length>E;E++)s(y,w=S[E])&&!s(_,w)&&v(_,w,h(y,w));_.prototype=b,b.constructor=_,a(i,g,_)}},ab13:function(t,e,r){var n=r("b622"),i=n("match");t.exports=function(t){var e=/./;try{"/./"[t](e)}catch(r){try{return e[i]=!1,"/./"[t](e)}catch(n){}}return!1}},ac1f:function(t,e,r){"use strict";var n=r("23e7"),i=r("9263");n({target:"RegExp",proto:!0,forced:/./.exec!==i},{exec:i})},ad6d:function(t,e,r){"use strict";var n=r("825a");t.exports=function(){var t=n(this),e="";return t.global&&(e+="g"),t.ignoreCase&&(e+="i"),t.multiline&&(e+="m"),t.dotAll&&(e+="s"),t.unicode&&(e+="u"),t.sticky&&(e+="y"),e}},ae40:function(t,e,r){var n=r("83ab"),i=r("d039"),o=r("5135"),a=Object.defineProperty,s={},c=function(t){throw t};t.exports=function(t,e){if(o(s,t))return s[t];e||(e={});var r=[][t],u=!!o(e,"ACCESSORS")&&e.ACCESSORS,f=o(e,0)?e[0]:c,l=o(e,1)?e[1]:void 0;return s[t]=!!r&&!i((function(){if(u&&!n)return!0;var t={length:-1};u?a(t,1,{enumerable:!0,get:c}):t[1]=1,r.call(t,f,l)}))}},ae93:function(t,e,r){"use strict";var n,i,o,a=r("e163"),s=r("9112"),c=r("5135"),u=r("b622"),f=r("c430"),l=u("iterator"),p=!1,d=function(){return this};[].keys&&(o=[].keys(),"next"in o?(i=a(a(o)),i!==Object.prototype&&(n=i)):p=!0),void 0==n&&(n={}),f||c(n,l)||s(n,l,d),t.exports={IteratorPrototype:n,BUGGY_SAFARI_ITERATORS:p}},b041:function(t,e,r){"use strict";var n=r("00ee"),i=r("f5df");t.exports=n?{}.toString:function(){return"[object "+i(this)+"]"}},b575:function(t,e,r){var n,i,o,a,s,c,u,f,l=r("da84"),p=r("06cf").f,d=r("c6b6"),h=r("2cf4").set,v=r("1cdc"),m=l.MutationObserver||l.WebKitMutationObserver,g=l.process,y=l.Promise,b="process"==d(g),x=p(l,"queueMicrotask"),k=x&&x.value;k||(n=function(){var t,e;b&&(t=g.domain)&&t.exit();while(i){e=i.fn,i=i.next;try{e()}catch(r){throw i?a():o=void 0,r}}o=void 0,t&&t.enter()},b?a=function(){g.nextTick(n)}:m&&!v?(s=!0,c=document.createTextNode(""),new m(n).observe(c,{characterData:!0}),a=function(){c.data=s=!s}):y&&y.resolve?(u=y.resolve(void 0),f=u.then,a=function(){f.call(u,n)}):a=function(){h.call(l,n)}),t.exports=k||function(t){var e={fn:t,next:void 0};o&&(o.next=e),i||(i=e,a()),o=e}},b622:function(t,e,r){var n=r("da84"),i=r("5692"),o=r("5135"),a=r("90e3"),s=r("4930"),c=r("fdbf"),u=i("wks"),f=n.Symbol,l=c?f:f&&f.withoutSetter||a;t.exports=function(t){return o(u,t)||(s&&o(f,t)?u[t]=f[t]:u[t]=l("Symbol."+t)),u[t]}},b64b:function(t,e,r){var n=r("23e7"),i=r("7b0b"),o=r("df75"),a=r("d039"),s=a((function(){o(1)}));n({target:"Object",stat:!0,forced:s},{keys:function(t){return o(i(t))}})},b680:function(t,e,r){"use strict";var n=r("23e7"),i=r("a691"),o=r("408a"),a=r("1148"),s=r("d039"),c=1..toFixed,u=Math.floor,f=function(t,e,r){return 0===e?r:e%2===1?f(t,e-1,r*t):f(t*t,e/2,r)},l=function(t){var e=0,r=t;while(r>=4096)e+=12,r/=4096;while(r>=2)e+=1,r/=2;return e},p=c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!s((function(){c.call({})}));n({target:"Number",proto:!0,forced:p},{toFixed:function(t){var e,r,n,s,c=o(this),p=i(t),d=[0,0,0,0,0,0],h="",v="0",m=function(t,e){var r=-1,n=e;while(++r<6)n+=t*d[r],d[r]=n%1e7,n=u(n/1e7)},g=function(t){var e=6,r=0;while(--e>=0)r+=d[e],d[e]=u(r/t),r=r%t*1e7},y=function(){var t=6,e="";while(--t>=0)if(""!==e||0===t||0!==d[t]){var r=String(d[t]);e=""===e?r:e+a.call("0",7-r.length)+r}return e};if(p<0||p>20)throw RangeError("Incorrect fraction digits");if(c!=c)return"NaN";if(c<=-1e21||c>=1e21)return String(c);if(c<0&&(h="-",c=-c),c>1e-21)if(e=l(c*f(2,69,1))-69,r=e<0?c*f(2,-e,1):c/f(2,e,1),r*=4503599627370496,e=52-e,e>0){m(0,r),n=p;while(n>=7)m(1e7,0),n-=7;m(f(10,n,1),0),n=e-1;while(n>=23)g(1<<23),n-=23;g(1<<n),m(1,1),g(2),v=y()}else m(0,r),m(1<<-e,0),v=y()+a.call("0",p);return p>0?(s=v.length,v=h+(s<=p?"0."+a.call("0",p-s)+v:v.slice(0,s-p)+"."+v.slice(s-p))):v=h+v,v}})},b727:function(t,e,r){var n=r("0366"),i=r("44ad"),o=r("7b0b"),a=r("50c4"),s=r("65f0"),c=[].push,u=function(t){var e=1==t,r=2==t,u=3==t,f=4==t,l=6==t,p=5==t||l;return function(d,h,v,m){for(var g,y,b=o(d),x=i(b),k=n(h,v,3),w=a(x.length),_=0,S=m||s,E=e?S(d,w):r?S(d,0):void 0;w>_;_++)if((p||_ in x)&&(g=x[_],y=k(g,_,b),t))if(e)E[_]=y;else if(y)switch(t){case 3:return!0;case 5:return g;case 6:return _;case 2:c.call(E,g)}else if(f)return!1;return l?-1:u||f?f:E}};t.exports={forEach:u(0),map:u(1),filter:u(2),some:u(3),every:u(4),find:u(5),findIndex:u(6)}},c04e:function(t,e,r){var n=r("861d");t.exports=function(t,e){if(!n(t))return t;var r,i;if(e&&"function"==typeof(r=t.toString)&&!n(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!n(i=r.call(t)))return i;if(!e&&"function"==typeof(r=t.toString)&&!n(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},c430:function(t,e){t.exports=!1},c49e:function(t,e,r){"use strict";var n=r("fec1"),i=r.n(n);i.a},c6b6:function(t,e){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},c6cd:function(t,e,r){var n=r("da84"),i=r("ce4e"),o="__core-js_shared__",a=n[o]||i(o,{});t.exports=a},c8ba:function(t,e){var r;r=function(){return this}();try{r=r||new Function("return this")()}catch(n){"object"===typeof window&&(r=window)}t.exports=r},c8d2:function(t,e,r){var n=r("d039"),i=r("5899"),o="âÂá ";t.exports=function(t){return n((function(){return!!i[t]()||o[t]()!=o||i[t].name!==t}))}},ca84:function(t,e,r){var n=r("5135"),i=r("fc6a"),o=r("4d64").indexOf,a=r("d012");t.exports=function(t,e){var r,s=i(t),c=0,u=[];for(r in s)!n(a,r)&&n(s,r)&&u.push(r);while(e.length>c)n(s,r=e[c++])&&(~o(u,r)||u.push(r));return u}},caad:function(t,e,r){"use strict";var n=r("23e7"),i=r("4d64").includes,o=r("44d2"),a=r("ae40"),s=a("indexOf",{ACCESSORS:!0,1:0});n({target:"Array",proto:!0,forced:!s},{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),o("includes")},cc12:function(t,e,r){var n=r("da84"),i=r("861d"),o=n.document,a=i(o)&&i(o.createElement);t.exports=function(t){return a?o.createElement(t):{}}},cdf9:function(t,e,r){var n=r("825a"),i=r("861d"),o=r("f069");t.exports=function(t,e){if(n(t),i(e)&&e.constructor===t)return e;var r=o.f(t),a=r.resolve;return a(e),r.promise}},ce4e:function(t,e,r){var n=r("da84"),i=r("9112");t.exports=function(t,e){try{i(n,t,e)}catch(r){n[t]=e}return e}},d012:function(t,e){t.exports={}},d039:function(t,e){t.exports=function(t){try{return!!t()}catch(e){return!0}}},d066:function(t,e,r){var n=r("428f"),i=r("da84"),o=function(t){return"function"==typeof t?t:void 0};t.exports=function(t,e){return arguments.length<2?o(n[t])||o(i[t]):n[t]&&n[t][e]||i[t]&&i[t][e]}},d07f:function(t,e,r){var n=r("a91a");"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var i=r("499e").default;i("a2fae2cc",n,!0,{sourceMap:!1,shadowMode:!1})},d1e7:function(t,e,r){"use strict";var n={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,o=i&&!n.call({1:2},1);e.f=o?function(t){var e=i(this,t);return!!e&&e.enumerable}:n},d28b:function(t,e,r){var n=r("746f");n("iterator")},d2bb:function(t,e,r){var n=r("825a"),i=r("3bbe");t.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var t,e=!1,r={};try{t=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set,t.call(r,[]),e=r instanceof Array}catch(o){}return function(r,o){return n(r),i(o),e?t.call(r,o):r.__proto__=o,r}}():void 0)},d30c:function(t,e,r){var n=r("d5a4");"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var i=r("499e").default;i("3d0aec29",n,!0,{sourceMap:!1,shadowMode:!1})},d3b7:function(t,e,r){var n=r("00ee"),i=r("6eeb"),o=r("b041");n||i(Object.prototype,"toString",o,{unsafe:!0})},d44e:function(t,e,r){var n=r("9bf2").f,i=r("5135"),o=r("b622"),a=o("toStringTag");t.exports=function(t,e,r){t&&!i(t=r?t:t.prototype,a)&&n(t,a,{configurable:!0,value:e})}},d58f:function(t,e,r){var n=r("1c0b"),i=r("7b0b"),o=r("44ad"),a=r("50c4"),s=function(t){return function(e,r,s,c){n(r);var u=i(e),f=o(u),l=a(u.length),p=t?l-1:0,d=t?-1:1;if(s<2)while(1){if(p in f){c=f[p],p+=d;break}if(p+=d,t?p<0:l<=p)throw TypeError("Reduce of empty array with no initial value")}for(;t?p>=0:l>p;p+=d)p in f&&(c=r(c,f[p],p,u));return c}};t.exports={left:s(!1),right:s(!0)}},d5a4:function(t,e,r){var n=r("24fb");e=n(!1),e.push([t.i,".ep-circle[data-v-7d0a0fbb]{-webkit-transform-origin:50% 50%;transform-origin:50% 50%}",""]),t.exports=e},d784:function(t,e,r){"use strict";r("ac1f");var n=r("6eeb"),i=r("d039"),o=r("b622"),a=r("9263"),s=r("9112"),c=o("species"),u=!i((function(){var t=/./;return t.exec=function(){var t=[];return t.groups={a:"7"},t},"7"!=="".replace(t,"$<a>")})),f=function(){return"$0"==="a".replace(/./,"$0")}(),l=o("replace"),p=function(){return!!/./[l]&&""===/./[l]("a","$0")}(),d=!i((function(){var t=/(?:)/,e=t.exec;t.exec=function(){return e.apply(this,arguments)};var r="ab".split(t);return 2!==r.length||"a"!==r[0]||"b"!==r[1]}));t.exports=function(t,e,r,l){var h=o(t),v=!i((function(){var e={};return e[h]=function(){return 7},7!=""[t](e)})),m=v&&!i((function(){var e=!1,r=/a/;return"split"===t&&(r={},r.constructor={},r.constructor[c]=function(){return r},r.flags="",r[h]=/./[h]),r.exec=function(){return e=!0,null},r[h](""),!e}));if(!v||!m||"replace"===t&&(!u||!f||p)||"split"===t&&!d){var g=/./[h],y=r(h,""[t],(function(t,e,r,n,i){return e.exec===a?v&&!i?{done:!0,value:g.call(e,r,n)}:{done:!0,value:t.call(r,e,n)}:{done:!1}}),{REPLACE_KEEPS_$0:f,REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE:p}),b=y[0],x=y[1];n(String.prototype,t,b),n(RegExp.prototype,h,2==e?function(t,e){return x.call(t,this,e)}:function(t){return x.call(t,this)})}l&&s(RegExp.prototype[h],"sham",!0)}},d81d:function(t,e,r){"use strict";var n=r("23e7"),i=r("b727").map,o=r("1dde"),a=r("ae40"),s=o("map"),c=a("map");n({target:"Array",proto:!0,forced:!s||!c},{map:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},da84:function(t,e,r){(function(e){var r=function(t){return t&&t.Math==Math&&t};t.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof e&&e)||Function("return this")()}).call(this,r("c8ba"))},dbb4:function(t,e,r){var n=r("23e7"),i=r("83ab"),o=r("56ef"),a=r("fc6a"),s=r("06cf"),c=r("8418");n({target:"Object",stat:!0,sham:!i},{getOwnPropertyDescriptors:function(t){var e,r,n=a(t),i=s.f,u=o(n),f={},l=0;while(u.length>l)r=i(n,e=u[l++]),void 0!==r&&c(f,e,r);return f}})},ddb0:function(t,e,r){var n=r("da84"),i=r("fdbc"),o=r("e260"),a=r("9112"),s=r("b622"),c=s("iterator"),u=s("toStringTag"),f=o.values;for(var l in i){var p=n[l],d=p&&p.prototype;if(d){if(d[c]!==f)try{a(d,c,f)}catch(v){d[c]=f}if(d[u]||a(d,u,l),i[l])for(var h in o)if(d[h]!==o[h])try{a(d,h,o[h])}catch(v){d[h]=o[h]}}}},df75:function(t,e,r){var n=r("ca84"),i=r("7839");t.exports=Object.keys||function(t){return n(t,i)}},e01a:function(t,e,r){"use strict";var n=r("23e7"),i=r("83ab"),o=r("da84"),a=r("5135"),s=r("861d"),c=r("9bf2").f,u=r("e893"),f=o.Symbol;if(i&&"function"==typeof f&&(!("description"in f.prototype)||void 0!==f().description)){var l={},p=function(){var t=arguments.length<1||void 0===arguments[0]?void 0:String(arguments[0]),e=this instanceof p?new f(t):void 0===t?f():f(t);return""===t&&(l[e]=!0),e};u(p,f);var d=p.prototype=f.prototype;d.constructor=p;var h=d.toString,v="Symbol(test)"==String(f("test")),m=/^Symbol\((.*)\)[^)]+$/;c(d,"description",{configurable:!0,get:function(){var t=s(this)?this.valueOf():this,e=h.call(t);if(a(l,t))return"";var r=v?e.slice(7,-1):e.replace(m,"$1");return""===r?void 0:r}}),n({global:!0,forced:!0},{Symbol:p})}},e163:function(t,e,r){var n=r("5135"),i=r("7b0b"),o=r("f772"),a=r("e177"),s=o("IE_PROTO"),c=Object.prototype;t.exports=a?Object.getPrototypeOf:function(t){return t=i(t),n(t,s)?t[s]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?c:null}},e177:function(t,e,r){var n=r("d039");t.exports=!n((function(){function t(){}return t.prototype.constructor=null,Object.getPrototypeOf(new t)!==t.prototype}))},e260:function(t,e,r){"use strict";var n=r("fc6a"),i=r("44d2"),o=r("3f8c"),a=r("69f3"),s=r("7dd0"),c="Array Iterator",u=a.set,f=a.getterFor(c);t.exports=s(Array,"Array",(function(t,e){u(this,{type:c,target:n(t),index:0,kind:e})}),(function(){var t=f(this),e=t.target,r=t.kind,n=t.index++;return!e||n>=e.length?(t.target=void 0,{value:void 0,done:!0}):"keys"==r?{value:n,done:!1}:"values"==r?{value:e[n],done:!1}:{value:[n,e[n]],done:!1}}),"values"),o.Arguments=o.Array,i("keys"),i("values"),i("entries")},e2cc:function(t,e,r){var n=r("6eeb");t.exports=function(t,e,r){for(var i in e)n(t,i,e[i],r);return t}},e439:function(t,e,r){var n=r("23e7"),i=r("d039"),o=r("fc6a"),a=r("06cf").f,s=r("83ab"),c=i((function(){a(1)})),u=!s||c;n({target:"Object",stat:!0,forced:u,sham:!s},{getOwnPropertyDescriptor:function(t,e){return a(o(t),e)}})},e538:function(t,e,r){var n=r("b622");e.f=n},e667:function(t,e){t.exports=function(t){try{return{error:!1,value:t()}}catch(e){return{error:!0,value:e}}}},e6cf:function(t,e,r){"use strict";var n,i,o,a,s=r("23e7"),c=r("c430"),u=r("da84"),f=r("d066"),l=r("fea9"),p=r("6eeb"),d=r("e2cc"),h=r("d44e"),v=r("2626"),m=r("861d"),g=r("1c0b"),y=r("19aa"),b=r("c6b6"),x=r("8925"),k=r("2266"),w=r("1c7e"),_=r("4840"),S=r("2cf4").set,E=r("b575"),T=r("cdf9"),O=r("44de"),C=r("f069"),j=r("e667"),A=r("69f3"),P=r("94ca"),R=r("b622"),F=r("2d00"),I=R("species"),N="Promise",D=A.get,L=A.set,M=A.getterFor(N),z=l,q=u.TypeError,V=u.document,G=u.process,$=f("fetch"),B=C.f,U=B,W="process"==b(G),H=!!(V&&V.createEvent&&u.dispatchEvent),X="unhandledrejection",Y="rejectionhandled",K=0,J=1,Q=2,Z=1,tt=2,et=P(N,(function(){var t=x(z)!==String(z);if(!t){if(66===F)return!0;if(!W&&"function"!=typeof PromiseRejectionEvent)return!0}if(c&&!z.prototype["finally"])return!0;if(F>=51&&/native code/.test(z))return!1;var e=z.resolve(1),r=function(t){t((function(){}),(function(){}))},n=e.constructor={};return n[I]=r,!(e.then((function(){}))instanceof r)})),rt=et||!w((function(t){z.all(t)["catch"]((function(){}))})),nt=function(t){var e;return!(!m(t)||"function"!=typeof(e=t.then))&&e},it=function(t,e,r){if(!e.notified){e.notified=!0;var n=e.reactions;E((function(){var i=e.value,o=e.state==J,a=0;while(n.length>a){var s,c,u,f=n[a++],l=o?f.ok:f.fail,p=f.resolve,d=f.reject,h=f.domain;try{l?(o||(e.rejection===tt&&ct(t,e),e.rejection=Z),!0===l?s=i:(h&&h.enter(),s=l(i),h&&(h.exit(),u=!0)),s===f.promise?d(q("Promise-chain cycle")):(c=nt(s))?c.call(s,p,d):p(s)):d(i)}catch(v){h&&!u&&h.exit(),d(v)}}e.reactions=[],e.notified=!1,r&&!e.rejection&&at(t,e)}))}},ot=function(t,e,r){var n,i;H?(n=V.createEvent("Event"),n.promise=e,n.reason=r,n.initEvent(t,!1,!0),u.dispatchEvent(n)):n={promise:e,reason:r},(i=u["on"+t])?i(n):t===X&&O("Unhandled promise rejection",r)},at=function(t,e){S.call(u,(function(){var r,n=e.value,i=st(e);if(i&&(r=j((function(){W?G.emit("unhandledRejection",n,t):ot(X,t,n)})),e.rejection=W||st(e)?tt:Z,r.error))throw r.value}))},st=function(t){return t.rejection!==Z&&!t.parent},ct=function(t,e){S.call(u,(function(){W?G.emit("rejectionHandled",t):ot(Y,t,e.value)}))},ut=function(t,e,r,n){return function(i){t(e,r,i,n)}},ft=function(t,e,r,n){e.done||(e.done=!0,n&&(e=n),e.value=r,e.state=Q,it(t,e,!0))},lt=function(t,e,r,n){if(!e.done){e.done=!0,n&&(e=n);try{if(t===r)throw q("Promise can't be resolved itself");var i=nt(r);i?E((function(){var n={done:!1};try{i.call(r,ut(lt,t,n,e),ut(ft,t,n,e))}catch(o){ft(t,n,o,e)}})):(e.value=r,e.state=J,it(t,e,!1))}catch(o){ft(t,{done:!1},o,e)}}};et&&(z=function(t){y(this,z,N),g(t),n.call(this);var e=D(this);try{t(ut(lt,this,e),ut(ft,this,e))}catch(r){ft(this,e,r)}},n=function(t){L(this,{type:N,done:!1,notified:!1,parent:!1,reactions:[],rejection:!1,state:K,value:void 0})},n.prototype=d(z.prototype,{then:function(t,e){var r=M(this),n=B(_(this,z));return n.ok="function"!=typeof t||t,n.fail="function"==typeof e&&e,n.domain=W?G.domain:void 0,r.parent=!0,r.reactions.push(n),r.state!=K&&it(this,r,!1),n.promise},catch:function(t){return this.then(void 0,t)}}),i=function(){var t=new n,e=D(t);this.promise=t,this.resolve=ut(lt,t,e),this.reject=ut(ft,t,e)},C.f=B=function(t){return t===z||t===o?new i(t):U(t)},c||"function"!=typeof l||(a=l.prototype.then,p(l.prototype,"then",(function(t,e){var r=this;return new z((function(t,e){a.call(r,t,e)})).then(t,e)}),{unsafe:!0}),"function"==typeof $&&s({global:!0,enumerable:!0,forced:!0},{fetch:function(t){return T(z,$.apply(u,arguments))}}))),s({global:!0,wrap:!0,forced:et},{Promise:z}),h(z,N,!1,!0),v(N),o=f(N),s({target:N,stat:!0,forced:et},{reject:function(t){var e=B(this);return e.reject.call(void 0,t),e.promise}}),s({target:N,stat:!0,forced:c||et},{resolve:function(t){return T(c&&this===o?z:this,t)}}),s({target:N,stat:!0,forced:rt},{all:function(t){var e=this,r=B(e),n=r.resolve,i=r.reject,o=j((function(){var r=g(e.resolve),o=[],a=0,s=1;k(t,(function(t){var c=a++,u=!1;o.push(void 0),s++,r.call(e,t).then((function(t){u||(u=!0,o[c]=t,--s||n(o))}),i)})),--s||n(o)}));return o.error&&i(o.value),r.promise},race:function(t){var e=this,r=B(e),n=r.reject,i=j((function(){var i=g(e.resolve);k(t,(function(t){i.call(e,t).then(r.resolve,n)}))}));return i.error&&n(i.value),r.promise}})},e893:function(t,e,r){var n=r("5135"),i=r("56ef"),o=r("06cf"),a=r("9bf2");t.exports=function(t,e){for(var r=i(e),s=a.f,c=o.f,u=0;u<r.length;u++){var f=r[u];n(t,f)||s(t,f,c(e,f))}}},e8b5:function(t,e,r){var n=r("c6b6");t.exports=Array.isArray||function(t){return"Array"==n(t)}},e95a:function(t,e,r){var n=r("b622"),i=r("3f8c"),o=n("iterator"),a=Array.prototype;t.exports=function(t){return void 0!==t&&(i.Array===t||a[o]===t)}},f069:function(t,e,r){"use strict";var n=r("1c0b"),i=function(t){var e,r;this.promise=new t((function(t,n){if(void 0!==e||void 0!==r)throw TypeError("Bad Promise constructor");e=t,r=n})),this.resolve=n(e),this.reject=n(r)};t.exports.f=function(t){return new i(t)}},f5df:function(t,e,r){var n=r("00ee"),i=r("c6b6"),o=r("b622"),a=o("toStringTag"),s="Arguments"==i(function(){return arguments}()),c=function(t,e){try{return t[e]}catch(r){}};t.exports=n?i:function(t){var e,r,n;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=c(e=Object(t),a))?r:s?i(e):"Object"==(n=i(e))&&"function"==typeof e.callee?"Arguments":n}},f772:function(t,e,r){var n=r("5692"),i=r("90e3"),o=n("keys");t.exports=function(t){return o[t]||(o[t]=i(t))}},fb15:function(t,e,r){"use strict";if(r.r(e),"undefined"!==typeof window){var n=window.document.currentScript,i=r("8875");n=i(),"currentScript"in document||Object.defineProperty(document,"currentScript",{get:i});var o=n&&n.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);o&&(r.p=o[1])}var a=r("fe83");e["default"]=a["a"]},fc6a:function(t,e,r){var n=r("44ad"),i=r("1d80");t.exports=function(t){return n(i(t))}},fdbc:function(t,e){t.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},fdbf:function(t,e,r){var n=r("4930");t.exports=n&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},fe83:function(t,e,r){"use strict";(function(t){var n=r("28ab"),i=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"vue-ellipse-progress";return t.component(e,n["a"])},o=null;"undefined"!==typeof window?o=window.Vue:"undefined"!==typeof t&&(o=t.Vue),o&&o.use({install:i}),e["a"]={install:i}}).call(this,r("c8ba"))},fea9:function(t,e,r){var n=r("da84");t.exports=n.Promise},fec1:function(t,e,r){var n=r("02d4");"string"===typeof n&&(n=[[t.i,n,""]]),n.locals&&(t.exports=n.locals);var i=r("499e").default;i("ec09b49c",n,!0,{sourceMap:!1,shadowMode:!1})}})}));

/***/ }),

/***/ "./node_modules/vue-phone-number-input/dist/vue-phone-number-input.common.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/vue-phone-number-input/dist/vue-phone-number-input.common.js ***!
  \***********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_187__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_187__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_187__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_187__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_187__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_187__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_187__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_187__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_187__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_187__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_187__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_187__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_187__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_187__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_187__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_187__(__nested_webpack_require_187__.s = "fb15");
/******/ })
/************************************************************************/
/******/ ({

/***/ "014b":
/***/ (function(module, exports, __nested_webpack_require_3663__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __nested_webpack_require_3663__("e53d");
var has = __nested_webpack_require_3663__("07e3");
var DESCRIPTORS = __nested_webpack_require_3663__("8e60");
var $export = __nested_webpack_require_3663__("63b6");
var redefine = __nested_webpack_require_3663__("9138");
var META = __nested_webpack_require_3663__("ebfd").KEY;
var $fails = __nested_webpack_require_3663__("294c");
var shared = __nested_webpack_require_3663__("dbdb");
var setToStringTag = __nested_webpack_require_3663__("45f2");
var uid = __nested_webpack_require_3663__("62a0");
var wks = __nested_webpack_require_3663__("5168");
var wksExt = __nested_webpack_require_3663__("ccb9");
var wksDefine = __nested_webpack_require_3663__("6718");
var enumKeys = __nested_webpack_require_3663__("47ee");
var isArray = __nested_webpack_require_3663__("9003");
var anObject = __nested_webpack_require_3663__("e4ae");
var isObject = __nested_webpack_require_3663__("f772");
var toObject = __nested_webpack_require_3663__("241e");
var toIObject = __nested_webpack_require_3663__("36c3");
var toPrimitive = __nested_webpack_require_3663__("1bc3");
var createDesc = __nested_webpack_require_3663__("aebd");
var _create = __nested_webpack_require_3663__("a159");
var gOPNExt = __nested_webpack_require_3663__("0395");
var $GOPD = __nested_webpack_require_3663__("bf0b");
var $GOPS = __nested_webpack_require_3663__("9aa9");
var $DP = __nested_webpack_require_3663__("d9f6");
var $keys = __nested_webpack_require_3663__("c3a1");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __nested_webpack_require_3663__("6abf").f = gOPNExt.f = $getOwnPropertyNames;
  __nested_webpack_require_3663__("355d").f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__nested_webpack_require_3663__("b8e3")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __nested_webpack_require_3663__("35e8")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "01f9":
/***/ (function(module, exports, __nested_webpack_require_13165__) {

"use strict";

var LIBRARY = __nested_webpack_require_13165__("2d00");
var $export = __nested_webpack_require_13165__("5ca1");
var redefine = __nested_webpack_require_13165__("2aba");
var hide = __nested_webpack_require_13165__("32e9");
var Iterators = __nested_webpack_require_13165__("84f2");
var $iterCreate = __nested_webpack_require_13165__("41a0");
var setToStringTag = __nested_webpack_require_13165__("7f20");
var getPrototypeOf = __nested_webpack_require_13165__("38fd");
var ITERATOR = __nested_webpack_require_13165__("2b4c")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "0395":
/***/ (function(module, exports, __nested_webpack_require_16071__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __nested_webpack_require_16071__("36c3");
var gOPN = __nested_webpack_require_16071__("6abf").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "07e3":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "0a49":
/***/ (function(module, exports, __nested_webpack_require_16947__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __nested_webpack_require_16947__("9b43");
var IObject = __nested_webpack_require_16947__("626a");
var toObject = __nested_webpack_require_16947__("4bf8");
var toLength = __nested_webpack_require_16947__("9def");
var asc = __nested_webpack_require_16947__("cd1c");
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),

/***/ "0bfb":
/***/ (function(module, exports, __nested_webpack_require_18542__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __nested_webpack_require_18542__("cb7c");
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "0d58":
/***/ (function(module, exports, __nested_webpack_require_19001__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __nested_webpack_require_19001__("ce10");
var enumBugKeys = __nested_webpack_require_19001__("e11e");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "0fc9":
/***/ (function(module, exports, __nested_webpack_require_19300__) {

var toInteger = __nested_webpack_require_19300__("3a38");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "1169":
/***/ (function(module, exports, __nested_webpack_require_19610__) {

// 7.2.2 IsArray(argument)
var cof = __nested_webpack_require_19610__("2d95");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "1173":
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ "11e9":
/***/ (function(module, exports, __nested_webpack_require_20151__) {

var pIE = __nested_webpack_require_20151__("52a7");
var createDesc = __nested_webpack_require_20151__("4630");
var toIObject = __nested_webpack_require_20151__("6821");
var toPrimitive = __nested_webpack_require_20151__("6a99");
var has = __nested_webpack_require_20151__("69a8");
var IE8_DOM_DEFINE = __nested_webpack_require_20151__("c69a");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __nested_webpack_require_20151__("9e1e") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "1495":
/***/ (function(module, exports, __nested_webpack_require_20830__) {

var dP = __nested_webpack_require_20830__("86cc");
var anObject = __nested_webpack_require_20830__("cb7c");
var getKeys = __nested_webpack_require_20830__("0d58");

module.exports = __nested_webpack_require_20830__("9e1e") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "1654":
/***/ (function(module, exports, __nested_webpack_require_21330__) {

"use strict";

var $at = __nested_webpack_require_21330__("71c1")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__nested_webpack_require_21330__("30f1")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "1691":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "1af6":
/***/ (function(module, exports, __nested_webpack_require_22175__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __nested_webpack_require_22175__("63b6");

$export($export.S, 'Array', { isArray: __nested_webpack_require_22175__("9003") });


/***/ }),

/***/ "1bc3":
/***/ (function(module, exports, __nested_webpack_require_22416__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __nested_webpack_require_22416__("f772");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "1ec9":
/***/ (function(module, exports, __nested_webpack_require_23159__) {

var isObject = __nested_webpack_require_23159__("f772");
var document = __nested_webpack_require_23159__("e53d").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "20d6":
/***/ (function(module, exports, __nested_webpack_require_23543__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __nested_webpack_require_23543__("5ca1");
var $find = __nested_webpack_require_23543__("0a49")(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__nested_webpack_require_23543__("9c6c")(KEY);


/***/ }),

/***/ "20fd":
/***/ (function(module, exports, __nested_webpack_require_24177__) {

"use strict";

var $defineProperty = __nested_webpack_require_24177__("d9f6");
var createDesc = __nested_webpack_require_24177__("aebd");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "230e":
/***/ (function(module, exports, __nested_webpack_require_24537__) {

var isObject = __nested_webpack_require_24537__("d3f4");
var document = __nested_webpack_require_24537__("7726").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "241e":
/***/ (function(module, exports, __nested_webpack_require_24921__) {

// 7.1.13 ToObject(argument)
var defined = __nested_webpack_require_24921__("25eb");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "24c5":
/***/ (function(module, exports, __nested_webpack_require_25143__) {

"use strict";

var LIBRARY = __nested_webpack_require_25143__("b8e3");
var global = __nested_webpack_require_25143__("e53d");
var ctx = __nested_webpack_require_25143__("d864");
var classof = __nested_webpack_require_25143__("40c3");
var $export = __nested_webpack_require_25143__("63b6");
var isObject = __nested_webpack_require_25143__("f772");
var aFunction = __nested_webpack_require_25143__("79aa");
var anInstance = __nested_webpack_require_25143__("1173");
var forOf = __nested_webpack_require_25143__("a22a");
var speciesConstructor = __nested_webpack_require_25143__("f201");
var task = __nested_webpack_require_25143__("4178").set;
var microtask = __nested_webpack_require_25143__("aba2")();
var newPromiseCapabilityModule = __nested_webpack_require_25143__("656e");
var perform = __nested_webpack_require_25143__("4439");
var userAgent = __nested_webpack_require_25143__("bc13");
var promiseResolve = __nested_webpack_require_25143__("cd78");
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__nested_webpack_require_25143__("5168")('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __nested_webpack_require_25143__("5c95")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__nested_webpack_require_25143__("45f2")($Promise, PROMISE);
__nested_webpack_require_25143__("4c95")(PROMISE);
Wrapper = __nested_webpack_require_25143__("584a")[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __nested_webpack_require_25143__("4ee1")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),

/***/ "252c":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_35129__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* unused harmony export install */
/* harmony export (binding) */ __nested_webpack_require_35129__.d(__webpack_exports__, "a", function() { return ResizeObserver; });
function getInternetExplorerVersion() {
	var ua = window.navigator.userAgent;

	var msie = ua.indexOf('MSIE ');
	if (msie > 0) {
		// IE 10 or older => return version number
		return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
	}

	var trident = ua.indexOf('Trident/');
	if (trident > 0) {
		// IE 11 => return version number
		var rv = ua.indexOf('rv:');
		return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
	}

	var edge = ua.indexOf('Edge/');
	if (edge > 0) {
		// Edge (IE 12+) => return version number
		return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
	}

	// other browser
	return -1;
}

var isIE = void 0;

function initCompat() {
	if (!initCompat.init) {
		initCompat.init = true;
		isIE = getInternetExplorerVersion() !== -1;
	}
}

var ResizeObserver = { render: function render() {
		var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "resize-observer", attrs: { "tabindex": "-1" } });
	}, staticRenderFns: [], _scopeId: 'data-v-b329ee4c',
	name: 'resize-observer',

	methods: {
		compareAndNotify: function compareAndNotify() {
			if (this._w !== this.$el.offsetWidth || this._h !== this.$el.offsetHeight) {
				this._w = this.$el.offsetWidth;
				this._h = this.$el.offsetHeight;
				this.$emit('notify');
			}
		},
		addResizeHandlers: function addResizeHandlers() {
			this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify);
			this.compareAndNotify();
		},
		removeResizeHandlers: function removeResizeHandlers() {
			if (this._resizeObject && this._resizeObject.onload) {
				if (!isIE && this._resizeObject.contentDocument) {
					this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify);
				}
				delete this._resizeObject.onload;
			}
		}
	},

	mounted: function mounted() {
		var _this = this;

		initCompat();
		this.$nextTick(function () {
			_this._w = _this.$el.offsetWidth;
			_this._h = _this.$el.offsetHeight;
		});
		var object = document.createElement('object');
		this._resizeObject = object;
		object.setAttribute('aria-hidden', 'true');
		object.setAttribute('tabindex', -1);
		object.onload = this.addResizeHandlers;
		object.type = 'text/html';
		if (isIE) {
			this.$el.appendChild(object);
		}
		object.data = 'about:blank';
		if (!isIE) {
			this.$el.appendChild(object);
		}
	},
	beforeDestroy: function beforeDestroy() {
		this.removeResizeHandlers();
	}
};

// Install the components
function install(Vue) {
	Vue.component('resize-observer', ResizeObserver);
	Vue.component('ResizeObserver', ResizeObserver);
}

// Plugin
var plugin = {
	// eslint-disable-next-line no-undef
	version: "0.4.5",
	install: install
};

// Auto-install
var GlobalVue = null;
if (typeof window !== 'undefined') {
	GlobalVue = window.Vue;
} else if (typeof global !== 'undefined') {
	GlobalVue = global.Vue;
}
if (GlobalVue) {
	GlobalVue.use(plugin);
}


/* unused harmony default export */ var _unused_webpack_default_export = (plugin);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_35129__("c8ba")))

/***/ }),

/***/ "25eb":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "2621":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "294c":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "2aba":
/***/ (function(module, exports, __nested_webpack_require_39038__) {

var global = __nested_webpack_require_39038__("7726");
var hide = __nested_webpack_require_39038__("32e9");
var has = __nested_webpack_require_39038__("69a8");
var SRC = __nested_webpack_require_39038__("ca5a")('src');
var $toString = __nested_webpack_require_39038__("fa5b");
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__nested_webpack_require_39038__("8378").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),

/***/ "2aeb":
/***/ (function(module, exports, __nested_webpack_require_40212__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __nested_webpack_require_40212__("cb7c");
var dPs = __nested_webpack_require_40212__("1495");
var enumBugKeys = __nested_webpack_require_40212__("e11e");
var IE_PROTO = __nested_webpack_require_40212__("613b")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __nested_webpack_require_40212__("230e")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __nested_webpack_require_40212__("fab2").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "2b4c":
/***/ (function(module, exports, __nested_webpack_require_41823__) {

var store = __nested_webpack_require_41823__("5537")('wks');
var uid = __nested_webpack_require_41823__("ca5a");
var Symbol = __nested_webpack_require_41823__("7726").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "2d00":
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "2d95":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "2fdb":
/***/ (function(module, exports, __nested_webpack_require_42545__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __nested_webpack_require_42545__("5ca1");
var context = __nested_webpack_require_42545__("d2c8");
var INCLUDES = 'includes';

$export($export.P + $export.F * __nested_webpack_require_42545__("5147")(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "3024":
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),

/***/ "30f1":
/***/ (function(module, exports, __nested_webpack_require_43877__) {

"use strict";

var LIBRARY = __nested_webpack_require_43877__("b8e3");
var $export = __nested_webpack_require_43877__("63b6");
var redefine = __nested_webpack_require_43877__("9138");
var hide = __nested_webpack_require_43877__("35e8");
var Iterators = __nested_webpack_require_43877__("481b");
var $iterCreate = __nested_webpack_require_43877__("8f60");
var setToStringTag = __nested_webpack_require_43877__("45f2");
var getPrototypeOf = __nested_webpack_require_43877__("53e2");
var ITERATOR = __nested_webpack_require_43877__("5168")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "32e9":
/***/ (function(module, exports, __nested_webpack_require_46783__) {

var dP = __nested_webpack_require_46783__("86cc");
var createDesc = __nested_webpack_require_46783__("4630");
module.exports = __nested_webpack_require_46783__("9e1e") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "32fc":
/***/ (function(module, exports, __nested_webpack_require_47159__) {

var document = __nested_webpack_require_47159__("e53d").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "3314":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_47363__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_46e105de_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_47363__("8f82");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_46e105de_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_47363__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_46e105de_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */
 /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_46e105de_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "335c":
/***/ (function(module, exports, __nested_webpack_require_49648__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __nested_webpack_require_49648__("6b4c");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "355d":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "35e8":
/***/ (function(module, exports, __nested_webpack_require_50131__) {

var dP = __nested_webpack_require_50131__("d9f6");
var createDesc = __nested_webpack_require_50131__("aebd");
module.exports = __nested_webpack_require_50131__("8e60") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "36c3":
/***/ (function(module, exports, __nested_webpack_require_50507__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __nested_webpack_require_50507__("335c");
var defined = __nested_webpack_require_50507__("25eb");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "3702":
/***/ (function(module, exports, __nested_webpack_require_50820__) {

// check on default Array iterator
var Iterators = __nested_webpack_require_50820__("481b");
var ITERATOR = __nested_webpack_require_50820__("5168")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "3846":
/***/ (function(module, exports, __nested_webpack_require_51197__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__nested_webpack_require_51197__("9e1e") && /./g.flags != 'g') __nested_webpack_require_51197__("86cc").f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __nested_webpack_require_51197__("0bfb")
});


/***/ }),

/***/ "38fd":
/***/ (function(module, exports, __nested_webpack_require_51496__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __nested_webpack_require_51496__("69a8");
var toObject = __nested_webpack_require_51496__("4bf8");
var IE_PROTO = __nested_webpack_require_51496__("613b")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "3a38":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "3c11":
/***/ (function(module, exports, __nested_webpack_require_52314__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __nested_webpack_require_52314__("63b6");
var core = __nested_webpack_require_52314__("584a");
var global = __nested_webpack_require_52314__("e53d");
var speciesConstructor = __nested_webpack_require_52314__("f201");
var promiseResolve = __nested_webpack_require_52314__("cd78");

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),

/***/ "40c3":
/***/ (function(module, exports, __nested_webpack_require_53177__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __nested_webpack_require_53177__("6b4c");
var TAG = __nested_webpack_require_53177__("5168")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "4178":
/***/ (function(module, exports, __nested_webpack_require_53999__) {

var ctx = __nested_webpack_require_53999__("d864");
var invoke = __nested_webpack_require_53999__("3024");
var html = __nested_webpack_require_53999__("32fc");
var cel = __nested_webpack_require_53999__("1ec9");
var global = __nested_webpack_require_53999__("e53d");
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__nested_webpack_require_53999__("6b4c")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),

/***/ "41a0":
/***/ (function(module, exports, __nested_webpack_require_56613__) {

"use strict";

var create = __nested_webpack_require_56613__("2aeb");
var descriptor = __nested_webpack_require_56613__("4630");
var setToStringTag = __nested_webpack_require_56613__("7f20");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__nested_webpack_require_56613__("32e9")(IteratorPrototype, __nested_webpack_require_56613__("2b4c")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "43fc":
/***/ (function(module, exports, __nested_webpack_require_57239__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __nested_webpack_require_57239__("63b6");
var newPromiseCapability = __nested_webpack_require_57239__("656e");
var perform = __nested_webpack_require_57239__("4439");

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),

/***/ "4439":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),

/***/ "454f":
/***/ (function(module, exports, __nested_webpack_require_58000__) {

__nested_webpack_require_58000__("46a7");
var $Object = __nested_webpack_require_58000__("584a").Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),

/***/ "456d":
/***/ (function(module, exports, __nested_webpack_require_58272__) {

// 19.1.2.14 Object.keys(O)
var toObject = __nested_webpack_require_58272__("4bf8");
var $keys = __nested_webpack_require_58272__("0d58");

__nested_webpack_require_58272__("5eda")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ "4588":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "45f2":
/***/ (function(module, exports, __nested_webpack_require_58814__) {

var def = __nested_webpack_require_58814__("d9f6").f;
var has = __nested_webpack_require_58814__("07e3");
var TAG = __nested_webpack_require_58814__("5168")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "4630":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "46a7":
/***/ (function(module, exports, __nested_webpack_require_59420__) {

var $export = __nested_webpack_require_59420__("63b6");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__nested_webpack_require_59420__("8e60"), 'Object', { defineProperty: __nested_webpack_require_59420__("d9f6").f });


/***/ }),

/***/ "47ee":
/***/ (function(module, exports, __nested_webpack_require_59734__) {

// all enumerable object keys, includes symbols
var getKeys = __nested_webpack_require_59734__("c3a1");
var gOPS = __nested_webpack_require_59734__("9aa9");
var pIE = __nested_webpack_require_59734__("355d");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "481b":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "4883":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:!0}),exports.colorNameToHex=exports.isColorName=exports.HexToRgba=exports.ShadeColor=void 0;var ShadeColor=function(e,f){var a=parseInt(e.substring(1,3),16),r=parseInt(e.substring(3,5),16),o=parseInt(e.substring(5,7),16);return a=parseInt(a*(100+f)/100),r=parseInt(r*(100+f)/100),o=parseInt(o*(100+f)/100),a=a<255?a:255,r=r<255?r:255,o=o<255?o:255,"#"+(1===a.toString(16).length?"0"+a.toString(16):a.toString(16))+(1===r.toString(16).length?"0"+r.toString(16):r.toString(16))+(1===o.toString(16).length?"0"+o.toString(16):o.toString(16))};exports.ShadeColor=ShadeColor;var HexToRgba=function(e,f){var a;if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(e))return 3===(a=e.substring(1).split("")).length&&(a=[a[0],a[0],a[1],a[1],a[2],a[2]]),a="0x".concat(a.join("")),"rgba(".concat([a>>16&255,a>>8&255,255&a].join(", "),", ").concat(f,")");throw new Error("Bad Hex")};exports.HexToRgba=HexToRgba;var isColorName=function(e){if(!e)throw new Error("isColorName: No color");return!e.includes("#")};exports.isColorName=isColorName;var colorNameToHex=function(e){if(!e)throw new Error("colorNameToHex: No color");var f={aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",gray:"#808080",green:"#008000",greenyellow:"#adff2f",honeydew:"#f0fff0",hotpink:"#ff69b4","indianred ":"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgrey:"#d3d3d3",lightgreen:"#90ee90",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370d8",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#d87093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",rebeccapurple:"#663399",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32"};return void 0!==f[e.toLowerCase()]&&f[e.toLowerCase()]};exports.colorNameToHex=colorNameToHex;

/***/ }),

/***/ "4bf8":
/***/ (function(module, exports, __nested_webpack_require_64532__) {

// 7.1.13 ToObject(argument)
var defined = __nested_webpack_require_64532__("be13");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "4c95":
/***/ (function(module, exports, __nested_webpack_require_64754__) {

"use strict";

var global = __nested_webpack_require_64754__("e53d");
var core = __nested_webpack_require_64754__("584a");
var dP = __nested_webpack_require_64754__("d9f6");
var DESCRIPTORS = __nested_webpack_require_64754__("8e60");
var SPECIES = __nested_webpack_require_64754__("5168")('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ "4ee1":
/***/ (function(module, exports, __nested_webpack_require_65306__) {

var ITERATOR = __nested_webpack_require_65306__("5168")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "50ed":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "5147":
/***/ (function(module, exports, __nested_webpack_require_66194__) {

var MATCH = __nested_webpack_require_66194__("2b4c")('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),

/***/ "5168":
/***/ (function(module, exports, __nested_webpack_require_66539__) {

var store = __nested_webpack_require_66539__("dbdb")('wks');
var uid = __nested_webpack_require_66539__("62a0");
var Symbol = __nested_webpack_require_66539__("e53d").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "52a7":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "53e2":
/***/ (function(module, exports, __nested_webpack_require_67105__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __nested_webpack_require_67105__("07e3");
var toObject = __nested_webpack_require_67105__("241e");
var IE_PROTO = __nested_webpack_require_67105__("5559")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "549b":
/***/ (function(module, exports, __nested_webpack_require_67699__) {

"use strict";

var ctx = __nested_webpack_require_67699__("d864");
var $export = __nested_webpack_require_67699__("63b6");
var toObject = __nested_webpack_require_67699__("241e");
var call = __nested_webpack_require_67699__("b0dc");
var isArrayIter = __nested_webpack_require_67699__("3702");
var toLength = __nested_webpack_require_67699__("b447");
var createProperty = __nested_webpack_require_67699__("20fd");
var getIterFn = __nested_webpack_require_67699__("7cd6");

$export($export.S + $export.F * !__nested_webpack_require_67699__("4ee1")(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ "54a1":
/***/ (function(module, exports, __nested_webpack_require_69438__) {

__nested_webpack_require_69438__("6c1c");
__nested_webpack_require_69438__("1654");
module.exports = __nested_webpack_require_69438__("95d5");


/***/ }),

/***/ "5537":
/***/ (function(module, exports, __nested_webpack_require_69626__) {

var core = __nested_webpack_require_69626__("8378");
var global = __nested_webpack_require_69626__("7726");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __nested_webpack_require_69626__("2d00") ? 'pure' : 'global',
  copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "5559":
/***/ (function(module, exports, __nested_webpack_require_70159__) {

var shared = __nested_webpack_require_70159__("dbdb")('keys');
var uid = __nested_webpack_require_70159__("62a0");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "584a":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "5b4e":
/***/ (function(module, exports, __nested_webpack_require_70605__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __nested_webpack_require_70605__("36c3");
var toLength = __nested_webpack_require_70605__("b447");
var toAbsoluteIndex = __nested_webpack_require_70605__("0fc9");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "5c95":
/***/ (function(module, exports, __nested_webpack_require_71616__) {

var hide = __nested_webpack_require_71616__("35e8");
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),

/***/ "5ca1":
/***/ (function(module, exports, __nested_webpack_require_71926__) {

var global = __nested_webpack_require_71926__("7726");
var core = __nested_webpack_require_71926__("8378");
var hide = __nested_webpack_require_71926__("32e9");
var redefine = __nested_webpack_require_71926__("2aba");
var ctx = __nested_webpack_require_71926__("9b43");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "5dbc":
/***/ (function(module, exports, __nested_webpack_require_73651__) {

var isObject = __nested_webpack_require_73651__("d3f4");
var setPrototypeOf = __nested_webpack_require_73651__("8b97").set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),

/***/ "5eda":
/***/ (function(module, exports, __nested_webpack_require_74080__) {

// most Object methods by ES6 should accept primitives
var $export = __nested_webpack_require_74080__("5ca1");
var core = __nested_webpack_require_74080__("8378");
var fails = __nested_webpack_require_74080__("79e5");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "613b":
/***/ (function(module, exports, __nested_webpack_require_74558__) {

var shared = __nested_webpack_require_74558__("5537")('keys');
var uid = __nested_webpack_require_74558__("ca5a");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "626a":
/***/ (function(module, exports, __nested_webpack_require_74818__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __nested_webpack_require_74818__("2d95");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "62a0":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "63b6":
/***/ (function(module, exports, __nested_webpack_require_75426__) {

var global = __nested_webpack_require_75426__("e53d");
var core = __nested_webpack_require_75426__("584a");
var ctx = __nested_webpack_require_75426__("d864");
var hide = __nested_webpack_require_75426__("35e8");
var has = __nested_webpack_require_75426__("07e3");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "656e":
/***/ (function(module, exports, __nested_webpack_require_77904__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __nested_webpack_require_77904__("79aa");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "6718":
/***/ (function(module, exports, __nested_webpack_require_78496__) {

var global = __nested_webpack_require_78496__("e53d");
var core = __nested_webpack_require_78496__("584a");
var LIBRARY = __nested_webpack_require_78496__("b8e3");
var wksExt = __nested_webpack_require_78496__("ccb9");
var defineProperty = __nested_webpack_require_78496__("d9f6").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "6762":
/***/ (function(module, exports, __nested_webpack_require_79029__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export = __nested_webpack_require_79029__("5ca1");
var $includes = __nested_webpack_require_79029__("c366")(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__nested_webpack_require_79029__("9c6c")('includes');


/***/ }),

/***/ "67bb":
/***/ (function(module, exports, __nested_webpack_require_79494__) {

module.exports = __nested_webpack_require_79494__("f921");

/***/ }),

/***/ "6821":
/***/ (function(module, exports, __nested_webpack_require_79623__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __nested_webpack_require_79623__("626a");
var defined = __nested_webpack_require_79623__("be13");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "696e":
/***/ (function(module, exports, __nested_webpack_require_79936__) {

__nested_webpack_require_79936__("c207");
__nested_webpack_require_79936__("1654");
__nested_webpack_require_79936__("6c1c");
__nested_webpack_require_79936__("24c5");
__nested_webpack_require_79936__("3c11");
__nested_webpack_require_79936__("43fc");
module.exports = __nested_webpack_require_79936__("584a").Promise;


/***/ }),

/***/ "6996":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_80260__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_19c9a1c7_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_80260__("92cc");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_19c9a1c7_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_80260__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_19c9a1c7_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */
 /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_19c9a1c7_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "69a8":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "69d3":
/***/ (function(module, exports, __nested_webpack_require_82728__) {

__nested_webpack_require_82728__("6718")('asyncIterator');


/***/ }),

/***/ "6a99":
/***/ (function(module, exports, __nested_webpack_require_82858__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __nested_webpack_require_82858__("d3f4");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "6abf":
/***/ (function(module, exports, __nested_webpack_require_83601__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __nested_webpack_require_83601__("e6f3");
var hiddenKeys = __nested_webpack_require_83601__("1691").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "6b4c":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "6b54":
/***/ (function(module, exports, __nested_webpack_require_84135__) {

"use strict";

__nested_webpack_require_84135__("3846");
var anObject = __nested_webpack_require_84135__("cb7c");
var $flags = __nested_webpack_require_84135__("0bfb");
var DESCRIPTORS = __nested_webpack_require_84135__("9e1e");
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __nested_webpack_require_84135__("2aba")(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__nested_webpack_require_84135__("79e5")(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),

/***/ "6c1c":
/***/ (function(module, exports, __nested_webpack_require_85071__) {

__nested_webpack_require_85071__("c367");
var global = __nested_webpack_require_85071__("e53d");
var hide = __nested_webpack_require_85071__("35e8");
var Iterators = __nested_webpack_require_85071__("481b");
var TO_STRING_TAG = __nested_webpack_require_85071__("5168")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),

/***/ "71c1":
/***/ (function(module, exports, __nested_webpack_require_86150__) {

var toInteger = __nested_webpack_require_86150__("3a38");
var defined = __nested_webpack_require_86150__("25eb");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "7514":
/***/ (function(module, exports, __nested_webpack_require_86863__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __nested_webpack_require_86863__("5ca1");
var $find = __nested_webpack_require_86863__("0a49")(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__nested_webpack_require_86863__("9c6c")(KEY);


/***/ }),

/***/ "765d":
/***/ (function(module, exports, __nested_webpack_require_87477__) {

__nested_webpack_require_87477__("6718")('observable');


/***/ }),

/***/ "7726":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "774e":
/***/ (function(module, exports, __nested_webpack_require_88036__) {

module.exports = __nested_webpack_require_88036__("d2d5");

/***/ }),

/***/ "77f1":
/***/ (function(module, exports, __nested_webpack_require_88165__) {

var toInteger = __nested_webpack_require_88165__("4588");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "794b":
/***/ (function(module, exports, __nested_webpack_require_88475__) {

module.exports = !__nested_webpack_require_88475__("8e60") && !__nested_webpack_require_88475__("294c")(function () {
  return Object.defineProperty(__nested_webpack_require_88475__("1ec9")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "795b":
/***/ (function(module, exports, __nested_webpack_require_88771__) {

module.exports = __nested_webpack_require_88771__("696e");

/***/ }),

/***/ "79aa":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "79e5":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "7cd6":
/***/ (function(module, exports, __nested_webpack_require_89255__) {

var classof = __nested_webpack_require_89255__("40c3");
var ITERATOR = __nested_webpack_require_89255__("5168")('iterator');
var Iterators = __nested_webpack_require_89255__("481b");
module.exports = __nested_webpack_require_89255__("584a").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "7e90":
/***/ (function(module, exports, __nested_webpack_require_89665__) {

var dP = __nested_webpack_require_89665__("d9f6");
var anObject = __nested_webpack_require_89665__("e4ae");
var getKeys = __nested_webpack_require_89665__("c3a1");

module.exports = __nested_webpack_require_89665__("8e60") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "7f20":
/***/ (function(module, exports, __nested_webpack_require_90165__) {

var def = __nested_webpack_require_90165__("86cc").f;
var has = __nested_webpack_require_90165__("69a8");
var TAG = __nested_webpack_require_90165__("2b4c")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "7f7f":
/***/ (function(module, exports, __nested_webpack_require_90535__) {

var dP = __nested_webpack_require_90535__("86cc").f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __nested_webpack_require_90535__("9e1e") && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),

/***/ "8378":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "8436":
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "84f2":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "85f2":
/***/ (function(module, exports, __nested_webpack_require_91359__) {

module.exports = __nested_webpack_require_91359__("454f");

/***/ }),

/***/ "85fe":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_91500__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __nested_webpack_require_91500__.d(__webpack_exports__, "a", function() { return ObserveVisibility; });
/* unused harmony export install */
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function processOptions(value) {
  var options;

  if (typeof value === 'function') {
    // Simple options (callback-only)
    options = {
      callback: value
    };
  } else {
    // Options object
    options = value;
  }

  return options;
}
function throttle(callback, delay) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var timeout;
  var lastState;
  var currentArgs;

  var throttled = function throttled(state) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    currentArgs = args;
    if (timeout && state === lastState) return;
    var leading = options.leading;

    if (typeof leading === 'function') {
      leading = leading(state, lastState);
    }

    if ((!timeout || state !== lastState) && leading) {
      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));
    }

    lastState = state;
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));
      timeout = 0;
    }, delay);
  };

  throttled._clear = function () {
    clearTimeout(timeout);
    timeout = null;
  };

  return throttled;
}
function deepEqual(val1, val2) {
  if (val1 === val2) return true;

  if (_typeof(val1) === 'object') {
    for (var key in val1) {
      if (!deepEqual(val1[key], val2[key])) {
        return false;
      }
    }

    return true;
  }

  return false;
}

var VisibilityState =
/*#__PURE__*/
function () {
  function VisibilityState(el, options, vnode) {
    _classCallCheck(this, VisibilityState);

    this.el = el;
    this.observer = null;
    this.frozen = false;
    this.createObserver(options, vnode);
  }

  _createClass(VisibilityState, [{
    key: "createObserver",
    value: function createObserver(options, vnode) {
      var _this = this;

      if (this.observer) {
        this.destroyObserver();
      }

      if (this.frozen) return;
      this.options = processOptions(options);

      this.callback = function (result, entry) {
        _this.options.callback(result, entry);

        if (result && _this.options.once) {
          _this.frozen = true;

          _this.destroyObserver();
        }
      }; // Throttle


      if (this.callback && this.options.throttle) {
        var _ref = this.options.throttleOptions || {},
            _leading = _ref.leading;

        this.callback = throttle(this.callback, this.options.throttle, {
          leading: function leading(state) {
            return _leading === 'both' || _leading === 'visible' && state || _leading === 'hidden' && !state;
          }
        });
      }

      this.oldResult = undefined;
      this.observer = new IntersectionObserver(function (entries) {
        var entry = entries[0];

        if (entries.length > 1) {
          var intersectingEntry = entries.find(function (e) {
            return e.isIntersecting;
          });

          if (intersectingEntry) {
            entry = intersectingEntry;
          }
        }

        if (_this.callback) {
          // Use isIntersecting if possible because browsers can report isIntersecting as true, but intersectionRatio as 0, when something very slowly enters the viewport.
          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;
          if (result === _this.oldResult) return;
          _this.oldResult = result;

          _this.callback(result, entry);
        }
      }, this.options.intersection); // Wait for the element to be in document

      vnode.context.$nextTick(function () {
        if (_this.observer) {
          _this.observer.observe(_this.el);
        }
      });
    }
  }, {
    key: "destroyObserver",
    value: function destroyObserver() {
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      } // Cancel throttled call


      if (this.callback && this.callback._clear) {
        this.callback._clear();

        this.callback = null;
      }
    }
  }, {
    key: "threshold",
    get: function get() {
      return this.options.intersection && this.options.intersection.threshold || 0;
    }
  }]);

  return VisibilityState;
}();

function bind(el, _ref2, vnode) {
  var value = _ref2.value;
  if (!value) return;

  if (typeof IntersectionObserver === 'undefined') {
    console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill');
  } else {
    var state = new VisibilityState(el, value, vnode);
    el._vue_visibilityState = state;
  }
}

function update(el, _ref3, vnode) {
  var value = _ref3.value,
      oldValue = _ref3.oldValue;
  if (deepEqual(value, oldValue)) return;
  var state = el._vue_visibilityState;

  if (!value) {
    unbind(el);
    return;
  }

  if (state) {
    state.createObserver(value, vnode);
  } else {
    bind(el, {
      value: value
    }, vnode);
  }
}

function unbind(el) {
  var state = el._vue_visibilityState;

  if (state) {
    state.destroyObserver();
    delete el._vue_visibilityState;
  }
}

var ObserveVisibility = {
  bind: bind,
  update: update,
  unbind: unbind
};

function install(Vue) {
  Vue.directive('observe-visibility', ObserveVisibility);
  /* -- Add more components here -- */
}
/* -- Plugin definition & Auto-install -- */

/* You shouldn't have to modify the code below */
// Plugin

var plugin = {
  // eslint-disable-next-line no-undef
  version: "0.4.6",
  install: install
};

var GlobalVue = null;

if (typeof window !== 'undefined') {
  GlobalVue = window.Vue;
} else if (typeof global !== 'undefined') {
  GlobalVue = global.Vue;
}

if (GlobalVue) {
  GlobalVue.use(plugin);
}

/* unused harmony default export */ var _unused_webpack_default_export = (plugin);


/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_91500__("c8ba")))

/***/ }),

/***/ "86cc":
/***/ (function(module, exports, __nested_webpack_require_99479__) {

var anObject = __nested_webpack_require_99479__("cb7c");
var IE8_DOM_DEFINE = __nested_webpack_require_99479__("c69a");
var toPrimitive = __nested_webpack_require_99479__("6a99");
var dP = Object.defineProperty;

exports.f = __nested_webpack_require_99479__("9e1e") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "8875":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// addapted from the document.currentScript polyfill by Adam Miller
// MIT license
// source: https://github.com/amiller-gh/currentScript-polyfill

// added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505

(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(typeof self !== 'undefined' ? self : this, function () {
  function getCurrentScript () {
    if (document.currentScript) {
      return document.currentScript
    }
  
    // IE 8-10 support script readyState
    // IE 11+ & Firefox support stack trace
    try {
      throw new Error();
    }
    catch (err) {
      // Find the second match for the "at" string to get file src url from stack.
      var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig,
        ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig,
        stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack),
        scriptLocation = (stackDetails && stackDetails[1]) || false,
        line = (stackDetails && stackDetails[2]) || false,
        currentLocation = document.location.href.replace(document.location.hash, ''),
        pageSource,
        inlineScriptSourceRegExp,
        inlineScriptSource,
        scripts = document.getElementsByTagName('script'); // Live NodeList collection
  
      if (scriptLocation === currentLocation) {
        pageSource = document.documentElement.outerHTML;
        inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
        inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
      }
  
      for (var i = 0; i < scripts.length; i++) {
        // If ready state is interactive, return the script tag
        if (scripts[i].readyState === 'interactive') {
          return scripts[i];
        }
  
        // If src matches, return the script tag
        if (scripts[i].src === scriptLocation) {
          return scripts[i];
        }
  
        // If inline source matches, return the script tag
        if (
          scriptLocation === currentLocation &&
          scripts[i].innerHTML &&
          scripts[i].innerHTML.trim() === inlineScriptSource
        ) {
          return scripts[i];
        }
      }
  
      // If no match, return null
      return null;
    }
  };

  return getCurrentScript
}));


/***/ }),

/***/ "8b97":
/***/ (function(module, exports, __nested_webpack_require_103081__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __nested_webpack_require_103081__("d3f4");
var anObject = __nested_webpack_require_103081__("cb7c");
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __nested_webpack_require_103081__("9b43")(Function.call, __nested_webpack_require_103081__("11e9").f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),

/***/ "8bbf":
/***/ (function(module, exports) {

module.exports = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");

/***/ }),

/***/ "8e60":
/***/ (function(module, exports, __nested_webpack_require_104186__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__nested_webpack_require_104186__("294c")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "8e6e":
/***/ (function(module, exports, __nested_webpack_require_104462__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __nested_webpack_require_104462__("5ca1");
var ownKeys = __nested_webpack_require_104462__("990b");
var toIObject = __nested_webpack_require_104462__("6821");
var gOPD = __nested_webpack_require_104462__("11e9");
var createProperty = __nested_webpack_require_104462__("f1ae");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),

/***/ "8f60":
/***/ (function(module, exports, __nested_webpack_require_105251__) {

"use strict";

var create = __nested_webpack_require_105251__("a159");
var descriptor = __nested_webpack_require_105251__("aebd");
var setToStringTag = __nested_webpack_require_105251__("45f2");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__nested_webpack_require_105251__("35e8")(IteratorPrototype, __nested_webpack_require_105251__("5168")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "8f82":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "9003":
/***/ (function(module, exports, __nested_webpack_require_106000__) {

// 7.2.2 IsArray(argument)
var cof = __nested_webpack_require_106000__("6b4c");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "9093":
/***/ (function(module, exports, __nested_webpack_require_106241__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __nested_webpack_require_106241__("ce10");
var hiddenKeys = __nested_webpack_require_106241__("e11e").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "9138":
/***/ (function(module, exports, __nested_webpack_require_106606__) {

module.exports = __nested_webpack_require_106606__("35e8");


/***/ }),

/***/ "92cc":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "95d5":
/***/ (function(module, exports, __nested_webpack_require_106859__) {

var classof = __nested_webpack_require_106859__("40c3");
var ITERATOR = __nested_webpack_require_106859__("5168")('iterator');
var Iterators = __nested_webpack_require_106859__("481b");
module.exports = __nested_webpack_require_106859__("584a").isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};


/***/ }),

/***/ "96cf":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
    true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "990b":
/***/ (function(module, exports, __nested_webpack_require_131604__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __nested_webpack_require_131604__("9093");
var gOPS = __nested_webpack_require_131604__("2621");
var anObject = __nested_webpack_require_131604__("cb7c");
var Reflect = __nested_webpack_require_131604__("7726").Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),

/***/ "9aa9":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "9b43":
/***/ (function(module, exports, __nested_webpack_require_132217__) {

// optional / simple context binding
var aFunction = __nested_webpack_require_132217__("d8e8");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "9c6c":
/***/ (function(module, exports, __nested_webpack_require_132824__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __nested_webpack_require_132824__("2b4c")('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __nested_webpack_require_132824__("32e9")(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "9def":
/***/ (function(module, exports, __nested_webpack_require_133224__) {

// 7.1.15 ToLength
var toInteger = __nested_webpack_require_133224__("4588");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "9e1e":
/***/ (function(module, exports, __nested_webpack_require_133526__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__nested_webpack_require_133526__("79e5")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "a159":
/***/ (function(module, exports, __nested_webpack_require_133802__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __nested_webpack_require_133802__("e4ae");
var dPs = __nested_webpack_require_133802__("7e90");
var enumBugKeys = __nested_webpack_require_133802__("1691");
var IE_PROTO = __nested_webpack_require_133802__("5559")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __nested_webpack_require_133802__("1ec9")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __nested_webpack_require_133802__("32fc").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "a22a":
/***/ (function(module, exports, __nested_webpack_require_135413__) {

var ctx = __nested_webpack_require_135413__("d864");
var call = __nested_webpack_require_135413__("b0dc");
var isArrayIter = __nested_webpack_require_135413__("3702");
var anObject = __nested_webpack_require_135413__("e4ae");
var toLength = __nested_webpack_require_135413__("b447");
var getIterFn = __nested_webpack_require_135413__("7cd6");
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ "a745":
/***/ (function(module, exports, __nested_webpack_require_136685__) {

module.exports = __nested_webpack_require_136685__("f410");

/***/ }),

/***/ "aa77":
/***/ (function(module, exports, __nested_webpack_require_136814__) {

var $export = __nested_webpack_require_136814__("5ca1");
var defined = __nested_webpack_require_136814__("be13");
var fails = __nested_webpack_require_136814__("79e5");
var spaces = __nested_webpack_require_136814__("fdef");
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),

/***/ "aae3":
/***/ (function(module, exports, __nested_webpack_require_137822__) {

// 7.2.8 IsRegExp(argument)
var isObject = __nested_webpack_require_137822__("d3f4");
var cof = __nested_webpack_require_137822__("2d95");
var MATCH = __nested_webpack_require_137822__("2b4c")('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),

/***/ "aba2":
/***/ (function(module, exports, __nested_webpack_require_138219__) {

var global = __nested_webpack_require_138219__("e53d");
var macrotask = __nested_webpack_require_138219__("4178").set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __nested_webpack_require_138219__("6b4c")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),

/***/ "ac6a":
/***/ (function(module, exports, __nested_webpack_require_140311__) {

var $iterators = __nested_webpack_require_140311__("cadf");
var getKeys = __nested_webpack_require_140311__("0d58");
var redefine = __nested_webpack_require_140311__("2aba");
var global = __nested_webpack_require_140311__("7726");
var hide = __nested_webpack_require_140311__("32e9");
var Iterators = __nested_webpack_require_140311__("84f2");
var wks = __nested_webpack_require_140311__("2b4c");
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),

/***/ "aebd":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "b0dc":
/***/ (function(module, exports, __nested_webpack_require_142474__) {

// call something on iterator step with safe closing on error
var anObject = __nested_webpack_require_142474__("e4ae");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "b447":
/***/ (function(module, exports, __nested_webpack_require_142972__) {

// 7.1.15 ToLength
var toInteger = __nested_webpack_require_142972__("3a38");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "b8ac":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_143286__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_e59be3b4_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_143286__("d052");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_e59be3b4_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_143286__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_e59be3b4_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */
 /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_e59be3b4_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "b8e3":
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "bc13":
/***/ (function(module, exports, __nested_webpack_require_145657__) {

var global = __nested_webpack_require_145657__("e53d");
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),

/***/ "be13":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "bf0b":
/***/ (function(module, exports, __nested_webpack_require_146100__) {

var pIE = __nested_webpack_require_146100__("355d");
var createDesc = __nested_webpack_require_146100__("aebd");
var toIObject = __nested_webpack_require_146100__("36c3");
var toPrimitive = __nested_webpack_require_146100__("1bc3");
var has = __nested_webpack_require_146100__("07e3");
var IE8_DOM_DEFINE = __nested_webpack_require_146100__("794b");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __nested_webpack_require_146100__("8e60") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "c207":
/***/ (function(module, exports) {



/***/ }),

/***/ "c366":
/***/ (function(module, exports, __nested_webpack_require_146842__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __nested_webpack_require_146842__("6821");
var toLength = __nested_webpack_require_146842__("9def");
var toAbsoluteIndex = __nested_webpack_require_146842__("77f1");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "c367":
/***/ (function(module, exports, __nested_webpack_require_147853__) {

"use strict";

var addToUnscopables = __nested_webpack_require_147853__("8436");
var step = __nested_webpack_require_147853__("50ed");
var Iterators = __nested_webpack_require_147853__("481b");
var toIObject = __nested_webpack_require_147853__("36c3");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __nested_webpack_require_147853__("30f1")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "c3a1":
/***/ (function(module, exports, __nested_webpack_require_149062__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __nested_webpack_require_149062__("e6f3");
var enumBugKeys = __nested_webpack_require_149062__("1691");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "c5f6":
/***/ (function(module, exports, __nested_webpack_require_149361__) {

"use strict";

var global = __nested_webpack_require_149361__("7726");
var has = __nested_webpack_require_149361__("69a8");
var cof = __nested_webpack_require_149361__("2d95");
var inheritIfRequired = __nested_webpack_require_149361__("5dbc");
var toPrimitive = __nested_webpack_require_149361__("6a99");
var fails = __nested_webpack_require_149361__("79e5");
var gOPN = __nested_webpack_require_149361__("9093").f;
var gOPD = __nested_webpack_require_149361__("11e9").f;
var dP = __nested_webpack_require_149361__("86cc").f;
var $trim = __nested_webpack_require_149361__("aa77").trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__nested_webpack_require_149361__("2aeb")(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __nested_webpack_require_149361__("9e1e") ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __nested_webpack_require_149361__("2aba")(global, NUMBER, $Number);
}


/***/ }),

/***/ "c69a":
/***/ (function(module, exports, __nested_webpack_require_152286__) {

module.exports = !__nested_webpack_require_152286__("9e1e") && !__nested_webpack_require_152286__("79e5")(function () {
  return Object.defineProperty(__nested_webpack_require_152286__("230e")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "c8ba":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "c8bb":
/***/ (function(module, exports, __nested_webpack_require_153117__) {

module.exports = __nested_webpack_require_153117__("54a1");

/***/ }),

/***/ "ca5a":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "cadf":
/***/ (function(module, exports, __nested_webpack_require_153471__) {

"use strict";

var addToUnscopables = __nested_webpack_require_153471__("9c6c");
var step = __nested_webpack_require_153471__("d53b");
var Iterators = __nested_webpack_require_153471__("84f2");
var toIObject = __nested_webpack_require_153471__("6821");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __nested_webpack_require_153471__("01f9")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "cb7c":
/***/ (function(module, exports, __nested_webpack_require_154680__) {

var isObject = __nested_webpack_require_154680__("d3f4");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "ccb9":
/***/ (function(module, exports, __nested_webpack_require_154922__) {

exports.f = __nested_webpack_require_154922__("5168");


/***/ }),

/***/ "cd1c":
/***/ (function(module, exports, __nested_webpack_require_155047__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __nested_webpack_require_155047__("e853");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),

/***/ "cd78":
/***/ (function(module, exports, __nested_webpack_require_155342__) {

var anObject = __nested_webpack_require_155342__("e4ae");
var isObject = __nested_webpack_require_155342__("f772");
var newPromiseCapability = __nested_webpack_require_155342__("656e");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "ce10":
/***/ (function(module, exports, __nested_webpack_require_155822__) {

var has = __nested_webpack_require_155822__("69a8");
var toIObject = __nested_webpack_require_155822__("6821");
var arrayIndexOf = __nested_webpack_require_155822__("c366")(false);
var IE_PROTO = __nested_webpack_require_155822__("613b")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "d052":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "d2c8":
/***/ (function(module, exports, __nested_webpack_require_156581__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __nested_webpack_require_156581__("aae3");
var defined = __nested_webpack_require_156581__("be13");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),

/***/ "d2d5":
/***/ (function(module, exports, __nested_webpack_require_156989__) {

__nested_webpack_require_156989__("1654");
__nested_webpack_require_156989__("549b");
module.exports = __nested_webpack_require_156989__("584a").Array.from;


/***/ }),

/***/ "d391":
/***/ (function(module) {

module.exports = JSON.parse("{\"AC\":\"40123\",\"AD\":\"312345\",\"AE\":\"501234567\",\"AF\":\"701234567\",\"AG\":\"2684641234\",\"AI\":\"2642351234\",\"AL\":\"672123456\",\"AM\":\"77123456\",\"AO\":\"923123456\",\"AR\":\"91123456789\",\"AS\":\"6847331234\",\"AT\":\"664123456\",\"AU\":\"412345678\",\"AW\":\"5601234\",\"AX\":\"412345678\",\"AZ\":\"401234567\",\"BA\":\"61123456\",\"BB\":\"2462501234\",\"BD\":\"1812345678\",\"BE\":\"470123456\",\"BF\":\"70123456\",\"BG\":\"48123456\",\"BH\":\"36001234\",\"BI\":\"79561234\",\"BJ\":\"90011234\",\"BL\":\"690001234\",\"BM\":\"4413701234\",\"BN\":\"7123456\",\"BO\":\"71234567\",\"BQ\":\"3181234\",\"BR\":\"11961234567\",\"BS\":\"2423591234\",\"BT\":\"17123456\",\"BW\":\"71123456\",\"BY\":\"294911911\",\"BZ\":\"6221234\",\"CA\":\"5062345678\",\"CC\":\"412345678\",\"CD\":\"991234567\",\"CF\":\"70012345\",\"CG\":\"061234567\",\"CH\":\"781234567\",\"CI\":\"01234567\",\"CK\":\"71234\",\"CL\":\"221234567\",\"CM\":\"671234567\",\"CN\":\"13123456789\",\"CO\":\"3211234567\",\"CR\":\"83123456\",\"CU\":\"51234567\",\"CV\":\"9911234\",\"CW\":\"95181234\",\"CX\":\"412345678\",\"CY\":\"96123456\",\"CZ\":\"601123456\",\"DE\":\"15123456789\",\"DJ\":\"77831001\",\"DK\":\"32123456\",\"DM\":\"7672251234\",\"DO\":\"8092345678\",\"DZ\":\"551234567\",\"EC\":\"991234567\",\"EE\":\"51234567\",\"EG\":\"1001234567\",\"EH\":\"650123456\",\"ER\":\"7123456\",\"ES\":\"612345678\",\"ET\":\"911234567\",\"FI\":\"412345678\",\"FJ\":\"7012345\",\"FK\":\"51234\",\"FM\":\"3501234\",\"FO\":\"211234\",\"FR\":\"612345678\",\"GA\":\"06031234\",\"GB\":\"7400123456\",\"GD\":\"4734031234\",\"GE\":\"555123456\",\"GF\":\"694201234\",\"GG\":\"7781123456\",\"GH\":\"231234567\",\"GI\":\"57123456\",\"GL\":\"221234\",\"GM\":\"3012345\",\"GN\":\"601123456\",\"GP\":\"690001234\",\"GQ\":\"222123456\",\"GR\":\"6912345678\",\"GT\":\"51234567\",\"GU\":\"6713001234\",\"GW\":\"955012345\",\"GY\":\"6091234\",\"HK\":\"51234567\",\"HN\":\"91234567\",\"HR\":\"921234567\",\"HT\":\"34101234\",\"HU\":\"201234567\",\"ID\":\"812345678\",\"IE\":\"850123456\",\"IL\":\"502345678\",\"IM\":\"7924123456\",\"IN\":\"8123456789\",\"IO\":\"3801234\",\"IQ\":\"7912345678\",\"IR\":\"9123456789\",\"IS\":\"6111234\",\"IT\":\"3123456789\",\"JE\":\"7797712345\",\"JM\":\"8762101234\",\"JO\":\"790123456\",\"JP\":\"9012345678\",\"KE\":\"712123456\",\"KG\":\"700123456\",\"KH\":\"91234567\",\"KI\":\"72001234\",\"KM\":\"3212345\",\"KN\":\"8697652917\",\"KP\":\"1921234567\",\"KR\":\"1020000000\",\"KW\":\"50012345\",\"KY\":\"3453231234\",\"KZ\":\"7710009998\",\"LA\":\"2023123456\",\"LB\":\"71123456\",\"LC\":\"7582845678\",\"LI\":\"660234567\",\"LK\":\"712345678\",\"LR\":\"770123456\",\"LS\":\"50123456\",\"LT\":\"61234567\",\"LU\":\"628123456\",\"LV\":\"21234567\",\"LY\":\"912345678\",\"MA\":\"650123456\",\"MC\":\"612345678\",\"MD\":\"62112345\",\"ME\":\"67622901\",\"MF\":\"690001234\",\"MG\":\"321234567\",\"MH\":\"2351234\",\"MK\":\"72345678\",\"ML\":\"65012345\",\"MM\":\"92123456\",\"MN\":\"88123456\",\"MO\":\"66123456\",\"MP\":\"6702345678\",\"MQ\":\"696201234\",\"MR\":\"22123456\",\"MS\":\"6644923456\",\"MT\":\"96961234\",\"MU\":\"52512345\",\"MV\":\"7712345\",\"MW\":\"991234567\",\"MX\":\"12221234567\",\"MY\":\"123456789\",\"MZ\":\"821234567\",\"NA\":\"811234567\",\"NC\":\"751234\",\"NE\":\"93123456\",\"NF\":\"381234\",\"NG\":\"8021234567\",\"NI\":\"81234567\",\"NL\":\"612345678\",\"NO\":\"40612345\",\"NP\":\"9841234567\",\"NR\":\"5551234\",\"NU\":\"8884012\",\"NZ\":\"211234567\",\"OM\":\"92123456\",\"PA\":\"61234567\",\"PE\":\"912345678\",\"PF\":\"87123456\",\"PG\":\"70123456\",\"PH\":\"9051234567\",\"PK\":\"3012345678\",\"PL\":\"512345678\",\"PM\":\"551234\",\"PR\":\"7872345678\",\"PS\":\"599123456\",\"PT\":\"912345678\",\"PW\":\"6201234\",\"PY\":\"961456789\",\"QA\":\"33123456\",\"RE\":\"692123456\",\"RO\":\"712034567\",\"RS\":\"601234567\",\"RU\":\"9123456789\",\"RW\":\"720123456\",\"SA\":\"512345678\",\"SB\":\"7421234\",\"SC\":\"2510123\",\"SD\":\"911231234\",\"SE\":\"701234567\",\"SG\":\"81234567\",\"SH\":\"51234\",\"SI\":\"31234567\",\"SJ\":\"41234567\",\"SK\":\"912123456\",\"SL\":\"25123456\",\"SM\":\"66661212\",\"SN\":\"701234567\",\"SO\":\"71123456\",\"SR\":\"7412345\",\"SS\":\"977123456\",\"ST\":\"9812345\",\"SV\":\"70123456\",\"SX\":\"7215205678\",\"SY\":\"944567890\",\"SZ\":\"76123456\",\"TA\":\"8999\",\"TC\":\"6492311234\",\"TD\":\"63012345\",\"TG\":\"90112345\",\"TH\":\"812345678\",\"TJ\":\"917123456\",\"TK\":\"7290\",\"TL\":\"77212345\",\"TM\":\"66123456\",\"TN\":\"20123456\",\"TO\":\"7715123\",\"TR\":\"5012345678\",\"TT\":\"8682911234\",\"TV\":\"901234\",\"TW\":\"912345678\",\"TZ\":\"621234567\",\"UA\":\"501234567\",\"UG\":\"712345678\",\"US\":\"2015550123\",\"UY\":\"94231234\",\"UZ\":\"912345678\",\"VA\":\"3123456789\",\"VC\":\"7844301234\",\"VE\":\"4121234567\",\"VG\":\"2843001234\",\"VI\":\"3406421234\",\"VN\":\"912345678\",\"VU\":\"5912345\",\"WF\":\"501234\",\"WS\":\"7212345\",\"XK\":\"43201234\",\"YE\":\"712345678\",\"YT\":\"639012345\",\"ZA\":\"711234567\",\"ZM\":\"955123456\",\"ZW\":\"712345678\"}");

/***/ }),

/***/ "d3f4":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "d53b":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "d864":
/***/ (function(module, exports, __nested_webpack_require_162637__) {

// optional / simple context binding
var aFunction = __nested_webpack_require_162637__("79aa");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "d8e8":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "d9f6":
/***/ (function(module, exports, __nested_webpack_require_163432__) {

var anObject = __nested_webpack_require_163432__("e4ae");
var IE8_DOM_DEFINE = __nested_webpack_require_163432__("794b");
var toPrimitive = __nested_webpack_require_163432__("1bc3");
var dP = Object.defineProperty;

exports.f = __nested_webpack_require_163432__("8e60") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "dbdb":
/***/ (function(module, exports, __nested_webpack_require_164122__) {

var core = __nested_webpack_require_164122__("584a");
var global = __nested_webpack_require_164122__("e53d");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __nested_webpack_require_164122__("b8e3") ? 'pure' : 'global',
  copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "e11e":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "e4ae":
/***/ (function(module, exports, __nested_webpack_require_164878__) {

var isObject = __nested_webpack_require_164878__("f772");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "e508":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_165132__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* unused harmony export DynamicScroller */
/* unused harmony export DynamicScrollerItem */
/* unused harmony export IdState */
/* harmony export (binding) */ __nested_webpack_require_165132__.d(__webpack_exports__, "a", function() { return __vue_component__; });
/* harmony import */ var vue_resize__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_165132__("252c");
/* harmony import */ var vue_observe_visibility__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_165132__("85fe");
/* harmony import */ var scrollparent__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_165132__("ed83");
/* harmony import */ var scrollparent__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_165132__.n(scrollparent__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_165132__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_165132__.n(vue__WEBPACK_IMPORTED_MODULE_3__);





var config = {
  itemsLimit: 1000
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelper(o) {
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var it,
      normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = o[Symbol.iterator]();
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var props = {
  items: {
    type: Array,
    required: true
  },
  keyField: {
    type: String,
    default: 'id'
  },
  direction: {
    type: String,
    default: 'vertical',
    validator: function validator(value) {
      return ['vertical', 'horizontal'].includes(value);
    }
  }
};
function simpleArray() {
  return this.items.length && _typeof(this.items[0]) !== 'object';
}

var supportsPassive = false;

if (typeof window !== 'undefined') {
  supportsPassive = false;

  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function get() {
        supportsPassive = true;
      }
    });
    window.addEventListener('test', null, opts);
  } catch (e) {}
}

var uid = 0;
var script = {
  name: 'RecycleScroller',
  components: {
    ResizeObserver: vue_resize__WEBPACK_IMPORTED_MODULE_0__[/* ResizeObserver */ "a"]
  },
  directives: {
    ObserveVisibility: vue_observe_visibility__WEBPACK_IMPORTED_MODULE_1__[/* ObserveVisibility */ "a"]
  },
  props: _objectSpread2({}, props, {
    itemSize: {
      type: Number,
      default: null
    },
    minItemSize: {
      type: [Number, String],
      default: null
    },
    sizeField: {
      type: String,
      default: 'size'
    },
    typeField: {
      type: String,
      default: 'type'
    },
    buffer: {
      type: Number,
      default: 200
    },
    pageMode: {
      type: Boolean,
      default: false
    },
    prerender: {
      type: Number,
      default: 0
    },
    emitUpdate: {
      type: Boolean,
      default: false
    }
  }),
  data: function data() {
    return {
      pool: [],
      totalSize: 0,
      ready: false,
      hoverKey: null
    };
  },
  computed: {
    sizes: function sizes() {
      if (this.itemSize === null) {
        var sizes = {
          '-1': {
            accumulator: 0
          }
        };
        var items = this.items;
        var field = this.sizeField;
        var minItemSize = this.minItemSize;
        var computedMinSize = 10000;
        var accumulator = 0;
        var current;

        for (var i = 0, l = items.length; i < l; i++) {
          current = items[i][field] || minItemSize;

          if (current < computedMinSize) {
            computedMinSize = current;
          }

          accumulator += current;
          sizes[i] = {
            accumulator: accumulator,
            size: current
          };
        } // eslint-disable-next-line


        this.$_computedMinItemSize = computedMinSize;
        return sizes;
      }

      return [];
    },
    simpleArray: simpleArray
  },
  watch: {
    items: function items() {
      this.updateVisibleItems(true);
    },
    pageMode: function pageMode() {
      this.applyPageMode();
      this.updateVisibleItems(false);
    },
    sizes: {
      handler: function handler() {
        this.updateVisibleItems(false);
      },
      deep: true
    }
  },
  created: function created() {
    this.$_startIndex = 0;
    this.$_endIndex = 0;
    this.$_views = new Map();
    this.$_unusedViews = new Map();
    this.$_scrollDirty = false;
    this.$_lastUpdateScrollPosition = 0; // In SSR mode, we also prerender the same number of item for the first render
    // to avoir mismatch between server and client templates

    if (this.prerender) {
      this.$_prerender = true;
      this.updateVisibleItems(false);
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.applyPageMode();
    this.$nextTick(function () {
      // In SSR mode, render the real number of visible items
      _this.$_prerender = false;

      _this.updateVisibleItems(true);

      _this.ready = true;
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.removeListeners();
  },
  methods: {
    addView: function addView(pool, index, item, key, type) {
      var view = {
        item: item,
        position: 0
      };
      var nonReactive = {
        id: uid++,
        index: index,
        used: true,
        key: key,
        type: type
      };
      Object.defineProperty(view, 'nr', {
        configurable: false,
        value: nonReactive
      });
      pool.push(view);
      return view;
    },
    unuseView: function unuseView(view) {
      var fake = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var unusedViews = this.$_unusedViews;
      var type = view.nr.type;
      var unusedPool = unusedViews.get(type);

      if (!unusedPool) {
        unusedPool = [];
        unusedViews.set(type, unusedPool);
      }

      unusedPool.push(view);

      if (!fake) {
        view.nr.used = false;
        view.position = -9999;
        this.$_views.delete(view.nr.key);
      }
    },
    handleResize: function handleResize() {
      this.$emit('resize');
      if (this.ready) this.updateVisibleItems(false);
    },
    handleScroll: function handleScroll(event) {
      var _this2 = this;

      if (!this.$_scrollDirty) {
        this.$_scrollDirty = true;
        requestAnimationFrame(function () {
          _this2.$_scrollDirty = false;

          var _this2$updateVisibleI = _this2.updateVisibleItems(false, true),
              continuous = _this2$updateVisibleI.continuous; // It seems sometimes chrome doesn't fire scroll event :/
          // When non continous scrolling is ending, we force a refresh


          if (!continuous) {
            clearTimeout(_this2.$_refreshTimout);
            _this2.$_refreshTimout = setTimeout(_this2.handleScroll, 100);
          }
        });
      }
    },
    handleVisibilityChange: function handleVisibilityChange(isVisible, entry) {
      var _this3 = this;

      if (this.ready) {
        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {
          this.$emit('visible');
          requestAnimationFrame(function () {
            _this3.updateVisibleItems(false);
          });
        } else {
          this.$emit('hidden');
        }
      }
    },
    updateVisibleItems: function updateVisibleItems(checkItem) {
      var checkPositionDiff = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var itemSize = this.itemSize;
      var minItemSize = this.$_computedMinItemSize;
      var typeField = this.typeField;
      var keyField = this.simpleArray ? null : this.keyField;
      var items = this.items;
      var count = items.length;
      var sizes = this.sizes;
      var views = this.$_views;
      var unusedViews = this.$_unusedViews;
      var pool = this.pool;
      var startIndex, endIndex;
      var totalSize;

      if (!count) {
        startIndex = endIndex = totalSize = 0;
      } else if (this.$_prerender) {
        startIndex = 0;
        endIndex = this.prerender;
        totalSize = null;
      } else {
        var scroll = this.getScroll(); // Skip update if use hasn't scrolled enough

        if (checkPositionDiff) {
          var positionDiff = scroll.start - this.$_lastUpdateScrollPosition;
          if (positionDiff < 0) positionDiff = -positionDiff;

          if (itemSize === null && positionDiff < minItemSize || positionDiff < itemSize) {
            return {
              continuous: true
            };
          }
        }

        this.$_lastUpdateScrollPosition = scroll.start;
        var buffer = this.buffer;
        scroll.start -= buffer;
        scroll.end += buffer; // Variable size mode

        if (itemSize === null) {
          var h;
          var a = 0;
          var b = count - 1;
          var i = ~~(count / 2);
          var oldI; // Searching for startIndex

          do {
            oldI = i;
            h = sizes[i].accumulator;

            if (h < scroll.start) {
              a = i;
            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {
              b = i;
            }

            i = ~~((a + b) / 2);
          } while (i !== oldI);

          i < 0 && (i = 0);
          startIndex = i; // For container style

          totalSize = sizes[count - 1].accumulator; // Searching for endIndex

          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++) {
          }

          if (endIndex === -1) {
            endIndex = items.length - 1;
          } else {
            endIndex++; // Bounds

            endIndex > count && (endIndex = count);
          }
        } else {
          // Fixed size mode
          startIndex = ~~(scroll.start / itemSize);
          endIndex = Math.ceil(scroll.end / itemSize); // Bounds

          startIndex < 0 && (startIndex = 0);
          endIndex > count && (endIndex = count);
          totalSize = count * itemSize;
        }
      }

      if (endIndex - startIndex > config.itemsLimit) {
        this.itemsLimitError();
      }

      this.totalSize = totalSize;
      var view;
      var continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex;

      if (this.$_continuous !== continuous) {
        if (continuous) {
          views.clear();
          unusedViews.clear();

          for (var _i = 0, l = pool.length; _i < l; _i++) {
            view = pool[_i];
            this.unuseView(view);
          }
        }

        this.$_continuous = continuous;
      } else if (continuous) {
        for (var _i2 = 0, _l = pool.length; _i2 < _l; _i2++) {
          view = pool[_i2];

          if (view.nr.used) {
            // Update view item index
            if (checkItem) {
              view.nr.index = items.findIndex(function (item) {
                return keyField ? item[keyField] === view.item[keyField] : item === view.item;
              });
            } // Check if index is still in visible range


            if (view.nr.index === -1 || view.nr.index < startIndex || view.nr.index >= endIndex) {
              this.unuseView(view);
            }
          }
        }
      }

      var unusedIndex = continuous ? null : new Map();
      var item, type, unusedPool;
      var v;

      for (var _i3 = startIndex; _i3 < endIndex; _i3++) {
        item = items[_i3];
        var key = keyField ? item[keyField] : item;

        if (key == null) {
          throw new Error("Key is ".concat(key, " on item (keyField is '").concat(keyField, "')"));
        }

        view = views.get(key);

        if (!itemSize && !sizes[_i3].size) {
          if (view) this.unuseView(view);
          continue;
        } // No view assigned to item


        if (!view) {
          type = item[typeField];
          unusedPool = unusedViews.get(type);

          if (continuous) {
            // Reuse existing view
            if (unusedPool && unusedPool.length) {
              view = unusedPool.pop();
              view.item = item;
              view.nr.used = true;
              view.nr.index = _i3;
              view.nr.key = key;
              view.nr.type = type;
            } else {
              view = this.addView(pool, _i3, item, key, type);
            }
          } else {
            // Use existing view
            // We don't care if they are already used
            // because we are not in continous scrolling
            v = unusedIndex.get(type) || 0;

            if (!unusedPool || v >= unusedPool.length) {
              view = this.addView(pool, _i3, item, key, type);
              this.unuseView(view, true);
              unusedPool = unusedViews.get(type);
            }

            view = unusedPool[v];
            view.item = item;
            view.nr.used = true;
            view.nr.index = _i3;
            view.nr.key = key;
            view.nr.type = type;
            unusedIndex.set(type, v + 1);
            v++;
          }

          views.set(key, view);
        } else {
          view.nr.used = true;
          view.item = item;
        } // Update position


        if (itemSize === null) {
          view.position = sizes[_i3 - 1].accumulator;
        } else {
          view.position = _i3 * itemSize;
        }
      }

      this.$_startIndex = startIndex;
      this.$_endIndex = endIndex;
      if (this.emitUpdate) this.$emit('update', startIndex, endIndex); // After the user has finished scrolling
      // Sort views so text selection is correct

      clearTimeout(this.$_sortTimer);
      this.$_sortTimer = setTimeout(this.sortViews, 300);
      return {
        continuous: continuous
      };
    },
    getListenerTarget: function getListenerTarget() {
      var target = scrollparent__WEBPACK_IMPORTED_MODULE_2___default()(this.$el); // Fix global scroll target for Chrome and Safari

      if (window.document && (target === window.document.documentElement || target === window.document.body)) {
        target = window;
      }

      return target;
    },
    getScroll: function getScroll() {
      var el = this.$el,
          direction = this.direction;
      var isVertical = direction === 'vertical';
      var scrollState;

      if (this.pageMode) {
        var bounds = el.getBoundingClientRect();
        var boundsSize = isVertical ? bounds.height : bounds.width;
        var start = -(isVertical ? bounds.top : bounds.left);
        var size = isVertical ? window.innerHeight : window.innerWidth;

        if (start < 0) {
          size += start;
          start = 0;
        }

        if (start + size > boundsSize) {
          size = boundsSize - start;
        }

        scrollState = {
          start: start,
          end: start + size
        };
      } else if (isVertical) {
        scrollState = {
          start: el.scrollTop,
          end: el.scrollTop + el.clientHeight
        };
      } else {
        scrollState = {
          start: el.scrollLeft,
          end: el.scrollLeft + el.clientWidth
        };
      }

      return scrollState;
    },
    applyPageMode: function applyPageMode() {
      if (this.pageMode) {
        this.addListeners();
      } else {
        this.removeListeners();
      }
    },
    addListeners: function addListeners() {
      this.listenerTarget = this.getListenerTarget();
      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive ? {
        passive: true
      } : false);
      this.listenerTarget.addEventListener('resize', this.handleResize);
    },
    removeListeners: function removeListeners() {
      if (!this.listenerTarget) {
        return;
      }

      this.listenerTarget.removeEventListener('scroll', this.handleScroll);
      this.listenerTarget.removeEventListener('resize', this.handleResize);
      this.listenerTarget = null;
    },
    scrollToItem: function scrollToItem(index) {
      var scroll;

      if (this.itemSize === null) {
        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0;
      } else {
        scroll = index * this.itemSize;
      }

      this.scrollToPosition(scroll);
    },
    scrollToPosition: function scrollToPosition(position) {
      if (this.direction === 'vertical') {
        this.$el.scrollTop = position;
      } else {
        this.$el.scrollLeft = position;
      }
    },
    itemsLimitError: function itemsLimitError() {
      var _this4 = this;

      setTimeout(function () {
        console.log('It seems the scroller element isn\'t scrolling, so it tries to render all the items at once.', 'Scroller:', _this4.$el);
        console.log('Make sure the scroller has a fixed height (or width) and \'overflow-y\' (or \'overflow-x\') set to \'auto\' so it can scroll correctly and only render the items visible in the scroll viewport.');
      });
      throw new Error('Rendered items limit reached');
    },
    sortViews: function sortViews() {
      this.pool.sort(function (viewA, viewB) {
        return viewA.nr.index - viewB.nr.index;
      });
    }
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
        createInjectorSSR = createInjector;
        createInjector = shadowMode;
        shadowMode = false;
    }
    // Vue.extend constructor export interop.
    const options = typeof script === 'function' ? script.options : script;
    // render functions
    if (template && template.render) {
        options.render = template.render;
        options.staticRenderFns = template.staticRenderFns;
        options._compiled = true;
        // functional template
        if (isFunctionalTemplate) {
            options.functional = true;
        }
    }
    // scopedId
    if (scopeId) {
        options._scopeId = scopeId;
    }
    let hook;
    if (moduleIdentifier) {
        // server build
        hook = function (context) {
            // 2.3 injection
            context =
                context || // cached call
                    (this.$vnode && this.$vnode.ssrContext) || // stateful
                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
            // 2.2 with runInNewContext: true
            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                context = __VUE_SSR_CONTEXT__;
            }
            // inject component styles
            if (style) {
                style.call(this, createInjectorSSR(context));
            }
            // register component module identifier for async chunk inference
            if (context && context._registeredComponents) {
                context._registeredComponents.add(moduleIdentifier);
            }
        };
        // used by ssr in case component is cached and beforeCreate
        // never gets called
        options._ssrRegister = hook;
    }
    else if (style) {
        hook = shadowMode
            ? function (context) {
                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
            }
            : function (context) {
                style.call(this, createInjector(context));
            };
    }
    if (hook) {
        if (options.functional) {
            // register for functional component in vue file
            const originalRender = options.render;
            options.render = function renderWithStyleInjection(h, context) {
                hook.call(context);
                return originalRender(h, context);
            };
        }
        else {
            // inject component registration as beforeCreate hook
            const existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
    }
    return script;
}

/* script */
const __vue_script__ = script;
/* template */
var __vue_render__ = function() {
  var _obj, _obj$1;
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      directives: [
        {
          name: "observe-visibility",
          rawName: "v-observe-visibility",
          value: _vm.handleVisibilityChange,
          expression: "handleVisibilityChange"
        }
      ],
      staticClass: "vue-recycle-scroller",
      class:
        ((_obj = {
          ready: _vm.ready,
          "page-mode": _vm.pageMode
        }),
        (_obj["direction-" + _vm.direction] = true),
        _obj),
      on: {
        "&scroll": function($event) {
          return _vm.handleScroll($event)
        }
      }
    },
    [
      _vm.$slots.before
        ? _c(
            "div",
            { staticClass: "vue-recycle-scroller__slot" },
            [_vm._t("before")],
            2
          )
        : _vm._e(),
      _vm._v(" "),
      _c(
        "div",
        {
          ref: "wrapper",
          staticClass: "vue-recycle-scroller__item-wrapper",
          style:
            ((_obj$1 = {}),
            (_obj$1[_vm.direction === "vertical" ? "minHeight" : "minWidth"] =
              _vm.totalSize + "px"),
            _obj$1)
        },
        _vm._l(_vm.pool, function(view) {
          return _c(
            "div",
            {
              key: view.nr.id,
              staticClass: "vue-recycle-scroller__item-view",
              class: { hover: _vm.hoverKey === view.nr.key },
              style: _vm.ready
                ? {
                    transform:
                      "translate" +
                      (_vm.direction === "vertical" ? "Y" : "X") +
                      "(" +
                      view.position +
                      "px)"
                  }
                : null,
              on: {
                mouseenter: function($event) {
                  _vm.hoverKey = view.nr.key;
                },
                mouseleave: function($event) {
                  _vm.hoverKey = null;
                }
              }
            },
            [
              _vm._t("default", null, {
                item: view.item,
                index: view.nr.index,
                active: view.nr.used
              })
            ],
            2
          )
        }),
        0
      ),
      _vm._v(" "),
      _vm.$slots.after
        ? _c(
            "div",
            { staticClass: "vue-recycle-scroller__slot" },
            [_vm._t("after")],
            2
          )
        : _vm._e(),
      _vm._v(" "),
      _c("ResizeObserver", { on: { notify: _vm.handleResize } })
    ],
    1
  )
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;

  /* style */
  const __vue_inject_styles__ = undefined;
  /* scoped */
  const __vue_scope_id__ = undefined;
  /* module identifier */
  const __vue_module_identifier__ = undefined;
  /* functional template */
  const __vue_is_functional_template__ = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__ = normalizeComponent(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    false,
    undefined,
    undefined,
    undefined
  );

var script$1 = {
  name: 'DynamicScroller',
  components: {
    RecycleScroller: __vue_component__
  },
  inheritAttrs: false,
  provide: function provide() {
    if (typeof ResizeObserver !== 'undefined') {
      this.$_resizeObserver = new ResizeObserver(function (entries) {
        var _iterator = _createForOfIteratorHelper(entries),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var entry = _step.value;

            if (entry.target) {
              var event = new CustomEvent('resize', {
                detail: {
                  contentRect: entry.contentRect
                }
              });
              entry.target.dispatchEvent(event);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
    }

    return {
      vscrollData: this.vscrollData,
      vscrollParent: this,
      vscrollResizeObserver: this.$_resizeObserver
    };
  },
  props: _objectSpread2({}, props, {
    minItemSize: {
      type: [Number, String],
      required: true
    }
  }),
  data: function data() {
    return {
      vscrollData: {
        active: true,
        sizes: {},
        validSizes: {},
        keyField: this.keyField,
        simpleArray: false
      }
    };
  },
  computed: {
    simpleArray: simpleArray,
    itemsWithSize: function itemsWithSize() {
      var result = [];
      var items = this.items,
          keyField = this.keyField,
          simpleArray = this.simpleArray;
      var sizes = this.vscrollData.sizes;

      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var id = simpleArray ? i : item[keyField];
        var size = sizes[id];

        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {
          size = 0;
        }

        result.push({
          item: item,
          id: id,
          size: size
        });
      }

      return result;
    },
    listeners: function listeners() {
      var listeners = {};

      for (var key in this.$listeners) {
        if (key !== 'resize' && key !== 'visible') {
          listeners[key] = this.$listeners[key];
        }
      }

      return listeners;
    }
  },
  watch: {
    items: function items() {
      this.forceUpdate(false);
    },
    simpleArray: {
      handler: function handler(value) {
        this.vscrollData.simpleArray = value;
      },
      immediate: true
    },
    direction: function direction(value) {
      this.forceUpdate(true);
    }
  },
  created: function created() {
    this.$_updates = [];
    this.$_undefinedSizes = 0;
    this.$_undefinedMap = {};
  },
  activated: function activated() {
    this.vscrollData.active = true;
  },
  deactivated: function deactivated() {
    this.vscrollData.active = false;
  },
  methods: {
    onScrollerResize: function onScrollerResize() {
      var scroller = this.$refs.scroller;

      if (scroller) {
        this.forceUpdate();
      }

      this.$emit('resize');
    },
    onScrollerVisible: function onScrollerVisible() {
      this.$emit('vscroll:update', {
        force: false
      });
      this.$emit('visible');
    },
    forceUpdate: function forceUpdate() {
      var clear = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (clear || this.simpleArray) {
        this.vscrollData.validSizes = {};
      }

      this.$emit('vscroll:update', {
        force: true
      });
    },
    scrollToItem: function scrollToItem(index) {
      var scroller = this.$refs.scroller;
      if (scroller) scroller.scrollToItem(index);
    },
    getItemSize: function getItemSize(item) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var id = this.simpleArray ? index != null ? index : this.items.indexOf(item) : item[this.keyField];
      return this.vscrollData.sizes[id] || 0;
    },
    scrollToBottom: function scrollToBottom() {
      var _this = this;

      if (this.$_scrollingToBottom) return;
      this.$_scrollingToBottom = true;
      var el = this.$el; // Item is inserted to the DOM

      this.$nextTick(function () {
        el.scrollTop = el.scrollHeight + 5000; // Item sizes are computed

        var cb = function cb() {
          el.scrollTop = el.scrollHeight + 5000;
          requestAnimationFrame(function () {
            el.scrollTop = el.scrollHeight + 5000;

            if (_this.$_undefinedSizes === 0) {
              _this.$_scrollingToBottom = false;
            } else {
              requestAnimationFrame(cb);
            }
          });
        };

        requestAnimationFrame(cb);
      });
    }
  }
};

/* script */
const __vue_script__$1 = script$1;

/* template */
var __vue_render__$1 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "RecycleScroller",
    _vm._g(
      _vm._b(
        {
          ref: "scroller",
          attrs: {
            items: _vm.itemsWithSize,
            "min-item-size": _vm.minItemSize,
            direction: _vm.direction,
            "key-field": "id"
          },
          on: { resize: _vm.onScrollerResize, visible: _vm.onScrollerVisible },
          scopedSlots: _vm._u(
            [
              {
                key: "default",
                fn: function(ref) {
                  var itemWithSize = ref.item;
                  var index = ref.index;
                  var active = ref.active;
                  return [
                    _vm._t("default", null, null, {
                      item: itemWithSize.item,
                      index: index,
                      active: active,
                      itemWithSize: itemWithSize
                    })
                  ]
                }
              }
            ],
            null,
            true
          )
        },
        "RecycleScroller",
        _vm.$attrs,
        false
      ),
      _vm.listeners
    ),
    [
      _vm._v(" "),
      _c("template", { slot: "before" }, [_vm._t("before")], 2),
      _vm._v(" "),
      _c("template", { slot: "after" }, [_vm._t("after")], 2)
    ],
    2
  )
};
var __vue_staticRenderFns__$1 = [];
__vue_render__$1._withStripped = true;

  /* style */
  const __vue_inject_styles__$1 = undefined;
  /* scoped */
  const __vue_scope_id__$1 = undefined;
  /* module identifier */
  const __vue_module_identifier__$1 = undefined;
  /* functional template */
  const __vue_is_functional_template__$1 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$1 = normalizeComponent(
    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
    __vue_inject_styles__$1,
    __vue_script__$1,
    __vue_scope_id__$1,
    __vue_is_functional_template__$1,
    __vue_module_identifier__$1,
    false,
    undefined,
    undefined,
    undefined
  );

var script$2 = {
  name: 'DynamicScrollerItem',
  inject: ['vscrollData', 'vscrollParent', 'vscrollResizeObserver'],
  props: {
    // eslint-disable-next-line vue/require-prop-types
    item: {
      required: true
    },
    watchData: {
      type: Boolean,
      default: false
    },

    /**
     * Indicates if the view is actively used to display an item.
     */
    active: {
      type: Boolean,
      required: true
    },
    index: {
      type: Number,
      default: undefined
    },
    sizeDependencies: {
      type: [Array, Object],
      default: null
    },
    emitResize: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: 'div'
    }
  },
  computed: {
    id: function id() {
      return this.vscrollData.simpleArray ? this.index : this.item[this.vscrollData.keyField];
    },
    size: function size() {
      return this.vscrollData.validSizes[this.id] && this.vscrollData.sizes[this.id] || 0;
    },
    finalActive: function finalActive() {
      return this.active && this.vscrollData.active;
    }
  },
  watch: {
    watchData: 'updateWatchData',
    id: function id() {
      if (!this.size) {
        this.onDataUpdate();
      }
    },
    finalActive: function finalActive(value) {
      if (!this.size) {
        if (value) {
          if (!this.vscrollParent.$_undefinedMap[this.id]) {
            this.vscrollParent.$_undefinedSizes++;
            this.vscrollParent.$_undefinedMap[this.id] = true;
          }
        } else {
          if (this.vscrollParent.$_undefinedMap[this.id]) {
            this.vscrollParent.$_undefinedSizes--;
            this.vscrollParent.$_undefinedMap[this.id] = false;
          }
        }
      }

      if (this.vscrollResizeObserver) {
        if (value) {
          this.observeSize();
        } else {
          this.unobserveSize();
        }
      } else if (value && this.$_pendingVScrollUpdate === this.id) {
        this.updateSize();
      }
    }
  },
  created: function created() {
    var _this = this;

    if (this.$isServer) return;
    this.$_forceNextVScrollUpdate = null;
    this.updateWatchData();

    if (!this.vscrollResizeObserver) {
      var _loop = function _loop(k) {
        _this.$watch(function () {
          return _this.sizeDependencies[k];
        }, _this.onDataUpdate);
      };

      for (var k in this.sizeDependencies) {
        _loop(k);
      }

      this.vscrollParent.$on('vscroll:update', this.onVscrollUpdate);
      this.vscrollParent.$on('vscroll:update-size', this.onVscrollUpdateSize);
    }
  },
  mounted: function mounted() {
    if (this.vscrollData.active) {
      this.updateSize();
      this.observeSize();
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.vscrollParent.$off('vscroll:update', this.onVscrollUpdate);
    this.vscrollParent.$off('vscroll:update-size', this.onVscrollUpdateSize);
    this.unobserveSize();
  },
  methods: {
    updateSize: function updateSize() {
      if (this.finalActive) {
        if (this.$_pendingSizeUpdate !== this.id) {
          this.$_pendingSizeUpdate = this.id;
          this.$_forceNextVScrollUpdate = null;
          this.$_pendingVScrollUpdate = null;
          this.computeSize(this.id);
        }
      } else {
        this.$_forceNextVScrollUpdate = this.id;
      }
    },
    updateWatchData: function updateWatchData() {
      var _this2 = this;

      if (this.watchData) {
        this.$_watchData = this.$watch('data', function () {
          _this2.onDataUpdate();
        }, {
          deep: true
        });
      } else if (this.$_watchData) {
        this.$_watchData();
        this.$_watchData = null;
      }
    },
    onVscrollUpdate: function onVscrollUpdate(_ref) {
      var force = _ref.force;

      // If not active, sechedule a size update when it becomes active
      if (!this.finalActive && force) {
        this.$_pendingVScrollUpdate = this.id;
      }

      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {
        this.updateSize();
      }
    },
    onDataUpdate: function onDataUpdate() {
      this.updateSize();
    },
    computeSize: function computeSize(id) {
      var _this3 = this;

      this.$nextTick(function () {
        if (_this3.id === id) {
          var width = _this3.$el.offsetWidth;
          var height = _this3.$el.offsetHeight;

          _this3.applySize(width, height);
        }

        _this3.$_pendingSizeUpdate = null;
      });
    },
    applySize: function applySize(width, height) {
      var size = Math.round(this.vscrollParent.direction === 'vertical' ? height : width);

      if (size && this.size !== size) {
        if (this.vscrollParent.$_undefinedMap[this.id]) {
          this.vscrollParent.$_undefinedSizes--;
          this.vscrollParent.$_undefinedMap[this.id] = undefined;
        }

        this.$set(this.vscrollData.sizes, this.id, size);
        this.$set(this.vscrollData.validSizes, this.id, true);
        if (this.emitResize) this.$emit('resize', this.id);
      }
    },
    observeSize: function observeSize() {
      if (!this.vscrollResizeObserver) return;
      this.vscrollResizeObserver.observe(this.$el.parentNode);
      this.$el.parentNode.addEventListener('resize', this.onResize);
    },
    unobserveSize: function unobserveSize() {
      if (!this.vscrollResizeObserver) return;
      this.vscrollResizeObserver.unobserve(this.$el.parentNode);
      this.$el.parentNode.removeEventListener('resize', this.onResize);
    },
    onResize: function onResize(event) {
      var _event$detail$content = event.detail.contentRect,
          width = _event$detail$content.width,
          height = _event$detail$content.height;
      this.applySize(width, height);
    }
  },
  render: function render(h) {
    return h(this.tag, this.$slots.default);
  }
};

/* script */
const __vue_script__$2 = script$2;

/* template */

  /* style */
  const __vue_inject_styles__$2 = undefined;
  /* scoped */
  const __vue_scope_id__$2 = undefined;
  /* module identifier */
  const __vue_module_identifier__$2 = undefined;
  /* functional template */
  const __vue_is_functional_template__$2 = undefined;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__$2 = normalizeComponent(
    {},
    __vue_inject_styles__$2,
    __vue_script__$2,
    __vue_scope_id__$2,
    __vue_is_functional_template__$2,
    __vue_module_identifier__$2,
    false,
    undefined,
    undefined,
    undefined
  );

function IdState () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$idProp = _ref.idProp,
      idProp = _ref$idProp === void 0 ? function (vm) {
    return vm.item.id;
  } : _ref$idProp;

  var store = {};
  var vm = new vue__WEBPACK_IMPORTED_MODULE_3___default.a({
    data: function data() {
      return {
        store: store
      };
    }
  }); // @vue/component

  return {
    data: function data() {
      return {
        idState: null
      };
    },
    created: function created() {
      var _this = this;

      this.$_id = null;

      if (typeof idProp === 'function') {
        this.$_getId = function () {
          return idProp.call(_this, _this);
        };
      } else {
        this.$_getId = function () {
          return _this[idProp];
        };
      }

      this.$watch(this.$_getId, {
        handler: function handler(value) {
          var _this2 = this;

          this.$nextTick(function () {
            _this2.$_id = value;
          });
        },
        immediate: true
      });
      this.$_updateIdState();
    },
    beforeUpdate: function beforeUpdate() {
      this.$_updateIdState();
    },
    methods: {
      /**
       * Initialize an idState
       * @param {number|string} id Unique id for the data
       */
      $_idStateInit: function $_idStateInit(id) {
        var factory = this.$options.idState;

        if (typeof factory === 'function') {
          var data = factory.call(this, this);
          vm.$set(store, id, data);
          this.$_id = id;
          return data;
        } else {
          throw new Error('[mixin IdState] Missing `idState` function on component definition.');
        }
      },

      /**
       * Ensure idState is created and up-to-date
       */
      $_updateIdState: function $_updateIdState() {
        var id = this.$_getId();

        if (id == null) {
          console.warn("No id found for IdState with idProp: '".concat(idProp, "'."));
        }

        if (id !== this.$_id) {
          if (!store[id]) {
            this.$_idStateInit(id);
          }

          this.idState = store[id];
        }
      }
    }
  };
}

function registerComponents(Vue, prefix) {
  Vue.component("".concat(prefix, "recycle-scroller"), __vue_component__);
  Vue.component("".concat(prefix, "RecycleScroller"), __vue_component__);
  Vue.component("".concat(prefix, "dynamic-scroller"), __vue_component__$1);
  Vue.component("".concat(prefix, "DynamicScroller"), __vue_component__$1);
  Vue.component("".concat(prefix, "dynamic-scroller-item"), __vue_component__$2);
  Vue.component("".concat(prefix, "DynamicScrollerItem"), __vue_component__$2);
}

var plugin = {
  // eslint-disable-next-line no-undef
  version: "1.0.10",
  install: function install(Vue, options) {
    var finalOptions = Object.assign({}, {
      installComponents: true,
      componentsPrefix: ''
    }, options);

    for (var key in finalOptions) {
      if (typeof finalOptions[key] !== 'undefined') {
        config[key] = finalOptions[key];
      }
    }

    if (finalOptions.installComponents) {
      registerComponents(Vue, finalOptions.componentsPrefix);
    }
  }
};

var GlobalVue = null;

if (typeof window !== 'undefined') {
  GlobalVue = window.Vue;
} else if (typeof global !== 'undefined') {
  GlobalVue = global.Vue;
}

if (GlobalVue) {
  GlobalVue.use(plugin);
}

/* unused harmony default export */ var _unused_webpack_default_export = (plugin);

//# sourceMappingURL=vue-virtual-scroller.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_165132__("c8ba")))

/***/ }),

/***/ "e53d":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "e6f3":
/***/ (function(module, exports, __nested_webpack_require_209301__) {

var has = __nested_webpack_require_209301__("07e3");
var toIObject = __nested_webpack_require_209301__("36c3");
var arrayIndexOf = __nested_webpack_require_209301__("5b4e")(false);
var IE_PROTO = __nested_webpack_require_209301__("5559")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "e853":
/***/ (function(module, exports, __nested_webpack_require_209937__) {

var isObject = __nested_webpack_require_209937__("d3f4");
var isArray = __nested_webpack_require_209937__("1169");
var SPECIES = __nested_webpack_require_209937__("2b4c")('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "ebfd":
/***/ (function(module, exports, __nested_webpack_require_210515__) {

var META = __nested_webpack_require_210515__("62a0")('meta');
var isObject = __nested_webpack_require_210515__("f772");
var has = __nested_webpack_require_210515__("07e3");
var setDesc = __nested_webpack_require_210515__("d9f6").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__nested_webpack_require_210515__("294c")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "ed83":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(this, function () {
  var regex = /(auto|scroll)/;

  var parents = function (node, ps) {
    if (node.parentNode === null) { return ps; }

    return parents(node.parentNode, ps.concat([node]));
  };

  var style = function (node, prop) {
    return getComputedStyle(node, null).getPropertyValue(prop);
  };

  var overflow = function (node) {
    return style(node, "overflow") + style(node, "overflow-y") + style(node, "overflow-x");
  };

  var scroll = function (node) {
   return regex.test(overflow(node));
  };

  var scrollParent = function (node) {
    if (!(node instanceof HTMLElement || node instanceof SVGElement)) {
      return ;
    }

    var ps = parents(node.parentNode, []);

    for (var i = 0; i < ps.length; i += 1) {
      if (scroll(ps[i])) {
        return ps[i];
      }
    }

    return document.scrollingElement || document.documentElement;
  };

  return scrollParent;
}));


/***/ }),

/***/ "f1ae":
/***/ (function(module, exports, __nested_webpack_require_213731__) {

"use strict";

var $defineProperty = __nested_webpack_require_213731__("86cc");
var createDesc = __nested_webpack_require_213731__("4630");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "f201":
/***/ (function(module, exports, __nested_webpack_require_214091__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __nested_webpack_require_214091__("e4ae");
var aFunction = __nested_webpack_require_214091__("79aa");
var SPECIES = __nested_webpack_require_214091__("5168")('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),

/***/ "f410":
/***/ (function(module, exports, __nested_webpack_require_214540__) {

__nested_webpack_require_214540__("1af6");
module.exports = __nested_webpack_require_214540__("584a").Array.isArray;


/***/ }),

/***/ "f559":
/***/ (function(module, exports, __nested_webpack_require_214713__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __nested_webpack_require_214713__("5ca1");
var toLength = __nested_webpack_require_214713__("9def");
var context = __nested_webpack_require_214713__("d2c8");
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __nested_webpack_require_214713__("5147")(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),

/***/ "f772":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "f921":
/***/ (function(module, exports, __nested_webpack_require_215741__) {

__nested_webpack_require_215741__("014b");
__nested_webpack_require_215741__("c207");
__nested_webpack_require_215741__("69d3");
__nested_webpack_require_215741__("765d");
module.exports = __nested_webpack_require_215741__("584a").Symbol;


/***/ }),

/***/ "fa5b":
/***/ (function(module, exports, __nested_webpack_require_215994__) {

module.exports = __nested_webpack_require_215994__("5537")('native-function-to-string', Function.toString);


/***/ }),

/***/ "fab2":
/***/ (function(module, exports, __nested_webpack_require_216172__) {

var document = __nested_webpack_require_216172__("7726").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "fb15":
/***/ (function(module, __webpack_exports__, __nested_webpack_require_216376__) {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_216376__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (true) {
    var getCurrentScript = __nested_webpack_require_216376__("8875")
    currentScript = getCurrentScript()

    // for backward compatibility, because previously we directly included the polyfill
    if (!('currentScript' in document)) {
      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })
    }
  }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __nested_webpack_require_216376__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e3879104-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/VuePhoneNumberInput/index.vue?vue&type=template&id=19c9a1c7&scoped=true&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"vue-phone-number-input flex",class:[{ 'dark': _vm.dark }, _vm.size],attrs:{"id":_vm.id}},[(!_vm.noCountrySelector)?_c('div',{staticClass:"select-country-container"},[_c('CountrySelector',{ref:"CountrySelector",staticClass:"input-country-selector",attrs:{"id":(_vm.uniqueId + "_country_selector"),"items":_vm.codesCountries,"countries-height":_vm.countriesHeight,"error":_vm.shouldChooseCountry,"hint":_vm.shouldChooseCountry ? _vm.t.countrySelectorError : null,"disabled":_vm.disabled,"valid":_vm.isValid && !_vm.noValidatorState,"preferred-countries":_vm.preferredCountries,"only-countries":_vm.onlyCountries,"ignored-countries":_vm.ignoredCountries,"label":_vm.t.countrySelectorLabel,"no-flags":_vm.noFlags,"show-code-on-list":_vm.showCodeOnList,"size":_vm.size,"dark":_vm.dark,"theme":_vm.theme},model:{value:(_vm.countryCode),callback:function ($$v) {_vm.countryCode=$$v},expression:"countryCode"}},[_vm._t("arrow",null,{"slot":"arrow"})],2)],1):_vm._e(),_c('div',{staticClass:"flex-1"},[_c('InputTel',_vm._b({ref:"PhoneNumberInput",staticClass:"input-phone-number",attrs:{"id":(_vm.uniqueId + "_phone_number"),"label":_vm.t.phoneNumberLabel,"hint":_vm.hintValue,"dark":_vm.dark,"disabled":_vm.disabled,"size":_vm.size,"error":_vm.error,"valid":_vm.isValid && !_vm.noValidatorState,"required":_vm.required,"no-country-selector":_vm.noCountrySelector,"theme":_vm.theme},on:{"keydown":function (e) { _vm.lastKeyPressed = e.keyCode },"focus":function($event){return _vm.$emit('phone-number-focused')},"blur":function($event){return _vm.$emit('phone-number-blur')}},model:{value:(_vm.phoneNumber),callback:function ($$v) {_vm.phoneNumber=$$v},expression:"phoneNumber"}},'InputTel',_vm.$attrs,false))],1)])}
var staticRenderFns = []


// CONCATENATED MODULE: ./src/VuePhoneNumberInput/index.vue?vue&type=template&id=19c9a1c7&scoped=true&

// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js
var es7_object_get_own_property_descriptors = __nested_webpack_require_216376__("8e6e");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js
var web_dom_iterable = __nested_webpack_require_216376__("ac6a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.iterator.js
var es6_array_iterator = __nested_webpack_require_216376__("cadf");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.keys.js
var es6_object_keys = __nested_webpack_require_216376__("456d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.to-string.js
var es6_regexp_to_string = __nested_webpack_require_216376__("6b54");

// EXTERNAL MODULE: ./node_modules/regenerator-runtime/runtime.js
var runtime = __nested_webpack_require_216376__("96cf");

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/promise.js
var promise = __nested_webpack_require_216376__("795b");
var promise_default = /*#__PURE__*/__nested_webpack_require_216376__.n(promise);

// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator.js


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    promise_default.a.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new promise_default.a(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/object/define-property.js
var define_property = __nested_webpack_require_216376__("85f2");
var define_property_default = /*#__PURE__*/__nested_webpack_require_216376__.n(define_property);

// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty.js

function _defineProperty(obj, key, value) {
  if (key in obj) {
    define_property_default()(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.number.constructor.js
var es6_number_constructor = __nested_webpack_require_216376__("c5f6");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.array.includes.js
var es7_array_includes = __nested_webpack_require_216376__("6762");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.includes.js
var es6_string_includes = __nested_webpack_require_216376__("2fdb");

// CONCATENATED MODULE: ./src/VuePhoneNumberInput/assets/js/phoneCodeCountries.js
var allCountries = [['Afghanistan (â«Ø§ÙØºØ§ÙØ³ØªØ§Ùâ¬â)', 'af', '93'], ['Albania (ShqipÃ«ri)', 'al', '355'], ['Algeria (â«Ø§ÙØ¬Ø²Ø§Ø¦Ø±â¬â)', 'dz', '213'], ['American Samoa', 'as', '1684'], ['Andorra', 'ad', '376'], ['Angola', 'ao', '244'], ['Anguilla', 'ai', '1264'], ['Antigua and Barbuda', 'ag', '1268'], ['Argentina', 'ar', '54'], ['Armenia (ÕÕ¡ÕµÕ¡Õ½Õ¿Õ¡Õ¶)', 'am', '374'], ['Aruba', 'aw', '297'], ['Australia', 'au', '61', 0], ['Austria (Ãsterreich)', 'at', '43'], ['Azerbaijan (AzÉrbaycan)', 'az', '994'], ['Bahamas', 'bs', '1242'], ['Bahrain (â«Ø§ÙØ¨Ø­Ø±ÙÙâ¬â)', 'bh', '973'], ['Bangladesh (à¦¬à¦¾à¦à¦²à¦¾à¦¦à§à¦¶)', 'bd', '880'], ['Barbados', 'bb', '1246'], ['Belarus (ÐÐµÐ»Ð°ÑÑÑÑ)', 'by', '375'], ['Belgium (BelgiÃ«)', 'be', '32'], ['Belize', 'bz', '501'], ['Benin (BÃ©nin)', 'bj', '229'], ['Bermuda', 'bm', '1441'], ['Bhutan (à½ à½à¾²à½´à½)', 'bt', '975'], ['Bolivia', 'bo', '591'], ['Bosnia and Herzegovina (ÐÐ¾ÑÐ½Ð° Ð¸ Ð¥ÐµÑÑÐµÐ³Ð¾Ð²Ð¸Ð½Ð°)', 'ba', '387'], ['Botswana', 'bw', '267'], ['Brazil (Brasil)', 'br', '55'], ['British Indian Ocean Territory', 'io', '246'], ['British Virgin Islands', 'vg', '1284'], ['Brunei', 'bn', '673'], ['Bulgaria (ÐÑÐ»Ð³Ð°ÑÐ¸Ñ)', 'bg', '359'], ['Burkina Faso', 'bf', '226'], ['Burundi (Uburundi)', 'bi', '257'], ['Cambodia (ááááá»áá¶)', 'kh', '855'], ['Cameroon (Cameroun)', 'cm', '237'], ['Canada', 'ca', '1', 1, ['204', '226', '236', '249', '250', '289', '306', '343', '365', '387', '403', '416', '418', '431', '437', '438', '450', '506', '514', '519', '548', '579', '581', '587', '604', '613', '639', '647', '672', '705', '709', '742', '778', '780', '782', '807', '819', '825', '867', '873', '902', '905']], ['Cape Verde (Kabu Verdi)', 'cv', '238'], ['Caribbean Netherlands', 'bq', '599', 1], ['Cayman Islands', 'ky', '1345'], ['Central African Republic (RÃ©publique centrafricaine)', 'cf', '236'], ['Chad (Tchad)', 'td', '235'], ['Chile', 'cl', '56'], ['China (ä¸­å½)', 'cn', '86'], ['Christmas Island', 'cx', '61', 2], ['Cocos (Keeling) Islands', 'cc', '61', 1], ['Colombia', 'co', '57'], ['Comoros (â«Ø¬Ø²Ø± Ø§ÙÙÙØ±â¬â)', 'km', '269'], ['Congo (DRC) (Jamhuri ya Kidemokrasia ya Kongo)', 'cd', '243'], ['Congo (Republic) (Congo-Brazzaville)', 'cg', '242'], ['Cook Islands', 'ck', '682'], ['Costa Rica', 'cr', '506'], ['CÃ´te dâIvoire', 'ci', '225'], ['Croatia (Hrvatska)', 'hr', '385'], ['Cuba', 'cu', '53'], ['CuraÃ§ao', 'cw', '599', 0], ['Cyprus (ÎÏÏÏÎ¿Ï)', 'cy', '357'], ['Czech Republic (ÄeskÃ¡ republika)', 'cz', '420'], ['Denmark (Danmark)', 'dk', '45'], ['Djibouti', 'dj', '253'], ['Dominica', 'dm', '1767'], ['Dominican Republic (RepÃºblica Dominicana)', 'do', '1', 2, ['809', '829', '849']], ['Ecuador', 'ec', '593'], ['Egypt (â«ÙØµØ±â¬â)', 'eg', '20'], ['El Salvador', 'sv', '503'], ['Equatorial Guinea (Guinea Ecuatorial)', 'gq', '240'], ['Eritrea', 'er', '291'], ['Estonia (Eesti)', 'ee', '372'], ['Ethiopia', 'et', '251'], ['Falkland Islands (Islas Malvinas)', 'fk', '500'], ['Faroe Islands (FÃ¸royar)', 'fo', '298'], ['Fiji', 'fj', '679'], ['Finland (Suomi)', 'fi', '358', 0], ['France', 'fr', '33'], ['French Guiana (Guyane franÃ§aise)', 'gf', '594'], ['French Polynesia (PolynÃ©sie franÃ§aise)', 'pf', '689'], ['Gabon', 'ga', '241'], ['Gambia', 'gm', '220'], ['Georgia (á¡áá¥áá ááááá)', 'ge', '995'], ['Germany (Deutschland)', 'de', '49'], ['Ghana (Gaana)', 'gh', '233'], ['Gibraltar', 'gi', '350'], ['Greece (ÎÎ»Î»Î¬Î´Î±)', 'gr', '30'], ['Greenland (Kalaallit Nunaat)', 'gl', '299'], ['Grenada', 'gd', '1473'], ['Guadeloupe', 'gp', '590', 0], ['Guam', 'gu', '1671'], ['Guatemala', 'gt', '502'], ['Guernsey', 'gg', '44', 1], ['Guinea (GuinÃ©e)', 'gn', '224'], ['Guinea-Bissau (GuinÃ© Bissau)', 'gw', '245'], ['Guyana', 'gy', '592'], ['Haiti', 'ht', '509'], ['Honduras', 'hn', '504'], ['Hong Kong (é¦æ¸¯)', 'hk', '852'], ['Hungary (MagyarorszÃ¡g)', 'hu', '36'], ['Iceland (Ãsland)', 'is', '354'], ['India (à¤­à¤¾à¤°à¤¤)', 'in', '91'], ['Indonesia', 'id', '62'], ['Iran (â«Ø§ÛØ±Ø§Ùâ¬â)', 'ir', '98'], ['Iraq (â«Ø§ÙØ¹Ø±Ø§Ùâ¬â)', 'iq', '964'], ['Ireland', 'ie', '353'], ['Isle of Man', 'im', '44', 2], ['Israel (â«××©×¨××â¬â)', 'il', '972'], ['Italy (Italia)', 'it', '39', 0], ['Jamaica', 'jm', '1876'], ['Japan (æ¥æ¬)', 'jp', '81'], ['Jersey', 'je', '44', 3], ['Jordan (â«Ø§ÙØ£Ø±Ø¯Ùâ¬â)', 'jo', '962'], ['Kazakhstan (ÐÐ°Ð·Ð°ÑÑÑÐ°Ð½)', 'kz', '7', 1], ['Kenya', 'ke', '254'], ['Kiribati', 'ki', '686'], ['Kosovo', 'xk', '383'], ['Kuwait (â«Ø§ÙÙÙÙØªâ¬â)', 'kw', '965'], ['Kyrgyzstan (ÐÑÑÐ³ÑÐ·ÑÑÐ°Ð½)', 'kg', '996'], ['Laos (àº¥àº²àº§)', 'la', '856'], ['Latvia (Latvija)', 'lv', '371'], ['Lebanon (â«ÙØ¨ÙØ§Ùâ¬â)', 'lb', '961'], ['Lesotho', 'ls', '266'], ['Liberia', 'lr', '231'], ['Libya (â«ÙÙØ¨ÙØ§â¬â)', 'ly', '218'], ['Liechtenstein', 'li', '423'], ['Lithuania (Lietuva)', 'lt', '370'], ['Luxembourg', 'lu', '352'], ['Macau (æ¾³é)', 'mo', '853'], ['Macedonia (FYROM) (ÐÐ°ÐºÐµÐ´Ð¾Ð½Ð¸ÑÐ°)', 'mk', '389'], ['Madagascar (Madagasikara)', 'mg', '261'], ['Malawi', 'mw', '265'], ['Malaysia', 'my', '60'], ['Maldives', 'mv', '960'], ['Mali', 'ml', '223'], ['Malta', 'mt', '356'], ['Marshall Islands', 'mh', '692'], ['Martinique', 'mq', '596'], ['Mauritania (â«ÙÙØ±ÙØªØ§ÙÙØ§â¬â)', 'mr', '222'], ['Mauritius (Moris)', 'mu', '230'], ['Mayotte', 'yt', '262', 1], ['Mexico (MÃ©xico)', 'mx', '52'], ['Micronesia', 'fm', '691'], ['Moldova (Republica Moldova)', 'md', '373'], ['Monaco', 'mc', '377'], ['Mongolia (ÐÐ¾Ð½Ð³Ð¾Ð»)', 'mn', '976'], ['Montenegro (Crna Gora)', 'me', '382'], ['Montserrat', 'ms', '1664'], ['Morocco (â«Ø§ÙÙØºØ±Ø¨â¬â)', 'ma', '212', 0], ['Mozambique (MoÃ§ambique)', 'mz', '258'], ['Myanmar (Burma) (áá¼ááºáá¬)', 'mm', '95'], ['Namibia (NamibiÃ«)', 'na', '264'], ['Nauru', 'nr', '674'], ['Nepal (à¤¨à¥à¤ªà¤¾à¤²)', 'np', '977'], ['Netherlands (Nederland)', 'nl', '31'], ['New Caledonia (Nouvelle-CalÃ©donie)', 'nc', '687'], ['New Zealand', 'nz', '64'], ['Nicaragua', 'ni', '505'], ['Niger (Nijar)', 'ne', '227'], ['Nigeria', 'ng', '234'], ['Niue', 'nu', '683'], ['Norfolk Island', 'nf', '672'], ['North Korea (ì¡°ì  ë¯¼ì£¼ì£¼ì ì¸ë¯¼ ê³µíêµ­)', 'kp', '850'], ['Northern Mariana Islands', 'mp', '1670'], ['Norway (Norge)', 'no', '47', 0], ['Oman (â«Ø¹ÙÙØ§Ùâ¬â)', 'om', '968'], ['Pakistan (â«Ù¾Ø§Ú©Ø³ØªØ§Ùâ¬â)', 'pk', '92'], ['Palau', 'pw', '680'], ['Palestine (â«ÙÙØ³Ø·ÙÙâ¬â)', 'ps', '970'], ['Panama (PanamÃ¡)', 'pa', '507'], ['Papua New Guinea', 'pg', '675'], ['Paraguay', 'py', '595'], ['Peru (PerÃº)', 'pe', '51'], ['Philippines', 'ph', '63'], ['Poland (Polska)', 'pl', '48'], ['Portugal', 'pt', '351'], ['Puerto Rico', 'pr', '1', 3, ['787', '939']], ['Qatar (â«ÙØ·Ø±â¬â)', 'qa', '974'], ['RÃ©union (La RÃ©union)', 're', '262', 0], ['Romania (RomÃ¢nia)', 'ro', '40'], ['Russia (Ð Ð¾ÑÑÐ¸Ñ)', 'ru', '7', 0], ['Rwanda', 'rw', '250'], ['Saint BarthÃ©lemy', 'bl', '590', 1], ['Saint Helena', 'sh', '290'], ['Saint Kitts and Nevis', 'kn', '1869'], ['Saint Lucia', 'lc', '1758'], ['Saint Martin (Saint-Martin (partie franÃ§aise))', 'mf', '590', 2], ['Saint Pierre and Miquelon (Saint-Pierre-et-Miquelon)', 'pm', '508'], ['Saint Vincent and the Grenadines', 'vc', '1784'], ['Samoa', 'ws', '685'], ['San Marino', 'sm', '378'], ['SÃ£o TomÃ© and PrÃ­ncipe (SÃ£o TomÃ© e PrÃ­ncipe)', 'st', '239'], ['Saudi Arabia (â«Ø§ÙÙÙÙÙØ© Ø§ÙØ¹Ø±Ø¨ÙØ© Ø§ÙØ³Ø¹ÙØ¯ÙØ©â¬â)', 'sa', '966'], ['Senegal (SÃ©nÃ©gal)', 'sn', '221'], ['Serbia (Ð¡ÑÐ±Ð¸ÑÐ°)', 'rs', '381'], ['Seychelles', 'sc', '248'], ['Sierra Leone', 'sl', '232'], ['Singapore', 'sg', '65'], ['Sint Maarten', 'sx', '1721'], ['Slovakia (Slovensko)', 'sk', '421'], ['Slovenia (Slovenija)', 'si', '386'], ['Solomon Islands', 'sb', '677'], ['Somalia (Soomaaliya)', 'so', '252'], ['South Africa', 'za', '27'], ['South Korea (ëíë¯¼êµ­)', 'kr', '82'], ['South Sudan (â«Ø¬ÙÙØ¨ Ø§ÙØ³ÙØ¯Ø§Ùâ¬â)', 'ss', '211'], ['Spain (EspaÃ±a)', 'es', '34'], ['Sri Lanka (à·à·âà¶»à· à¶½à¶à¶à·à·)', 'lk', '94'], ['Sudan (â«Ø§ÙØ³ÙØ¯Ø§Ùâ¬â)', 'sd', '249'], ['Suriname', 'sr', '597'], ['Svalbard and Jan Mayen', 'sj', '47', 1], ['Swaziland', 'sz', '268'], ['Sweden (Sverige)', 'se', '46'], ['Switzerland (Schweiz)', 'ch', '41'], ['Syria (â«Ø³ÙØ±ÙØ§â¬â)', 'sy', '963'], ['Taiwan (å°ç£)', 'tw', '886'], ['Tajikistan', 'tj', '992'], ['Tanzania', 'tz', '255'], ['Thailand (à¹à¸à¸¢)', 'th', '66'], ['Timor-Leste', 'tl', '670'], ['Togo', 'tg', '228'], ['Tokelau', 'tk', '690'], ['Tonga', 'to', '676'], ['Trinidad and Tobago', 'tt', '1868'], ['Tunisia (â«ØªÙÙØ³â¬â)', 'tn', '216'], ['Turkey (TÃ¼rkiye)', 'tr', '90'], ['Turkmenistan', 'tm', '993'], ['Turks and Caicos Islands', 'tc', '1649'], ['Tuvalu', 'tv', '688'], ['U.S. Virgin Islands', 'vi', '1340'], ['Uganda', 'ug', '256'], ['Ukraine (Ð£ÐºÑÐ°ÑÐ½Ð°)', 'ua', '380'], ['United Arab Emirates (â«Ø§ÙØ¥ÙØ§Ø±Ø§Øª Ø§ÙØ¹Ø±Ø¨ÙØ© Ø§ÙÙØªØ­Ø¯Ø©â¬â)', 'ae', '971'], ['United Kingdom', 'gb', '44', 0], ['United States', 'us', '1', 0], ['Uruguay', 'uy', '598'], ['Uzbekistan (OÊ»zbekiston)', 'uz', '998'], ['Vanuatu', 'vu', '678'], ['Vatican City (CittÃ  del Vaticano)', 'va', '39', 1], ['Venezuela', 've', '58'], ['Vietnam (Viá»t Nam)', 'vn', '84'], ['Wallis and Futuna (Wallis-et-Futuna)', 'wf', '681'], ['Western Sahara (â«Ø§ÙØµØ­Ø±Ø§Ø¡ Ø§ÙØºØ±Ø¨ÙØ©â¬â)', 'eh', '212', 1], ['Yemen (â«Ø§ÙÙÙÙâ¬â)', 'ye', '967'], ['Zambia', 'zm', '260'], ['Zimbabwe', 'zw', '263'], ['Ãland Islands', 'ax', '358', 1]];
var countriesIso = allCountries.map(function (country) {
  return country[1].toUpperCase();
});
var countries = allCountries.map(function (country) {
  return {
    name: country[0],
    iso2: country[1].toUpperCase(),
    dialCode: country[2],
    priority: country[3] || 0,
    areaCodes: country[4] || null
  };
});
// EXTERNAL MODULE: ./node_modules/libphonenumber-js/examples.mobile.json
var examples_mobile = __nested_webpack_require_216376__("d391");

// CONCATENATED MODULE: ./node_modules/libphonenumber-js/metadata.min.json.js
// This file is a workaround for a bug in web browsers' "native"
// ES6 importing system which is uncapable of importing "*.json" files.
// https://github.com/catamphetamine/libphonenumber-js/issues/239
/* harmony default export */ var metadata_min_json = ({"version":"1.7.51","country_calling_codes":{"1":["US","AG","AI","AS","BB","BM","BS","CA","DM","DO","GD","GU","JM","KN","KY","LC","MP","MS","PR","SX","TC","TT","VC","VG","VI"],"7":["RU","KZ"],"20":["EG"],"27":["ZA"],"30":["GR"],"31":["NL"],"32":["BE"],"33":["FR"],"34":["ES"],"36":["HU"],"39":["IT","VA"],"40":["RO"],"41":["CH"],"43":["AT"],"44":["GB","GG","IM","JE"],"45":["DK"],"46":["SE"],"47":["NO","SJ"],"48":["PL"],"49":["DE"],"51":["PE"],"52":["MX"],"53":["CU"],"54":["AR"],"55":["BR"],"56":["CL"],"57":["CO"],"58":["VE"],"60":["MY"],"61":["AU","CC","CX"],"62":["ID"],"63":["PH"],"64":["NZ"],"65":["SG"],"66":["TH"],"81":["JP"],"82":["KR"],"84":["VN"],"86":["CN"],"90":["TR"],"91":["IN"],"92":["PK"],"93":["AF"],"94":["LK"],"95":["MM"],"98":["IR"],"211":["SS"],"212":["MA","EH"],"213":["DZ"],"216":["TN"],"218":["LY"],"220":["GM"],"221":["SN"],"222":["MR"],"223":["ML"],"224":["GN"],"225":["CI"],"226":["BF"],"227":["NE"],"228":["TG"],"229":["BJ"],"230":["MU"],"231":["LR"],"232":["SL"],"233":["GH"],"234":["NG"],"235":["TD"],"236":["CF"],"237":["CM"],"238":["CV"],"239":["ST"],"240":["GQ"],"241":["GA"],"242":["CG"],"243":["CD"],"244":["AO"],"245":["GW"],"246":["IO"],"247":["AC"],"248":["SC"],"249":["SD"],"250":["RW"],"251":["ET"],"252":["SO"],"253":["DJ"],"254":["KE"],"255":["TZ"],"256":["UG"],"257":["BI"],"258":["MZ"],"260":["ZM"],"261":["MG"],"262":["RE","YT"],"263":["ZW"],"264":["NA"],"265":["MW"],"266":["LS"],"267":["BW"],"268":["SZ"],"269":["KM"],"290":["SH","TA"],"291":["ER"],"297":["AW"],"298":["FO"],"299":["GL"],"350":["GI"],"351":["PT"],"352":["LU"],"353":["IE"],"354":["IS"],"355":["AL"],"356":["MT"],"357":["CY"],"358":["FI","AX"],"359":["BG"],"370":["LT"],"371":["LV"],"372":["EE"],"373":["MD"],"374":["AM"],"375":["BY"],"376":["AD"],"377":["MC"],"378":["SM"],"380":["UA"],"381":["RS"],"382":["ME"],"383":["XK"],"385":["HR"],"386":["SI"],"387":["BA"],"389":["MK"],"420":["CZ"],"421":["SK"],"423":["LI"],"500":["FK"],"501":["BZ"],"502":["GT"],"503":["SV"],"504":["HN"],"505":["NI"],"506":["CR"],"507":["PA"],"508":["PM"],"509":["HT"],"590":["GP","BL","MF"],"591":["BO"],"592":["GY"],"593":["EC"],"594":["GF"],"595":["PY"],"596":["MQ"],"597":["SR"],"598":["UY"],"599":["CW","BQ"],"670":["TL"],"672":["NF"],"673":["BN"],"674":["NR"],"675":["PG"],"676":["TO"],"677":["SB"],"678":["VU"],"679":["FJ"],"680":["PW"],"681":["WF"],"682":["CK"],"683":["NU"],"685":["WS"],"686":["KI"],"687":["NC"],"688":["TV"],"689":["PF"],"690":["TK"],"691":["FM"],"692":["MH"],"850":["KP"],"852":["HK"],"853":["MO"],"855":["KH"],"856":["LA"],"880":["BD"],"886":["TW"],"960":["MV"],"961":["LB"],"962":["JO"],"963":["SY"],"964":["IQ"],"965":["KW"],"966":["SA"],"967":["YE"],"968":["OM"],"970":["PS"],"971":["AE"],"972":["IL"],"973":["BH"],"974":["QA"],"975":["BT"],"976":["MN"],"977":["NP"],"992":["TJ"],"993":["TM"],"994":["AZ"],"995":["GE"],"996":["KG"],"998":["UZ"]},"countries":{"AC":["247","00","(?:[01589]\\d|[46])\\d{4}",[5,6]],"AD":["376","00","(?:1|6\\d)\\d{7}|[135-9]\\d{5}",[6,8,9],[["(\\d{3})(\\d{3})","$1 $2",["[135-9]"]],["(\\d{4})(\\d{4})","$1 $2",["1"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6"]]]],"AE":["971","00","(?:[4-7]\\d|9[0-689])\\d{7}|800\\d{2,9}|[2-4679]\\d{7}",[5,6,7,8,9,10,11,12],[["(\\d{3})(\\d{2,9})","$1 $2",["60|8"]],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[236]|[479][2-8]"],"0$1"],["(\\d{3})(\\d)(\\d{5})","$1 $2 $3",["[479]"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["5"],"0$1"]],"0"],"AF":["93","00","[2-7]\\d{8}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[2-7]"],"0$1"]],"0"],"AG":["1","011","(?:268|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([457]\\d{6})$","268$1",0,"268"],"AI":["1","011","(?:264|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2457]\\d{6})$","264$1",0,"264"],"AL":["355","00","(?:700\\d\\d|900)\\d{3}|8\\d{5,7}|(?:[2-5]|6\\d)\\d{7}",[6,7,8,9],[["(\\d{3})(\\d{3,4})","$1 $2",["80|9"],"0$1"],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["4[2-6]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[2358][2-5]|4"],"0$1"],["(\\d{3})(\\d{5})","$1 $2",["[23578]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["6"],"0$1"]],"0"],"AM":["374","00","(?:[1-489]\\d|55|60|77)\\d{6}",[8],[["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[89]0"],"0 $1"],["(\\d{3})(\\d{5})","$1 $2",["2|3[12]"],"(0$1)"],["(\\d{2})(\\d{6})","$1 $2",["1|47"],"(0$1)"],["(\\d{2})(\\d{6})","$1 $2",["[3-9]"],"0$1"]],"0"],"AO":["244","00","[29]\\d{8}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[29]"]]]],"AR":["54","00","11\\d{8}|(?:[2368]|9\\d)\\d{9}",[10,11],[["(\\d{4})(\\d{2})(\\d{4})","$1 $2-$3",["2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9])","2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8]))|2(?:2[24-9]|3[1-59]|47)","2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5[56][46]|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]","2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|58|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|54(?:4|5[13-7]|6[89])|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:454|85[56])[46]|3(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"],"0$1",1],["(\\d{2})(\\d{4})(\\d{4})","$1 $2-$3",["1"],"0$1",1],["(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["[68]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2-$3",["[23]"],"0$1",1],["(\\d)(\\d{4})(\\d{2})(\\d{4})","$2 15-$3-$4",["9(?:2[2-469]|3[3-578])","9(?:2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9]))","9(?:2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8])))|92(?:2[24-9]|3[1-59]|47)","9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5(?:[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]","9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|5(?:4(?:4|5[13-7]|6[89])|[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"],"0$1",0,"$1 $2 $3-$4"],["(\\d)(\\d{2})(\\d{4})(\\d{4})","$2 15-$3-$4",["91"],"0$1",0,"$1 $2 $3-$4"],["(\\d)(\\d{3})(\\d{3})(\\d{4})","$2 15-$3-$4",["9"],"0$1",0,"$1 $2 $3-$4"]],"0",0,"0?(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1267])|3(?:02?|1[467]|2[03-6]|3[13-8]|[49][2-6]|5[2-8]|[67])|4(?:7[3-578]|9)|6(?:[0136]|2[24-6]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\d|3[1-6]|4[02568]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|6|8[2578])|4(?:0[0-24-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6[02-9]|7[126]|8[2379]?|9[1-36-8])|5(?:1|2[1245]|3[237]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:[069]|1[1568]|2[15]|3[145]|4[13]|5[14-8]|7[2-57]|8[126])|8(?:[01]|2[15-7]|3[2578]?|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))15)?","9$1"],"AS":["1","011","(?:[58]\\d\\d|684|900)\\d{7}",[10],0,"1",0,"1|([267]\\d{6})$","684$1",0,"684"],"AT":["43","00","1\\d{3,12}|2\\d{6,12}|43(?:(?:0\\d|5[02-9])\\d{3,9}|2\\d{4,5}|[3467]\\d{4}|8\\d{4,6}|9\\d{4,7})|5\\d{4,12}|8\\d{7,12}|9\\d{8,12}|(?:[367]\\d|4[0-24-9])\\d{4,11}",[4,5,6,7,8,9,10,11,12,13],[["(\\d)(\\d{3,12})","$1 $2",["1(?:11|[2-9])"],"0$1"],["(\\d{3})(\\d{2})","$1 $2",["517"],"0$1"],["(\\d{2})(\\d{3,5})","$1 $2",["5[079]"],"0$1"],["(\\d{3})(\\d{3,10})","$1 $2",["(?:31|4)6|51|6(?:5[0-3579]|[6-9])|7(?:20|32|8)|[89]"],"0$1"],["(\\d{4})(\\d{3,9})","$1 $2",["[2-467]|5[2-6]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["5"],"0$1"],["(\\d{2})(\\d{4})(\\d{4,7})","$1 $2 $3",["5"],"0$1"]],"0"],"AU":["61","001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011","1(?:[0-79]\\d{7,8}|8[0-24-9]\\d{7})|(?:[2-478]\\d\\d|550)\\d{6}|1\\d{4,7}",[5,6,7,8,9,10],[["(\\d{2})(\\d{3,4})","$1 $2",["16"],"0$1"],["(\\d{2})(\\d{3})(\\d{2,4})","$1 $2 $3",["16"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["14|[45]"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["[2378]"],"(0$1)"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1(?:30|[89])"]]],"0",0,"0|(183[12])",0,0,0,[["(?:[237]\\d{5}|8(?:51(?:0(?:0[03-9]|[1247]\\d|3[2-9]|5[0-8]|6[1-9]|8[0-6])|1(?:1[69]|[23]\\d|4[0-4]))|(?:[6-8]\\d{3}|9(?:[02-9]\\d\\d|1(?:[0-57-9]\\d|6[0135-9])))\\d))\\d{3}",[9]],["4(?:83[0-38]|93[01])\\d{5}|4(?:[0-3]\\d|4[047-9]|5[0-25-9]|6[06-9]|7[02-9]|8[0-2457-9]|9[0-27-9])\\d{6}",[9]],["180(?:0\\d{3}|2)\\d{3}",[7,10]],["190[0-26]\\d{6}",[10]],0,0,0,["16\\d{3,7}",[5,6,7,8,9]],["(?:14(?:5(?:1[0458]|[23][458])|71\\d)|550\\d\\d)\\d{4}",[9]],["13(?:00\\d{3}|45[0-4])\\d{3}|13\\d{4}",[6,8,10]]],"0011"],"AW":["297","00","(?:[25-79]\\d\\d|800)\\d{4}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[25-9]"]]]],"AX":["358","00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))","2\\d{4,9}|35\\d{4,5}|(?:60\\d\\d|800)\\d{4,6}|7\\d{5,11}|(?:[14]\\d|3[0-46-9]|50)\\d{4,8}",[5,6,7,8,9,10,11,12],0,"0",0,0,0,0,"18",0,"00"],"AZ":["994","00","365\\d{6}|(?:[124579]\\d|60|88)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["90"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[28]|2|365|46","1[28]|2|365|46","1[28]|2|365(?:[0-46-9]|5[0-35-9])|46"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[13-9]"],"0$1"]],"0"],"BA":["387","00","6\\d{8}|(?:[35689]\\d|49|70)\\d{6}",[8,9],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["6[1-3]|[7-9]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2-$3",["[3-5]|6[56]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["6"],"0$1"]],"0"],"BB":["1","011","(?:246|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2-9]\\d{6})$","246$1",0,"246"],"BD":["880","00","1\\d{9}|2\\d{7,8}|88\\d{4,6}|(?:8[0-79]|9\\d)\\d{4,8}|(?:[346]\\d|[57])\\d{5,8}",[6,7,8,9,10],[["(\\d{2})(\\d{4,6})","$1-$2",["31[5-8]|[459]1"],"0$1"],["(\\d{3})(\\d{3,7})","$1-$2",["3(?:[67]|8[013-9])|4(?:6[168]|7|[89][18])|5(?:6[128]|9)|6(?:28|4[14]|5)|7[2-589]|8(?:0[014-9]|[12])|9[358]|(?:3[2-5]|4[235]|5[2-578]|6[0389]|76|8[3-7]|9[24])1|(?:44|66)[01346-9]"],"0$1"],["(\\d{4})(\\d{3,6})","$1-$2",["[13-9]"],"0$1"],["(\\d)(\\d{7,8})","$1-$2",["2"],"0$1"]],"0"],"BE":["32","00","4\\d{8}|[1-9]\\d{7}",[8,9],[["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["(?:80|9)0"],"0$1"],["(\\d)(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[239]|4[23]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[15-8]"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["4"],"0$1"]],"0"],"BF":["226","00","[025-7]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[025-7]"]]]],"BG":["359","00","[2-7]\\d{6,7}|[89]\\d{6,8}|2\\d{5}",[6,7,8,9],[["(\\d)(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["2"],"0$1"],["(\\d{3})(\\d{4})","$1 $2",["43[1-6]|70[1-9]"],"0$1"],["(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{2,3})","$1 $2 $3",["[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]"],"0$1"],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["(?:70|8)0"],"0$1"],["(\\d{3})(\\d{3})(\\d{2})","$1 $2 $3",["43[1-7]|7"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[48]|9[08]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"],"0$1"]],"0"],"BH":["973","00","[136-9]\\d{7}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[13679]|8[047]"]]]],"BI":["257","00","(?:[267]\\d|31)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2367]"]]]],"BJ":["229","00","(?:[2689]\\d|51)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[25689]"]]]],"BL":["590","00","(?:590|69\\d|976)\\d{6}",[9],0,"0",0,0,0,0,0,[["590(?:2[7-9]|5[12]|87)\\d{4}"],["69(?:0\\d\\d|1(?:2[29]|3[0-5]))\\d{4}"],0,0,0,0,0,0,["976[01]\\d{5}"]]],"BM":["1","011","(?:441|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2-8]\\d{6})$","441$1",0,"441"],"BN":["673","00","[2-578]\\d{6}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-578]"]]]],"BO":["591","00(?:1\\d)?","(?:[2-467]\\d\\d|8001)\\d{5}",[8,9],[["(\\d)(\\d{7})","$1 $2",["[23]|4[46]"]],["(\\d{8})","$1",["[67]"]],["(\\d{3})(\\d{2})(\\d{4})","$1 $2 $3",["8"]]],"0",0,"0(1\\d)?"],"BQ":["599","00","(?:[34]1|7\\d)\\d{5}",[7],0,0,0,0,0,0,"[347]"],"BR":["55","00(?:1[245]|2[1-35]|31|4[13]|[56]5|99)","(?:[1-46-9]\\d\\d|5(?:[0-46-9]\\d|5[0-24679]))\\d{8}|[1-9]\\d{9}|[3589]\\d{8}|[34]\\d{7}",[8,9,10,11],[["(\\d{4})(\\d{4})","$1-$2",["300|4(?:0[02]|37)","4(?:02|37)0|[34]00"]],["(\\d{3})(\\d{2,3})(\\d{4})","$1 $2 $3",["(?:[358]|90)0"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1 $2-$3",["(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-57]"],"($1)"],["(\\d{2})(\\d{5})(\\d{4})","$1 $2-$3",["[16][1-9]|[2-57-9]"],"($1)"]],"0",0,"0(?:(1[245]|2[1-35]|31|4[13]|[56]5|99)(\\d{10,11}))?","$2"],"BS":["1","011","(?:242|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([3-8]\\d{6})$","242$1",0,"242"],"BT":["975","00","[17]\\d{7}|[2-8]\\d{6}",[7,8],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[2-68]|7[246]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[67]|7"]]]],"BW":["267","00","90\\d{5}|(?:[2-6]|7\\d)\\d{6}",[7,8],[["(\\d{2})(\\d{5})","$1 $2",["90"]],["(\\d{3})(\\d{4})","$1 $2",["[2-6]"]],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["7"]]]],"BY":["375","810","(?:[12]\\d|33|44|902)\\d{7}|8(?:0[0-79]\\d{5,7}|[1-7]\\d{9})|8(?:1[0-489]|[5-79]\\d)\\d{7}|8[1-79]\\d{6,7}|8[0-79]\\d{5}|8\\d{5}",[6,7,8,9,10,11],[["(\\d{3})(\\d{3})","$1 $2",["800"],"8 $1"],["(\\d{3})(\\d{2})(\\d{2,4})","$1 $2 $3",["800"],"8 $1"],["(\\d{4})(\\d{2})(\\d{3})","$1 $2-$3",["1(?:5[169]|6[3-5]|7[179])|2(?:1[35]|2[34]|3[3-5])","1(?:5[169]|6(?:3[1-3]|4|5[125])|7(?:1[3-9]|7[0-24-6]|9[2-7]))|2(?:1[35]|2[34]|3[3-5])"],"8 0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2-$3-$4",["1(?:[56]|7[467])|2[1-3]"],"8 0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2-$3-$4",["[1-4]"],"8 0$1"],["(\\d{3})(\\d{3,4})(\\d{4})","$1 $2 $3",["[89]"],"8 $1"]],"8",0,"0|80?",0,0,0,0,"8~10"],"BZ":["501","00","(?:0800\\d|[2-8])\\d{6}",[7,11],[["(\\d{3})(\\d{4})","$1-$2",["[2-8]"]],["(\\d)(\\d{3})(\\d{4})(\\d{3})","$1-$2-$3-$4",["0"]]]],"CA":["1","011","(?:[2-8]\\d|90)\\d{8}",[10],0,"1",0,0,0,0,0,[["(?:2(?:04|[23]6|[48]9|50)|3(?:06|43|6[57])|4(?:03|1[68]|3[178]|50)|5(?:06|1[49]|48|79|8[17])|6(?:04|13|39|47|72)|7(?:0[59]|78|8[02])|8(?:[06]7|19|25|73)|90[25])[2-9]\\d{6}"],[""],["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"],["900[2-9]\\d{6}"],["52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|(?:5(?:00|2[12]|33|44|66|77|88)|622)[2-9]\\d{6}"],0,0,0,["600[2-9]\\d{6}"]]],"CC":["61","001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011","1(?:[0-79]\\d|8[0-24-9])\\d{7}|(?:[148]\\d\\d|550)\\d{6}|1\\d{5,7}",[6,7,8,9,10],0,"0",0,"0|([59]\\d{7})$","8$1",0,0,[["8(?:51(?:0(?:02|31|60)|118)|91(?:0(?:1[0-2]|29)|1(?:[28]2|50|79)|2(?:10|64)|3(?:[06]8|22)|4[29]8|62\\d|70[23]|959))\\d{3}",[9]],["4(?:83[0-38]|93[01])\\d{5}|4(?:[0-3]\\d|4[047-9]|5[0-25-9]|6[06-9]|7[02-9]|8[0-2457-9]|9[0-27-9])\\d{6}",[9]],["180(?:0\\d{3}|2)\\d{3}",[7,10]],["190[0-26]\\d{6}",[10]],0,0,0,0,["(?:14(?:5(?:1[0458]|[23][458])|71\\d)|550\\d\\d)\\d{4}",[9]],["13(?:00\\d{3}|45[0-4])\\d{3}|13\\d{4}",[6,8,10]]],"0011"],"CD":["243","00","[189]\\d{8}|[1-68]\\d{6}",[7,9],[["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["88"],"0$1"],["(\\d{2})(\\d{5})","$1 $2",["[1-6]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[89]"],"0$1"]],"0"],"CF":["236","00","(?:[27]\\d{3}|8776)\\d{4}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[278]"]]]],"CG":["242","00","222\\d{6}|(?:0\\d|80)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["801"]],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["8"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[02]"]]]],"CH":["41","00","8\\d{11}|[2-9]\\d{8}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8[047]|90"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-79]|81"],"0$1"],["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["8"],"0$1"]],"0"],"CI":["225","00","[02-9]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[02-9]"]]]],"CK":["682","00","[2-578]\\d{4}",[5],[["(\\d{2})(\\d{3})","$1 $2",["[2-578]"]]]],"CL":["56","(?:0|1(?:1[0-69]|2[02-5]|5[13-58]|69|7[0167]|8[018]))0","12300\\d{6}|6\\d{9,10}|[2-9]\\d{8}",[9,10,11],[["(\\d{5})(\\d{4})","$1 $2",["219","2196"],"($1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["44"]],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["2[1-3]"],"($1)"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["9[2-9]"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["3[2-5]|[47]|5[1-3578]|6[13-57]|8(?:0[1-9]|[1-9])"],"($1)"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["60|8"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]],["(\\d{3})(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3 $4",["60"]]]],"CM":["237","00","(?:[26]\\d\\d|88)\\d{6}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["88"]],["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["[26]"]]]],"CN":["86","00|1(?:[12]\\d|79)\\d\\d00","1[127]\\d{8,9}|2\\d{9}(?:\\d{2})?|[12]\\d{6,7}|86\\d{6}|(?:1[03-689]\\d|6)\\d{7,9}|(?:[3-579]\\d|8[0-57-9])\\d{6,9}",[7,8,9,10,11,12],[["(\\d{2})(\\d{5,6})","$1 $2",["(?:10|2[0-57-9])[19]","(?:10|2[0-57-9])(?:10|9[56])","(?:10|2[0-57-9])(?:100|9[56])"],"0$1"],["(\\d{3})(\\d{5,6})","$1 $2",["3(?:[157]|35|49|9[1-68])|4(?:[17]|2[179]|6[47-9]|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])|(?:4[35]|59|85)[1-9]","(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))[19]","85[23](?:10|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:10|9[56])","85[23](?:100|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:100|9[56])"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["(?:4|80)0"]],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["10|2(?:[02-57-9]|1[1-9])","10|2(?:[02-57-9]|1[1-9])","10[0-79]|2(?:[02-57-9]|1[1-79])|(?:10|21)8(?:0[1-9]|[1-9])"],"0$1",1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["3(?:[3-59]|7[02-68])|4(?:[26-8]|3[3-9]|5[2-9])|5(?:3[03-9]|[468]|7[028]|9[2-46-9])|6|7(?:[0-247]|3[04-9]|5[0-4689]|6[2368])|8(?:[1-358]|9[1-7])|9(?:[013479]|5[1-5])|(?:[34]1|55|79|87)[02-9]"],"0$1",1],["(\\d{3})(\\d{7,8})","$1 $2",["9"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["80"],"0$1",1],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["[3-578]"],"0$1",1],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["1[3-9]"]],["(\\d{2})(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3 $4",["[12]"],"0$1",1]],"0",0,"0|(1(?:[12]\\d|79)\\d\\d)",0,0,0,0,"00"],"CO":["57","00(?:4(?:[14]4|56)|[579])","(?:1\\d|3)\\d{9}|[124-8]\\d{7}",[8,10,11],[["(\\d)(\\d{7})","$1 $2",["[14][2-9]|[25-8]"],"($1)"],["(\\d{3})(\\d{7})","$1 $2",["3"]],["(\\d)(\\d{3})(\\d{7})","$1-$2-$3",["1"],"0$1",0,"$1 $2 $3"]],"0",0,"0([3579]|4(?:[14]4|56))?"],"CR":["506","00","(?:8\\d|90)\\d{8}|(?:[24-8]\\d{3}|3005)\\d{4}",[8,10],[["(\\d{4})(\\d{4})","$1 $2",["[2-7]|8[3-9]"]],["(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["[89]"]]],0,0,"(19(?:0[0-2468]|1[09]|20|66|77|99))"],"CU":["53","119","[27]\\d{6,7}|[34]\\d{5,7}|(?:5|8\\d\\d)\\d{7}",[6,7,8,10],[["(\\d{2})(\\d{4,6})","$1 $2",["2[1-4]|[34]"],"(0$1)"],["(\\d)(\\d{6,7})","$1 $2",["7"],"(0$1)"],["(\\d)(\\d{7})","$1 $2",["5"],"0$1"],["(\\d{3})(\\d{7})","$1 $2",["8"],"0$1"]],"0"],"CV":["238","0","(?:[2-59]\\d\\d|800)\\d{4}",[7],[["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[2-589]"]]]],"CW":["599","00","(?:[34]1|60|(?:7|9\\d)\\d)\\d{5}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["[3467]"]],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["9[4-8]"]]],0,0,0,0,0,"[69]"],"CX":["61","001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011","1(?:[0-79]\\d|8[0-24-9])\\d{7}|(?:[148]\\d\\d|550)\\d{6}|1\\d{5,7}",[6,7,8,9,10],0,"0",0,"0|([59]\\d{7})$","8$1",0,0,[["8(?:51(?:0(?:01|30|59)|117)|91(?:00[6-9]|1(?:[28]1|49|78)|2(?:09|63)|3(?:12|26|75)|4(?:56|97)|64\\d|7(?:0[01]|1[0-2])|958))\\d{3}",[9]],["4(?:83[0-38]|93[01])\\d{5}|4(?:[0-3]\\d|4[047-9]|5[0-25-9]|6[06-9]|7[02-9]|8[0-2457-9]|9[0-27-9])\\d{6}",[9]],["180(?:0\\d{3}|2)\\d{3}",[7,10]],["190[0-26]\\d{6}",[10]],0,0,0,0,["(?:14(?:5(?:1[0458]|[23][458])|71\\d)|550\\d\\d)\\d{4}",[9]],["13(?:00\\d{3}|45[0-4])\\d{3}|13\\d{4}",[6,8,10]]],"0011"],"CY":["357","00","(?:[279]\\d|[58]0)\\d{6}",[8],[["(\\d{2})(\\d{6})","$1 $2",["[257-9]"]]]],"CZ":["420","00","(?:[2-578]\\d|60)\\d{7}|9\\d{8,11}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[2-8]|9[015-7]"]],["(\\d{2})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["9"]],["(\\d{3})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["9"]]]],"DE":["49","00","[2579]\\d{5,14}|49(?:[05]\\d{10}|[46][1-8]\\d{4,9})|49(?:[0-25]\\d|3[1-689]|7[1-7])\\d{4,8}|49(?:[0-2579]\\d|[34][1-9]|6[0-8])\\d{3}|49\\d{3,4}|(?:1|[368]\\d|4[0-8])\\d{3,13}",[4,5,6,7,8,9,10,11,12,13,14,15],[["(\\d{2})(\\d{3,13})","$1 $2",["3[02]|40|[68]9"],"0$1"],["(\\d{3})(\\d{3,12})","$1 $2",["2(?:0[1-389]|1[124]|2[18]|3[14])|3(?:[35-9][15]|4[015])|906|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1","2(?:0[1-389]|12[0-8])|3(?:[35-9][15]|4[015])|906|2(?:[13][14]|2[18])|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1"],"0$1"],["(\\d{4})(\\d{2,11})","$1 $2",["[24-6]|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]","[24-6]|3(?:3(?:0[1-467]|2[127-9]|3[124578]|7[1257-9]|8[1256]|9[145])|4(?:2[135]|4[13578]|9[1346])|5(?:0[14]|2[1-3589]|6[1-4]|7[13468]|8[13568])|6(?:2[1-489]|3[124-6]|6[13]|7[12579]|8[1-356]|9[135])|7(?:2[1-7]|4[145]|6[1-5]|7[1-4])|8(?:21|3[1468]|6|7[1467]|8[136])|9(?:0[12479]|2[1358]|4[134679]|6[1-9]|7[136]|8[147]|9[1468]))|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]|3[68]4[1347]|3(?:47|60)[1356]|3(?:3[46]|46|5[49])[1246]|3[4579]3[1357]"],"0$1"],["(\\d{3})(\\d{4})","$1 $2",["138"],"0$1"],["(\\d{5})(\\d{2,10})","$1 $2",["3"],"0$1"],["(\\d{3})(\\d{5,11})","$1 $2",["181"],"0$1"],["(\\d{3})(\\d)(\\d{4,10})","$1 $2 $3",["1(?:3|80)|9"],"0$1"],["(\\d{3})(\\d{7,8})","$1 $2",["1[67]"],"0$1"],["(\\d{3})(\\d{7,12})","$1 $2",["8"],"0$1"],["(\\d{5})(\\d{6})","$1 $2",["185","1850","18500"],"0$1"],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["7"],"0$1"],["(\\d{4})(\\d{7})","$1 $2",["18[68]"],"0$1"],["(\\d{5})(\\d{6})","$1 $2",["15[0568]"],"0$1"],["(\\d{4})(\\d{7})","$1 $2",["15[1279]"],"0$1"],["(\\d{3})(\\d{8})","$1 $2",["18"],"0$1"],["(\\d{3})(\\d{2})(\\d{7,8})","$1 $2 $3",["1(?:6[023]|7)"],"0$1"],["(\\d{4})(\\d{2})(\\d{7})","$1 $2 $3",["15[279]"],"0$1"],["(\\d{3})(\\d{2})(\\d{8})","$1 $2 $3",["15"],"0$1"]],"0"],"DJ":["253","00","(?:2\\d|77)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[27]"]]]],"DK":["45","00","[2-9]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-9]"]]]],"DM":["1","011","(?:[58]\\d\\d|767|900)\\d{7}",[10],0,"1",0,"1|([2-7]\\d{6})$","767$1",0,"767"],"DO":["1","011","(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,0,0,0,"8[024]9"],"DZ":["213","00","(?:[1-4]|[5-79]\\d|80)\\d{7}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[1-4]"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["9"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-8]"],"0$1"]],"0"],"EC":["593","00","1\\d{9,10}|(?:[2-7]|9\\d)\\d{7}",[8,9,10,11],[["(\\d)(\\d{3})(\\d{4})","$1 $2-$3",["[2-7]"],"(0$1)",0,"$1-$2-$3"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["9"],"0$1"],["(\\d{4})(\\d{3})(\\d{3,4})","$1 $2 $3",["1"]]],"0"],"EE":["372","00","8\\d{9}|[4578]\\d{7}|(?:[3-8]\\d|90)\\d{5}",[7,8,10],[["(\\d{3})(\\d{4})","$1 $2",["[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]|88","[369]|4[3-8]|5(?:[02]|1(?:[0-8]|95)|5[0-478]|6(?:4[0-4]|5[1-589]))|7[1-9]|88"]],["(\\d{4})(\\d{3,4})","$1 $2",["[45]|8(?:00|[1-49])","[45]|8(?:00[1-9]|[1-49])"]],["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["7"]],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["8"]]]],"EG":["20","00","[189]\\d{8,9}|[24-6]\\d{8}|[135]\\d{7}",[8,9,10],[["(\\d)(\\d{7,8})","$1 $2",["[23]"],"0$1"],["(\\d{2})(\\d{6,7})","$1 $2",["1[35]|[4-6]|8[2468]|9[235-7]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[189]"],"0$1"]],"0"],"EH":["212","00","[5-8]\\d{8}",[9],0,"0",0,0,0,0,"528[89]"],"ER":["291","00","[178]\\d{6}",[7],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[178]"],"0$1"]],"0"],"ES":["34","00","(?:51|[6-9]\\d)\\d{7}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[89]00"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-9]"]]]],"ET":["251","00","(?:11|[2-59]\\d)\\d{7}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-59]"],"0$1"]],"0"],"FI":["358","00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))","[1-35689]\\d{4}|7\\d{10,11}|(?:[124-7]\\d|3[0-46-9])\\d{8}|[1-9]\\d{5,8}",[5,6,7,8,9,10,11,12],[["(\\d)(\\d{4,9})","$1 $2",["[2568][1-8]|3(?:0[1-9]|[1-9])|9"],"0$1"],["(\\d{3})(\\d{3,7})","$1 $2",["[12]00|[368]|70[07-9]"],"0$1"],["(\\d{2})(\\d{4,8})","$1 $2",["[1245]|7[135]"],"0$1"],["(\\d{2})(\\d{6,10})","$1 $2",["7"],"0$1"]],"0",0,0,0,0,"1[03-79]|[2-9]",0,"00"],"FJ":["679","0(?:0|52)","45\\d{5}|(?:0800\\d|[235-9])\\d{6}",[7,11],[["(\\d{3})(\\d{4})","$1 $2",["[235-9]|45"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["0"]]],0,0,0,0,0,0,0,"00"],"FK":["500","00","[2-7]\\d{4}",[5]],"FM":["691","00","(?:[39]\\d\\d|820)\\d{4}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[389]"]]]],"FO":["298","00","(?:[2-8]\\d|90)\\d{4}",[6],[["(\\d{6})","$1",["[2-9]"]]],0,0,"(10(?:01|[12]0|88))"],"FR":["33","00","[1-9]\\d{8}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"],"0 $1"],["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["[1-79]"],"0$1"]],"0"],"GA":["241","00","(?:[067]\\d|11)\\d{6}|[2-7]\\d{6}",[7,8],[["(\\d)(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-7]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["11|[67]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["0"]]],0,0,"0(11\\d{6}|6[256]\\d{6}|7[47]\\d{6})","$1"],"GB":["44","00","[1-357-9]\\d{9}|[18]\\d{8}|8\\d{6}",[7,9,10],[["(\\d{3})(\\d{4})","$1 $2",["800","8001","80011","800111","8001111"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["845","8454","84546","845464"],"0$1"],["(\\d{3})(\\d{6})","$1 $2",["800"],"0$1"],["(\\d{5})(\\d{4,5})","$1 $2",["1(?:38|5[23]|69|76|94)","1(?:(?:38|69)7|5(?:24|39)|768|946)","1(?:3873|5(?:242|39[4-6])|(?:697|768)[347]|9467)"],"0$1"],["(\\d{4})(\\d{5,6})","$1 $2",["1(?:[2-69][02-9]|[78])"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["[25]|7(?:0|6[02-9])","[25]|7(?:0|6(?:[03-9]|2[356]))"],"0$1"],["(\\d{4})(\\d{6})","$1 $2",["7"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[1389]"],"0$1"]],"0",0,0,0,0,0,[["(?:1(?:1(?:3(?:[0-58]\\d\\d|73[03])|(?:4[0-5]|5[0-26-9]|6[0-4]|[78][0-49])\\d\\d)|2(?:(?:0[024-9]|2[3-9]|3[3-79]|4[1-689]|[58][02-9]|6[0-47-9]|7[013-9]|9\\d)\\d\\d|1(?:[0-7]\\d\\d|8(?:0\\d|20)))|(?:3(?:0\\d|1[0-8]|[25][02-9]|3[02-579]|[468][0-46-9]|7[1-35-79]|9[2-578])|4(?:0[03-9]|[137]\\d|[28][02-57-9]|4[02-69]|5[0-8]|[69][0-79])|5(?:0[1-35-9]|[16]\\d|2[024-9]|3[015689]|4[02-9]|5[03-9]|7[0-35-9]|8[0-468]|9[0-57-9])|6(?:0[034689]|1\\d|2[0-35689]|[38][013-9]|4[1-467]|5[0-69]|6[13-9]|7[0-8]|9[0-24578])|7(?:0[0246-9]|2\\d|3[0236-8]|4[03-9]|5[0-46-9]|6[013-9]|7[0-35-9]|8[024-9]|9[02-9])|8(?:0[35-9]|2[1-57-9]|3[02-578]|4[0-578]|5[124-9]|6[2-69]|7\\d|8[02-9]|9[02569])|9(?:0[02-589]|[18]\\d|2[02-689]|3[1-57-9]|4[2-9]|5[0-579]|6[2-47-9]|7[0-24578]|9[2-57]))\\d\\d)|2(?:0[013478]|3[0189]|4[017]|8[0-46-9]|9[0-2])\\d{3})\\d{4}|1(?:2(?:0(?:46[1-4]|87[2-9])|545[1-79]|76(?:2\\d|3[1-8]|6[1-6])|9(?:7(?:2[0-4]|3[2-5])|8(?:2[2-8]|7[0-47-9]|8[3-5])))|3(?:6(?:38[2-5]|47[23])|8(?:47[04-9]|64[0157-9]))|4(?:044[1-7]|20(?:2[23]|8\\d)|6(?:0(?:30|5[2-57]|6[1-8]|7[2-8])|140)|8(?:052|87[1-3]))|5(?:2(?:4(?:3[2-79]|6\\d)|76\\d)|6(?:26[06-9]|686))|6(?:06(?:4\\d|7[4-79])|295[5-7]|35[34]\\d|47(?:24|61)|59(?:5[08]|6[67]|74)|9(?:55[0-4]|77[23]))|7(?:26(?:6[13-9]|7[0-7])|(?:442|688)\\d|50(?:2[0-3]|[3-68]2|76))|8(?:27[56]\\d|37(?:5[2-5]|8[239])|843[2-58])|9(?:0(?:0(?:6[1-8]|85)|52\\d)|3583|4(?:66[1-8]|9(?:2[01]|81))|63(?:23|3[1-4])|9561))\\d{3}",[9,10]],["7(?:457[0-57-9]|700[01]|911[028])\\d{5}|7(?:[1-3]\\d\\d|4(?:[0-46-9]\\d|5[0-689])|5(?:0[0-8]|[13-9]\\d|2[0-35-9])|7(?:0[1-9]|[1-7]\\d|8[02-9]|9[0-689])|8(?:[014-9]\\d|[23][0-8])|9(?:[024-9]\\d|1[02-9]|3[0-689]))\\d{6}",[10]],["80[08]\\d{7}|800\\d{6}|8001111"],["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[2-49]))\\d{7}|845464\\d",[7,10]],["70\\d{8}",[10]],0,["(?:3[0347]|55)\\d{8}",[10]],["76(?:0[0-2]|2[356]|34|4[0134]|5[49]|6[0-369]|77|81|9[39])\\d{6}",[10]],["56\\d{8}",[10]]],0," x"],"GD":["1","011","(?:473|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2-9]\\d{6})$","473$1",0,"473"],"GE":["995","00","(?:[3-57]\\d\\d|800)\\d{6}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["70"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["32"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[57]"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[348]"],"0$1"]],"0"],"GF":["594","00","(?:[56]94|976)\\d{6}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[569]"],"0$1"]],"0"],"GG":["44","00","(?:1481|[357-9]\\d{3})\\d{6}|8\\d{6}(?:\\d{2})?",[7,9,10],0,"0",0,"0|([25-9]\\d{5})$","1481$1",0,0,[["1481[25-9]\\d{5}",[10]],["7(?:(?:781|839)\\d|911[17])\\d{5}",[10]],["80[08]\\d{7}|800\\d{6}|8001111"],["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[0-3]))\\d{7}|845464\\d",[7,10]],["70\\d{8}",[10]],0,["(?:3[0347]|55)\\d{8}",[10]],["76(?:0[0-2]|2[356]|34|4[0134]|5[49]|6[0-369]|77|81|9[39])\\d{6}",[10]],["56\\d{8}",[10]]]],"GH":["233","00","(?:[235]\\d{3}|800)\\d{5}",[8,9],[["(\\d{3})(\\d{5})","$1 $2",["8"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[235]"],"0$1"]],"0"],"GI":["350","00","[256]\\d{7}",[8],[["(\\d{3})(\\d{5})","$1 $2",["2"]]]],"GL":["299","00","(?:19|[2-689]\\d)\\d{4}",[6],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["19|[2-689]"]]]],"GM":["220","00","[2-9]\\d{6}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-9]"]]]],"GN":["224","00","722\\d{6}|(?:3|6\\d)\\d{7}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["3"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[67]"]]]],"GP":["590","00","(?:590|69\\d|976)\\d{6}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[569]"],"0$1"]],"0",0,0,0,0,0,[["590(?:0[1-68]|1[0-2]|2[0-68]|3[1289]|4[0-24-9]|5[3-579]|6[0189]|7[08]|8[0-689]|9\\d)\\d{4}"],["69(?:0\\d\\d|1(?:2[29]|3[0-5]))\\d{4}"],0,0,0,0,0,0,["976[01]\\d{5}"]]],"GQ":["240","00","222\\d{6}|(?:3\\d|55|[89]0)\\d{7}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[235]"]],["(\\d{3})(\\d{6})","$1 $2",["[89]"]]]],"GR":["30","00","5005000\\d{3}|(?:[2689]\\d|70)\\d{8}",[10],[["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["21|7"]],["(\\d{4})(\\d{6})","$1 $2",["2(?:2|3[2-57-9]|4[2-469]|5[2-59]|6[2-9]|7[2-69]|8[2-49])|5"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[2689]"]]]],"GT":["502","00","(?:1\\d{3}|[2-7])\\d{7}",[8,11],[["(\\d{4})(\\d{4})","$1 $2",["[2-7]"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]]]],"GU":["1","011","(?:[58]\\d\\d|671|900)\\d{7}",[10],0,"1",0,"1|([3-9]\\d{6})$","671$1",0,"671"],"GW":["245","00","[49]\\d{8}|4\\d{6}",[7,9],[["(\\d{3})(\\d{4})","$1 $2",["40"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[49]"]]]],"GY":["592","001","(?:862\\d|9008)\\d{3}|(?:[2-46]\\d|77)\\d{5}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-46-9]"]]]],"HK":["852","00(?:30|5[09]|[126-9]?)","8[0-46-9]\\d{6,7}|9\\d{4}(?:\\d(?:\\d(?:\\d{4})?)?)?|(?:[235-79]\\d|46)\\d{6}",[5,6,7,8,9,11],[["(\\d{3})(\\d{2,5})","$1 $2",["900","9003"]],["(\\d{4})(\\d{4})","$1 $2",["[2-7]|8[1-4]|9(?:0[1-9]|[1-8])"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"]],["(\\d{3})(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3 $4",["9"]]],0,0,0,0,0,0,0,"00"],"HN":["504","00","8\\d{10}|[237-9]\\d{7}",[8,11],[["(\\d{4})(\\d{4})","$1-$2",["[237-9]"]]]],"HR":["385","00","(?:[24-69]\\d|3[0-79])\\d{7}|80\\d{5,7}|[1-79]\\d{7}|6\\d{5,6}",[6,7,8,9],[["(\\d{2})(\\d{2})(\\d{2,3})","$1 $2 $3",["6[01]"],"0$1"],["(\\d{3})(\\d{2})(\\d{2,3})","$1 $2 $3",["8"],"0$1"],["(\\d)(\\d{4})(\\d{3})","$1 $2 $3",["1"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[67]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["9"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-5]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"],"0$1"]],"0"],"HT":["509","00","[2-489]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["[2-489]"]]]],"HU":["36","00","[2357]\\d{8}|[1-9]\\d{7}",[8,9],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["1"],"(06 $1)"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[27][2-9]|3[2-7]|4[24-9]|5[2-79]|6|8[2-57-9]|9[2-69]"],"(06 $1)"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-57-9]"],"06 $1"]],"06"],"ID":["62","00[189]","(?:(?:007803|8\\d{4})\\d|[1-36])\\d{6}|[1-9]\\d{8,10}|[2-9]\\d{7}",[7,8,9,10,11,12,13],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["15"]],["(\\d{2})(\\d{5,9})","$1 $2",["2[124]|[36]1"],"(0$1)"],["(\\d{3})(\\d{5,7})","$1 $2",["800"],"0$1"],["(\\d{3})(\\d{5,8})","$1 $2",["[2-79]"],"(0$1)"],["(\\d{3})(\\d{3,4})(\\d{3})","$1-$2-$3",["8[1-35-9]"],"0$1"],["(\\d{3})(\\d{6,8})","$1 $2",["1"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["804"],"0$1"],["(\\d{3})(\\d)(\\d{3})(\\d{3})","$1 $2 $3 $4",["80"],"0$1"],["(\\d{3})(\\d{4})(\\d{4,5})","$1-$2-$3",["8"],"0$1"]],"0"],"IE":["353","00","(?:1\\d|[2569])\\d{6,8}|4\\d{6,9}|7\\d{8}|8\\d{8,9}",[7,8,9,10],[["(\\d{2})(\\d{5})","$1 $2",["2[24-9]|47|58|6[237-9]|9[35-9]"],"(0$1)"],["(\\d{3})(\\d{5})","$1 $2",["[45]0"],"(0$1)"],["(\\d)(\\d{3,4})(\\d{4})","$1 $2 $3",["1"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2569]|4[1-69]|7[14]"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["70"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["81"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[78]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["4"],"(0$1)"],["(\\d{2})(\\d)(\\d{3})(\\d{4})","$1 $2 $3 $4",["8"],"0$1"]],"0"],"IL":["972","0(?:0|1[2-9])","1\\d{6}(?:\\d{3,5})?|[57]\\d{8}|[1-489]\\d{7}",[7,8,9,10,11,12],[["(\\d{4})(\\d{3})","$1-$2",["125"]],["(\\d{4})(\\d{2})(\\d{2})","$1-$2-$3",["121"]],["(\\d)(\\d{3})(\\d{4})","$1-$2-$3",["[2-489]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["[57]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1-$2-$3",["12"]],["(\\d{4})(\\d{6})","$1-$2",["159"]],["(\\d)(\\d{3})(\\d{3})(\\d{3})","$1-$2-$3-$4",["1[7-9]"]],["(\\d{3})(\\d{1,2})(\\d{3})(\\d{4})","$1-$2 $3-$4",["15"]]],"0"],"IM":["44","00","1624\\d{6}|(?:[3578]\\d|90)\\d{8}",[10],0,"0",0,"0|([5-8]\\d{5})$","1624$1",0,"74576|(?:16|7[56])24"],"IN":["91","00","(?:000800|[2-9]\\d\\d)\\d{7}|1\\d{7,12}",[8,9,10,11,12,13],[["(\\d{8})","$1",["5(?:0|2[23]|3[03]|[67]1|88)","5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|888)","5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|8888)"],0,1],["(\\d{4})(\\d{4,5})","$1 $2",["180","1800"],0,1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["140"],0,1],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["11|2[02]|33|4[04]|79[1-7]|80[2-46]","11|2[02]|33|4[04]|79(?:[1-6]|7[19])|80(?:[2-4]|6[0-589])","11|2[02]|33|4[04]|79(?:[124-6]|3(?:[02-9]|1[0-24-9])|7(?:1|9[1-6]))|80(?:[2-4]|6[0-589])"],"0$1",1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["1(?:2[0-249]|3[0-25]|4[145]|[68]|7[1257])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|5[12]|[78]1)|6(?:12|[2-4]1|5[17]|6[13]|80)|7(?:12|3[134]|4[47]|61|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)|(?:43|59|75)[15]|(?:1[59]|29|67|72)[14]","1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|674|7(?:(?:2[14]|3[34]|5[15])[2-6]|61[346]|88[0-8])|8(?:70[2-6]|84[235-7]|91[3-7])|(?:1(?:29|60|8[06])|261|552|6(?:12|[2-47]1|5[17]|6[13]|80)|7(?:12|31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))[2-7]","1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12(?:[2-6]|7[0-8])|74[2-7])|7(?:(?:2[14]|5[15])[2-6]|3171|61[346]|88(?:[2-7]|82))|8(?:70[2-6]|84(?:[2356]|7[19])|91(?:[3-6]|7[19]))|73[134][2-6]|(?:74[47]|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[2-6]|7[19])|(?:1(?:29|60|8[06])|261|552|6(?:[2-4]1|5[17]|6[13]|7(?:1|4[0189])|80)|7(?:12|88[01]))[2-7]"],"0$1",1],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2[2457-9]|3[2-5]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1[013-9]|28|3[129]|4[1-35689]|5[29]|6[02-5]|70)|807","1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2(?:[2457]|84|95)|3(?:[2-4]|55)|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1(?:[013-8]|9[6-9])|28[6-8]|3(?:17|2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4|5[0-367])|70[13-7])|807[19]","1(?:[2-479]|5(?:[0236-9]|5[013-9]))|[2-5]|6(?:2(?:84|95)|355|83)|73179|807(?:1|9[1-3])|(?:1552|6(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[124-6])\\d|7(?:1(?:[013-8]\\d|9[6-9])|28[6-8]|3(?:2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\d|5[0-367])|70[13-7]))[2-7]"],"0$1",1],["(\\d{5})(\\d{5})","$1 $2",["[6-9]"],"0$1",1],["(\\d{4})(\\d{2,4})(\\d{4})","$1 $2 $3",["1(?:6|8[06])","1(?:6|8[06]0)"],0,1],["(\\d{4})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["18"],0,1]],"0"],"IO":["246","00","3\\d{6}",[7],[["(\\d{3})(\\d{4})","$1 $2",["3"]]]],"IQ":["964","00","(?:1|7\\d\\d)\\d{7}|[2-6]\\d{7,8}",[8,9,10],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-6]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"0$1"]],"0"],"IR":["98","00","[1-9]\\d{9}|(?:[1-8]\\d\\d|9)\\d{3,4}",[4,5,6,7,10],[["(\\d{4,5})","$1",["96"],"0$1"],["(\\d{2})(\\d{4,5})","$1 $2",["(?:1[137]|2[13-68]|3[1458]|4[145]|5[1468]|6[16]|7[1467]|8[13467])[12689]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["9"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["[1-8]"],"0$1"]],"0"],"IS":["354","00|1(?:0(?:01|[12]0)|100)","(?:38\\d|[4-9])\\d{6}",[7,9],[["(\\d{3})(\\d{4})","$1 $2",["[4-9]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["3"]]],0,0,0,0,0,0,0,"00"],"IT":["39","00","0\\d{5,10}|3[0-8]\\d{7,10}|55\\d{8}|8\\d{5}(?:\\d{2,4})?|(?:1\\d|39)\\d{7,8}",[6,7,8,9,10,11],[["(\\d{2})(\\d{4,6})","$1 $2",["0[26]"]],["(\\d{3})(\\d{3,6})","$1 $2",["0[13-57-9][0159]|8(?:03|4[17]|9[245])","0[13-57-9][0159]|8(?:03|4[17]|9(?:2|[45][0-4]))"]],["(\\d{4})(\\d{2,6})","$1 $2",["0(?:[13-579][2-46-8]|8[236-8])"]],["(\\d{4})(\\d{4})","$1 $2",["894"]],["(\\d{2})(\\d{3,4})(\\d{4})","$1 $2 $3",["0[26]|5"]],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["1[4679]|[38]"]],["(\\d{3})(\\d{3,4})(\\d{4})","$1 $2 $3",["0[13-57-9][0159]"]],["(\\d{2})(\\d{4})(\\d{5})","$1 $2 $3",["0[26]"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["0"]],["(\\d{3})(\\d{4})(\\d{4,5})","$1 $2 $3",["3"]]],0,0,0,0,0,0,[["0669[0-79]\\d{1,6}|0(?:1(?:[0159]\\d|[27][1-5]|31|4[1-4]|6[1356]|8[2-57])|2\\d\\d|3(?:[0159]\\d|2[1-4]|3[12]|[48][1-6]|6[2-59]|7[1-7])|4(?:[0159]\\d|[23][1-9]|4[245]|6[1-5]|7[1-4]|81)|5(?:[0159]\\d|2[1-5]|3[2-6]|4[1-79]|6[4-6]|7[1-578]|8[3-8])|6(?:[0-57-9]\\d|6[0-8])|7(?:[0159]\\d|2[12]|3[1-7]|4[2-46]|6[13569]|7[13-6]|8[1-59])|8(?:[0159]\\d|2[3-578]|3[1-356]|[6-8][1-5])|9(?:[0159]\\d|[238][1-5]|4[12]|6[1-8]|7[1-6]))\\d{2,7}"],["3[1-9]\\d{8}|3[2-9]\\d{7}",[9,10]],["80(?:0\\d{3}|3)\\d{3}",[6,9]],["(?:0878\\d\\d|89(?:2|4[5-9]\\d))\\d{3}|89[45][0-4]\\d\\d|(?:1(?:44|6[346])|89(?:5[5-9]|9))\\d{6}",[6,8,9,10]],["1(?:78\\d|99)\\d{6}",[9,10]],0,0,0,["55\\d{8}",[10]],["84(?:[08]\\d{3}|[17])\\d{3}",[6,9]]]],"JE":["44","00","1534\\d{6}|(?:[3578]\\d|90)\\d{8}",[10],0,"0",0,"0|([0-24-8]\\d{5})$","1534$1",0,0,[["1534[0-24-8]\\d{5}"],["7(?:(?:(?:50|82)9|937)\\d|7(?:00[378]|97[7-9]))\\d{5}"],["80(?:07(?:35|81)|8901)\\d{4}"],["(?:8(?:4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|90(?:066[59]|1810|71(?:07|55)))\\d{4}"],["701511\\d{4}"],0,["(?:3(?:0(?:07(?:35|81)|8901)|3\\d{4}|4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|55\\d{4})\\d{4}"],["76(?:0[0-2]|2[356]|34|4[0134]|5[49]|6[0-369]|77|81|9[39])\\d{6}"],["56\\d{8}"]]],"JM":["1","011","(?:[58]\\d\\d|658|900)\\d{7}",[10],0,"1",0,0,0,0,"658|876"],"JO":["962","00","(?:(?:[2689]|7\\d)\\d|32|53)\\d{6}",[8,9],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[2356]|87"],"(0$1)"],["(\\d{3})(\\d{5,6})","$1 $2",["[89]"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["70"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["7"],"0$1"]],"0"],"JP":["81","010","00[1-9]\\d{6,14}|[257-9]\\d{9}|(?:00|[1-9]\\d\\d)\\d{6}",[8,9,10,11,12,13,14,15,16,17],[["(\\d{3})(\\d{3})(\\d{3})","$1-$2-$3",["(?:12|57|99)0"],"0$1"],["(\\d{4})(\\d)(\\d{4})","$1-$2-$3",["1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|499|5(?:76|97)|746|8(?:3[89]|47|51|63)|9(?:49|80|9[16])","1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:76|97)9|7468|8(?:3(?:8[78]|96)|477|51[24]|636)|9(?:496|802|9(?:1[23]|69))|1(?:45|58)[67]","1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:769|979[2-69])|7468|8(?:3(?:8[78]|96[2457-9])|477|51[24]|636[457-9])|9(?:496|802|9(?:1[23]|69))|1(?:45|58)[67]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["60"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1-$2-$3",["[36]|4(?:2[09]|7[01])","[36]|4(?:2(?:0|9[02-69])|7(?:0[019]|1))"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["1(?:1|5[45]|77|88|9[69])|2(?:2[1-37]|3[0-269]|4[59]|5|6[24]|7[1-358]|8[1369]|9[0-38])|4(?:[28][1-9]|3[0-57]|[45]|6[248]|7[2-579]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-389])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9[2-6])|8(?:2[124589]|3[279]|49|6|7[0-468]|8[68]|9[019])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9[1-489])","1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2(?:[127]|3[014-9])|3[0-269]|4[59]|5(?:[0468][01]|[1-3]|5[0-69]|9[19])|62|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|2[01]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|8[1-9])|5(?:2|3[045]|4[0-369]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0-2469])|49|6(?:[0-24]|36|5[0-3589]|72|9[01459])|7[0-468]|8[68])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3[34]|4[0178]))|(?:49|55|83)[29]|(?:264|837)[016-9]|2(?:57|93)[015-9]|(?:47[59]|59[89]|8(?:6[68]|9))[019]","1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[0468][01]|[1-3]|5[0-69]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|2[01]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0169])|3(?:[29]|7(?:[017-9]|6[6-8]))|49|6(?:[0-24]|36[23]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|72|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:8294|96)[1-3]|2(?:57|93)[015-9]|(?:223|8699)[014-9]|(?:48|8292|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]","1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[0468][01]|[1-3]|5[0-69]|7[015-9]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17|3[015-9]))|4(?:2(?:[13-79]|2[01]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9(?:[019]|4[1-3]|6(?:[0-47-9]|5[01346-9])))|3(?:[29]|7(?:[017-9]|6[6-8]))|49|6(?:[0-24]|36[23]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|72|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:223|8699)[014-9]|(?:48|829(?:2|66)|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]"],"0$1"],["(\\d{3})(\\d{2})(\\d{4})","$1-$2-$3",["[14]|[29][2-9]|5[3-9]|7[2-4679]|8(?:[246-9]|3[3-8]|5[2-9])","[14]|[29][2-9]|5[3-9]|7[2-4679]|8(?:[246-9]|3(?:[3-6][2-9]|7|8[2-5])|5[2-9])"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["800"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1-$2-$3",["[2579]|80"],"0$1"]],"0"],"KE":["254","000","(?:[17]\\d\\d|900)\\d{6}|(?:2|80)0\\d{6,7}|[4-6]\\d{6,8}",[7,8,9,10],[["(\\d{2})(\\d{5,7})","$1 $2",["[24-6]"],"0$1"],["(\\d{3})(\\d{6})","$1 $2",["[17]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["[89]"],"0$1"]],"0"],"KG":["996","00","8\\d{9}|(?:[235-8]\\d|99)\\d{7}",[9,10],[["(\\d{4})(\\d{5})","$1 $2",["3(?:1[346]|[24-79])"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[235-79]|88"],"0$1"],["(\\d{3})(\\d{3})(\\d)(\\d{2,3})","$1 $2 $3 $4",["8"],"0$1"]],"0"],"KH":["855","00[14-9]","1\\d{9}|[1-9]\\d{7,8}",[8,9,10],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[1-9]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]]],"0"],"KI":["686","00","(?:[37]\\d|6[0-79])\\d{6}|(?:[2-48]\\d|50)\\d{3}",[5,8],0,"0"],"KM":["269","00","[3478]\\d{6}",[7],[["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[3478]"]]]],"KN":["1","011","(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2-7]\\d{6})$","869$1",0,"869"],"KP":["850","00|99","85\\d{6}|(?:19\\d|[2-7])\\d{7}",[8,10],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["8"],"0$1"],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[2-7]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"]],"0"],"KR":["82","00(?:[125689]|3(?:[46]5|91)|7(?:00|27|3|55|6[126]))","00[1-9]\\d{8,11}|(?:[12]|5\\d{3})\\d{7}|[13-6]\\d{9}|(?:[1-6]\\d|80)\\d{7}|[3-6]\\d{4,5}|(?:00|7)0\\d{8}",[5,6,8,9,10,11,12,13,14],[["(\\d{2})(\\d{3,4})","$1-$2",["(?:3[1-3]|[46][1-4]|5[1-5])1"],"0$1"],["(\\d{4})(\\d{4})","$1-$2",["1"]],["(\\d)(\\d{3,4})(\\d{4})","$1-$2-$3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["60|8"],"0$1"],["(\\d{2})(\\d{3,4})(\\d{4})","$1-$2-$3",["[1346]|5[1-5]"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1-$2-$3",["[57]"],"0$1"],["(\\d{2})(\\d{5})(\\d{4})","$1-$2-$3",["5"],"0$1"]],"0",0,"0(8(?:[1-46-8]|5\\d\\d))?"],"KW":["965","00","(?:18|[2569]\\d\\d)\\d{5}",[7,8],[["(\\d{4})(\\d{3,4})","$1 $2",["[169]|2(?:[235]|4[1-35-9])|52"]],["(\\d{3})(\\d{5})","$1 $2",["[25]"]]]],"KY":["1","011","(?:345|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2-9]\\d{6})$","345$1",0,"345"],"KZ":["7","810","33622\\d{5}|(?:7\\d|80)\\d{8}",[10],0,"8",0,0,0,0,"33|7",0,"8~10"],"LA":["856","00","[23]\\d{9}|3\\d{8}|(?:[235-8]\\d|41)\\d{6}",[8,9,10],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["2[13]|3[14]|[4-8]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["30[013-9]"],"0$1"],["(\\d{2})(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3 $4",["[23]"],"0$1"]],"0"],"LB":["961","00","[7-9]\\d{7}|[13-9]\\d{6}",[7,8],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[13-69]|7(?:[2-57]|62|8[0-7]|9[04-9])|8[02-9]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[7-9]"]]],"0"],"LC":["1","011","(?:[58]\\d\\d|758|900)\\d{7}",[10],0,"1",0,"1|([2-8]\\d{6})$","758$1",0,"758"],"LI":["423","00","90\\d{5}|(?:[2378]|6\\d\\d)\\d{6}",[7,9],[["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[237-9]"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["69"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6"]]],"0",0,"0|(1001)"],"LK":["94","00","[1-9]\\d{8}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[1-689]"],"0$1"]],"0"],"LR":["231","00","(?:2|33|5\\d|77|88)\\d{7}|[4-6]\\d{6}",[7,8,9],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[4-6]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[3578]"],"0$1"]],"0"],"LS":["266","00","(?:[256]\\d\\d|800)\\d{5}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[2568]"]]]],"LT":["370","00","(?:[3469]\\d|52|[78]0)\\d{6}",[8],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["52[0-7]"],"(8-$1)",1],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[7-9]"],"8 $1",1],["(\\d{2})(\\d{6})","$1 $2",["37|4(?:[15]|6[1-8])"],"(8-$1)",1],["(\\d{3})(\\d{5})","$1 $2",["[3-6]"],"(8-$1)",1]],"8",0,"[08]"],"LU":["352","00","35[013-9]\\d{4,8}|6\\d{8}|35\\d{2,4}|(?:[2457-9]\\d|3[0-46-9])\\d{2,9}",[4,5,6,7,8,9,10,11],[["(\\d{2})(\\d{3})","$1 $2",["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]],["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]],["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["20[2-689]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})","$1 $2 $3 $4",["2(?:[0367]|4[3-8])"]],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["80[01]|90[015]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["20"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})","$1 $2 $3 $4 $5",["2(?:[0367]|4[3-8])"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{1,5})","$1 $2 $3 $4",["[3-57]|8[13-9]|9(?:0[89]|[2-579])|(?:2|80)[2-9]"]]],0,0,"(15(?:0[06]|1[12]|[35]5|4[04]|6[26]|77|88|99)\\d)"],"LV":["371","00","(?:[268]\\d|90)\\d{6}",[8],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[269]|8[01]"]]]],"LY":["218","00","[2-9]\\d{8}",[9],[["(\\d{2})(\\d{7})","$1-$2",["[2-9]"],"0$1"]],"0"],"MA":["212","00","[5-8]\\d{8}",[9],[["(\\d{5})(\\d{4})","$1-$2",["5(?:29|38)","5(?:29|38)[89]","5(?:29|38)[89]0"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["5[45]"],"0$1"],["(\\d{4})(\\d{5})","$1-$2",["5(?:2[2-489]|3[5-9]|9)|892","5(?:2(?:[2-49]|8[235-9])|3[5-9]|9)|892"],"0$1"],["(\\d{2})(\\d{7})","$1-$2",["8"],"0$1"],["(\\d{3})(\\d{6})","$1-$2",["[5-7]"],"0$1"]],"0",0,0,0,0,0,[["5(?:29(?:[189][05]|2[29]|3[01])|38[89][05])\\d{4}|5(?:2(?:[015-7]\\d|2[02-9]|3[0-578]|4[02-46-8]|8[0235-7]|90)|3(?:[0-47]\\d|5[02-9]|6[02-8]|80|9[3-9])|(?:4[067]|5[03])\\d)\\d{5}"],["(?:6(?:[0-79]\\d|8[0-247-9])|7(?:0[016-8]|6[1267]|7[0-27]))\\d{6}"],["80\\d{7}"],["89\\d{7}"],0,0,0,0,["592(?:4[0-2]|93)\\d{4}"]]],"MC":["377","00","870\\d{5}|(?:[349]|6\\d)\\d{7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["4"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[39]"]],["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["6"],"0$1"]],"0"],"MD":["373","00","(?:[235-7]\\d|[89]0)\\d{6}",[8],[["(\\d{3})(\\d{5})","$1 $2",["[89]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["22|3"],"0$1"],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[25-7]"],"0$1"]],"0"],"ME":["382","00","(?:20|[3-79]\\d)\\d{6}|80\\d{6,7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-9]"],"0$1"]],"0"],"MF":["590","00","(?:590|69\\d|976)\\d{6}",[9],0,"0",0,0,0,0,0,[["590(?:0[079]|[14]3|[27][79]|30|5[0-268]|87)\\d{4}"],["69(?:0\\d\\d|1(?:2[29]|3[0-5]))\\d{4}"],0,0,0,0,0,0,["976[01]\\d{5}"]]],"MG":["261","00","[23]\\d{8}",[9],[["(\\d{2})(\\d{2})(\\d{3})(\\d{2})","$1 $2 $3 $4",["[23]"],"0$1"]],"0",0,"0|([24-9]\\d{6})$","20$1"],"MH":["692","011","329\\d{4}|(?:[256]\\d|45)\\d{5}",[7],[["(\\d{3})(\\d{4})","$1-$2",["[2-6]"]]],"1"],"MK":["389","00","[2-578]\\d{7}",[8],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[347]"],"0$1"],["(\\d{3})(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["[58]"],"0$1"]],"0"],"ML":["223","00","[24-9]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[24-9]"]]]],"MM":["95","00","1\\d{5,7}|95\\d{6}|(?:[4-7]|9[0-46-9])\\d{6,8}|(?:2|8\\d)\\d{5,8}",[6,7,8,9,10],[["(\\d)(\\d{2})(\\d{3})","$1 $2 $3",["16|2"],"0$1"],["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["[45]|6(?:0[23]|[1-689]|7[235-7])|7(?:[0-4]|5[2-7])|8[1-6]"],"0$1"],["(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["[12]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[4-7]|8[1-35]"],"0$1"],["(\\d)(\\d{3})(\\d{4,6})","$1 $2 $3",["9(?:2[0-4]|[35-9]|4[137-9])"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["2"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"],"0$1"],["(\\d)(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["92"],"0$1"],["(\\d)(\\d{5})(\\d{4})","$1 $2 $3",["9"],"0$1"]],"0"],"MN":["976","001","[12]\\d{7,9}|[57-9]\\d{7}",[8,9,10],[["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["[12]1"],"0$1"],["(\\d{4})(\\d{4})","$1 $2",["[57-9]"]],["(\\d{3})(\\d{5,6})","$1 $2",["[12]2[1-3]"],"0$1"],["(\\d{4})(\\d{5,6})","$1 $2",["[12](?:27|3[2-8]|4[2-68]|5[1-4689])","[12](?:27|3[2-8]|4[2-68]|5[1-4689])[0-3]"],"0$1"],["(\\d{5})(\\d{4,5})","$1 $2",["[12]"],"0$1"]],"0"],"MO":["853","00","(?:28|[68]\\d)\\d{6}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[268]"]]]],"MP":["1","011","[58]\\d{9}|(?:67|90)0\\d{7}",[10],0,"1",0,"1|([2-9]\\d{6})$","670$1",0,"670"],"MQ":["596","00","69\\d{7}|(?:59|97)6\\d{6}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[569]"],"0$1"]],"0"],"MR":["222","00","(?:[2-4]\\d\\d|800)\\d{5}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-48]"]]]],"MS":["1","011","(?:[58]\\d\\d|664|900)\\d{7}",[10],0,"1",0,"1|([34]\\d{6})$","664$1",0,"664"],"MT":["356","00","3550\\d{4}|(?:[2579]\\d\\d|800)\\d{5}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[2357-9]"]]]],"MU":["230","0(?:0|[24-7]0|3[03])","(?:[2-468]|5\\d)\\d{6}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["[2-46]|8[013]"]],["(\\d{4})(\\d{4})","$1 $2",["5"]]],0,0,0,0,0,0,0,"020"],"MV":["960","0(?:0|19)","(?:800|9[0-57-9]\\d)\\d{7}|[34679]\\d{6}",[7,10],[["(\\d{3})(\\d{4})","$1-$2",["[3467]|9[13-9]"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[89]"]]],0,0,0,0,0,0,0,"00"],"MW":["265","00","1\\d{6}(?:\\d{2})?|(?:[23]1|77|88|99)\\d{7}",[7,9],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["1[2-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["2"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[137-9]"],"0$1"]],"0"],"MX":["52","0[09]","(?:1(?:[01467]\\d|[2359][1-9]|8[1-79])|[2-9]\\d)\\d{8}",[10,11],[["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["33|5[56]|81"],0,1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[2-9]"],0,1],["(\\d)(\\d{2})(\\d{4})(\\d{4})","$2 $3 $4",["1(?:33|5[56]|81)"],0,1],["(\\d)(\\d{3})(\\d{3})(\\d{4})","$2 $3 $4",["1"],0,1]],"01",0,"0(?:[12]|4[45])|1",0,0,0,0,"00"],"MY":["60","00","1\\d{8,9}|(?:3\\d|[4-9])\\d{7}",[8,9,10],[["(\\d)(\\d{3})(\\d{4})","$1-$2 $3",["[4-79]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1-$2 $3",["1(?:[02469]|[378][1-9])|8"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1-$2 $3",["3"],"0$1"],["(\\d)(\\d{3})(\\d{2})(\\d{4})","$1-$2-$3-$4",["1[36-8]"]],["(\\d{3})(\\d{3})(\\d{4})","$1-$2 $3",["15"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1-$2 $3",["1"],"0$1"]],"0"],"MZ":["258","00","(?:2|8\\d)\\d{7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["2|8[2-79]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"]]]],"NA":["264","00","[68]\\d{7,8}",[8,9],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["88"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["6"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["87"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["8"],"0$1"]],"0"],"NC":["687","00","[2-57-9]\\d{5}",[6],[["(\\d{2})(\\d{2})(\\d{2})","$1.$2.$3",["[2-57-9]"]]]],"NE":["227","00","[0289]\\d{7}",[8],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["08"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[089]|2[013]"]]]],"NF":["672","00","[13]\\d{5}",[6],[["(\\d{2})(\\d{4})","$1 $2",["1[0-3]"]],["(\\d)(\\d{5})","$1 $2",["[13]"]]],0,0,"([0-258]\\d{4})$","3$1"],"NG":["234","009","(?:[124-7]|9\\d{3})\\d{6}|[1-9]\\d{7}|[78]\\d{9,13}",[7,8,10,11,12,13,14],[["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["78"],"0$1"],["(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["[12]|9(?:0[3-9]|[1-9])"],"0$1"],["(\\d{2})(\\d{3})(\\d{2,3})","$1 $2 $3",["[3-7]|8[2-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["[7-9]"],"0$1"],["(\\d{3})(\\d{4})(\\d{4,5})","$1 $2 $3",["[78]"],"0$1"],["(\\d{3})(\\d{5})(\\d{5,6})","$1 $2 $3",["[78]"],"0$1"]],"0"],"NI":["505","00","(?:1800|[25-8]\\d{3})\\d{4}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[125-8]"]]]],"NL":["31","00","(?:[124-7]\\d\\d|3(?:[02-9]\\d|1[0-8]))\\d{6}|[89]\\d{6,9}|1\\d{4,5}",[5,6,7,8,9,10],[["(\\d{3})(\\d{4,7})","$1 $2",["[89]0"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["66"],"0$1"],["(\\d)(\\d{8})","$1 $2",["6"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["1[16-8]|2[259]|3[124]|4[17-9]|5[124679]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-57-9]"],"0$1"]],"0"],"NO":["47","00","(?:0|[2-9]\\d{3})\\d{4}",[5,8],[["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[489]|5[89]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[235-7]"]]],0,0,0,0,0,"[02-689]|7[0-8]"],"NP":["977","00","9\\d{9}|[1-9]\\d{7}",[8,10],[["(\\d)(\\d{7})","$1-$2",["1[2-6]"],"0$1"],["(\\d{2})(\\d{6})","$1-$2",["[1-8]|9(?:[1-579]|6[2-6])"],"0$1"],["(\\d{3})(\\d{7})","$1-$2",["9"]]],"0"],"NR":["674","00","(?:444|(?:55|8\\d)\\d|666)\\d{4}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[4-68]"]]]],"NU":["683","00","(?:[47]|888\\d)\\d{3}",[4,7],[["(\\d{3})(\\d{4})","$1 $2",["8"]]]],"NZ":["64","0(?:0|161)","[29]\\d{7,9}|50\\d{5}(?:\\d{2,3})?|6[0-35-9]\\d{6}|7\\d{7,8}|8\\d{4,9}|(?:11\\d|[34])\\d{7}",[5,6,7,8,9,10],[["(\\d{2})(\\d{3,8})","$1 $2",["83"],"0$1"],["(\\d{3})(\\d{2})(\\d{2,3})","$1 $2 $3",["50[0367]|[89]0"],"0$1"],["(\\d)(\\d{3})(\\d{4})","$1-$2 $3",["24|[346]|7[2-57-9]|9[2-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["2(?:10|74)|[59]|80"],"0$1"],["(\\d{2})(\\d{3,4})(\\d{4})","$1 $2 $3",["1|2[028]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,5})","$1 $2 $3",["2(?:[169]|7[0-35-9])|7|86"],"0$1"]],"0",0,0,0,0,0,0,"00"],"OM":["968","00","(?:1505|[279]\\d{3}|500)\\d{4}|8007\\d{4,5}",[7,8,9],[["(\\d{3})(\\d{4,6})","$1 $2",["[58]"]],["(\\d{2})(\\d{6})","$1 $2",["2"]],["(\\d{4})(\\d{4})","$1 $2",["[179]"]]]],"PA":["507","00","(?:[1-57-9]|6\\d)\\d{6}",[7,8],[["(\\d{3})(\\d{4})","$1-$2",["[1-57-9]"]],["(\\d{4})(\\d{4})","$1-$2",["6"]]]],"PE":["51","19(?:1[124]|77|90)00","(?:[14-8]|9\\d)\\d{7}",[8,9],[["(\\d{3})(\\d{5})","$1 $2",["80"],"(0$1)"],["(\\d)(\\d{7})","$1 $2",["1"],"(0$1)"],["(\\d{2})(\\d{6})","$1 $2",["[4-8]"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"]]],"0",0,0,0,0,0,0,0," Anexo "],"PF":["689","00","[48]\\d{7}|4\\d{5}",[6,8],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["44"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[48]"]]]],"PG":["675","00|140[1-3]","(?:180|[78]\\d{3})\\d{4}|(?:[2-589]\\d|64)\\d{5}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["18|[2-69]|85"]],["(\\d{4})(\\d{4})","$1 $2",["[78]"]]],0,0,0,0,0,0,0,"00"],"PH":["63","00","1800\\d{7,9}|(?:2|[89]\\d{4})\\d{5}|[2-8]\\d{8}|[28]\\d{7}",[6,8,9,10,11,12,13],[["(\\d)(\\d{5})","$1 $2",["2"],"(0$1)"],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["2"],"(0$1)"],["(\\d{4})(\\d{4,6})","$1 $2",["3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|544|88[245]|(?:52|64|86)2","3(?:230|397|461)|4(?:2(?:35|[46]4|51)|396|4(?:22|63)|59[347]|76[15])|5(?:221|446)|642[23]|8(?:622|8(?:[24]2|5[13]))"],"(0$1)"],["(\\d{5})(\\d{4})","$1 $2",["346|4(?:27|9[35])|883","3469|4(?:279|9(?:30|56))|8834"],"(0$1)"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["2"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[3-7]|8[2-8]"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[89]"],"0$1"],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]],["(\\d{4})(\\d{1,2})(\\d{3})(\\d{4})","$1 $2 $3 $4",["1"]]],"0"],"PK":["92","00","122\\d{6}|[24-8]\\d{10,11}|9(?:[013-9]\\d{8,10}|2(?:[01]\\d\\d|2(?:[06-8]\\d|1[01]))\\d{7})|(?:[2-8]\\d{3}|92(?:[0-7]\\d|8[1-9]))\\d{6}|[24-9]\\d{8}|[89]\\d{7}",[8,9,10,11,12],[["(\\d{3})(\\d{3})(\\d{2})","$1 $2 $3",["[89]0"],"0$1"],["(\\d{4})(\\d{5})","$1 $2",["1"]],["(\\d{3})(\\d{6,7})","$1 $2",["2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8])","9(?:2[3-8]|98)|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:22|3[27-9]|4[2-6]|6[3569]|9[25-7]))[2-9]"],"(0$1)"],["(\\d{2})(\\d{7,8})","$1 $2",["(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]"],"(0$1)"],["(\\d{5})(\\d{5})","$1 $2",["58"],"(0$1)"],["(\\d{3})(\\d{7})","$1 $2",["3"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["[24-9]"],"(0$1)"]],"0"],"PL":["48","00","[1-57-9]\\d{6}(?:\\d{2})?|6\\d{5,8}",[6,7,8,9],[["(\\d{5})","$1",["19"]],["(\\d{3})(\\d{3})","$1 $2",["11|64"]],["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])1","(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])19"]],["(\\d{3})(\\d{2})(\\d{2,3})","$1 $2 $3",["64"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["39|45|5[0137]|6[0469]|7[02389]|8[08]"]],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[2-8]|[2-8]|9[145]"]]]],"PM":["508","00","[45]\\d{5}",[6],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["[45]"],"0$1"]],"0"],"PR":["1","011","(?:[589]\\d\\d|787)\\d{7}",[10],0,"1",0,0,0,0,"787|939"],"PS":["970","00","[2489]2\\d{6}|(?:1\\d|5)\\d{8}",[8,9,10],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[2489]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["5"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]]],"0"],"PT":["351","00","(?:[26-9]\\d|30)\\d{7}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["2[12]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[236-9]"]]]],"PW":["680","01[12]","(?:[24-8]\\d\\d|345|900)\\d{4}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-9]"]]]],"PY":["595","00","59\\d{4,6}|(?:[2-46-9]\\d|5[0-8])\\d{4,7}",[6,7,8,9],[["(\\d{3})(\\d{3,6})","$1 $2",["[2-9]0"],"0$1"],["(\\d{2})(\\d{5})","$1 $2",["[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36]"],"(0$1)"],["(\\d{3})(\\d{4,5})","$1 $2",["2[279]|3[13-5]|4[359]|5|6(?:[34]|7[1-46-8])|7[46-8]|85"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["2[14-68]|3[26-9]|4[1246-8]|6(?:1|75)|7[1-35]|8[1-36]"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["87"]],["(\\d{3})(\\d{6})","$1 $2",["9"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[2-8]"],"0$1"]],"0"],"QA":["974","00","[2-7]\\d{7}|(?:2\\d\\d|800)\\d{4}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["2[126]|8"]],["(\\d{4})(\\d{4})","$1 $2",["[2-7]"]]]],"RE":["262","00","9769\\d{5}|(?:26|[68]\\d)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2689]"],"0$1"]],"0",0,0,0,0,"26[23]|69|[89]"],"RO":["40","00","(?:[237]\\d|[89]0)\\d{7}|[23]\\d{5}",[6,9],[["(\\d{3})(\\d{3})","$1 $2",["2[3-6]","2[3-6]\\d9"],"0$1"],["(\\d{2})(\\d{4})","$1 $2",["219|31"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[23]1"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[237-9]"],"0$1"]],"0",0,0,0,0,0,0,0," int "],"RS":["381","00","38[02-9]\\d{6,9}|6\\d{7,9}|90\\d{4,8}|38\\d{5,6}|(?:7\\d\\d|800)\\d{3,9}|(?:[12]\\d|3[0-79])\\d{5,10}",[6,7,8,9,10,11,12],[["(\\d{3})(\\d{3,9})","$1 $2",["(?:2[389]|39)0|[7-9]"],"0$1"],["(\\d{2})(\\d{5,10})","$1 $2",["[1-36]"],"0$1"]],"0"],"RU":["7","810","[347-9]\\d{9}",[10],[["(\\d{4})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["7(?:1[0-8]|2[1-9])","7(?:1(?:[0-6]2|7|8[27])|2(?:1[23]|[2-9]2))","7(?:1(?:[0-6]2|7|8[27])|2(?:13[03-69]|62[013-9]))|72[1-57-9]2"],"8 ($1)",1],["(\\d{5})(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["7(?:1[0-68]|2[1-9])","7(?:1(?:[06][3-6]|[18]|2[35]|[3-5][3-5])|2(?:[13][3-5]|[24-689]|7[457]))","7(?:1(?:0(?:[356]|4[023])|[18]|2(?:3[013-9]|5)|3[45]|43[013-79]|5(?:3[1-8]|4[1-7]|5)|6(?:3[0-35-9]|[4-6]))|2(?:1(?:3[178]|[45])|[24-689]|3[35]|7[457]))|7(?:14|23)4[0-8]|71(?:33|45)[1-79]"],"8 ($1)",1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"8 ($1)",1],["(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2-$3-$4",["[3489]"],"8 ($1)",1]],"8",0,0,0,0,"3[04-689]|[489]",0,"8~10"],"RW":["250","00","(?:06|[27]\\d\\d|[89]00)\\d{6}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["0"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[7-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["2"]]],"0"],"SA":["966","00","92\\d{7}|(?:[15]|8\\d)\\d{8}",[9,10],[["(\\d{4})(\\d{5})","$1 $2",["9"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["5"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["81"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"]]],"0"],"SB":["677","0[01]","(?:[1-6]|[7-9]\\d\\d)\\d{4}",[5,7],[["(\\d{2})(\\d{5})","$1 $2",["7|8[4-9]|9(?:[1-8]|9[0-8])"]]]],"SC":["248","010|0[0-2]","8000\\d{3}|(?:[249]\\d|64)\\d{5}",[7],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[246]|9[57]"]]],0,0,0,0,0,0,0,"00"],"SD":["249","00","[19]\\d{8}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[19]"],"0$1"]],"0"],"SE":["46","00","(?:[26]\\d\\d|9)\\d{9}|[1-9]\\d{8}|[1-689]\\d{7}|[1-4689]\\d{6}|2\\d{5}",[6,7,8,9,10],[["(\\d{2})(\\d{2,3})(\\d{2})","$1-$2 $3",["20"],"0$1",0,"$1 $2 $3"],["(\\d{3})(\\d{4})","$1-$2",["9(?:00|39|44)"],"0$1",0,"$1 $2"],["(\\d{2})(\\d{3})(\\d{2})","$1-$2 $3",["[12][136]|3[356]|4[0246]|6[03]|90[1-9]"],"0$1",0,"$1 $2 $3"],["(\\d)(\\d{2,3})(\\d{2})(\\d{2})","$1-$2 $3 $4",["8"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2,3})(\\d{2})","$1-$2 $3",["1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[125689]|4[02-57]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"],"0$1",0,"$1 $2 $3"],["(\\d{3})(\\d{2,3})(\\d{3})","$1-$2 $3",["9(?:00|39|44)"],"0$1",0,"$1 $2 $3"],["(\\d{2})(\\d{2,3})(\\d{2})(\\d{2})","$1-$2 $3 $4",["1[13689]|2[0136]|3[1356]|4[0246]|54|6[03]|90[1-9]"],"0$1",0,"$1 $2 $3 $4"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1-$2 $3 $4",["10|7"],"0$1",0,"$1 $2 $3 $4"],["(\\d)(\\d{3})(\\d{3})(\\d{2})","$1-$2 $3 $4",["8"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1-$2 $3 $4",["[13-5]|2(?:[247-9]|5[0138])|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2})(\\d{2})(\\d{3})","$1-$2 $3 $4",["9"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1-$2 $3 $4 $5",["[26]"],"0$1",0,"$1 $2 $3 $4 $5"]],"0"],"SG":["65","0[0-3]\\d","(?:(?:1\\d|8)\\d\\d|7000)\\d{7}|[3689]\\d{7}",[8,10,11],[["(\\d{4})(\\d{4})","$1 $2",["[369]|8(?:01|[1-9])"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"]],["(\\d{4})(\\d{4})(\\d{3})","$1 $2 $3",["7"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]]]],"SH":["290","00","(?:[256]\\d|8)\\d{3}",[4,5],0,0,0,0,0,0,"[256]"],"SI":["386","00|10(?:22|66|88|99)","[1-7]\\d{7}|8\\d{4,7}|90\\d{4,6}",[5,6,7,8],[["(\\d{2})(\\d{3,6})","$1 $2",["8[09]|9"],"0$1"],["(\\d{3})(\\d{5})","$1 $2",["59|8"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[37][01]|4[0139]|51|6"],"0$1"],["(\\d)(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[1-57]"],"(0$1)"]],"0",0,0,0,0,0,0,"00"],"SJ":["47","00","0\\d{4}|(?:[4589]\\d|79)\\d{6}",[5,8],0,0,0,0,0,0,"79"],"SK":["421","00","[2-689]\\d{8}|[2-59]\\d{6}|[2-5]\\d{5}",[6,7,9],[["(\\d)(\\d{2})(\\d{3,4})","$1 $2 $3",["21"],"0$1"],["(\\d{2})(\\d{2})(\\d{2,3})","$1 $2 $3",["[3-5][1-8]1","[3-5][1-8]1[67]"],"0$1"],["(\\d)(\\d{3})(\\d{3})(\\d{2})","$1/$2 $3 $4",["2"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[689]"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1/$2 $3 $4",["[3-5]"],"0$1"]],"0"],"SL":["232","00","(?:[2378]\\d|66|99)\\d{6}",[8],[["(\\d{2})(\\d{6})","$1 $2",["[236-9]"],"(0$1)"]],"0"],"SM":["378","00","(?:0549|[5-7]\\d)\\d{6}",[8,10],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-7]"]],["(\\d{4})(\\d{6})","$1 $2",["0"]]],0,0,"([89]\\d{5})$","0549$1"],"SN":["221","00","(?:[378]\\d{4}|93330)\\d{4}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"]],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[379]"]]]],"SO":["252","00","[346-9]\\d{8}|[12679]\\d{7}|[1-5]\\d{6}|[1348]\\d{5}",[6,7,8,9],[["(\\d{2})(\\d{4})","$1 $2",["8[125]"]],["(\\d{6})","$1",["[134]"]],["(\\d)(\\d{6})","$1 $2",["[15]|2[0-79]|3[0-46-8]|4[0-7]"]],["(\\d)(\\d{7})","$1 $2",["24|[67]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[3478]|64|90"]],["(\\d{2})(\\d{5,7})","$1 $2",["1|28|6[1-35-9]|9[2-9]"]]],"0"],"SR":["597","00","(?:[2-5]|68|[78]\\d)\\d{5}",[6,7],[["(\\d{2})(\\d{2})(\\d{2})","$1-$2-$3",["56"]],["(\\d{3})(\\d{3})","$1-$2",["[2-5]"]],["(\\d{3})(\\d{4})","$1-$2",["[6-8]"]]]],"SS":["211","00","[19]\\d{8}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[19]"],"0$1"]],"0"],"ST":["239","00","(?:22|9\\d)\\d{5}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[29]"]]]],"SV":["503","00","[267]\\d{7}|[89]00\\d{4}(?:\\d{4})?",[7,8,11],[["(\\d{3})(\\d{4})","$1 $2",["[89]"]],["(\\d{4})(\\d{4})","$1 $2",["[267]"]],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["[89]"]]]],"SX":["1","011","7215\\d{6}|(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|(5\\d{6})$","721$1",0,"721"],"SY":["963","00","[1-39]\\d{8}|[1-5]\\d{7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[1-5]"],"0$1",1],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"],"0$1",1]],"0"],"SZ":["268","00","0800\\d{4}|(?:[237]\\d|900)\\d{6}",[8,9],[["(\\d{4})(\\d{4})","$1 $2",["[0237]"]],["(\\d{5})(\\d{4})","$1 $2",["9"]]]],"TA":["290","00","8\\d{3}",[4],0,0,0,0,0,0,"8"],"TC":["1","011","(?:[58]\\d\\d|649|900)\\d{7}",[10],0,"1",0,"1|([2-479]\\d{6})$","649$1",0,"649"],"TD":["235","00|16","(?:22|[69]\\d|77)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2679]"]]],0,0,0,0,0,0,0,"00"],"TG":["228","00","[279]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[279]"]]]],"TH":["66","00[1-9]","1\\d{8,9}|(?:[2-57]|[689]\\d)\\d{7}",[8,9,10],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["14|[3-9]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]]],"0"],"TJ":["992","810","(?:00|11|[3-579]\\d|88)\\d{7}",[9],[["(\\d{6})(\\d)(\\d{2})","$1 $2 $3",["331","3317"],0,1],["(\\d{3})(\\d{2})(\\d{4})","$1 $2 $3",["[34]7|91[78]"],0,1],["(\\d{4})(\\d)(\\d{4})","$1 $2 $3",["3"],0,1],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[0457-9]|11"],0,1]],"8",0,0,0,0,0,0,"8~10"],"TK":["690","00","[2-47]\\d{3,6}",[4,5,6,7]],"TL":["670","00","7\\d{7}|(?:[2-47]\\d|[89]0)\\d{5}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["[2-489]|70"]],["(\\d{4})(\\d{4})","$1 $2",["7"]]]],"TM":["993","810","[1-6]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2-$3-$4",["12"],"(8 $1)"],["(\\d{3})(\\d)(\\d{2})(\\d{2})","$1 $2-$3-$4",["[1-5]"],"(8 $1)"],["(\\d{2})(\\d{6})","$1 $2",["6"],"8 $1"]],"8",0,0,0,0,0,0,"8~10"],"TN":["216","00","[2-57-9]\\d{7}",[8],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[2-57-9]"]]]],"TO":["676","00","(?:0800|[5-8]\\d{3})\\d{3}|[2-8]\\d{4}",[5,7],[["(\\d{2})(\\d{3})","$1-$2",["[2-4]|50|6[09]|7[0-24-69]|8[05]"]],["(\\d{4})(\\d{3})","$1 $2",["0"]],["(\\d{3})(\\d{4})","$1 $2",["[5-8]"]]]],"TR":["90","00","(?:4|8\\d{5})\\d{6}|(?:[2-58]\\d\\d|900)\\d{7}",[7,10,12],[["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["512|8[0589]|90"],"0$1",1],["(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["5(?:[0-59]|61)","5(?:[0-59]|616)","5(?:[0-59]|6161)"],"0$1",1],["(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[24][1-8]|3[1-9]"],"(0$1)",1],["(\\d{3})(\\d{3})(\\d{6})","$1 $2 $3",["80"],"0$1",1]],"0"],"TT":["1","011","(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2-46-8]\\d{6})$","868$1",0,"868"],"TV":["688","00","(?:2|7\\d\\d|90)\\d{4}",[5,6,7],[["(\\d{2})(\\d{3})","$1 $2",["2"]],["(\\d{2})(\\d{4})","$1 $2",["90"]],["(\\d{2})(\\d{5})","$1 $2",["7"]]]],"TW":["886","0(?:0[25-79]|19)","[2-689]\\d{8}|7\\d{9,10}|[2-8]\\d{7}|2\\d{6}",[7,8,9,10,11],[["(\\d{2})(\\d)(\\d{4})","$1 $2 $3",["202"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[258]0"],"0$1"],["(\\d)(\\d{3,4})(\\d{4})","$1 $2 $3",["[23568]|4(?:0[02-48]|[1-47-9])|7[1-9]","[23568]|4(?:0[2-48]|[1-47-9])|(?:400|7)[1-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[49]"],"0$1"],["(\\d{2})(\\d{4})(\\d{4,5})","$1 $2 $3",["7"],"0$1"]],"0",0,0,0,0,0,0,0,"#"],"TZ":["255","00[056]","(?:[26-8]\\d|41|90)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{4})","$1 $2 $3",["[89]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[24]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[67]"],"0$1"]],"0"],"UA":["380","00","[89]\\d{9}|[3-9]\\d{8}",[9,10],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6[12][29]|(?:3[1-8]|4[136-8]|5[12457]|6[49])2|(?:56|65)[24]","6[12][29]|(?:35|4[1378]|5[12457]|6[49])2|(?:56|65)[24]|(?:3[1-46-8]|46)2[013-9]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["4[45][0-5]|5(?:0|6[37])|6(?:[12][018]|[36-8])|7|89|9[1-9]|(?:48|57)[0137-9]","4[45][0-5]|5(?:0|6(?:3[14-7]|7))|6(?:[12][018]|[36-8])|7|89|9[1-9]|(?:48|57)[0137-9]"],"0$1"],["(\\d{4})(\\d{5})","$1 $2",["[3-6]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["[89]"],"0$1"]],"0",0,0,0,0,0,0,"0~0"],"UG":["256","00[057]","800\\d{6}|(?:[29]0|[347]\\d)\\d{7}",[9],[["(\\d{4})(\\d{5})","$1 $2",["202","2024"],"0$1"],["(\\d{3})(\\d{6})","$1 $2",["[27-9]|4(?:6[45]|[7-9])"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["[34]"],"0$1"]],"0"],"US":["1","011","[2-9]\\d{9}",[10],[["(\\d{3})(\\d{3})(\\d{4})","($1) $2-$3",["[2-9]"],0,1,"$1-$2-$3"]],"1",0,0,0,0,0,[["(?:2(?:0[1-35-9]|1[02-9]|2[03-589]|3[149]|4[08]|5[1-46]|6[0279]|7[0269]|8[13])|3(?:0[1-57-9]|1[02-9]|2[0135]|3[0-24679]|4[167]|5[12]|6[014]|8[056])|4(?:0[124-9]|1[02-579]|2[3-5]|3[0245]|4[0235]|58|6[39]|7[0589]|8[04])|5(?:0[1-57-9]|1[0235-8]|20|3[0149]|4[01]|5[19]|6[1-47]|7[013-5]|8[056])|6(?:0[1-35-9]|1[024-9]|2[03689]|[34][016]|5[0179]|6[0-279]|78|8[0-29])|7(?:0[1-46-8]|1[2-9]|2[04-7]|3[1247]|4[037]|5[47]|6[02359]|7[02-59]|8[156])|8(?:0[1-68]|1[02-8]|2[08]|3[0-28]|4[3578]|5[046-9]|6[02-5]|7[028])|9(?:0[1346-9]|1[02-9]|2[0589]|3[0146-8]|4[0179]|5[12469]|7[0-389]|8[04-69]))[2-9]\\d{6}"],[""],["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"],["900[2-9]\\d{6}"],["52(?:35(?:[02-46-9]\\d|1[02-9]|5[0-46-9])|45(?:[034]\\d|1[02-9]|2[024-9]|5[0-46-9]))\\d{4}|52(?:3[2-46-9]|4[2-4])(?:[02-9]\\d|1[02-9])\\d{4}|5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}"]]],"UY":["598","0(?:0|1[3-9]\\d)","(?:[249]\\d\\d|80)\\d{5}|9\\d{6}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["8|90"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["9"],"0$1"],["(\\d{4})(\\d{4})","$1 $2",["[24]"]]],"0",0,0,0,0,0,0,"00"," int. "],"UZ":["998","810","(?:[679]\\d|88)\\d{7}",[9],[["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[6-9]"],"8 $1"]],"8",0,0,0,0,0,0,"8~10"],"VA":["39","00","0\\d{5,10}|3[0-8]\\d{7,10}|55\\d{8}|8\\d{5}(?:\\d{2,4})?|(?:1\\d|39)\\d{7,8}",[6,7,8,9,10,11],0,0,0,0,0,0,"06698"],"VC":["1","011","(?:[58]\\d\\d|784|900)\\d{7}",[10],0,"1",0,"1|([2-7]\\d{6})$","784$1",0,"784"],"VE":["58","00","[68]00\\d{7}|(?:[24]\\d|[59]0)\\d{8}",[10],[["(\\d{3})(\\d{7})","$1-$2",["[24-689]"],"0$1"]],"0"],"VG":["1","011","(?:284|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2-578]\\d{6})$","284$1",0,"284"],"VI":["1","011","[58]\\d{9}|(?:34|90)0\\d{7}",[10],0,"1",0,"1|([2-9]\\d{6})$","340$1",0,"340"],"VN":["84","00","[12]\\d{9}|[135-9]\\d{8}|[16]\\d{7}|[16-8]\\d{6}",[7,8,9,10],[["(\\d{2})(\\d{5})","$1 $2",["80"],"0$1",1],["(\\d{4})(\\d{4,6})","$1 $2",["1"],0,1],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[69]"],"0$1",1],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[3578]"],"0$1",1],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["2[48]"],"0$1",1],["(\\d{3})(\\d{4})(\\d{3})","$1 $2 $3",["2"],"0$1",1]],"0"],"VU":["678","00","(?:[23]\\d|[48]8)\\d{3}|(?:[57]\\d|90)\\d{5}",[5,7],[["(\\d{3})(\\d{4})","$1 $2",["[579]"]]]],"WF":["681","00","(?:[45]0|68|72|8\\d)\\d{4}",[6],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["[4-8]"]]]],"WS":["685","0","(?:[2-6]|8\\d{5})\\d{4}|[78]\\d{6}|[68]\\d{5}",[5,6,7,10],[["(\\d{5})","$1",["[2-5]|6[1-9]"]],["(\\d{3})(\\d{3,7})","$1 $2",["[68]"]],["(\\d{2})(\\d{5})","$1 $2",["7"]]]],"XK":["383","00","[23]\\d{7,8}|(?:4\\d\\d|[89]00)\\d{5}",[8,9],[["(\\d{3})(\\d{5})","$1 $2",["[89]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[2-4]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[23]"],"0$1"]],"0"],"YE":["967","00","(?:1|7\\d)\\d{7}|[1-7]\\d{6}",[7,8,9],[["(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["[1-6]|7[24-68]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["7"],"0$1"]],"0"],"YT":["262","00","80\\d{7}|(?:26|63)9\\d{6}",[9],0,"0",0,0,0,0,"269|63"],"ZA":["27","00","[1-9]\\d{8}|8\\d{4,7}",[5,6,7,8,9],[["(\\d{2})(\\d{3,4})","$1 $2",["8[1-4]"],"0$1"],["(\\d{2})(\\d{3})(\\d{2,3})","$1 $2 $3",["8[1-4]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["860"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-9]"],"0$1"]],"0"],"ZM":["260","00","(?:63|80)0\\d{6}|(?:21|[79]\\d)\\d{7}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[28]"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["[79]"],"0$1"]],"0"],"ZW":["263","00","2(?:[0-57-9]\\d{6,8}|6[0-24-9]\\d{6,7})|[38]\\d{9}|[35-8]\\d{8}|[3-6]\\d{7}|[1-689]\\d{6}|[1-3569]\\d{5}|[1356]\\d{4}",[5,6,7,8,9,10],[["(\\d{3})(\\d{3,5})","$1 $2",["2(?:0[45]|2[278]|[49]8)|3(?:[09]8|17)|6(?:[29]8|37|75)|[23][78]|(?:33|5[15]|6[68])[78]"],"0$1"],["(\\d)(\\d{3})(\\d{2,4})","$1 $2 $3",["[49]"],"0$1"],["(\\d{3})(\\d{4})","$1 $2",["80"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["24|8[13-59]|(?:2[05-79]|39|5[45]|6[15-8])2","2(?:02[014]|4|[56]20|[79]2)|392|5(?:42|525)|6(?:[16-8]21|52[013])|8[13-59]"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["2(?:1[39]|2[0157]|[378]|[56][14])|3(?:12|29)","2(?:1[39]|2[0157]|[378]|[56][14])|3(?:123|29)"],"0$1"],["(\\d{4})(\\d{6})","$1 $2",["8"],"0$1"],["(\\d{2})(\\d{3,5})","$1 $2",["1|2(?:0[0-36-9]|12|29|[56])|3(?:1[0-689]|[24-6])|5(?:[0236-9]|1[2-4])|6(?:[013-59]|7[0-46-9])|(?:33|55|6[68])[0-69]|(?:29|3[09]|62)[0-79]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["29[013-9]|39|54"],"0$1"],["(\\d{4})(\\d{3,5})","$1 $2",["(?:25|54)8","258|5483"],"0$1"]],"0"]},"nonGeographic":{"800":["800",0,"[1-9]\\d{7}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[1-9]"]]],0,0,0,0,0,0,[0,0,["[1-9]\\d{7}"]]],"808":["808",0,"[1-9]\\d{7}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[1-9]"]]],0,0,0,0,0,0,[0,0,0,0,0,0,0,0,0,["[1-9]\\d{7}"]]],"870":["870",0,"[35-7]\\d{8}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[35-7]"]]],0,0,0,0,0,0,[0,["(?:[356]\\d|7[6-8])\\d{7}"]]],"878":["878",0,"10\\d{10}",[12],[["(\\d{2})(\\d{5})(\\d{5})","$1 $2 $3",["1"]]],0,0,0,0,0,0,[0,0,0,0,0,0,0,0,["10\\d{10}"]]],"881":["881",0,"[0-36-9]\\d{8}",[9],[["(\\d)(\\d{3})(\\d{5})","$1 $2 $3",["[0-36-9]"]]],0,0,0,0,0,0,[0,["[0-36-9]\\d{8}"]]],"882":["882",0,"[13]\\d{6}(?:\\d{2,5})?|285\\d{9}|[19]\\d{7}",[7,8,9,10,11,12],[["(\\d{2})(\\d{5})","$1 $2",["16|342"]],["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["[19]"]],["(\\d{2})(\\d{4})(\\d{3})","$1 $2 $3",["3[23]"]],["(\\d{2})(\\d{3,4})(\\d{4})","$1 $2 $3",["1"]],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["34[57]"]],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["34"]],["(\\d{2})(\\d{4,5})(\\d{5})","$1 $2 $3",["[1-3]"]]],0,0,0,0,0,0,[0,["3(?:37\\d\\d|42)\\d{4}|3(?:2|47|7\\d{3})\\d{7}",[7,9,10,12]],0,0,0,0,0,0,["1(?:3(?:0[0347]|[13][0139]|2[035]|4[013568]|6[0459]|7[06]|8[15-8]|9[0689])\\d{4}|6\\d{5,10})|(?:(?:285\\d\\d|3(?:45|[69]\\d{3}))\\d|9[89])\\d{6}"]]],"883":["883",0,"51\\d{7}(?:\\d{3})?",[9,12],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["510"]],["(\\d{3})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["510"]],["(\\d{4})(\\d{4})(\\d{4})","$1 $2 $3",["5"]]],0,0,0,0,0,0,[0,0,0,0,0,0,0,0,["51[013]0\\d{8}|5100\\d{5}"]]],"888":["888",0,"\\d{11}",[11],[["(\\d{3})(\\d{3})(\\d{5})","$1 $2 $3"]],0,0,0,0,0,0,[0,0,0,0,0,0,["\\d{11}"]]],"979":["979",0,"[1359]\\d{8}",[9],[["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["[1359]"]]],0,0,0,0,0,0,[0,0,0,["[1359]\\d{8}"]]]}});
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/constants.js
// The minimum length of the national significant number.
var MIN_LENGTH_FOR_NSN = 2; // The ITU says the maximum length should be 15,
// but one can find longer numbers in Germany.

var MAX_LENGTH_FOR_NSN = 17; // The maximum length of the country calling code.

var MAX_LENGTH_COUNTRY_CODE = 3; // Digits accepted in phone numbers
// (ascii, fullwidth, arabic-indic, and eastern arabic digits).

var VALID_DIGITS = "0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9"; // `DASHES` will be right after the opening square bracket of the "character class"

var DASHES = "-\u2010-\u2015\u2212\u30FC\uFF0D";
var SLASHES = "\uFF0F/";
var DOTS = "\uFF0E.";
var WHITESPACE = " \xA0\xAD\u200B\u2060\u3000";
var BRACKETS = "()\uFF08\uFF09\uFF3B\uFF3D\\[\\]"; // export const OPENING_BRACKETS = '(\uFF08\uFF3B\\\['

var TILDES = "~\u2053\u223C\uFF5E"; // Regular expression of acceptable punctuation found in phone numbers. This
// excludes punctuation found as a leading character only. This consists of dash
// characters, white space characters, full stops, slashes, square brackets,
// parentheses and tildes. Full-width variants are also present.

var VALID_PUNCTUATION = "".concat(DASHES).concat(SLASHES).concat(DOTS).concat(WHITESPACE).concat(BRACKETS).concat(TILDES);
var PLUS_CHARS = "+\uFF0B"; // const LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+')
//# sourceMappingURL=constants.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/util.js
/**
 * Checks whether the entire input sequence can be matched
 * against the regular expression.
 * @return {boolean}
 */
function matchesEntirely(text, regular_expression) {
  // If assigning the `''` default value is moved to the arguments above,
  // code coverage would decrease for some weird reason.
  text = text || '';
  return new RegExp('^(?:' + regular_expression + ')$').test(text);
}
/**
 * Merges two arrays.
 * @param  {*} a
 * @param  {*} b
 * @return {*}
 */

function mergeArrays(a, b) {
  var merged = a.slice();

  for (var _iterator = b, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var element = _ref;

    if (a.indexOf(element) < 0) {
      merged.push(element);
    }
  }

  return merged.sort(function (a, b) {
    return a - b;
  }); // ES6 version, requires Set polyfill.
  // let merged = new Set(a)
  // for (const element of b)
  // {
  // 	merged.add(i)
  // }
  // return Array.from(merged).sort((a, b) => a - b)
}
//# sourceMappingURL=util.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/ParseError.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// https://stackoverflow.com/a/46971044/970769
var ParseError = function ParseError(code) {
  _classCallCheck(this, ParseError);

  this.name = this.constructor.name;
  this.message = code;
  this.stack = new Error(code).stack;
};


ParseError.prototype = Object.create(Error.prototype);
ParseError.prototype.constructor = ParseError;
//# sourceMappingURL=ParseError.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/tools/semver-compare.js
// Copy-pasted from:
// https://github.com/substack/semver-compare/blob/master/index.js
//
// Inlining this function because some users reported issues with
// importing from `semver-compare` in a browser with ES6 "native" modules.
//
// Fixes `semver-compare` not being able to compare versions with alpha/beta/etc "tags".
// https://github.com/catamphetamine/libphonenumber-js/issues/381
/* harmony default export */ var semver_compare = (function (a, b) {
  a = a.split('-');
  b = b.split('-');
  var pa = a[0].split('.');
  var pb = b[0].split('.');

  for (var i = 0; i < 3; i++) {
    var na = Number(pa[i]);
    var nb = Number(pb[i]);
    if (na > nb) return 1;
    if (nb > na) return -1;
    if (!isNaN(na) && isNaN(nb)) return 1;
    if (isNaN(na) && !isNaN(nb)) return -1;
  }

  if (a[1] && b[1]) {
    return a[1] > b[1] ? 1 : a[1] < b[1] ? -1 : 0;
  }

  return !a[1] && b[1] ? 1 : a[1] && !b[1] ? -1 : 0;
});
//# sourceMappingURL=semver-compare.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/metadata.js
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function metadata_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

 // Added "possibleLengths" and renamed
// "country_phone_code_to_countries" to "country_calling_codes".

var V2 = '1.0.18'; // Added "idd_prefix" and "default_idd_prefix".

var V3 = '1.2.0'; // Moved `001` country code to "nonGeographic" section of metadata.

var V4 = '1.7.35';
var DEFAULT_EXT_PREFIX = ' ext. ';
/**
 * See: https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md
 */

var Metadata =
/*#__PURE__*/
function () {
  function Metadata(metadata) {
    metadata_classCallCheck(this, Metadata);

    validateMetadata(metadata);
    this.metadata = metadata;
    setVersion.call(this, metadata);
  }

  _createClass(Metadata, [{
    key: "getCountries",
    value: function getCountries() {
      return Object.keys(this.metadata.countries).filter(function (_) {
        return _ !== '001';
      });
    }
  }, {
    key: "getCountryMetadata",
    value: function getCountryMetadata(countryCode) {
      return this.metadata.countries[countryCode];
    }
  }, {
    key: "nonGeographic",
    value: function nonGeographic() {
      if (this.v1 || this.v2 || this.v3) return; // `nonGeographical` was a typo.
      // It's present in metadata generated from `1.7.35` to `1.7.37`.

      return this.metadata.nonGeographic || this.metadata.nonGeographical;
    }
  }, {
    key: "hasCountry",
    value: function hasCountry(country) {
      return this.getCountryMetadata(country) !== undefined;
    }
  }, {
    key: "hasCallingCode",
    value: function hasCallingCode(callingCode) {
      if (this.getCountryCodesForCallingCode(callingCode)) {
        return true;
      }

      if (this.nonGeographic()) {
        if (this.nonGeographic()[callingCode]) {
          return true;
        }
      } else {
        // A hacky workaround for old custom metadata (generated before V4).
        var countryCodes = this.countryCallingCodes()[callingCode];

        if (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {
          return true;
        }
      }
    }
  }, {
    key: "isNonGeographicCallingCode",
    value: function isNonGeographicCallingCode(callingCode) {
      if (this.nonGeographic()) {
        return this.nonGeographic()[callingCode] ? true : false;
      } else {
        return this.getCountryCodesForCallingCode(callingCode) ? false : true;
      }
    } // Deprecated.

  }, {
    key: "country",
    value: function country(countryCode) {
      return this.selectNumberingPlan(countryCode);
    }
  }, {
    key: "selectNumberingPlan",
    value: function selectNumberingPlan(countryCode, callingCode) {
      if (countryCode && countryCode !== '001') {
        if (!this.hasCountry(countryCode)) {
          throw new Error("Unknown country: ".concat(countryCode));
        }

        this.numberingPlan = new NumberingPlan(this.getCountryMetadata(countryCode), this);
      } else if (callingCode) {
        if (!this.hasCallingCode(callingCode)) {
          throw new Error("Unknown calling code: ".concat(callingCode));
        }

        this.numberingPlan = new NumberingPlan(this.getNumberingPlanMetadata(callingCode), this);
      } else {
        this.numberingPlan = undefined;
      }

      return this;
    }
  }, {
    key: "getCountryCodesForCallingCode",
    value: function getCountryCodesForCallingCode(callingCode) {
      var countryCodes = this.countryCallingCodes()[callingCode];

      if (countryCodes) {
        // Metadata before V4 included "non-geographic entity" calling codes
        // inside `country_calling_codes` (for example, `"881":["001"]`).
        // Now the semantics of `country_calling_codes` has changed:
        // it's specifically for "countries" now.
        // Older versions of custom metadata will simply skip parsing
        // "non-geographic entity" phone numbers with new versions
        // of this library: it's not considered a bug,
        // because such numbers are extremely rare,
        // and developers extremely rarely use custom metadata.
        if (countryCodes.length === 1 && countryCodes[0].length === 3) {
          return;
        }

        return countryCodes;
      }
    }
  }, {
    key: "getCountryCodeForCallingCode",
    value: function getCountryCodeForCallingCode(callingCode) {
      var countryCodes = this.getCountryCodesForCallingCode(callingCode);

      if (countryCodes) {
        return countryCodes[0];
      }
    }
  }, {
    key: "getNumberingPlanMetadata",
    value: function getNumberingPlanMetadata(callingCode) {
      var countryCode = this.getCountryCodeForCallingCode(callingCode);

      if (countryCode) {
        return this.getCountryMetadata(countryCode);
      }

      if (this.nonGeographic()) {
        var metadata = this.nonGeographic()[callingCode];

        if (metadata) {
          return metadata;
        }
      } else {
        // A hacky workaround for old custom metadata (generated before V4).
        var countryCodes = this.countryCallingCodes()[callingCode];

        if (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {
          return this.metadata.countries['001'];
        }
      }
    } // Deprecated.

  }, {
    key: "countryCallingCode",
    value: function countryCallingCode() {
      return this.numberingPlan.callingCode();
    } // Deprecated.

  }, {
    key: "IDDPrefix",
    value: function IDDPrefix() {
      return this.numberingPlan.IDDPrefix();
    } // Deprecated.

  }, {
    key: "defaultIDDPrefix",
    value: function defaultIDDPrefix() {
      return this.numberingPlan.defaultIDDPrefix();
    } // Deprecated.

  }, {
    key: "nationalNumberPattern",
    value: function nationalNumberPattern() {
      return this.numberingPlan.nationalNumberPattern();
    } // Deprecated.

  }, {
    key: "possibleLengths",
    value: function possibleLengths() {
      return this.numberingPlan.possibleLengths();
    } // Deprecated.

  }, {
    key: "formats",
    value: function formats() {
      return this.numberingPlan.formats();
    } // Deprecated.

  }, {
    key: "nationalPrefixForParsing",
    value: function nationalPrefixForParsing() {
      return this.numberingPlan.nationalPrefixForParsing();
    } // Deprecated.

  }, {
    key: "nationalPrefixTransformRule",
    value: function nationalPrefixTransformRule() {
      return this.numberingPlan.nationalPrefixTransformRule();
    } // Deprecated.

  }, {
    key: "leadingDigits",
    value: function leadingDigits() {
      return this.numberingPlan.leadingDigits();
    } // Deprecated.

  }, {
    key: "hasTypes",
    value: function hasTypes() {
      return this.numberingPlan.hasTypes();
    } // Deprecated.

  }, {
    key: "type",
    value: function type(_type) {
      return this.numberingPlan.type(_type);
    } // Deprecated.

  }, {
    key: "ext",
    value: function ext() {
      return this.numberingPlan.ext();
    }
  }, {
    key: "countryCallingCodes",
    value: function countryCallingCodes() {
      if (this.v1) return this.metadata.country_phone_code_to_countries;
      return this.metadata.country_calling_codes;
    } // Deprecated.

  }, {
    key: "chooseCountryByCountryCallingCode",
    value: function chooseCountryByCountryCallingCode(callingCode) {
      this.selectNumberingPlan(null, callingCode);
    }
  }, {
    key: "hasSelectedNumberingPlan",
    value: function hasSelectedNumberingPlan() {
      return this.numberingPlan !== undefined;
    }
  }]);

  return Metadata;
}();



var NumberingPlan =
/*#__PURE__*/
function () {
  function NumberingPlan(metadata, globalMetadataObject) {
    metadata_classCallCheck(this, NumberingPlan);

    this.globalMetadataObject = globalMetadataObject;
    this.metadata = metadata;
    setVersion.call(this, globalMetadataObject.metadata);
  }

  _createClass(NumberingPlan, [{
    key: "callingCode",
    value: function callingCode() {
      return this.metadata[0];
    } // Formatting information for regions which share
    // a country calling code is contained by only one region
    // for performance reasons. For example, for NANPA region
    // ("North American Numbering Plan Administration",
    //  which includes USA, Canada, Cayman Islands, Bahamas, etc)
    // it will be contained in the metadata for `US`.

  }, {
    key: "getDefaultCountryMetadataForRegion",
    value: function getDefaultCountryMetadataForRegion() {
      return this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode());
    }
  }, {
    key: "IDDPrefix",
    value: function IDDPrefix() {
      if (this.v1 || this.v2) return;
      return this.metadata[1];
    }
  }, {
    key: "defaultIDDPrefix",
    value: function defaultIDDPrefix() {
      if (this.v1 || this.v2) return;
      return this.metadata[12];
    }
  }, {
    key: "nationalNumberPattern",
    value: function nationalNumberPattern() {
      if (this.v1 || this.v2) return this.metadata[1];
      return this.metadata[2];
    }
  }, {
    key: "possibleLengths",
    value: function possibleLengths() {
      if (this.v1) return;
      return this.metadata[this.v2 ? 2 : 3];
    }
  }, {
    key: "_getFormats",
    value: function _getFormats(metadata) {
      return metadata[this.v1 ? 2 : this.v2 ? 3 : 4];
    } // For countries of the same region (e.g. NANPA)
    // formats are all stored in the "main" country for that region.
    // E.g. "RU" and "KZ", "US" and "CA".

  }, {
    key: "formats",
    value: function formats() {
      var _this = this;

      var formats = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || [];
      return formats.map(function (_) {
        return new Format(_, _this);
      });
    }
  }, {
    key: "nationalPrefix",
    value: function nationalPrefix() {
      return this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5];
    }
  }, {
    key: "_getNationalPrefixFormattingRule",
    value: function _getNationalPrefixFormattingRule(metadata) {
      return metadata[this.v1 ? 4 : this.v2 ? 5 : 6];
    } // For countries of the same region (e.g. NANPA)
    // national prefix formatting rule is stored in the "main" country for that region.
    // E.g. "RU" and "KZ", "US" and "CA".

  }, {
    key: "nationalPrefixFormattingRule",
    value: function nationalPrefixFormattingRule() {
      return this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion());
    }
  }, {
    key: "_nationalPrefixForParsing",
    value: function _nationalPrefixForParsing() {
      return this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7];
    }
  }, {
    key: "nationalPrefixForParsing",
    value: function nationalPrefixForParsing() {
      // If `national_prefix_for_parsing` is not set explicitly,
      // then infer it from `national_prefix` (if any)
      return this._nationalPrefixForParsing() || this.nationalPrefix();
    }
  }, {
    key: "nationalPrefixTransformRule",
    value: function nationalPrefixTransformRule() {
      return this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8];
    }
  }, {
    key: "_getNationalPrefixIsOptionalWhenFormatting",
    value: function _getNationalPrefixIsOptionalWhenFormatting() {
      return !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9];
    } // For countries of the same region (e.g. NANPA)
    // "national prefix is optional when formatting" flag is
    // stored in the "main" country for that region.
    // E.g. "RU" and "KZ", "US" and "CA".

  }, {
    key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
    value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
      return this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) || this._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion());
    }
  }, {
    key: "leadingDigits",
    value: function leadingDigits() {
      return this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10];
    }
  }, {
    key: "types",
    value: function types() {
      return this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11];
    }
  }, {
    key: "hasTypes",
    value: function hasTypes() {
      // Versions 1.2.0 - 1.2.4: can be `[]`.

      /* istanbul ignore next */
      if (this.types() && this.types().length === 0) {
        return false;
      } // Versions <= 1.2.4: can be `undefined`.
      // Version >= 1.2.5: can be `0`.


      return !!this.types();
    }
  }, {
    key: "type",
    value: function type(_type2) {
      if (this.hasTypes() && metadata_getType(this.types(), _type2)) {
        return new Type(metadata_getType(this.types(), _type2), this);
      }
    }
  }, {
    key: "ext",
    value: function ext() {
      if (this.v1 || this.v2) return DEFAULT_EXT_PREFIX;
      return this.metadata[13] || DEFAULT_EXT_PREFIX;
    }
  }]);

  return NumberingPlan;
}();

var Format =
/*#__PURE__*/
function () {
  function Format(format, metadata) {
    metadata_classCallCheck(this, Format);

    this._format = format;
    this.metadata = metadata;
  }

  _createClass(Format, [{
    key: "pattern",
    value: function pattern() {
      return this._format[0];
    }
  }, {
    key: "format",
    value: function format() {
      return this._format[1];
    }
  }, {
    key: "leadingDigitsPatterns",
    value: function leadingDigitsPatterns() {
      return this._format[2] || [];
    }
  }, {
    key: "nationalPrefixFormattingRule",
    value: function nationalPrefixFormattingRule() {
      return this._format[3] || this.metadata.nationalPrefixFormattingRule();
    }
  }, {
    key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
    value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
      return !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
    }
  }, {
    key: "nationalPrefixIsMandatoryWhenFormattingInNationalFormat",
    value: function nationalPrefixIsMandatoryWhenFormattingInNationalFormat() {
      // National prefix is omitted if there's no national prefix formatting rule
      // set for this country, or when the national prefix formatting rule
      // contains no national prefix itself, or when this rule is set but
      // national prefix is optional for this phone number format
      // (and it is not enforced explicitly)
      return this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
    } // Checks whether national prefix formatting rule contains national prefix.

  }, {
    key: "usesNationalPrefix",
    value: function usesNationalPrefix() {
      return this.nationalPrefixFormattingRule() && // Check that national prefix formatting rule is not a "dummy" one.
      !FIRST_GROUP_ONLY_PREFIX_PATTERN.test(this.nationalPrefixFormattingRule()); // Previously, `FIRST_GROUP_ONLY_PREFIX_PATTERN` check was instead done via:
      // // Check that national prefix formatting rule is not a "dummy" one.
      // this.nationalPrefixFormattingRule() !== '$1' &&
      // // Check that national prefix formatting rule actually has national prefix digit(s).
      // // Filters out cases like "($1)".
      // // Is used in place of `libphonenumber`'s `FIRST_GROUP_ONLY_PREFIX_PATTERN_` regexp.
      // /\d/.test(this.nationalPrefixFormattingRule().replace('$1', ''))
    }
  }, {
    key: "internationalFormat",
    value: function internationalFormat() {
      return this._format[5] || this.format();
    }
  }]);

  return Format;
}();
/**
 * A pattern that is used to determine if the national prefix formatting rule
 * has the first group only, i.e., does not start with the national prefix.
 * Note that the pattern explicitly allows for unbalanced parentheses.
 */


var FIRST_GROUP_ONLY_PREFIX_PATTERN = /^\(?\$1\)?$/;

var Type =
/*#__PURE__*/
function () {
  function Type(type, metadata) {
    metadata_classCallCheck(this, Type);

    this.type = type;
    this.metadata = metadata;
  }

  _createClass(Type, [{
    key: "pattern",
    value: function pattern() {
      if (this.metadata.v1) return this.type;
      return this.type[0];
    }
  }, {
    key: "possibleLengths",
    value: function possibleLengths() {
      if (this.metadata.v1) return;
      return this.type[1] || this.metadata.possibleLengths();
    }
  }]);

  return Type;
}();

function metadata_getType(types, type) {
  switch (type) {
    case 'FIXED_LINE':
      return types[0];

    case 'MOBILE':
      return types[1];

    case 'TOLL_FREE':
      return types[2];

    case 'PREMIUM_RATE':
      return types[3];

    case 'PERSONAL_NUMBER':
      return types[4];

    case 'VOICEMAIL':
      return types[5];

    case 'UAN':
      return types[6];

    case 'PAGER':
      return types[7];

    case 'VOIP':
      return types[8];

    case 'SHARED_COST':
      return types[9];
  }
}

function validateMetadata(metadata) {
  if (!metadata) {
    throw new Error('[libphonenumber-js] `metadata` argument not passed. Check your arguments.');
  } // `country_phone_code_to_countries` was renamed to
  // `country_calling_codes` in `1.0.18`.


  if (!is_object(metadata) || !is_object(metadata.countries)) {
    throw new Error("[libphonenumber-js] `metadata` argument was passed but it's not a valid metadata. Must be an object having `.countries` child object property. Got ".concat(is_object(metadata) ? 'an object of shape: { ' + Object.keys(metadata).join(', ') + ' }' : 'a ' + type_of(metadata) + ': ' + metadata, "."));
  }
} // Babel transforms `typeof` into some "branches"
// so istanbul will show this as "branch not covered".

/* istanbul ignore next */

var is_object = function is_object(_) {
  return _typeof(_) === 'object';
}; // Babel transforms `typeof` into some "branches"
// so istanbul will show this as "branch not covered".

/* istanbul ignore next */


var type_of = function type_of(_) {
  return _typeof(_);
};
/**
 * Returns extension prefix for a country.
 * @param  {string} country
 * @param  {object} metadata
 * @return {string?}
 * @example
 * // Returns " ext. "
 * getExtPrefix("US")
 */


function getExtPrefix(country, metadata) {
  metadata = new Metadata(metadata);

  if (metadata.hasCountry(country)) {
    return metadata.country(country).ext();
  }

  return DEFAULT_EXT_PREFIX;
}
/**
 * Returns "country calling code" for a country.
 * Throws an error if the country doesn't exist or isn't supported by this library.
 * @param  {string} country
 * @param  {object} metadata
 * @return {string}
 * @example
 * // Returns "44"
 * getCountryCallingCode("GB")
 */

function getCountryCallingCode(country, metadata) {
  metadata = new Metadata(metadata);

  if (metadata.hasCountry(country)) {
    return metadata.country(country).countryCallingCode();
  }

  throw new Error("Unknown country: ".concat(country));
}
function isSupportedCountry(country, metadata) {
  // metadata = new Metadata(metadata)
  // return metadata.hasCountry(country)
  return metadata.countries[country] !== undefined;
}

function setVersion(metadata) {
  this.v1 = !metadata.version;
  this.v2 = metadata.version !== undefined && semver_compare(metadata.version, V3) === -1;
  this.v3 = metadata.version !== undefined && semver_compare(metadata.version, V4) === -1;
  this.v4 = metadata.version !== undefined; // && compare(metadata.version, V5) === -1
} // const ISO_COUNTRY_CODE = /^[A-Z]{2}$/
// function isCountryCode(countryCode) {
// 	return ISO_COUNTRY_CODE.test(countryCodeOrCountryCallingCode)
// }
//# sourceMappingURL=metadata.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/extension.js
 // The RFC 3966 format for extensions.

var RFC3966_EXTN_PREFIX = ';ext='; // Pattern to capture digits used in an extension.
// Places a maximum length of '7' for an extension.

var CAPTURING_EXTN_DIGITS = '([' + VALID_DIGITS + ']{1,7})';
/**
 * Regexp of all possible ways to write extensions, for use when parsing. This
 * will be run as a case-insensitive regexp match. Wide character versions are
 * also provided after each ASCII version. There are three regular expressions
 * here. The first covers RFC 3966 format, where the extension is added using
 * ';ext='. The second more generic one starts with optional white space and
 * ends with an optional full stop (.), followed by zero or more spaces/tabs
 * /commas and then the numbers themselves. The other one covers the special
 * case of American numbers where the extension is written with a hash at the
 * end, such as '- 503#'. Note that the only capturing groups should be around
 * the digits that you want to capture as part of the extension, or else parsing
 * will fail! We allow two options for representing the accented o - the
 * character itself, and one in the unicode decomposed form with the combining
 * acute accent.
 */

function create_extension_pattern(purpose) {
  // One-character symbols that can be used to indicate an extension.
  var single_extension_characters = "x\uFF58#\uFF03~\uFF5E";

  switch (purpose) {
    // For parsing, we are slightly more lenient in our interpretation than for matching. Here we
    // allow "comma" and "semicolon" as possible extension indicators. When matching, these are
    case 'parsing':
      single_extension_characters = ',;' + single_extension_characters;
  }

  return RFC3966_EXTN_PREFIX + CAPTURING_EXTN_DIGITS + '|' + "[ \xA0\\t,]*" + "(?:e?xt(?:ensi(?:o\u0301?|\xF3))?n?|\uFF45?\uFF58\uFF54\uFF4E?|" + // "Ð´Ð¾Ð±."
  "\u0434\u043E\u0431|" + '[' + single_extension_characters + "]|int|anexo|\uFF49\uFF4E\uFF54)" + "[:\\.\uFF0E]?[ \xA0\\t,-]*" + CAPTURING_EXTN_DIGITS + '#?|' + '[- ]+([' + VALID_DIGITS + ']{1,5})#';
}
/**
 * Regexp of all possible ways to write extensions, for use when parsing. This
 * will be run as a case-insensitive regexp match. Wide character versions are
 * also provided after each ASCII version. There are three regular expressions
 * here. The first covers RFC 3966 format, where the extension is added using
 * ';ext='. The second more generic one starts with optional white space and
 * ends with an optional full stop (.), followed by zero or more spaces/tabs
 * /commas and then the numbers themselves. The other one covers the special
 * case of American numbers where the extension is written with a hash at the
 * end, such as '- 503#'. Note that the only capturing groups should be around
 * the digits that you want to capture as part of the extension, or else parsing
 * will fail! We allow two options for representing the accented o - the
 * character itself, and one in the unicode decomposed form with the combining
 * acute accent.
 */


var EXTN_PATTERNS_FOR_PARSING = create_extension_pattern('parsing');
var EXTN_PATTERNS_FOR_MATCHING = create_extension_pattern('matching'); // Regexp of all known extension prefixes used by different regions followed by
// 1 or more valid digits, for use when parsing.

var EXTN_PATTERN = new RegExp('(?:' + EXTN_PATTERNS_FOR_PARSING + ')$', 'i'); // Strips any extension (as in, the part of the number dialled after the call is
// connected, usually indicated with extn, ext, x or similar) from the end of
// the number, and returns it.

function extractExtension(number) {
  var start = number.search(EXTN_PATTERN);

  if (start < 0) {
    return {};
  } // If we find a potential extension, and the number preceding this is a viable
  // number, we assume it is an extension.


  var number_without_extension = number.slice(0, start);
  var matches = number.match(EXTN_PATTERN);
  var i = 1;

  while (i < matches.length) {
    if (matches[i] != null && matches[i].length > 0) {
      return {
        number: number_without_extension,
        ext: matches[i]
      };
    }

    i++;
  }
}
//# sourceMappingURL=extension.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/isViablePhoneNumber.js

 //  Regular expression of viable phone numbers. This is location independent.
//  Checks we have at least three leading digits, and only valid punctuation,
//  alpha characters and digits in the phone number. Does not include extension
//  data. The symbol 'x' is allowed here as valid punctuation since it is often
//  used as a placeholder for carrier codes, for example in Brazilian phone
//  numbers. We also allow multiple '+' characters at the start.
//
//  Corresponds to the following:
//  [digits]{minLengthNsn}|
//  plus_sign*
//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*
//
//  The first reg-ex is to allow short numbers (two digits long) to be parsed if
//  they are entered as "15" etc, but only if there is no punctuation in them.
//  The second expression restricts the number of digits to three or more, but
//  then allows them to be in international form, and to have alpha-characters
//  and punctuation. We split up the two reg-exes here and combine them when
//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it
//  with ^ and append $ to each branch.
//
//  "Note VALID_PUNCTUATION starts with a -,
//   so must be the first in the range" (c) Google devs.
//  (wtf did they mean by saying that; probably nothing)
//

var MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}'; //
// And this is the second reg-exp:
// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)
//

var VALID_PHONE_NUMBER = '[' + PLUS_CHARS + ']{0,1}' + '(?:' + '[' + VALID_PUNCTUATION + ']*' + '[' + VALID_DIGITS + ']' + '){3,}' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*'; // The combined regular expression for valid phone numbers:
//

var VALID_PHONE_NUMBER_PATTERN = new RegExp( // Either a short two-digit-only phone number
'^' + MIN_LENGTH_PHONE_NUMBER_PATTERN + '$' + '|' + // Or a longer fully parsed phone number (min 3 characters)
'^' + VALID_PHONE_NUMBER + // Phone number extensions
'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?' + '$', 'i'); // Checks to see if the string of characters could possibly be a phone number at
// all. At the moment, checks to see that the string begins with at least 2
// digits, ignoring any punctuation commonly found in phone numbers. This method
// does not require the number to be normalized in advance - but does assume
// that leading non-number symbols have been removed, such as by the method
// `extract_possible_number`.
//

function isViablePhoneNumber(number) {
  return number.length >= MIN_LENGTH_FOR_NSN && VALID_PHONE_NUMBER_PATTERN.test(number);
}
//# sourceMappingURL=isViablePhoneNumber.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/parseDigits.js
// These mappings map a character (key) to a specific digit that should
// replace it for normalization purposes. Non-European digits that
// may be used in phone numbers are mapped to a European equivalent.
//
// E.g. in Iraq they don't write `+442323234` but rather `+Ù¤Ù¤Ù¢Ù£Ù¢Ù£Ù¢Ù£Ù¤`.
//
var DIGITS = {
  '0': '0',
  '1': '1',
  '2': '2',
  '3': '3',
  '4': '4',
  '5': '5',
  '6': '6',
  '7': '7',
  '8': '8',
  '9': '9',
  "\uFF10": '0',
  // Fullwidth digit 0
  "\uFF11": '1',
  // Fullwidth digit 1
  "\uFF12": '2',
  // Fullwidth digit 2
  "\uFF13": '3',
  // Fullwidth digit 3
  "\uFF14": '4',
  // Fullwidth digit 4
  "\uFF15": '5',
  // Fullwidth digit 5
  "\uFF16": '6',
  // Fullwidth digit 6
  "\uFF17": '7',
  // Fullwidth digit 7
  "\uFF18": '8',
  // Fullwidth digit 8
  "\uFF19": '9',
  // Fullwidth digit 9
  "\u0660": '0',
  // Arabic-indic digit 0
  "\u0661": '1',
  // Arabic-indic digit 1
  "\u0662": '2',
  // Arabic-indic digit 2
  "\u0663": '3',
  // Arabic-indic digit 3
  "\u0664": '4',
  // Arabic-indic digit 4
  "\u0665": '5',
  // Arabic-indic digit 5
  "\u0666": '6',
  // Arabic-indic digit 6
  "\u0667": '7',
  // Arabic-indic digit 7
  "\u0668": '8',
  // Arabic-indic digit 8
  "\u0669": '9',
  // Arabic-indic digit 9
  "\u06F0": '0',
  // Eastern-Arabic digit 0
  "\u06F1": '1',
  // Eastern-Arabic digit 1
  "\u06F2": '2',
  // Eastern-Arabic digit 2
  "\u06F3": '3',
  // Eastern-Arabic digit 3
  "\u06F4": '4',
  // Eastern-Arabic digit 4
  "\u06F5": '5',
  // Eastern-Arabic digit 5
  "\u06F6": '6',
  // Eastern-Arabic digit 6
  "\u06F7": '7',
  // Eastern-Arabic digit 7
  "\u06F8": '8',
  // Eastern-Arabic digit 8
  "\u06F9": '9' // Eastern-Arabic digit 9

};
function parseDigit(character) {
  return DIGITS[character];
}
/**
 * Parses phone number digits from a string.
 * Drops all punctuation leaving only digits.
 * Also converts wide-ascii and arabic-indic numerals to conventional numerals.
 * E.g. in Iraq they don't write `+442323234` but rather `+Ù¤Ù¤Ù¢Ù£Ù¢Ù£Ù¢Ù£Ù¤`.
 * @param  {string} string
 * @return {string}
 * @example
 * ```js
 * parseDigits('8 (800) 555')
 * // Outputs '8800555'.
 * ```
 */

function parseDigits(string) {
  var result = ''; // Using `.split('')` here instead of normal `for ... of`
  // because the importing application doesn't neccessarily include an ES6 polyfill.
  // The `.split('')` approach discards "exotic" UTF-8 characters
  // (the ones consisting of four bytes) but digits
  // (including non-European ones) don't fall into that range
  // so such "exotic" characters would be discarded anyway.

  for (var _iterator = string.split(''), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var character = _ref;
    var digit = parseDigit(character);

    if (digit) {
      result += digit;
    }
  }

  return result;
}
//# sourceMappingURL=parseDigits.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/parseIncompletePhoneNumber.js

/**
 * Parses phone number characters from a string.
 * Drops all punctuation leaving only digits and the leading `+` sign (if any).
 * Also converts wide-ascii and arabic-indic numerals to conventional numerals.
 * E.g. in Iraq they don't write `+442323234` but rather `+Ù¤Ù¤Ù¢Ù£Ù¢Ù£Ù¢Ù£Ù¤`.
 * @param  {string} string
 * @return {string}
 * @example
 * ```js
 * // Outputs '8800555'.
 * parseIncompletePhoneNumber('8 (800) 555')
 * // Outputs '+7800555'.
 * parseIncompletePhoneNumber('+7 800 555')
 * ```
 */

function parseIncompletePhoneNumber(string) {
  var result = ''; // Using `.split('')` here instead of normal `for ... of`
  // because the importing application doesn't neccessarily include an ES6 polyfill.
  // The `.split('')` approach discards "exotic" UTF-8 characters
  // (the ones consisting of four bytes) but digits
  // (including non-European ones) don't fall into that range
  // so such "exotic" characters would be discarded anyway.

  for (var _iterator = string.split(''), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var character = _ref;
    result += parsePhoneNumberCharacter(character, result) || '';
  }

  return result;
}
/**
 * `input-format` `parse()` function.
 * https://gitlab.com/catamphetamine/input-format
 * @param  {string} character - Yet another character from raw input string.
 * @param  {string} value - The value parsed so far.
 * @param  {object} meta - Optional custom use-case-specific metadata.
 * @return {string?} The parsed character.
 */

function parsePhoneNumberCharacter(character, value) {
  // Only allow a leading `+`.
  if (character === '+') {
    // If this `+` is not the first parsed character
    // then discard it.
    if (value) {
      return;
    }

    return '+';
  } // Allow digits.


  return parseDigit(character);
}
//# sourceMappingURL=parseIncompletePhoneNumber.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/getNumberType_.js


var NON_FIXED_LINE_PHONE_TYPES = ['MOBILE', 'PREMIUM_RATE', 'TOLL_FREE', 'SHARED_COST', 'VOIP', 'PERSONAL_NUMBER', 'PAGER', 'UAN', 'VOICEMAIL']; // Finds out national phone number type (fixed line, mobile, etc)

function getNumberType(input, options, metadata) {
  // If assigning the `{}` default value is moved to the arguments above,
  // code coverage would decrease for some weird reason.
  options = options || {}; // When `parse()` returned `{}`
  // meaning that the phone number is not a valid one.

  if (!input.country) {
    return;
  }

  metadata = new Metadata(metadata);
  metadata.selectNumberingPlan(input.country, input.countryCallingCode);
  var nationalNumber = options.v2 ? input.nationalNumber : input.phone; // The following is copy-pasted from the original function:
  // https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835
  // Is this national number even valid for this country

  if (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern())) {
    return;
  } // Is it fixed line number


  if (is_of_type(nationalNumber, 'FIXED_LINE', metadata)) {
    // Because duplicate regular expressions are removed
    // to reduce metadata size, if "mobile" pattern is ""
    // then it means it was removed due to being a duplicate of the fixed-line pattern.
    //
    if (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '') {
      return 'FIXED_LINE_OR_MOBILE';
    } // v1 metadata.
    // Legacy.
    // Deprecated.


    if (!metadata.type('MOBILE')) {
      return 'FIXED_LINE_OR_MOBILE';
    } // Check if the number happens to qualify as both fixed line and mobile.
    // (no such country in the minimal metadata set)

    /* istanbul ignore if */


    if (is_of_type(nationalNumber, 'MOBILE', metadata)) {
      return 'FIXED_LINE_OR_MOBILE';
    }

    return 'FIXED_LINE';
  }

  for (var _i = 0, _NON_FIXED_LINE_PHONE = NON_FIXED_LINE_PHONE_TYPES; _i < _NON_FIXED_LINE_PHONE.length; _i++) {
    var _type = _NON_FIXED_LINE_PHONE[_i];

    if (is_of_type(nationalNumber, _type, metadata)) {
      return _type;
    }
  }
}
function is_of_type(nationalNumber, type, metadata) {
  type = metadata.type(type);

  if (!type || !type.pattern()) {
    return false;
  } // Check if any possible number lengths are present;
  // if so, we use them to avoid checking
  // the validation pattern if they don't match.
  // If they are absent, this means they match
  // the general description, which we have
  // already checked before a specific number type.


  if (type.possibleLengths() && type.possibleLengths().indexOf(nationalNumber.length) < 0) {
    return false;
  }

  return matchesEntirely(nationalNumber, type.pattern());
} // Should only be called for the "new" metadata which has "possible lengths".

function checkNumberLengthForType(nationalNumber, type, metadata) {
  var type_info = metadata.type(type); // There should always be "<possiblePengths/>" set for every type element.
  // This is declared in the XML schema.
  // For size efficiency, where a sub-description (e.g. fixed-line)
  // has the same "<possiblePengths/>" as the "general description", this is missing,
  // so we fall back to the "general description". Where no numbers of the type
  // exist at all, there is one possible length (-1) which is guaranteed
  // not to match the length of any real phone number.

  var possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths(); // let local_lengths    = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()
  // Metadata before version `1.0.18` didn't contain `possible_lengths`.

  if (!possible_lengths) {
    return 'IS_POSSIBLE';
  }

  if (type === 'FIXED_LINE_OR_MOBILE') {
    // No such country in metadata.

    /* istanbul ignore next */
    if (!metadata.type('FIXED_LINE')) {
      // The rare case has been encountered where no fixedLine data is available
      // (true for some non-geographic entities), so we just check mobile.
      return checkNumberLengthForType(nationalNumber, 'MOBILE', metadata);
    }

    var mobile_type = metadata.type('MOBILE');

    if (mobile_type) {
      // Merge the mobile data in if there was any. "Concat" creates a new
      // array, it doesn't edit possible_lengths in place, so we don't need a copy.
      // Note that when adding the possible lengths from mobile, we have
      // to again check they aren't empty since if they are this indicates
      // they are the same as the general desc and should be obtained from there.
      possible_lengths = mergeArrays(possible_lengths, mobile_type.possibleLengths()); // The current list is sorted; we need to merge in the new list and
      // re-sort (duplicates are okay). Sorting isn't so expensive because
      // the lists are very small.
      // if (local_lengths)
      // {
      // 	local_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())
      // }
      // else
      // {
      // 	local_lengths = mobile_type.possibleLengthsLocal()
      // }
    }
  } // If the type doesn't exist then return 'INVALID_LENGTH'.
  else if (type && !type_info) {
      return 'INVALID_LENGTH';
    }

  var actual_length = nationalNumber.length; // In `libphonenumber-js` all "local-only" formats are dropped for simplicity.
  // // This is safe because there is never an overlap beween the possible lengths
  // // and the local-only lengths; this is checked at build time.
  // if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)
  // {
  // 	return 'IS_POSSIBLE_LOCAL_ONLY'
  // }

  var minimum_length = possible_lengths[0];

  if (minimum_length === actual_length) {
    return 'IS_POSSIBLE';
  }

  if (minimum_length > actual_length) {
    return 'TOO_SHORT';
  }

  if (possible_lengths[possible_lengths.length - 1] < actual_length) {
    return 'TOO_LONG';
  } // We skip the first element since we've already checked it.


  return possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH';
}
//# sourceMappingURL=getNumberType_.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/isPossibleNumber_.js


function isPossiblePhoneNumber(input, options, metadata) {
  /* istanbul ignore if */
  if (options === undefined) {
    options = {};
  }

  metadata = new Metadata(metadata);

  if (options.v2) {
    if (!input.countryCallingCode) {
      throw new Error('Invalid phone number object passed');
    }

    metadata.chooseCountryByCountryCallingCode(input.countryCallingCode);
  } else {
    if (!input.phone) {
      return false;
    }

    if (input.country) {
      if (!metadata.hasCountry(input.country)) {
        throw new Error("Unknown country: ".concat(input.country));
      }

      metadata.country(input.country);
    } else {
      if (!input.countryCallingCode) {
        throw new Error('Invalid phone number object passed');
      }

      metadata.chooseCountryByCountryCallingCode(input.countryCallingCode);
    }
  }

  if (metadata.possibleLengths()) {
    return isPossibleNumber(input.phone || input.nationalNumber, undefined, metadata);
  } else {
    // There was a bug between `1.7.35` and `1.7.37` where "possible_lengths"
    // were missing for "non-geographical" numbering plans.
    // Just assume the number is possible in such cases:
    // it's unlikely that anyone generated their custom metadata
    // in that short period of time (one day).
    // This code can be removed in some future major version update.
    if (input.countryCallingCode && metadata.isNonGeographicCallingCode(input.countryCallingCode)) {
      // "Non-geographic entities" did't have `possibleLengths`
      // due to a bug in metadata generation process.
      return true;
    } else {
      throw new Error('Missing "possibleLengths" in metadata. Perhaps the metadata has been generated before v1.0.18.');
    }
  }
}
function isPossibleNumber(nationalNumber, isInternational, metadata) {
  switch (checkNumberLengthForType(nationalNumber, undefined, metadata)) {
    case 'IS_POSSIBLE':
      return true;
    // case 'IS_POSSIBLE_LOCAL_ONLY':
    // 	return !isInternational

    default:
      return false;
  }
}
//# sourceMappingURL=isPossibleNumber_.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/IDD.js


var CAPTURING_DIGIT_PATTERN = new RegExp('([' + VALID_DIGITS + '])');
/**
 * Pattern that makes it easy to distinguish whether a region has a single
 * international dialing prefix or not. If a region has a single international
 * prefix (e.g. 011 in USA), it will be represented as a string that contains
 * a sequence of ASCII digits, and possibly a tilde, which signals waiting for
 * the tone. If there are multiple available international prefixes in a
 * region, they will be represented as a regex string that always contains one
 * or more characters that are not ASCII digits or a tilde.
 */

var SINGLE_IDD_PREFIX = /^[\d]+(?:[~\u2053\u223C\uFF5E][\d]+)?$/; // For regions that have multiple IDD prefixes
// a preferred IDD prefix is returned.

function getIDDPrefix(country, callingCode, metadata) {
  var countryMetadata = new Metadata(metadata);
  countryMetadata.selectNumberingPlan(country, callingCode);

  if (SINGLE_IDD_PREFIX.test(countryMetadata.IDDPrefix())) {
    return countryMetadata.IDDPrefix();
  }

  return countryMetadata.defaultIDDPrefix();
}
function stripIDDPrefix(number, country, callingCode, metadata) {
  if (!country) {
    return;
  } // Check if the number is IDD-prefixed.


  var countryMetadata = new Metadata(metadata);
  countryMetadata.selectNumberingPlan(country, callingCode);
  var IDDPrefixPattern = new RegExp(countryMetadata.IDDPrefix());

  if (number.search(IDDPrefixPattern) !== 0) {
    return;
  } // Strip IDD prefix.


  number = number.slice(number.match(IDDPrefixPattern)[0].length); // Some kind of a weird edge case.
  // No explanation from Google given.

  var matchedGroups = number.match(CAPTURING_DIGIT_PATTERN);
  /* istanbul ignore next */

  if (matchedGroups && matchedGroups[1] != null && matchedGroups[1].length > 0) {
    if (matchedGroups[1] === '0') {
      return;
    }
  }

  return number;
}
//# sourceMappingURL=IDD.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/RFC3966.js
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

 // https://www.ietf.org/rfc/rfc3966.txt

/**
 * @param  {string} text - Phone URI (RFC 3966).
 * @return {object} `{ ?number, ?ext }`.
 */

function parseRFC3966(text) {
  var number;
  var ext; // Replace "tel:" with "tel=" for parsing convenience.

  text = text.replace(/^tel:/, 'tel=');

  for (var _iterator = text.split(';'), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var part = _ref;

    var _part$split = part.split('='),
        _part$split2 = _slicedToArray(_part$split, 2),
        name = _part$split2[0],
        value = _part$split2[1];

    switch (name) {
      case 'tel':
        number = value;
        break;

      case 'ext':
        ext = value;
        break;

      case 'phone-context':
        // Only "country contexts" are supported.
        // "Domain contexts" are ignored.
        if (value[0] === '+') {
          number = value + number;
        }

        break;
    }
  } // If the phone number is not viable, then abort.


  if (!isViablePhoneNumber(number)) {
    return {};
  }

  var result = {
    number: number
  };

  if (ext) {
    result.ext = ext;
  }

  return result;
}
/**
 * @param  {object} - `{ ?number, ?extension }`.
 * @return {string} Phone URI (RFC 3966).
 */

function formatRFC3966(_ref2) {
  var number = _ref2.number,
      ext = _ref2.ext;

  if (!number) {
    return '';
  }

  if (number[0] !== '+') {
    throw new Error("\"formatRFC3966()\" expects \"number\" to be in E.164 format.");
  }

  return "tel:".concat(number).concat(ext ? ';ext=' + ext : '');
}
//# sourceMappingURL=RFC3966.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/validate_.js



/**
 * Checks if a given phone number is valid.
 *
 * If the `number` is a string, it will be parsed to an object,
 * but only if it contains only valid phone number characters (including punctuation).
 * If the `number` is an object, it is used as is.
 *
 * The optional `defaultCountry` argument is the default country.
 * I.e. it does not restrict to just that country,
 * e.g. in those cases where several countries share
 * the same phone numbering rules (NANPA, Britain, etc).
 * For example, even though the number `07624 369230`
 * belongs to the Isle of Man ("IM" country code)
 * calling `isValidNumber('07624369230', 'GB', metadata)`
 * still returns `true` because the country is not restricted to `GB`,
 * it's just that `GB` is the default one for the phone numbering rules.
 * For restricting the country see `isValidNumberForRegion()`
 * though restricting a country might not be a good idea.
 * https://github.com/googlei18n/libphonenumber/blob/master/FAQ.md#when-should-i-use-isvalidnumberforregion
 *
 * Examples:
 *
 * ```js
 * isValidNumber('+78005553535', metadata)
 * isValidNumber('8005553535', 'RU', metadata)
 * isValidNumber('88005553535', 'RU', metadata)
 * isValidNumber({ phone: '8005553535', country: 'RU' }, metadata)
 * ```
 */

function isValidNumber(input, options, metadata) {
  // If assigning the `{}` default value is moved to the arguments above,
  // code coverage would decrease for some weird reason.
  options = options || {};
  metadata = new Metadata(metadata); // This is just to support `isValidNumber({})`
  // for cases when `parseNumber()` returns `{}`.

  if (!input.country) {
    return false;
  }

  metadata.selectNumberingPlan(input.country, input.countryCallingCode); // By default, countries only have type regexps when it's required for
  // distinguishing different countries having the same `countryCallingCode`.

  if (metadata.hasTypes()) {
    return getNumberType(input, options, metadata.metadata) !== undefined;
  } // If there are no type regexps for this country in metadata then use
  // `nationalNumberPattern` as a "better than nothing" replacement.


  var national_number = options.v2 ? input.nationalNumber : input.phone;
  return matchesEntirely(national_number, metadata.nationalNumberPattern());
}
//# sourceMappingURL=validate_.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/format_.js
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { format_defineProperty(target, key, source[key]); }); } return target; }

function format_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// This is a port of Google Android `libphonenumber`'s
// `phonenumberutil.js` of December 31th, 2018.
//
// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js





var DEFAULT_OPTIONS = {
  formatExtension: function formatExtension(formattedNumber, extension, metadata) {
    return "".concat(formattedNumber).concat(metadata.ext()).concat(extension);
  } // Formats a phone number
  //
  // Example use cases:
  //
  // ```js
  // formatNumber('8005553535', 'RU', 'INTERNATIONAL')
  // formatNumber('8005553535', 'RU', 'INTERNATIONAL', metadata)
  // formatNumber({ phone: '8005553535', country: 'RU' }, 'INTERNATIONAL')
  // formatNumber({ phone: '8005553535', country: 'RU' }, 'INTERNATIONAL', metadata)
  // formatNumber('+78005553535', 'NATIONAL')
  // formatNumber('+78005553535', 'NATIONAL', metadata)
  // ```
  //

};
function format_formatNumber(input, format, options, metadata) {
  // Apply default options.
  if (options) {
    options = _objectSpread({}, DEFAULT_OPTIONS, options);
  } else {
    options = DEFAULT_OPTIONS;
  }

  metadata = new Metadata(metadata);

  if (input.country && input.country !== '001') {
    // Validate `input.country`.
    if (!metadata.hasCountry(input.country)) {
      throw new Error("Unknown country: ".concat(input.country));
    }

    metadata.country(input.country);
  } else if (input.countryCallingCode) {
    metadata.chooseCountryByCountryCallingCode(input.countryCallingCode);
  } else return input.phone || '';

  var countryCallingCode = metadata.countryCallingCode();
  var nationalNumber = options.v2 ? input.nationalNumber : input.phone; // This variable should have been declared inside `case`s
  // but Babel has a bug and it says "duplicate variable declaration".

  var number;

  switch (format) {
    case 'NATIONAL':
      // Legacy argument support.
      // (`{ country: ..., phone: '' }`)
      if (!nationalNumber) {
        return '';
      }

      number = formatNationalNumber(nationalNumber, 'NATIONAL', metadata, options);
      return addExtension(number, input.ext, metadata, options.formatExtension);

    case 'INTERNATIONAL':
      // Legacy argument support.
      // (`{ country: ..., phone: '' }`)
      if (!nationalNumber) {
        return "+".concat(countryCallingCode);
      }

      number = formatNationalNumber(nationalNumber, 'INTERNATIONAL', metadata, options);
      number = "+".concat(countryCallingCode, " ").concat(number);
      return addExtension(number, input.ext, metadata, options.formatExtension);

    case 'E.164':
      // `E.164` doesn't define "phone number extensions".
      return "+".concat(countryCallingCode).concat(nationalNumber);

    case 'RFC3966':
      return formatRFC3966({
        number: "+".concat(countryCallingCode).concat(nationalNumber),
        ext: input.ext
      });

    case 'IDD':
      if (!options.fromCountry) {
        return; // throw new Error('`fromCountry` option not passed for IDD-prefixed formatting.')
      }

      var IDDPrefix = getIDDPrefix(options.fromCountry, undefined, metadata.metadata);

      if (!IDDPrefix) {
        return;
      }

      if (options.humanReadable) {
        var formattedForSameCountryCallingCode = countryCallingCode && formatIDDSameCountryCallingCodeNumber(nationalNumber, metadata.countryCallingCode(), options.fromCountry, metadata, options);

        if (formattedForSameCountryCallingCode) {
          number = formattedForSameCountryCallingCode;
        } else {
          number = "".concat(IDDPrefix, " ").concat(countryCallingCode, " ").concat(formatNationalNumber(nationalNumber, 'INTERNATIONAL', metadata, options));
        }

        return addExtension(number, input.ext, metadata, options.formatExtension);
      }

      return "".concat(IDDPrefix).concat(countryCallingCode).concat(nationalNumber);

    default:
      throw new Error("Unknown \"format\" argument passed to \"formatNumber()\": \"".concat(format, "\""));
  }
} // This was originally set to $1 but there are some countries for which the
// first group is not used in the national pattern (e.g. Argentina) so the $1
// group does not match correctly.  Therefore, we use \d, so that the first
// group actually used in the pattern will be matched.

var FIRST_GROUP_PATTERN = /(\$\d)/;
function formatNationalNumberUsingFormat(number, format, useInternationalSeparator, useNationalPrefixFormattingRule, metadata) {
  var formattedNumber = number.replace(new RegExp(format.pattern()), useInternationalSeparator ? format.internationalFormat() : useNationalPrefixFormattingRule && format.nationalPrefixFormattingRule() ? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule()) : format.format());

  if (useInternationalSeparator) {
    return applyInternationalSeparatorStyle(formattedNumber);
  }

  return formattedNumber;
}

function formatNationalNumber(number, formatAs, metadata, options) {
  var format = chooseFormatForNumber(metadata.formats(), number);

  if (!format) {
    return number;
  }

  return formatNationalNumberUsingFormat(number, format, formatAs === 'INTERNATIONAL', format.nationalPrefixIsOptionalWhenFormattingInNationalFormat() && options.nationalPrefix === false ? false : true, metadata);
}

function chooseFormatForNumber(availableFormats, nationalNnumber) {
  for (var _iterator = availableFormats, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var format = _ref;

    // Validate leading digits
    if (format.leadingDigitsPatterns().length > 0) {
      // The last leading_digits_pattern is used here, as it is the most detailed
      var lastLeadingDigitsPattern = format.leadingDigitsPatterns()[format.leadingDigitsPatterns().length - 1]; // If leading digits don't match then move on to the next phone number format

      if (nationalNnumber.search(lastLeadingDigitsPattern) !== 0) {
        continue;
      }
    } // Check that the national number matches the phone number format regular expression


    if (matchesEntirely(nationalNnumber, format.pattern())) {
      return format;
    }
  }
} // Removes brackets and replaces dashes with spaces.
//
// E.g. "(999) 111-22-33" -> "999 111 22 33"
//
// For some reason Google's metadata contains `<intlFormat/>`s with brackets and dashes.
// Meanwhile, there's no single opinion about using punctuation in international phone numbers.
//
// For example, Google's `<intlFormat/>` for USA is `+1 213-373-4253`.
// And here's a quote from WikiPedia's "North American Numbering Plan" page:
// https://en.wikipedia.org/wiki/North_American_Numbering_Plan
//
// "The country calling code for all countries participating in the NANP is 1.
// In international format, an NANP number should be listed as +1 301 555 01 00,
// where 301 is an area code (Maryland)."
//
// I personally prefer the international format without any punctuation.
// For example, brackets are remnants of the old age, meaning that the
// phone number part in brackets (so called "area code") can be omitted
// if dialing within the same "area".
// And hyphens were clearly introduced for splitting local numbers into memorizable groups.
// For example, remembering "5553535" is difficult but "555-35-35" is much simpler.
// Imagine a man taking a bus from home to work and seeing an ad with a phone number.
// He has a couple of seconds to memorize that number until it passes by.
// If it were spaces instead of hyphens the man wouldn't necessarily get it,
// but with hyphens instead of spaces the grouping is more explicit.
// I personally think that hyphens introduce visual clutter,
// so I prefer replacing them with spaces in international numbers.
// In the modern age all output is done on displays where spaces are clearly distinguishable
// so hyphens can be safely replaced with spaces without losing any legibility.
//


function applyInternationalSeparatorStyle(local) {
  return local.replace(new RegExp("[".concat(VALID_PUNCTUATION, "]+"), 'g'), ' ').trim();
}

function addExtension(formattedNumber, ext, metadata, formatExtension) {
  return ext ? formatExtension(formattedNumber, ext, metadata) : formattedNumber;
}

function formatIDDSameCountryCallingCodeNumber(number, toCountryCallingCode, fromCountry, toCountryMetadata, options) {
  var fromCountryMetadata = new Metadata(toCountryMetadata.metadata);
  fromCountryMetadata.country(fromCountry); // If calling within the same country calling code.

  if (toCountryCallingCode === fromCountryMetadata.countryCallingCode()) {
    // For NANPA regions, return the national format for these regions
    // but prefix it with the country calling code.
    if (toCountryCallingCode === '1') {
      return toCountryCallingCode + ' ' + formatNationalNumber(number, 'NATIONAL', toCountryMetadata, options);
    } // If regions share a country calling code, the country calling code need
    // not be dialled. This also applies when dialling within a region, so this
    // if clause covers both these cases. Technically this is the case for
    // dialling from La Reunion to other overseas departments of France (French
    // Guiana, Martinique, Guadeloupe), but not vice versa - so we don't cover
    // this edge case for now and for those cases return the version including
    // country calling code. Details here:
    // http://www.petitfute.com/voyage/225-info-pratiques-reunion
    //


    return formatNationalNumber(number, 'NATIONAL', toCountryMetadata, options);
  }
}
//# sourceMappingURL=format_.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/PhoneNumber.js
function PhoneNumber_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { PhoneNumber_defineProperty(target, key, source[key]); }); } return target; }

function PhoneNumber_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function PhoneNumber_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function PhoneNumber_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function PhoneNumber_createClass(Constructor, protoProps, staticProps) { if (protoProps) PhoneNumber_defineProperties(Constructor.prototype, protoProps); if (staticProps) PhoneNumber_defineProperties(Constructor, staticProps); return Constructor; }







var USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;

var PhoneNumber_PhoneNumber =
/*#__PURE__*/
function () {
  function PhoneNumber(countryCallingCode, nationalNumber, metadata) {
    PhoneNumber_classCallCheck(this, PhoneNumber);

    if (!countryCallingCode) {
      throw new TypeError('`country` or `countryCallingCode` not passed');
    }

    if (!nationalNumber) {
      throw new TypeError('`nationalNumber` not passed');
    }

    var _metadata = new Metadata(metadata); // If country code is passed then derive `countryCallingCode` from it.
    // Also store the country code as `.country`.


    if (isCountryCode(countryCallingCode)) {
      this.country = countryCallingCode;

      _metadata.country(countryCallingCode);

      countryCallingCode = _metadata.countryCallingCode();
    } else {
      /* istanbul ignore if */
      if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
        if (_metadata.isNonGeographicCallingCode(countryCallingCode)) {
          this.country = '001';
        }
      }
    }

    this.countryCallingCode = countryCallingCode;
    this.nationalNumber = nationalNumber;
    this.number = '+' + this.countryCallingCode + this.nationalNumber;
    this.metadata = metadata;
  }

  PhoneNumber_createClass(PhoneNumber, [{
    key: "isPossible",
    value: function isPossible() {
      return isPossiblePhoneNumber(this, {
        v2: true
      }, this.metadata);
    }
  }, {
    key: "isValid",
    value: function isValid() {
      return isValidNumber(this, {
        v2: true
      }, this.metadata);
    }
  }, {
    key: "isNonGeographic",
    value: function isNonGeographic() {
      var metadata = new Metadata(this.metadata);
      return metadata.isNonGeographicCallingCode(this.countryCallingCode);
    }
  }, {
    key: "isEqual",
    value: function isEqual(phoneNumber) {
      return this.number === phoneNumber.number && this.ext === phoneNumber.ext;
    } // // Is just an alias for `this.isValid() && this.country === country`.
    // // https://github.com/googlei18n/libphonenumber/blob/master/FAQ.md#when-should-i-use-isvalidnumberforregion
    // isValidForRegion(country) {
    // 	return isValidNumberForRegion(this, country, { v2: true }, this.metadata)
    // }

  }, {
    key: "getType",
    value: function getType() {
      return getNumberType(this, {
        v2: true
      }, this.metadata);
    }
  }, {
    key: "format",
    value: function format(_format, options) {
      return format_formatNumber(this, _format, options ? PhoneNumber_objectSpread({}, options, {
        v2: true
      }) : {
        v2: true
      }, this.metadata);
    }
  }, {
    key: "formatNational",
    value: function formatNational(options) {
      return this.format('NATIONAL', options);
    }
  }, {
    key: "formatInternational",
    value: function formatInternational(options) {
      return this.format('INTERNATIONAL', options);
    }
  }, {
    key: "getURI",
    value: function getURI(options) {
      return this.format('RFC3966', options);
    }
  }]);

  return PhoneNumber;
}();



var isCountryCode = function isCountryCode(value) {
  return /^[A-Z]{2}$/.test(value);
};
//# sourceMappingURL=PhoneNumber.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/parse_.js
// This is a port of Google Android `libphonenumber`'s
// `phonenumberutil.js` of December 31th, 2018.
//
// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js












 // We don't allow input strings for parsing to be longer than 250 chars.
// This prevents malicious input from consuming CPU.

var MAX_INPUT_STRING_LENGTH = 250; // This consists of the plus symbol, digits, and arabic-indic digits.

var PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']'); // Regular expression of trailing characters that we want to remove.

var AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$');
var parse_USE_NON_GEOGRAPHIC_COUNTRY_CODE = false; // `options`:
//  {
//    country:
//    {
//      restrict - (a two-letter country code)
//                 the phone number must be in this country
//
//      default - (a two-letter country code)
//                default country to use for phone number parsing and validation
//                (if no country code could be derived from the phone number)
//    }
//  }
//
// Returns `{ country, number }`
//
// Example use cases:
//
// ```js
// parse('8 (800) 555-35-35', 'RU')
// parse('8 (800) 555-35-35', 'RU', metadata)
// parse('8 (800) 555-35-35', { country: { default: 'RU' } })
// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)
// parse('+7 800 555 35 35')
// parse('+7 800 555 35 35', metadata)
// ```
//

function parse(text, options, metadata) {
  // If assigning the `{}` default value is moved to the arguments above,
  // code coverage would decrease for some weird reason.
  options = options || {};
  metadata = new Metadata(metadata); // Validate `defaultCountry`.

  if (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {
    if (options.v2) {
      throw new ParseError('INVALID_COUNTRY');
    }

    throw new Error("Unknown country: ".concat(options.defaultCountry));
  } // Parse the phone number.


  var _parseInput = parseInput(text, options.v2),
      formattedPhoneNumber = _parseInput.number,
      ext = _parseInput.ext; // If the phone number is not viable then return nothing.


  if (!formattedPhoneNumber) {
    if (options.v2) {
      throw new ParseError('NOT_A_NUMBER');
    }

    return {};
  }

  var _parsePhoneNumber = parsePhoneNumber(formattedPhoneNumber, options.defaultCountry, options.defaultCallingCode, metadata),
      country = _parsePhoneNumber.country,
      nationalNumber = _parsePhoneNumber.nationalNumber,
      countryCallingCode = _parsePhoneNumber.countryCallingCode,
      carrierCode = _parsePhoneNumber.carrierCode;

  if (!metadata.hasSelectedNumberingPlan()) {
    if (options.v2) {
      throw new ParseError('INVALID_COUNTRY');
    }

    return {};
  } // Validate national (significant) number length.


  if (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {
    // Won't throw here because the regexp already demands length > 1.

    /* istanbul ignore if */
    if (options.v2) {
      throw new ParseError('TOO_SHORT');
    } // Google's demo just throws an error in this case.


    return {};
  } // Validate national (significant) number length.
  //
  // A sidenote:
  //
  // They say that sometimes national (significant) numbers
  // can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).
  // https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36
  // Such numbers will just be discarded.
  //


  if (nationalNumber.length > MAX_LENGTH_FOR_NSN) {
    if (options.v2) {
      throw new ParseError('TOO_LONG');
    } // Google's demo just throws an error in this case.


    return {};
  }

  if (options.v2) {
    var phoneNumber = new PhoneNumber_PhoneNumber(countryCallingCode, nationalNumber, metadata.metadata);

    if (country) {
      phoneNumber.country = country;
    }

    if (carrierCode) {
      phoneNumber.carrierCode = carrierCode;
    }

    if (ext) {
      phoneNumber.ext = ext;
    }

    return phoneNumber;
  } // Check if national phone number pattern matches the number.
  // National number pattern is different for each country,
  // even for those ones which are part of the "NANPA" group.


  var valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ? matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) : false;

  if (!options.extended) {
    return valid ? parse_result(country, nationalNumber, ext) : {};
  }

  return {
    country: country,
    countryCallingCode: countryCallingCode,
    carrierCode: carrierCode,
    valid: valid,
    possible: valid ? true : options.extended === true && metadata.possibleLengths() && isPossibleNumber(nationalNumber, countryCallingCode !== undefined, metadata) ? true : false,
    phone: nationalNumber,
    ext: ext
  };
}
/**
 * Extracts a formatted phone number from text.
 * Doesn't guarantee that the extracted phone number
 * is a valid phone number (for example, doesn't validate its length).
 * @param  {string} text
 * @param  {boolean} throwOnError â By default, it won't throw if the text is too long.
 * @return {string}
 * @example
 * // Returns "(213) 373-4253".
 * extractFormattedPhoneNumber("Call (213) 373-4253 for assistance.")
 */

function extractFormattedPhoneNumber(text, throwOnError) {
  if (!text) {
    return;
  }

  if (text.length > MAX_INPUT_STRING_LENGTH) {
    if (throwOnError) {
      throw new ParseError('TOO_LONG');
    }

    return;
  } // Attempt to extract a possible number from the string passed in


  var startsAt = text.search(PHONE_NUMBER_START_PATTERN);

  if (startsAt < 0) {
    return;
  }

  return text // Trim everything to the left of the phone number
  .slice(startsAt) // Remove trailing non-numerical characters
  .replace(AFTER_PHONE_NUMBER_END_PATTERN, '');
}
/**
 * Strips any national prefix (such as 0, 1) present in a
 * (possibly incomplete) number provided.
 * "Carrier codes" are only used  in Colombia and Brazil,
 * and only when dialing within those countries from a mobile phone to a fixed line number.
 * Sometimes it won't actually strip national prefix
 * and will instead prepend some digits to the `number`:
 * for example, when number `2345678` is passed with `VI` country selected,
 * it will return `{ number: "3402345678" }`, because `340` area code is prepended.
 * @param {string} number â National number digits.
 * @param {object} metadata â Metadata with country selected.
 * @return {object} `{ nationalNumber: string, carrierCode: string? }`.
 */

function stripNationalPrefixAndCarrierCode(number, metadata) {
  if (number && metadata.nationalPrefixForParsing()) {
    // See METADATA.md for the description of
    // `national_prefix_for_parsing` and `national_prefix_transform_rule`.
    // Attempt to parse the first digits as a national prefix.
    var prefixPattern = new RegExp('^(?:' + metadata.nationalPrefixForParsing() + ')');
    var prefixMatch = prefixPattern.exec(number);

    if (prefixMatch) {
      var nationalNumber;
      var carrierCode; // If a "capturing group" didn't match
      // then its element in `prefixMatch[]` array will be `undefined`.

      var capturedGroupsCount = prefixMatch.length - 1;

      if (metadata.nationalPrefixTransformRule() && capturedGroupsCount > 0 && prefixMatch[capturedGroupsCount]) {
        nationalNumber = number.replace(prefixPattern, metadata.nationalPrefixTransformRule()); // Carrier code is the last captured group,
        // but only when there's more than one captured group.

        if (capturedGroupsCount > 1 && prefixMatch[capturedGroupsCount]) {
          carrierCode = prefixMatch[1];
        }
      } // If it's a simple-enough case then just
      // strip the national prefix from the number.
      else {
          // National prefix is the whole substring matched by
          // the `national_prefix_for_parsing` regexp.
          var nationalPrefix = prefixMatch[0];
          nationalNumber = number.slice(nationalPrefix.length); // Carrier code is the last captured group.

          if (capturedGroupsCount > 0) {
            carrierCode = prefixMatch[1];
          }
        } // We require that the national (significant) number remaining after
      // stripping the national prefix and carrier code be long enough
      // to be a possible length for the region. Otherwise, we don't do
      // the stripping, since the original number could be a valid number.
      // For example, in some countries (Russia, Belarus) the same digit
      // could be both a national prefix and a leading digit of a valid
      // national phone number, like `8` is the national prefix for Russia
      // and `800 555 35 35` is a valid national (significant) number.


      if (matchesEntirely(number, metadata.nationalNumberPattern()) && !matchesEntirely(nationalNumber, metadata.nationalNumberPattern())) {// Don't strip national prefix or carrier code.
      } else {
        return {
          nationalNumber: nationalNumber,
          carrierCode: carrierCode
        };
      }
    }
  }

  return {
    nationalNumber: number
  };
}
function findCountryCode(callingCode, nationalPhoneNumber, metadata) {
  /* istanbul ignore if */
  if (parse_USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
    if (metadata.isNonGeographicCallingCode(callingCode)) {
      return '001';
    }
  } // Is always non-empty, because `callingCode` is always valid


  var possibleCountries = metadata.getCountryCodesForCallingCode(callingCode);

  if (!possibleCountries) {
    return;
  } // If there's just one country corresponding to the country code,
  // then just return it, without further phone number digits validation.


  if (possibleCountries.length === 1) {
    return possibleCountries[0];
  }

  return _findCountryCode(possibleCountries, nationalPhoneNumber, metadata.metadata);
} // Changes `metadata` `country`.

function _findCountryCode(possibleCountries, nationalPhoneNumber, metadata) {
  metadata = new Metadata(metadata);

  for (var _iterator = possibleCountries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var country = _ref;
    metadata.country(country); // Leading digits check would be the simplest one

    if (metadata.leadingDigits()) {
      if (nationalPhoneNumber && nationalPhoneNumber.search(metadata.leadingDigits()) === 0) {
        return country;
      }
    } // Else perform full validation with all of those
    // fixed-line/mobile/etc regular expressions.
    else if (getNumberType({
        phone: nationalPhoneNumber,
        country: country
      }, undefined, metadata.metadata)) {
        return country;
      }
  }
}
/**
 * @param  {string} text - Input.
 * @return {object} `{ ?number, ?ext }`.
 */


function parseInput(text, v2) {
  // Parse RFC 3966 phone number URI.
  if (text && text.indexOf('tel:') === 0) {
    return parseRFC3966(text);
  }

  var number = extractFormattedPhoneNumber(text, v2); // If the phone number is not viable, then abort.

  if (!number || !isViablePhoneNumber(number)) {
    return {};
  } // Attempt to parse extension first, since it doesn't require region-specific
  // data and we want to have the non-normalised number here.


  var withExtensionStripped = extractExtension(number);

  if (withExtensionStripped.ext) {
    return withExtensionStripped;
  }

  return {
    number: number
  };
}
/**
 * Creates `parse()` result object.
 */


function parse_result(country, nationalNumber, ext) {
  var result = {
    country: country,
    phone: nationalNumber
  };

  if (ext) {
    result.ext = ext;
  }

  return result;
}
/**
 * Parses a viable phone number.
 * @param {string} formattedPhoneNumber â Example: "(213) 373-4253".
 * @param {string} [defaultCountry]
 * @param {string} [defaultCallingCode]
 * @param {Metadata} metadata
 * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.
 */


function parsePhoneNumber(formattedPhoneNumber, defaultCountry, defaultCallingCode, metadata) {
  // Extract calling code from phone number.
  var _extractCountryCallin = parse_extractCountryCallingCode(parseIncompletePhoneNumber(formattedPhoneNumber), defaultCountry, defaultCallingCode, metadata.metadata),
      countryCallingCode = _extractCountryCallin.countryCallingCode,
      number = _extractCountryCallin.number; // Choose a country by `countryCallingCode`.


  var country;

  if (countryCallingCode) {
    metadata.chooseCountryByCountryCallingCode(countryCallingCode);
  } // If `formattedPhoneNumber` is in "national" format
  // then `number` is defined and `countryCallingCode` isn't.
  else if (number && (defaultCountry || defaultCallingCode)) {
      metadata.selectNumberingPlan(defaultCountry, defaultCallingCode);

      if (defaultCountry) {
        country = defaultCountry;
      } else {
        /* istanbul ignore if */
        if (parse_USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
          if (metadata.isNonGeographicCallingCode(defaultCallingCode)) {
            country = '001';
          }
        }
      }

      countryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata.metadata);
    } else return {};

  if (!number) {
    return {
      countryCallingCode: countryCallingCode
    };
  }

  var _stripNationalPrefixA = stripNationalPrefixAndCarrierCodeFromCompleteNumber(parseIncompletePhoneNumber(number), metadata),
      nationalNumber = _stripNationalPrefixA.nationalNumber,
      carrierCode = _stripNationalPrefixA.carrierCode; // Sometimes there are several countries
  // corresponding to the same country phone code
  // (e.g. NANPA countries all having `1` country phone code).
  // Therefore, to reliably determine the exact country,
  // national (significant) number should have been parsed first.
  //
  // When `metadata.json` is generated, all "ambiguous" country phone codes
  // get their countries populated with the full set of
  // "phone number type" regular expressions.
  //


  var exactCountry = findCountryCode(countryCallingCode, nationalNumber, metadata);

  if (exactCountry) {
    country = exactCountry;
    /* istanbul ignore if */

    if (exactCountry === '001') {// Can't happen with `USE_NON_GEOGRAPHIC_COUNTRY_CODE` being `false`.
      // If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` is set to `true` for some reason,
      // then remove the "istanbul ignore if".
    } else {
      metadata.country(country);
    }
  }

  return {
    country: country,
    countryCallingCode: countryCallingCode,
    nationalNumber: nationalNumber,
    carrierCode: carrierCode
  };
}
/**
 * Strips national prefix and carrier code from a complete phone number.
 * The difference from the non-"FromCompleteNumber" function is that
 * it won't extract national prefix if the resultant number is too short
 * to be a complete number for the selected phone numbering plan.
 * @param  {string} number â Complete phone number digits.
 * @param  {Metadata} metadata â Metadata with a phone numbering plan selected.
 * @return {object} `{ nationalNumber: string, carrierCode: string? }`.
 */


function stripNationalPrefixAndCarrierCodeFromCompleteNumber(number, metadata) {
  // Parsing national prefixes and carrier codes
  // is only required for local phone numbers
  // but some people don't understand that
  // and sometimes write international phone numbers
  // with national prefixes (or maybe even carrier codes).
  // http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html
  // Google's original library forgives such mistakes
  // and so does this library, because it has been requested:
  // https://github.com/catamphetamine/libphonenumber-js/issues/127
  var _stripNationalPrefixA2 = stripNationalPrefixAndCarrierCode(parseIncompletePhoneNumber(number), metadata),
      nationalNumber = _stripNationalPrefixA2.nationalNumber,
      carrierCode = _stripNationalPrefixA2.carrierCode; // If a national prefix has been extracted, check to see
  // if the resultant number isn't too short.


  if (nationalNumber.length !== number.length + (carrierCode ? carrierCode.length : 0)) {
    // If not using legacy generated metadata (before version `1.0.18`)
    // then it has "possible lengths", so use those to validate the number length.
    if (metadata.possibleLengths()) {
      // "We require that the NSN remaining after stripping the national prefix and
      // carrier code be long enough to be a possible length for the region.
      // Otherwise, we don't do the stripping, since the original number could be
      // a valid short number."
      // https://github.com/google/libphonenumber/blob/876268eb1ad6cdc1b7b5bef17fc5e43052702d57/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3236-L3250
      switch (checkNumberLengthForType(nationalNumber, undefined, metadata)) {
        case 'TOO_SHORT':
        case 'INVALID_LENGTH':
          // case 'IS_POSSIBLE_LOCAL_ONLY':
          // Don't strip the national prefix.
          return {
            nationalNumber: number
          };
      }
    }
  }

  return {
    nationalNumber: nationalNumber,
    carrierCode: carrierCode
  };
}
/**
 * Converts a phone number digits (possibly with a `+`)
 * into a calling code and the rest phone number digits.
 * The "rest phone number digits" could include
 * a national prefix, carrier code, and national
 * (significant) number.
 * @param  {string} number â Phone number digits (possibly with a `+`).
 * @param  {string} [country] âÂ Default country.
 * @param  {string} [callingCode] â Default calling code (some phone numbering plans are non-geographic).
 * @param  {object} metadata
 * @return {object} `{ countryCallingCode: string?, number: string }`
 * @example
 * // Returns `{ countryCallingCode: "1", number: "2133734253" }`.
 * extractCountryCallingCode('2133734253', 'US', null, metadata)
 * extractCountryCallingCode('2133734253', null, '1', metadata)
 * extractCountryCallingCode('+12133734253', null, null, metadata)
 * extractCountryCallingCode('+12133734253', 'RU', null, metadata)
 */

function parse_extractCountryCallingCode(number, country, callingCode, metadata) {
  if (!number) {
    return {};
  } // If this is not an international phone number,
  // then either extract an "IDD" prefix, or extract a
  // country calling code from a number by autocorrecting it
  // by prepending a leading `+` in cases when it starts
  // with the country calling code.
  // https://wikitravel.org/en/International_dialling_prefix
  // https://github.com/catamphetamine/libphonenumber-js/issues/376


  if (number[0] !== '+') {
    // Convert an "out-of-country" dialing phone number
    // to a proper international phone number.
    var numberWithoutIDD = stripIDDPrefix(number, country, callingCode, metadata); // If an IDD prefix was stripped then
    // convert the number to international one
    // for subsequent parsing.

    if (numberWithoutIDD && numberWithoutIDD !== number) {
      number = '+' + numberWithoutIDD;
    } else {
      // Check to see if the number starts with the country calling code
      // for the default country. If so, we remove the country calling code,
      // and do some checks on the validity of the number before and after.
      // https://github.com/catamphetamine/libphonenumber-js/issues/376
      if (country || callingCode) {
        var _extractCountryCallin2 = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(number, country, callingCode, metadata),
            countryCallingCode = _extractCountryCallin2.countryCallingCode,
            shorterNumber = _extractCountryCallin2.number;

        if (countryCallingCode) {
          return {
            countryCallingCode: countryCallingCode,
            number: shorterNumber
          };
        }
      }

      return {
        number: number
      };
    }
  } // Fast abortion: country codes do not begin with a '0'


  if (number[1] === '0') {
    return {};
  }

  metadata = new Metadata(metadata); // The thing with country phone codes
  // is that they are orthogonal to each other
  // i.e. there's no such country phone code A
  // for which country phone code B exists
  // where B starts with A.
  // Therefore, while scanning digits,
  // if a valid country code is found,
  // that means that it is the country code.
  //

  var i = 2;

  while (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {
    var _countryCallingCode = number.slice(1, i);

    if (metadata.hasCallingCode(_countryCallingCode)) {
      metadata.selectNumberingPlan(undefined, _countryCallingCode);
      return {
        countryCallingCode: _countryCallingCode,
        number: number.slice(i)
      };
    }

    i++;
  }

  return {};
}
/**
 * Sometimes some people incorrectly input international phone numbers
 * without the leading `+`. This function corrects such input.
 * @param  {string} number â Phone number digits.
 * @param  {string?} country
 * @param  {string?} callingCode
 * @param  {object} metadata
 * @return {object} `{ countryCallingCode: string?, number: string }`.
 */

function extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(number, country, callingCode, metadata) {
  var countryCallingCode = country ? getCountryCallingCode(country, metadata) : callingCode;

  if (number.indexOf(countryCallingCode) === 0) {
    metadata = new Metadata(metadata);
    metadata.selectNumberingPlan(country, callingCode);
    var possibleShorterNumber = number.slice(countryCallingCode.length);

    var _stripNationalPrefixA3 = stripNationalPrefixAndCarrierCode(possibleShorterNumber, metadata),
        possibleShorterNationalNumber = _stripNationalPrefixA3.nationalNumber;

    var _stripNationalPrefixA4 = stripNationalPrefixAndCarrierCode(number, metadata),
        nationalNumber = _stripNationalPrefixA4.nationalNumber; // If the number was not valid before but is valid now,
    // or if it was too long before, we consider the number
    // with the country calling code stripped to be a better result
    // and keep that instead.
    // For example, in Germany (+49), `49` is a valid area code,
    // so if a number starts with `49`, it could be both a valid
    // national German number or an international number without
    // a leading `+`.


    if (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) && matchesEntirely(possibleShorterNationalNumber, metadata.nationalNumberPattern()) || checkNumberLengthForType(nationalNumber, undefined, metadata) === 'TOO_LONG') {
      return {
        countryCallingCode: countryCallingCode,
        number: possibleShorterNumber
      };
    }
  }

  return {
    number: number
  };
}
//# sourceMappingURL=parse_.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/parsePhoneNumber_.js
function parsePhoneNumber_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { parsePhoneNumber_defineProperty(target, key, source[key]); }); } return target; }

function parsePhoneNumber_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


function parsePhoneNumber_parsePhoneNumber(text, options, metadata) {
  return parse(text, parsePhoneNumber_objectSpread({}, options, {
    v2: true
  }), metadata);
}
//# sourceMappingURL=parsePhoneNumber_.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/parsePhoneNumber.js
function parsePhoneNumber_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { parsePhoneNumber_typeof = function _typeof(obj) { return typeof obj; }; } else { parsePhoneNumber_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return parsePhoneNumber_typeof(obj); }

function es6_parsePhoneNumber_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { es6_parsePhoneNumber_defineProperty(target, key, source[key]); }); } return target; }

function es6_parsePhoneNumber_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function parsePhoneNumber_slicedToArray(arr, i) { return parsePhoneNumber_arrayWithHoles(arr) || parsePhoneNumber_iterableToArrayLimit(arr, i) || parsePhoneNumber_nonIterableRest(); }

function parsePhoneNumber_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function parsePhoneNumber_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function parsePhoneNumber_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


function es6_parsePhoneNumber_parsePhoneNumber() {
  var _normalizeArguments = normalizeArguments(arguments),
      text = _normalizeArguments.text,
      options = _normalizeArguments.options,
      metadata = _normalizeArguments.metadata;

  return parsePhoneNumber_parsePhoneNumber(text, options, metadata);
}
function normalizeArguments(args) {
  var _Array$prototype$slic = Array.prototype.slice.call(args),
      _Array$prototype$slic2 = parsePhoneNumber_slicedToArray(_Array$prototype$slic, 4),
      arg_1 = _Array$prototype$slic2[0],
      arg_2 = _Array$prototype$slic2[1],
      arg_3 = _Array$prototype$slic2[2],
      arg_4 = _Array$prototype$slic2[3];

  var text;
  var options;
  var metadata; // If the phone number is passed as a string.
  // `parsePhoneNumber('88005553535', ...)`.

  if (typeof arg_1 === 'string') {
    text = arg_1;
  } else throw new TypeError('A text for parsing must be a string.'); // If "default country" argument is being passed then move it to `options`.
  // `parsePhoneNumber('88005553535', 'RU', [options], metadata)`.


  if (!arg_2 || typeof arg_2 === 'string') {
    if (arg_4) {
      options = arg_3;
      metadata = arg_4;
    } else {
      options = undefined;
      metadata = arg_3;
    }

    if (arg_2) {
      options = es6_parsePhoneNumber_objectSpread({
        defaultCountry: arg_2
      }, options);
    }
  } // `defaultCountry` is not passed.
  // Example: `parsePhoneNumber('+78005553535', [options], metadata)`.
  else if (isObject(arg_2)) {
      if (arg_3) {
        options = arg_2;
        metadata = arg_3;
      } else {
        metadata = arg_2;
      }
    } else throw new Error("Invalid second argument: ".concat(arg_2));

  return {
    text: text,
    options: options,
    metadata: metadata
  };
} // Otherwise istanbul would show this as "branch not covered".

/* istanbul ignore next */

var isObject = function isObject(_) {
  return parsePhoneNumber_typeof(_) === 'object';
};
//# sourceMappingURL=parsePhoneNumber.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/parsePhoneNumberFromString_.js
function parsePhoneNumberFromString_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { parsePhoneNumberFromString_defineProperty(target, key, source[key]); }); } return target; }

function parsePhoneNumberFromString_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




function parsePhoneNumberFromString(text, options, metadata) {
  // Validate `defaultCountry`.
  if (options && options.defaultCountry && !isSupportedCountry(options.defaultCountry, metadata)) {
    options = parsePhoneNumberFromString_objectSpread({}, options, {
      defaultCountry: undefined
    });
  } // Parse phone number.


  try {
    return parsePhoneNumber_parsePhoneNumber(text, options, metadata);
  } catch (error) {
    /* istanbul ignore else */
    if (error instanceof ParseError) {//
    } else {
      throw error;
    }
  }
}
//# sourceMappingURL=parsePhoneNumberFromString_.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/parsePhoneNumberFromString.js


function parsePhoneNumberFromString_parsePhoneNumberFromString() {
  var _normalizeArguments = normalizeArguments(arguments),
      text = _normalizeArguments.text,
      options = _normalizeArguments.options,
      metadata = _normalizeArguments.metadata;

  return parsePhoneNumberFromString(text, options, metadata);
}
//# sourceMappingURL=parsePhoneNumberFromString.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/parse.js

 // `options`:
//  {
//    country:
//    {
//      restrict - (a two-letter country code)
//                 the phone number must be in this country
//
//      default - (a two-letter country code)
//                default country to use for phone number parsing and validation
//                (if no country code could be derived from the phone number)
//    }
//  }
//
// Returns `{ country, number }`
//
// Example use cases:
//
// ```js
// parse('8 (800) 555-35-35', 'RU')
// parse('8 (800) 555-35-35', 'RU', metadata)
// parse('8 (800) 555-35-35', { country: { default: 'RU' } })
// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)
// parse('+7 800 555 35 35')
// parse('+7 800 555 35 35', metadata)
// ```
//

function parseNumber() {
  var _normalizeArguments = normalizeArguments(arguments),
      text = _normalizeArguments.text,
      options = _normalizeArguments.options,
      metadata = _normalizeArguments.metadata;

  return parse(text, options, metadata);
}
//# sourceMappingURL=parse.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/format.js
function format_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { format_typeof = function _typeof(obj) { return typeof obj; }; } else { format_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return format_typeof(obj); }

function format_slicedToArray(arr, i) { return format_arrayWithHoles(arr) || format_iterableToArrayLimit(arr, i) || format_nonIterableRest(); }

function format_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function format_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function format_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



function es6_format_formatNumber() {
  var _normalizeArguments = format_normalizeArguments(arguments),
      input = _normalizeArguments.input,
      format = _normalizeArguments.format,
      options = _normalizeArguments.options,
      metadata = _normalizeArguments.metadata;

  return format_formatNumber(input, format, options, metadata);
} // Sort out arguments

function format_normalizeArguments(args) {
  var _Array$prototype$slic = Array.prototype.slice.call(args),
      _Array$prototype$slic2 = format_slicedToArray(_Array$prototype$slic, 5),
      arg_1 = _Array$prototype$slic2[0],
      arg_2 = _Array$prototype$slic2[1],
      arg_3 = _Array$prototype$slic2[2],
      arg_4 = _Array$prototype$slic2[3],
      arg_5 = _Array$prototype$slic2[4];

  var input;
  var format;
  var options;
  var metadata; // Sort out arguments.
  // If the phone number is passed as a string.
  // `format('8005553535', ...)`.

  if (typeof arg_1 === 'string') {
    // If country code is supplied.
    // `format('8005553535', 'RU', 'NATIONAL', [options], metadata)`.
    if (typeof arg_3 === 'string') {
      format = arg_3;

      if (arg_5) {
        options = arg_4;
        metadata = arg_5;
      } else {
        metadata = arg_4;
      }

      input = parse(arg_1, {
        defaultCountry: arg_2,
        extended: true
      }, metadata);
    } // Just an international phone number is supplied
    // `format('+78005553535', 'NATIONAL', [options], metadata)`.
    else {
        if (typeof arg_2 !== 'string') {
          throw new Error('`format` argument not passed to `formatNumber(number, format)`');
        }

        format = arg_2;

        if (arg_4) {
          options = arg_3;
          metadata = arg_4;
        } else {
          metadata = arg_3;
        }

        input = parse(arg_1, {
          extended: true
        }, metadata);
      }
  } // If the phone number is passed as a parsed number object.
  // `format({ phone: '8005553535', country: 'RU' }, 'NATIONAL', [options], metadata)`.
  else if (format_is_object(arg_1)) {
      input = arg_1;
      format = arg_2;

      if (arg_4) {
        options = arg_3;
        metadata = arg_4;
      } else {
        metadata = arg_3;
      }
    } else throw new TypeError('A phone number must either be a string or an object of shape { phone, [country] }.'); // Legacy lowercase formats.


  if (format === 'International') {
    format = 'INTERNATIONAL';
  } else if (format === 'National') {
    format = 'NATIONAL';
  }

  return {
    input: input,
    format: format,
    options: options,
    metadata: metadata
  };
} // Babel transforms `typeof` into some "branches"
// so istanbul will show this as "branch not covered".

/* istanbul ignore next */


var format_is_object = function is_object(_) {
  return format_typeof(_) === 'object';
};
//# sourceMappingURL=format.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/getNumberType.js
function getNumberType_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { getNumberType_typeof = function _typeof(obj) { return typeof obj; }; } else { getNumberType_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return getNumberType_typeof(obj); }

function getNumberType_slicedToArray(arr, i) { return getNumberType_arrayWithHoles(arr) || getNumberType_iterableToArrayLimit(arr, i) || getNumberType_nonIterableRest(); }

function getNumberType_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function getNumberType_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function getNumberType_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



 // Finds out national phone number type (fixed line, mobile, etc)

function getNumberType_getNumberType() {
  var _normalizeArguments = getNumberType_normalizeArguments(arguments),
      input = _normalizeArguments.input,
      options = _normalizeArguments.options,
      metadata = _normalizeArguments.metadata;

  return getNumberType(input, options, metadata);
} // Sort out arguments

function getNumberType_normalizeArguments(args) {
  var _Array$prototype$slic = Array.prototype.slice.call(args),
      _Array$prototype$slic2 = getNumberType_slicedToArray(_Array$prototype$slic, 4),
      arg_1 = _Array$prototype$slic2[0],
      arg_2 = _Array$prototype$slic2[1],
      arg_3 = _Array$prototype$slic2[2],
      arg_4 = _Array$prototype$slic2[3];

  var input;
  var options = {};
  var metadata; // If the phone number is passed as a string.
  // `getNumberType('88005553535', ...)`.

  if (typeof arg_1 === 'string') {
    // If "default country" argument is being passed
    // then convert it to an `options` object.
    // `getNumberType('88005553535', 'RU', metadata)`.
    if (getNumberType_typeof(arg_2) !== 'object') {
      if (arg_4) {
        options = arg_3;
        metadata = arg_4;
      } else {
        metadata = arg_3;
      } // `parse` extracts phone numbers from raw text,
      // therefore it will cut off all "garbage" characters,
      // while this `validate` function needs to verify
      // that the phone number contains no "garbage"
      // therefore the explicit `isViablePhoneNumber` check.


      if (isViablePhoneNumber(arg_1)) {
        input = parse(arg_1, {
          defaultCountry: arg_2
        }, metadata);
      } else {
        input = {};
      }
    } // No "resrict country" argument is being passed.
    // International phone number is passed.
    // `getNumberType('+78005553535', metadata)`.
    else {
        if (arg_3) {
          options = arg_2;
          metadata = arg_3;
        } else {
          metadata = arg_2;
        } // `parse` extracts phone numbers from raw text,
        // therefore it will cut off all "garbage" characters,
        // while this `validate` function needs to verify
        // that the phone number contains no "garbage"
        // therefore the explicit `isViablePhoneNumber` check.


        if (isViablePhoneNumber(arg_1)) {
          input = parse(arg_1, undefined, metadata);
        } else {
          input = {};
        }
      }
  } // If the phone number is passed as a parsed phone number.
  // `getNumberType({ phone: '88005553535', country: 'RU' }, ...)`.
  else if (getNumberType_is_object(arg_1)) {
      input = arg_1;

      if (arg_3) {
        options = arg_2;
        metadata = arg_3;
      } else {
        metadata = arg_2;
      }
    } else throw new TypeError('A phone number must either be a string or an object of shape { phone, [country] }.');

  return {
    input: input,
    options: options,
    metadata: metadata
  };
} // Babel transforms `typeof` into some "branches"
// so istanbul will show this as "branch not covered".

/* istanbul ignore next */

var getNumberType_is_object = function is_object(_) {
  return getNumberType_typeof(_) === 'object';
};
//# sourceMappingURL=getNumberType.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/getExampleNumber.js

function getExampleNumber(country, examples, metadata) {
  if (examples[country]) {
    return new PhoneNumber_PhoneNumber(country, examples[country], metadata);
  }
}
//# sourceMappingURL=getExampleNumber.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/isPossibleNumber.js


/**
 * Checks if a given phone number is possible.
 * Which means it only checks phone number length
 * and doesn't test any regular expressions.
 *
 * Examples:
 *
 * ```js
 * isPossibleNumber('+78005553535', metadata)
 * isPossibleNumber('8005553535', 'RU', metadata)
 * isPossibleNumber('88005553535', 'RU', metadata)
 * isPossibleNumber({ phone: '8005553535', country: 'RU' }, metadata)
 * ```
 */

function isPossibleNumber_isPossibleNumber() {
  var _normalizeArguments = getNumberType_normalizeArguments(arguments),
      input = _normalizeArguments.input,
      options = _normalizeArguments.options,
      metadata = _normalizeArguments.metadata;

  return isPossiblePhoneNumber(input, options, metadata);
}
//# sourceMappingURL=isPossibleNumber.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/validate.js

 // Finds out national phone number type (fixed line, mobile, etc)

function validate_isValidNumber() {
  var _normalizeArguments = getNumberType_normalizeArguments(arguments),
      input = _normalizeArguments.input,
      options = _normalizeArguments.options,
      metadata = _normalizeArguments.metadata;

  return isValidNumber(input, options, metadata);
}
//# sourceMappingURL=validate.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/isValidNumberForRegion_.js

/**
 * Checks if a given phone number is valid within a given region.
 * Is just an alias for `phoneNumber.isValid() && phoneNumber.country === country`.
 * https://github.com/googlei18n/libphonenumber/blob/master/FAQ.md#when-should-i-use-isvalidnumberforregion
 */

function isValidNumberForRegion(input, country, options, metadata) {
  // If assigning the `{}` default value is moved to the arguments above,
  // code coverage would decrease for some weird reason.
  options = options || {};
  return input.country === country && isValidNumber(input, options, metadata);
}
//# sourceMappingURL=isValidNumberForRegion_.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/isValidNumberForRegion.js



function isValidNumberForRegion_isValidNumberForRegion(number, country, metadata) {
  if (typeof number !== 'string') {
    throw new TypeError('number must be a string');
  }

  if (typeof country !== 'string') {
    throw new TypeError('country must be a string');
  } // `parse` extracts phone numbers from raw text,
  // therefore it will cut off all "garbage" characters,
  // while this `validate` function needs to verify
  // that the phone number contains no "garbage"
  // therefore the explicit `isViablePhoneNumber` check.


  var input;

  if (isViablePhoneNumber(number)) {
    input = parse(number, {
      defaultCountry: country
    }, metadata);
  } else {
    input = {};
  }

  return isValidNumberForRegion(input, country, undefined, metadata);
}
//# sourceMappingURL=isValidNumberForRegion.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/findNumbers/util.js
/** Returns a regular expression quantifier with an upper and lower limit. */
function limit(lower, upper) {
  if (lower < 0 || upper <= 0 || upper < lower) {
    throw new TypeError();
  }

  return "{".concat(lower, ",").concat(upper, "}");
}
/**
 * Trims away any characters after the first match of {@code pattern} in {@code candidate},
 * returning the trimmed version.
 */

function trimAfterFirstMatch(regexp, string) {
  var index = string.search(regexp);

  if (index >= 0) {
    return string.slice(0, index);
  }

  return string;
}
function startsWith(string, substring) {
  return string.indexOf(substring) === 0;
}
function endsWith(string, substring) {
  return string.indexOf(substring, string.length - substring.length) === string.length - substring.length;
}
//# sourceMappingURL=util.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/findNumbers/parsePreCandidate.js
 // Regular expression of characters typically used to start a second phone number for the purposes
// of parsing. This allows us to strip off parts of the number that are actually the start of
// another number, such as for: (530) 583-6985 x302/x2303 -> the second extension here makes this
// actually two phone numbers, (530) 583-6985 x302 and (530) 583-6985 x2303. We remove the second
// extension so that the first number is parsed correctly.
//
// Matches a slash (\ or /) followed by a space followed by an `x`.
//

var SECOND_NUMBER_START_PATTERN = /[\\/] *x/;
function parsePreCandidate(candidate) {
  // Check for extra numbers at the end.
  // TODO: This is the place to start when trying to support extraction of multiple phone number
  // from split notations (+41 79 123 45 67 / 68).
  return trimAfterFirstMatch(SECOND_NUMBER_START_PATTERN, candidate);
}
//# sourceMappingURL=parsePreCandidate.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/findNumbers/isValidPreCandidate.js
// Matches strings that look like dates using "/" as a separator.
// Examples: 3/10/2011, 31/10/96 or 08/31/95.
var SLASH_SEPARATED_DATES = /(?:(?:[0-3]?\d\/[01]?\d)|(?:[01]?\d\/[0-3]?\d))\/(?:[12]\d)?\d{2}/; // Matches timestamps.
// Examples: "2012-01-02 08:00".
// Note that the reg-ex does not include the
// trailing ":\d\d" -- that is covered by TIME_STAMPS_SUFFIX.

var TIME_STAMPS = /[12]\d{3}[-/]?[01]\d[-/]?[0-3]\d +[0-2]\d$/;
var TIME_STAMPS_SUFFIX_LEADING = /^:[0-5]\d/;
function isValidPreCandidate(candidate, offset, text) {
  // Skip a match that is more likely to be a date.
  if (SLASH_SEPARATED_DATES.test(candidate)) {
    return false;
  } // Skip potential time-stamps.


  if (TIME_STAMPS.test(candidate)) {
    var followingText = text.slice(offset + candidate.length);

    if (TIME_STAMPS_SUFFIX_LEADING.test(followingText)) {
      return false;
    }
  }

  return true;
}
//# sourceMappingURL=isValidPreCandidate.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/findNumbers/utf-8.js
// Javascript doesn't support UTF-8 regular expressions.
// So mimicking them here.
// Copy-pasted from `PhoneNumberMatcher.js`.

/**
 * "\p{Z}" is any kind of whitespace or invisible separator ("Separator").
 * http://www.regular-expressions.info/unicode.html
 * "\P{Z}" is the reverse of "\p{Z}".
 * "\p{N}" is any kind of numeric character in any script ("Number").
 * "\p{Nd}" is a digit zero through nine in any script except "ideographic scripts" ("Decimal_Digit_Number").
 * "\p{Sc}" is a currency symbol ("Currency_Symbol").
 * "\p{L}" is any kind of letter from any language ("Letter").
 * "\p{Mn}" is "non-spacing mark".
 *
 * Javascript doesn't support Unicode Regular Expressions
 * so substituting it with this explicit set of characters.
 *
 * https://stackoverflow.com/questions/13210194/javascript-regex-equivalent-of-a-za-z-using-pl
 * https://github.com/danielberndt/babel-plugin-utf-8-regex/blob/master/src/transformer.js
 */
var _pZ = " \xA0\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000";
var pZ = "[".concat(_pZ, "]");
var PZ = "[^".concat(_pZ, "]");
var _pN = "0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19"; // const pN = `[${_pN}]`

var _pNd = "0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19";
var pNd = "[".concat(_pNd, "]");
var _pL = "A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var pL = "[".concat(_pL, "]");
var pL_regexp = new RegExp(pL);
var _pSc = "$\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20B9\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6";
var pSc = "[".concat(_pSc, "]");
var pSc_regexp = new RegExp(pSc);
var _pMn = "\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u08FE\u0900-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1DC0-\u1DE6\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26";
var pMn = "[".concat(_pMn, "]");
var pMn_regexp = new RegExp(pMn);
var _InBasic_Latin = "\0-\x7F";
var _InLatin_1_Supplement = "\x80-\xFF";
var _InLatin_Extended_A = "\u0100-\u017F";
var _InLatin_Extended_Additional = "\u1E00-\u1EFF";
var _InLatin_Extended_B = "\u0180-\u024F";
var _InCombining_Diacritical_Marks = "\u0300-\u036F";
var latinLetterRegexp = new RegExp('[' + _InBasic_Latin + _InLatin_1_Supplement + _InLatin_Extended_A + _InLatin_Extended_Additional + _InLatin_Extended_B + _InCombining_Diacritical_Marks + ']');
/**
 * Helper method to determine if a character is a Latin-script letter or not.
 * For our purposes, combining marks should also return true since we assume
 * they have been added to a preceding Latin character.
 */

function isLatinLetter(letter) {
  // Combining marks are a subset of non-spacing-mark.
  if (!pL_regexp.test(letter) && !pMn_regexp.test(letter)) {
    return false;
  }

  return latinLetterRegexp.test(letter);
}
function isInvalidPunctuationSymbol(character) {
  return character === '%' || pSc_regexp.test(character);
}
//# sourceMappingURL=utf-8.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/findNumbers/isValidCandidate.js
// Copy-pasted from `PhoneNumberMatcher.js`.



var OPENING_PARENS = "(\\[\uFF08\uFF3B";
var CLOSING_PARENS = ")\\]\uFF09\uFF3D";
var NON_PARENS = "[^".concat(OPENING_PARENS).concat(CLOSING_PARENS, "]");
var LEAD_CLASS = "[".concat(OPENING_PARENS).concat(PLUS_CHARS, "]"); // Punctuation that may be at the start of a phone number - brackets and plus signs.

var LEAD_CLASS_LEADING = new RegExp('^' + LEAD_CLASS); // Limit on the number of pairs of brackets in a phone number.

var BRACKET_PAIR_LIMIT = limit(0, 3);
/**
 * Pattern to check that brackets match. Opening brackets should be closed within a phone number.
 * This also checks that there is something inside the brackets. Having no brackets at all is also
 * fine.
 *
 * An opening bracket at the beginning may not be closed, but subsequent ones should be.  It's
 * also possible that the leading bracket was dropped, so we shouldn't be surprised if we see a
 * closing bracket first. We limit the sets of brackets in a phone number to four.
 */

var MATCHING_BRACKETS_ENTIRE = new RegExp('^' + "(?:[" + OPENING_PARENS + "])?" + "(?:" + NON_PARENS + "+" + "[" + CLOSING_PARENS + "])?" + NON_PARENS + "+" + "(?:[" + OPENING_PARENS + "]" + NON_PARENS + "+[" + CLOSING_PARENS + "])" + BRACKET_PAIR_LIMIT + NON_PARENS + "*" + '$');
/**
 * Matches strings that look like publication pages. Example:
 * <pre>Computing Complete Answers to Queries in the Presence of Limited Access Patterns.
 * Chen Li. VLDB J. 12(3): 211-227 (2003).</pre>
 *
 * The string "211-227 (2003)" is not a telephone number.
 */

var PUB_PAGES = /\d{1,5}-+\d{1,5}\s{0,4}\(\d{1,4}/;
function isValidCandidate(candidate, offset, text, leniency) {
  // Check the candidate doesn't contain any formatting
  // which would indicate that it really isn't a phone number.
  if (!MATCHING_BRACKETS_ENTIRE.test(candidate) || PUB_PAGES.test(candidate)) {
    return;
  } // If leniency is set to VALID or stricter, we also want to skip numbers that are surrounded
  // by Latin alphabetic characters, to skip cases like abc8005001234 or 8005001234def.


  if (leniency !== 'POSSIBLE') {
    // If the candidate is not at the start of the text,
    // and does not start with phone-number punctuation,
    // check the previous character.
    if (offset > 0 && !LEAD_CLASS_LEADING.test(candidate)) {
      var previousChar = text[offset - 1]; // We return null if it is a latin letter or an invalid punctuation symbol.

      if (isInvalidPunctuationSymbol(previousChar) || isLatinLetter(previousChar)) {
        return false;
      }
    }

    var lastCharIndex = offset + candidate.length;

    if (lastCharIndex < text.length) {
      var nextChar = text[lastCharIndex];

      if (isInvalidPunctuationSymbol(nextChar) || isLatinLetter(nextChar)) {
        return false;
      }
    }
  }

  return true;
}
//# sourceMappingURL=isValidCandidate.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/findPhoneNumbers_.js
function findPhoneNumbers_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function findPhoneNumbers_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function findPhoneNumbers_createClass(Constructor, protoProps, staticProps) { if (protoProps) findPhoneNumbers_defineProperties(Constructor.prototype, protoProps); if (staticProps) findPhoneNumbers_defineProperties(Constructor, staticProps); return Constructor; }

function findPhoneNumbers_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// This is a legacy function.
// Use `findNumbers()` instead.





 // Copy-pasted from `./parse.js`.

var findPhoneNumbers_VALID_PHONE_NUMBER = '[' + PLUS_CHARS + ']{0,1}' + '(?:' + '[' + VALID_PUNCTUATION + ']*' + '[' + VALID_DIGITS + ']' + '){3,}' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*';
var WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + WHITESPACE + ']+');
var PUNCTUATION_IN_THE_END_PATTERN = new RegExp('[' + VALID_PUNCTUATION + ']+$'); // // Regular expression for getting opening brackets for a valid number
// // found using `PHONE_NUMBER_START_PATTERN` for prepending those brackets to the number.
// const BEFORE_NUMBER_DIGITS_PUNCTUATION = new RegExp('[' + OPENING_BRACKETS + ']+' + '[' + WHITESPACE + ']*' + '$')

var VALID_PRECEDING_CHARACTER_PATTERN = /[^a-zA-Z0-9]/;
function findPhoneNumbers(text, options, metadata) {
  /* istanbul ignore if */
  if (options === undefined) {
    options = {};
  }

  var search = new findPhoneNumbers_PhoneNumberSearch(text, options, metadata);
  var phones = [];

  while (search.hasNext()) {
    phones.push(search.next());
  }

  return phones;
}
/**
 * @return ES6 `for ... of` iterator.
 */

function searchPhoneNumbers(text, options, metadata) {
  /* istanbul ignore if */
  if (options === undefined) {
    options = {};
  }

  var search = new findPhoneNumbers_PhoneNumberSearch(text, options, metadata);
  return findPhoneNumbers_defineProperty({}, Symbol.iterator, function () {
    return {
      next: function next() {
        if (search.hasNext()) {
          return {
            done: false,
            value: search.next()
          };
        }

        return {
          done: true
        };
      }
    };
  });
}
/**
 * Extracts a parseable phone number including any opening brackets, etc.
 * @param  {string} text - Input.
 * @return {object} `{ ?number, ?startsAt, ?endsAt }`.
 */

var findPhoneNumbers_PhoneNumberSearch =
/*#__PURE__*/
function () {
  // Iteration tristate.
  function PhoneNumberSearch(text, options, metadata) {
    findPhoneNumbers_classCallCheck(this, PhoneNumberSearch);

    findPhoneNumbers_defineProperty(this, "state", 'NOT_READY');

    this.text = text; // If assigning the `{}` default value is moved to the arguments above,
    // code coverage would decrease for some weird reason.

    this.options = options || {};
    this.metadata = metadata;
    this.regexp = new RegExp(findPhoneNumbers_VALID_PHONE_NUMBER + // Phone number extensions
    '(?:' + EXTN_PATTERNS_FOR_PARSING + ')?', 'ig'); // this.searching_from = 0
  }

  findPhoneNumbers_createClass(PhoneNumberSearch, [{
    key: "find",
    value: function find() {
      var matches = this.regexp.exec(this.text);

      if (!matches) {
        return;
      }

      var number = matches[0];
      var startsAt = matches.index;
      number = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '');
      startsAt += matches[0].length - number.length; // Fixes not parsing numbers with whitespace in the end.
      // Also fixes not parsing numbers with opening parentheses in the end.
      // https://github.com/catamphetamine/libphonenumber-js/issues/252

      number = number.replace(PUNCTUATION_IN_THE_END_PATTERN, '');
      number = parsePreCandidate(number);
      var result = this.parseCandidate(number, startsAt);

      if (result) {
        return result;
      } // Tail recursion.
      // Try the next one if this one is not a valid phone number.


      return this.find();
    }
  }, {
    key: "parseCandidate",
    value: function parseCandidate(number, startsAt) {
      if (!isValidPreCandidate(number, startsAt, this.text)) {
        return;
      } // Don't parse phone numbers which are non-phone numbers
      // due to being part of something else (e.g. a UUID).
      // https://github.com/catamphetamine/libphonenumber-js/issues/213
      // Copy-pasted from Google's `PhoneNumberMatcher.js` (`.parseAndValidate()`).


      if (!isValidCandidate(number, startsAt, this.text, this.options.extended ? 'POSSIBLE' : 'VALID')) {
        return;
      } // // Prepend any opening brackets left behind by the
      // // `PHONE_NUMBER_START_PATTERN` regexp.
      // const text_before_number = text.slice(this.searching_from, startsAt)
      // const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)
      // if (full_number_starts_at >= 0)
      // {
      // 	number   = text_before_number.slice(full_number_starts_at) + number
      // 	startsAt = full_number_starts_at
      // }
      //
      // this.searching_from = matches.lastIndex


      var result = parse(number, this.options, this.metadata);

      if (!result.phone) {
        return;
      }

      result.startsAt = startsAt;
      result.endsAt = startsAt + number.length;
      return result;
    }
  }, {
    key: "hasNext",
    value: function hasNext() {
      if (this.state === 'NOT_READY') {
        this.last_match = this.find();

        if (this.last_match) {
          this.state = 'READY';
        } else {
          this.state = 'DONE';
        }
      }

      return this.state === 'READY';
    }
  }, {
    key: "next",
    value: function next() {
      // Check the state and find the next match as a side-effect if necessary.
      if (!this.hasNext()) {
        throw new Error('No next element');
      } // Don't retain that memory any longer than necessary.


      var result = this.last_match;
      this.last_match = null;
      this.state = 'NOT_READY';
      return result;
    }
  }]);

  return PhoneNumberSearch;
}();
//# sourceMappingURL=findPhoneNumbers_.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/findPhoneNumbers.js
// This is a legacy function.
// Use `findNumbers()` instead.


function findPhoneNumbers_findPhoneNumbers() {
  var _normalizeArguments = normalizeArguments(arguments),
      text = _normalizeArguments.text,
      options = _normalizeArguments.options,
      metadata = _normalizeArguments.metadata;

  return findPhoneNumbers(text, options, metadata);
}
/**
 * @return ES6 `for ... of` iterator.
 */

function findPhoneNumbers_searchPhoneNumbers() {
  var _normalizeArguments2 = normalizeArguments(arguments),
      text = _normalizeArguments2.text,
      options = _normalizeArguments2.options,
      metadata = _normalizeArguments2.metadata;

  return searchPhoneNumbers(text, options, metadata);
}
//# sourceMappingURL=findPhoneNumbers.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/findNumbers/LRUCache.js
function LRUCache_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function LRUCache_createClass(Constructor, protoProps, staticProps) { if (protoProps) LRUCache_defineProperties(Constructor.prototype, protoProps); if (staticProps) LRUCache_defineProperties(Constructor, staticProps); return Constructor; }

function LRUCache_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// https://medium.com/dsinjs/implementing-lru-cache-in-javascript-94ba6755cda9
var Node = function Node(key, value) {
  var next = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var prev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  LRUCache_classCallCheck(this, Node);

  this.key = key;
  this.value = value;
  this.next = next;
  this.prev = prev;
};

var LRUCache =
/*#__PURE__*/
function () {
  //set default limit of 10 if limit is not passed.
  function LRUCache() {
    var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

    LRUCache_classCallCheck(this, LRUCache);

    this.size = 0;
    this.limit = limit;
    this.head = null;
    this.tail = null;
    this.cache = {};
  } // Write Node to head of LinkedList
  // update cache with Node key and Node reference


  LRUCache_createClass(LRUCache, [{
    key: "put",
    value: function put(key, value) {
      this.ensureLimit();

      if (!this.head) {
        this.head = this.tail = new Node(key, value);
      } else {
        var node = new Node(key, value, this.head);
        this.head.prev = node;
        this.head = node;
      } //Update the cache map


      this.cache[key] = this.head;
      this.size++;
    } // Read from cache map and make that node as new Head of LinkedList

  }, {
    key: "get",
    value: function get(key) {
      if (this.cache[key]) {
        var value = this.cache[key].value; // node removed from it's position and cache

        this.remove(key); // write node again to the head of LinkedList to make it most recently used

        this.put(key, value);
        return value;
      }

      console.log("Item not available in cache for key ".concat(key));
    }
  }, {
    key: "ensureLimit",
    value: function ensureLimit() {
      if (this.size === this.limit) {
        this.remove(this.tail.key);
      }
    }
  }, {
    key: "remove",
    value: function remove(key) {
      var node = this.cache[key];

      if (node.prev !== null) {
        node.prev.next = node.next;
      } else {
        this.head = node.next;
      }

      if (node.next !== null) {
        node.next.prev = node.prev;
      } else {
        this.tail = node.prev;
      }

      delete this.cache[key];
      this.size--;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = null;
      this.tail = null;
      this.size = 0;
      this.cache = {};
    } // // Invokes the callback function with every node of the chain and the index of the node.
    // forEach(fn) {
    //   let node = this.head;
    //   let counter = 0;
    //   while (node) {
    //     fn(node, counter);
    //     node = node.next;
    //     counter++;
    //   }
    // }
    // // To iterate over LRU with a 'for...of' loop
    // *[Symbol.iterator]() {
    //   let node = this.head;
    //   while (node) {
    //     yield node;
    //     node = node.next;
    //   }
    // }

  }]);

  return LRUCache;
}();


//# sourceMappingURL=LRUCache.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/findNumbers/RegExpCache.js
function RegExpCache_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function RegExpCache_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function RegExpCache_createClass(Constructor, protoProps, staticProps) { if (protoProps) RegExpCache_defineProperties(Constructor.prototype, protoProps); if (staticProps) RegExpCache_defineProperties(Constructor, staticProps); return Constructor; }

 // A cache for frequently used country-specific regular expressions. Set to 32 to cover ~2-3
// countries being used for the same doc with ~10 patterns for each country. Some pages will have
// a lot more countries in use, but typically fewer numbers for each so expanding the cache for
// that use-case won't have a lot of benefit.

var RegExpCache_RegExpCache =
/*#__PURE__*/
function () {
  function RegExpCache(size) {
    RegExpCache_classCallCheck(this, RegExpCache);

    this.cache = new LRUCache(size);
  }

  RegExpCache_createClass(RegExpCache, [{
    key: "getPatternForRegExp",
    value: function getPatternForRegExp(pattern) {
      var regExp = this.cache.get(pattern);

      if (!regExp) {
        regExp = new RegExp('^' + pattern);
        this.cache.put(pattern, regExp);
      }

      return regExp;
    }
  }]);

  return RegExpCache;
}();


//# sourceMappingURL=RegExpCache.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/findNumbers/Leniency.js



/**
 * Leniency when finding potential phone numbers in text segments
 * The levels here are ordered in increasing strictness.
 */

/* harmony default export */ var Leniency = ({
  /**
   * Phone numbers accepted are "possible", but not necessarily "valid".
   */
  POSSIBLE: function POSSIBLE(number, candidate, metadata) {
    return true;
  },

  /**
   * Phone numbers accepted are "possible" and "valid".
   * Numbers written in national format must have their national-prefix
   * present if it is usually written for a number of this type.
   */
  VALID: function VALID(number, candidate, metadata) {
    if (!isValidNumber(number, undefined, metadata) || !containsOnlyValidXChars(number, candidate.toString(), metadata)) {
      return false;
    } // Skipped for simplicity.
    // return isNationalPrefixPresentIfRequired(number, metadata)


    return true;
  },

  /**
   * Phone numbers accepted are "valid" and
   * are grouped in a possible way for this locale. For example, a US number written as
   * "65 02 53 00 00" and "650253 0000" are not accepted at this leniency level, whereas
   * "650 253 0000", "650 2530000" or "6502530000" are.
   * Numbers with more than one '/' symbol in the national significant number
   * are also dropped at this level.
   *
   * Warning: This level might result in lower coverage especially for regions outside of
   * country code "+1". If you are not sure about which level to use,
   * email the discussion group libphonenumber-discuss@googlegroups.com.
   */
  STRICT_GROUPING: function STRICT_GROUPING(number, candidate, metadata, regExpCache) {
    var candidateString = candidate.toString();

    if (!isValidNumber(number, undefined, metadata) || !containsOnlyValidXChars(number, candidateString, metadata) || containsMoreThanOneSlashInNationalNumber(number, candidateString) || !isNationalPrefixPresentIfRequired(number, metadata)) {
      return false;
    }

    return checkNumberGroupingIsValid(number, candidate, metadata, allNumberGroupsRemainGrouped, regExpCache);
  },

  /**
   * Phone numbers accepted are {@linkplain PhoneNumberUtil#isValidNumber(PhoneNumber) valid} and
   * are grouped in the same way that we would have formatted it, or as a single block. For
   * example, a US number written as "650 2530000" is not accepted at this leniency level, whereas
   * "650 253 0000" or "6502530000" are.
   * Numbers with more than one '/' symbol are also dropped at this level.
   * <p>
   * Warning: This level might result in lower coverage especially for regions outside of country
   * code "+1". If you are not sure about which level to use, email the discussion group
   * libphonenumber-discuss@googlegroups.com.
   */
  EXACT_GROUPING: function EXACT_GROUPING(number, candidate, metadata, regExpCache) {
    var candidateString = candidate.toString();

    if (!isValidNumber(number, undefined, metadata) || !containsOnlyValidXChars(number, candidateString, metadata) || containsMoreThanOneSlashInNationalNumber(number, candidateString) || !isNationalPrefixPresentIfRequired(number, metadata)) {
      return false;
    }

    return checkNumberGroupingIsValid(number, candidate, metadata, allNumberGroupsAreExactlyPresent, regExpCache);
  }
});

function containsOnlyValidXChars(number, candidate, metadata) {
  // The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the
  // national significant number or (2) an extension sign, in which case they always precede the
  // extension number. We assume a carrier code is more than 1 digit, so the first case has to
  // have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'
  // or 'X'. We ignore the character if it appears as the last character of the string.
  for (var index = 0; index < candidate.length - 1; index++) {
    var charAtIndex = candidate.charAt(index);

    if (charAtIndex === 'x' || charAtIndex === 'X') {
      var charAtNextIndex = candidate.charAt(index + 1);

      if (charAtNextIndex === 'x' || charAtNextIndex === 'X') {
        // This is the carrier code case, in which the 'X's always precede the national
        // significant number.
        index++;

        if (util.isNumberMatch(number, candidate.substring(index)) != MatchType.NSN_MATCH) {
          return false;
        } // This is the extension sign case, in which the 'x' or 'X' should always precede the
        // extension number.

      } else if (parseDigits(candidate.substring(index)) !== number.ext) {
        return false;
      }
    }
  }

  return true;
}

function isNationalPrefixPresentIfRequired(number, _metadata) {
  // First, check how we deduced the country code. If it was written in international format, then
  // the national prefix is not required.
  if (number.getCountryCodeSource() != 'FROM_DEFAULT_COUNTRY') {
    return true;
  }

  var phoneNumberRegion = util.getRegionCodeForCountryCode(number.getCountryCode());
  var metadata = util.getMetadataForRegion(phoneNumberRegion);

  if (metadata == null) {
    return true;
  } // Check if a national prefix should be present when formatting this number.


  var nationalNumber = util.getNationalSignificantNumber(number);
  var formatRule = util.chooseFormattingPatternForNumber(metadata.numberFormats(), nationalNumber); // To do this, we check that a national prefix formatting rule was present
  // and that it wasn't just the first-group symbol ($1) with punctuation.

  if (formatRule && formatRule.getNationalPrefixFormattingRule().length > 0) {
    if (formatRule.getNationalPrefixOptionalWhenFormatting()) {
      // The national-prefix is optional in these cases, so we don't need to check if it was
      // present.
      return true;
    }

    if (PhoneNumberUtil.formattingRuleHasFirstGroupOnly(formatRule.getNationalPrefixFormattingRule())) {
      // National Prefix not needed for this number.
      return true;
    } // Normalize the remainder.


    var rawInputCopy = PhoneNumberUtil.normalizeDigitsOnly(number.getRawInput()); // Check if we found a national prefix and/or carrier code at the start of the raw input, and
    // return the result.

    return util.maybeStripNationalPrefixAndCarrierCode(rawInputCopy, metadata, null);
  }

  return true;
}

function containsMoreThanOneSlashInNationalNumber(number, candidate) {
  var firstSlashInBodyIndex = candidate.indexOf('/');

  if (firstSlashInBodyIndex < 0) {
    // No slashes, this is okay.
    return false;
  } // Now look for a second one.


  var secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1);

  if (secondSlashInBodyIndex < 0) {
    // Only one slash, this is okay.
    return false;
  } // If the first slash is after the country calling code, this is permitted.


  var candidateHasCountryCode = number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITH_PLUS_SIGN || number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITHOUT_PLUS_SIGN;

  if (candidateHasCountryCode && PhoneNumberUtil.normalizeDigitsOnly(candidate.substring(0, firstSlashInBodyIndex)) === String(number.getCountryCode())) {
    // Any more slashes and this is illegal.
    return candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0;
  }

  return true;
}

function checkNumberGroupingIsValid(number, candidate, metadata, checkGroups, regExpCache) {
  var normalizedCandidate = normalizeDigits(candidate, true
  /* keep non-digits */
  );
  var formattedNumberGroups = getNationalNumberGroups(metadata, number, null);

  if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {
    return true;
  } // If this didn't pass, see if there are any alternate formats that match, and try them instead.


  var alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode());
  var nationalSignificantNumber = util.getNationalSignificantNumber(number);

  if (alternateFormats) {
    for (var _iterator = alternateFormats.numberFormats(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var alternateFormat = _ref;

      if (alternateFormat.leadingDigitsPatterns().length > 0) {
        // There is only one leading digits pattern for alternate formats.
        var leadingDigitsRegExp = regExpCache.getPatternForRegExp('^' + alternateFormat.leadingDigitsPatterns()[0]);

        if (!leadingDigitsRegExp.test(nationalSignificantNumber)) {
          // Leading digits don't match; try another one.
          continue;
        }
      }

      formattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat);

      if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {
        return true;
      }
    }
  }

  return false;
}
/**
 * Helper method to get the national-number part of a number, formatted without any national
 * prefix, and return it as a set of digit blocks that would be formatted together following
 * standard formatting rules.
 */


function getNationalNumberGroups(metadata, number, formattingPattern) {
  if (formattingPattern) {
    // We format the NSN only, and split that according to the separator.
    var nationalSignificantNumber = util.getNationalSignificantNumber(number);
    return util.formatNsnUsingPattern(nationalSignificantNumber, formattingPattern, 'RFC3966', metadata).split('-');
  } // This will be in the format +CC-DG1-DG2-DGX;ext=EXT where DG1..DGX represents groups of digits.


  var rfc3966Format = formatNumber(number, 'RFC3966', metadata); // We remove the extension part from the formatted string before splitting it into different
  // groups.

  var endIndex = rfc3966Format.indexOf(';');

  if (endIndex < 0) {
    endIndex = rfc3966Format.length;
  } // The country-code will have a '-' following it.


  var startIndex = rfc3966Format.indexOf('-') + 1;
  return rfc3966Format.slice(startIndex, endIndex).split('-');
}

function allNumberGroupsAreExactlyPresent(metadata, number, normalizedCandidate, formattedNumberGroups) {
  var candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN); // Set this to the last group, skipping it if the number has an extension.

  var candidateNumberGroupIndex = number.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1; // First we check if the national significant number is formatted as a block.
  // We use contains and not equals, since the national significant number may be present with
  // a prefix such as a national number prefix, or the country code itself.

  if (candidateGroups.length == 1 || candidateGroups[candidateNumberGroupIndex].contains(util.getNationalSignificantNumber(number))) {
    return true;
  } // Starting from the end, go through in reverse, excluding the first group, and check the
  // candidate and number groups are the same.


  var formattedNumberGroupIndex = formattedNumberGroups.length - 1;

  while (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0) {
    if (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex]) {
      return false;
    }

    formattedNumberGroupIndex--;
    candidateNumberGroupIndex--;
  } // Now check the first group. There may be a national prefix at the start, so we only check
  // that the candidate group ends with the formatted number group.


  return candidateNumberGroupIndex >= 0 && endsWith(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]);
}

function allNumberGroupsRemainGrouped(metadata, number, normalizedCandidate, formattedNumberGroups) {
  var fromIndex = 0;

  if (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY) {
    // First skip the country code if the normalized candidate contained it.
    var countryCode = String(number.getCountryCode());
    fromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length();
  } // Check each group of consecutive digits are not broken into separate groupings in the
  // {@code normalizedCandidate} string.


  for (var i = 0; i < formattedNumberGroups.length; i++) {
    // Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}
    // doesn't contain the consecutive digits in formattedNumberGroups[i].
    fromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex);

    if (fromIndex < 0) {
      return false;
    } // Moves {@code fromIndex} forward.


    fromIndex += formattedNumberGroups[i].length();

    if (i == 0 && fromIndex < normalizedCandidate.length()) {
      // We are at the position right after the NDC. We get the region used for formatting
      // information based on the country code in the phone number, rather than the number itself,
      // as we do not need to distinguish between different countries with the same country
      // calling code and this is faster.
      var region = util.getRegionCodeForCountryCode(number.getCountryCode());

      if (util.getNddPrefixForRegion(region, true) != null && Character.isDigit(normalizedCandidate.charAt(fromIndex))) {
        // This means there is no formatting symbol after the NDC. In this case, we only
        // accept the number if there is no formatting symbol at all in the number, except
        // for extensions. This is only important for countries with national prefixes.
        var nationalSignificantNumber = util.getNationalSignificantNumber(number);
        return startsWith(normalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length), nationalSignificantNumber);
      }
    }
  } // The check here makes sure that we haven't mistakenly already used the extension to
  // match the last group of the subscriber number. Note the extension cannot have
  // formatting in-between digits.


  return normalizedCandidate.slice(fromIndex).contains(number.getExtension());
}
//# sourceMappingURL=Leniency.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/PhoneNumberMatcher.js
function PhoneNumberMatcher_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { PhoneNumberMatcher_defineProperty(target, key, source[key]); }); } return target; }

function PhoneNumberMatcher_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function PhoneNumberMatcher_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function PhoneNumberMatcher_createClass(Constructor, protoProps, staticProps) { if (protoProps) PhoneNumberMatcher_defineProperties(Constructor.prototype, protoProps); if (staticProps) PhoneNumberMatcher_defineProperties(Constructor, staticProps); return Constructor; }

function PhoneNumberMatcher_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * A port of Google's `PhoneNumberMatcher.java`.
 * https://github.com/googlei18n/libphonenumber/blob/master/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberMatcher.java
 * Date: 08.03.2018.
 */












/**
 * Patterns used to extract phone numbers from a larger phone-number-like pattern. These are
 * ordered according to specificity. For example, white-space is last since that is frequently
 * used in numbers, not just to separate two numbers. We have separate patterns since we don't
 * want to break up the phone-number-like text on more than one different kind of symbol at one
 * time, although symbols of the same type (e.g. space) can be safely grouped together.
 *
 * Note that if there is a match, we will always check any text found up to the first match as
 * well.
 */

var INNER_MATCHES = [// Breaks on the slash - e.g. "651-234-2345/332-445-1234"
'\\/+(.*)/', // Note that the bracket here is inside the capturing group, since we consider it part of the
// phone number. Will match a pattern like "(650) 223 3345 (754) 223 3321".
'(\\([^(]*)', // Breaks on a hyphen - e.g. "12345 - 332-445-1234 is my number."
// We require a space on either side of the hyphen for it to be considered a separator.
"(?:".concat(pZ, "-|-").concat(pZ, ")").concat(pZ, "*(.+)"), // Various types of wide hyphens. Note we have decided not to enforce a space here, since it's
// possible that it's supposed to be used to break two numbers without spaces, and we haven't
// seen many instances of it used within a number.
"[\u2012-\u2015\uFF0D]".concat(pZ, "*(.+)"), // Breaks on a full stop - e.g. "12345. 332-445-1234 is my number."
"\\.+".concat(pZ, "*([^.]+)"), // Breaks on space - e.g. "3324451234 8002341234"
"".concat(pZ, "+(").concat(PZ, "+)")]; // Limit on the number of leading (plus) characters.

var leadLimit = limit(0, 2); // Limit on the number of consecutive punctuation characters.

var punctuationLimit = limit(0, 4);
/* The maximum number of digits allowed in a digit-separated block. As we allow all digits in a
 * single block, set high enough to accommodate the entire national number and the international
 * country code. */

var digitBlockLimit = MAX_LENGTH_FOR_NSN + MAX_LENGTH_COUNTRY_CODE; // Limit on the number of blocks separated by punctuation.
// Uses digitBlockLimit since some formats use spaces to separate each digit.

var blockLimit = limit(0, digitBlockLimit);
/* A punctuation sequence allowing white space. */

var punctuation = "[".concat(VALID_PUNCTUATION, "]") + punctuationLimit; // A digits block without punctuation.

var digitSequence = pNd + limit(1, digitBlockLimit);
/**
 * Phone number pattern allowing optional punctuation.
 * The phone number pattern used by `find()`, similar to
 * VALID_PHONE_NUMBER, but with the following differences:
 * <ul>
 *   <li>All captures are limited in order to place an upper bound to the text matched by the
 *       pattern.
 * <ul>
 *   <li>Leading punctuation / plus signs are limited.
 *   <li>Consecutive occurrences of punctuation are limited.
 *   <li>Number of digits is limited.
 * </ul>
 *   <li>No whitespace is allowed at the start or end.
 *   <li>No alpha digits (vanity numbers such as 1-800-SIX-FLAGS) are currently supported.
 * </ul>
 */

var PATTERN = '(?:' + LEAD_CLASS + punctuation + ')' + leadLimit + digitSequence + '(?:' + punctuation + digitSequence + ')' + blockLimit + '(?:' + EXTN_PATTERNS_FOR_MATCHING + ')?'; // Regular expression of trailing characters that we want to remove.
// We remove all characters that are not alpha or numerical characters.
// The hash character is retained here, as it may signify
// the previous block was an extension.
//
// // Don't know what does '&&' mean here.
// const UNWANTED_END_CHAR_PATTERN = new RegExp(`[[\\P{N}&&\\P{L}]&&[^#]]+$`)
//

var UNWANTED_END_CHAR_PATTERN = new RegExp("[^".concat(_pN).concat(_pL, "#]+$"));
var PhoneNumberMatcher_NON_DIGITS_PATTERN = /(\D+)/;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
/**
 * A stateful class that finds and extracts telephone numbers from {@linkplain CharSequence text}.
 * Instances can be created using the {@linkplain PhoneNumberUtil#findNumbers factory methods} in
 * {@link PhoneNumberUtil}.
 *
 * <p>Vanity numbers (phone numbers using alphabetic digits such as <tt>1-800-SIX-FLAGS</tt> are
 * not found.
 *
 * <p>This class is not thread-safe.
 */

var PhoneNumberMatcher_PhoneNumberMatcher =
/*#__PURE__*/
function () {
  /** The iteration tristate. */

  /** The next index to start searching at. Undefined in {@link State#DONE}. */
  // A cache for frequently used country-specific regular expressions. Set to 32 to cover ~2-3
  // countries being used for the same doc with ~10 patterns for each country. Some pages will have
  // a lot more countries in use, but typically fewer numbers for each so expanding the cache for
  // that use-case won't have a lot of benefit.

  /**
   * Creates a new instance. See the factory methods in {@link PhoneNumberUtil} on how to obtain a
   * new instance.
   *
   * @param util  the phone number util to use
   * @param text  the character sequence that we will search, null for no text
   * @param country  the country to assume for phone numbers not written in international format
   *     (with a leading plus, or with the international dialing prefix of the specified region).
   *     May be null or "ZZ" if only numbers with a leading plus should be
   *     considered.
   * @param leniency  the leniency to use when evaluating candidate phone numbers
   * @param maxTries  the maximum number of invalid numbers to try before giving up on the text.
   *     This is to cover degenerate cases where the text has a lot of false positives in it. Must
   *     be {@code >= 0}.
   */
  function PhoneNumberMatcher() {
    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var metadata = arguments.length > 2 ? arguments[2] : undefined;

    PhoneNumberMatcher_classCallCheck(this, PhoneNumberMatcher);

    PhoneNumberMatcher_defineProperty(this, "state", 'NOT_READY');

    PhoneNumberMatcher_defineProperty(this, "searchIndex", 0);

    PhoneNumberMatcher_defineProperty(this, "regExpCache", new RegExpCache_RegExpCache(32));

    options = PhoneNumberMatcher_objectSpread({}, options, {
      defaultCallingCode: options.defaultCallingCode,
      defaultCountry: options.defaultCountry && isSupportedCountry(options.defaultCountry, metadata) ? options.defaultCountry : undefined,
      leniency: options.leniency || options.extended ? 'POSSIBLE' : 'VALID',
      maxTries: options.maxTries || MAX_SAFE_INTEGER
    });

    if (!options.leniency) {
      throw new TypeError('`Leniency` not supplied');
    }

    if (options.maxTries < 0) {
      throw new TypeError('`maxTries` not supplied');
    }

    this.text = text;
    this.options = options;
    this.metadata = metadata;
    /** The degree of validation requested. */

    this.leniency = Leniency[options.leniency];

    if (!this.leniency) {
      throw new TypeError("Unknown leniency: ".concat(options.leniency, "."));
    }
    /** The maximum number of retries after matching an invalid number. */


    this.maxTries = options.maxTries;
    this.PATTERN = new RegExp(PATTERN, 'ig');
  }
  /**
   * Attempts to find the next subsequence in the searched sequence on or after {@code searchIndex}
   * that represents a phone number. Returns the next match, null if none was found.
   *
   * @param index  the search index to start searching at
   * @return  the phone number match found, null if none can be found
   */


  PhoneNumberMatcher_createClass(PhoneNumberMatcher, [{
    key: "find",
    value: function find() // (index)
    {
      // // Reset the regular expression.
      // this.PATTERN.lastIndex = index
      var matches;

      while (this.maxTries > 0 && (matches = this.PATTERN.exec(this.text)) !== null) {
        var candidate = matches[0];
        var offset = matches.index;
        candidate = parsePreCandidate(candidate);

        if (isValidPreCandidate(candidate, offset, this.text)) {
          var match = // Try to come up with a valid match given the entire candidate.
          this.parseAndVerify(candidate, offset, this.text) // If that failed, try to find an "inner match" -
          // there might be a phone number within this candidate.
          || this.extractInnerMatch(candidate, offset, this.text);

          if (match) {
            if (this.options.v2) {
              var phoneNumber = new PhoneNumber_PhoneNumber(match.country || match.countryCallingCode, match.phone, this.metadata);

              if (match.ext) {
                phoneNumber.ext = match.ext;
              }

              return {
                startsAt: match.startsAt,
                endsAt: match.endsAt,
                number: phoneNumber
              };
            }

            return match;
          }
        }

        this.maxTries--;
      }
    }
    /**
     * Attempts to extract a match from `candidate`
     * if the whole candidate does not qualify as a match.
     */

  }, {
    key: "extractInnerMatch",
    value: function extractInnerMatch(candidate, offset, text) {
      for (var _i = 0, _INNER_MATCHES = INNER_MATCHES; _i < _INNER_MATCHES.length; _i++) {
        var innerMatchPattern = _INNER_MATCHES[_i];
        var isFirstMatch = true;
        var matches = void 0;
        var possibleInnerMatch = new RegExp(innerMatchPattern, 'g');

        while ((matches = possibleInnerMatch.exec(candidate)) !== null && this.maxTries > 0) {
          if (isFirstMatch) {
            // We should handle any group before this one too.
            var _group = trimAfterFirstMatch(UNWANTED_END_CHAR_PATTERN, candidate.slice(0, matches.index));

            var _match = this.parseAndVerify(_group, offset, text);

            if (_match) {
              return _match;
            }

            this.maxTries--;
            isFirstMatch = false;
          }

          var group = trimAfterFirstMatch(UNWANTED_END_CHAR_PATTERN, matches[1]); // Java code does `groupMatcher.start(1)` here,
          // but there's no way in javascript to get a group match start index,
          // therefore using the overall match start index `matches.index`.

          var match = this.parseAndVerify(group, offset + matches.index, text);

          if (match) {
            return match;
          }

          this.maxTries--;
        }
      }
    }
    /**
     * Parses a phone number from the `candidate` using `parseNumber` and
     * verifies it matches the requested `leniency`. If parsing and verification succeed,
     * a corresponding `PhoneNumberMatch` is returned, otherwise this method returns `null`.
     *
     * @param candidate  the candidate match
     * @param offset  the offset of {@code candidate} within {@link #text}
     * @return  the parsed and validated phone number match, or null
     */

  }, {
    key: "parseAndVerify",
    value: function parseAndVerify(candidate, offset, text) {
      if (!isValidCandidate(candidate, offset, text, this.options.leniency)) {
        return;
      }

      var number = parse(candidate, {
        extended: true,
        defaultCountry: this.options.defaultCountry,
        defaultCallingCode: this.options.defaultCallingCode
      }, this.metadata);

      if (!number.possible) {
        return;
      }

      if (this.leniency(number, candidate, this.metadata, this.regExpCache)) {
        // // We used parseAndKeepRawInput to create this number,
        // // but for now we don't return the extra values parsed.
        // // TODO: stop clearing all values here and switch all users over
        // // to using rawInput() rather than the rawString() of PhoneNumberMatch.
        // number.clearCountryCodeSource()
        // number.clearRawInput()
        // number.clearPreferredDomesticCarrierCode()
        var result = {
          startsAt: offset,
          endsAt: offset + candidate.length,
          phone: number.phone
        };

        if (number.country && number.country !== '001') {
          result.country = number.country;
        } else {
          result.countryCallingCode = number.countryCallingCode;
        }

        if (number.ext) {
          result.ext = number.ext;
        }

        return result;
      }
    }
  }, {
    key: "hasNext",
    value: function hasNext() {
      if (this.state === 'NOT_READY') {
        this.lastMatch = this.find(); // (this.searchIndex)

        if (this.lastMatch) {
          // this.searchIndex = this.lastMatch.endsAt
          this.state = 'READY';
        } else {
          this.state = 'DONE';
        }
      }

      return this.state === 'READY';
    }
  }, {
    key: "next",
    value: function next() {
      // Check the state and find the next match as a side-effect if necessary.
      if (!this.hasNext()) {
        throw new Error('No next element');
      } // Don't retain that memory any longer than necessary.


      var result = this.lastMatch;
      this.lastMatch = null;
      this.state = 'NOT_READY';
      return result;
    }
  }]);

  return PhoneNumberMatcher;
}();


//# sourceMappingURL=PhoneNumberMatcher.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/findNumbers_.js

function findNumbers(text, options, metadata) {
  var matcher = new PhoneNumberMatcher_PhoneNumberMatcher(text, options, metadata);
  var results = [];

  while (matcher.hasNext()) {
    results.push(matcher.next());
  }

  return results;
}
//# sourceMappingURL=findNumbers_.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/findNumbers.js


function findNumbers_findNumbers() {
  var _normalizeArguments = normalizeArguments(arguments),
      text = _normalizeArguments.text,
      options = _normalizeArguments.options,
      metadata = _normalizeArguments.metadata;

  return findNumbers(text, options, metadata);
}
//# sourceMappingURL=findNumbers.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/searchNumbers.js
function searchNumbers_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * @return ES6 `for ... of` iterator.
 */

function searchNumbers() {
  var _normalizeArguments = normalizeArguments(arguments),
      text = _normalizeArguments.text,
      options = _normalizeArguments.options,
      metadata = _normalizeArguments.metadata;

  var matcher = new PhoneNumberMatcher_PhoneNumberMatcher(text, options, metadata);
  return searchNumbers_defineProperty({}, Symbol.iterator, function () {
    return {
      next: function next() {
        if (matcher.hasNext()) {
          return {
            done: false,
            value: matcher.next()
          };
        }

        return {
          done: true
        };
      }
    };
  });
}
//# sourceMappingURL=searchNumbers.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/findPhoneNumbersInText.js
function findPhoneNumbersInText_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { findPhoneNumbersInText_typeof = function _typeof(obj) { return typeof obj; }; } else { findPhoneNumbersInText_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return findPhoneNumbersInText_typeof(obj); }

function findPhoneNumbersInText_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { findPhoneNumbersInText_defineProperty(target, key, source[key]); }); } return target; }

function findPhoneNumbersInText_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


function findPhoneNumbersInText(text, defaultCountry, options, metadata) {
  var args = getArguments(defaultCountry, options, metadata);
  return findNumbers_findNumbers(text, args.options, args.metadata);
}
function getArguments(defaultCountry, options, metadata) {
  if (metadata) {
    if (defaultCountry) {
      options = findPhoneNumbersInText_objectSpread({}, options, {
        defaultCountry: defaultCountry
      });
    }
  } else {
    if (options) {
      metadata = options;

      if (defaultCountry) {
        if (findPhoneNumbersInText_is_object(defaultCountry)) {
          options = defaultCountry;
        } else {
          options = {
            defaultCountry: defaultCountry
          };
        }
      } else {
        options = undefined;
      }
    } else {
      metadata = defaultCountry;
      options = undefined;
    }
  }

  return {
    options: findPhoneNumbersInText_objectSpread({}, options, {
      v2: true
    }),
    metadata: metadata
  };
} // Babel transforms `typeof` into some "branches"
// so istanbul will show this as "branch not covered".

/* istanbul ignore next */

var findPhoneNumbersInText_is_object = function is_object(_) {
  return findPhoneNumbersInText_typeof(_) === 'object';
};
//# sourceMappingURL=findPhoneNumbersInText.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/searchPhoneNumbersInText.js


function searchPhoneNumbersInText(text, defaultCountry, options, metadata) {
  var args = getArguments(defaultCountry, options, metadata);
  return searchNumbers(text, args.options, args.metadata);
}
//# sourceMappingURL=searchPhoneNumbersInText.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/AsYouType.js
function AsYouType_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { AsYouType_typeof = function _typeof(obj) { return typeof obj; }; } else { AsYouType_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return AsYouType_typeof(obj); }

function AsYouType_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function AsYouType_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function AsYouType_createClass(Constructor, protoProps, staticProps) { if (protoProps) AsYouType_defineProperties(Constructor.prototype, protoProps); if (staticProps) AsYouType_defineProperties(Constructor, staticProps); return Constructor; }

function AsYouType_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// This is an enhanced port of Google Android `libphonenumber`'s
// `asyoutypeformatter.js` of December 31th, 2018.
//
// https://github.com/googlei18n/libphonenumber/blob/8d21a365061de2ba0675c878a710a7b24f74d2ae/javascript/i18n/phonenumbers/asyoutypeformatter.js
//
// Simplified: does not differentiate between "local-only" numbers
// and "internationally dialable" numbers.
// For example, doesn't include changes like this:
// https://github.com/googlei18n/libphonenumber/commit/865da605da12b01053c4f053310bac7c5fbb7935








 // Used in phone number format template creation.
// Could be any digit, I guess.

var DUMMY_DIGIT = '9'; // I don't know why is it exactly `15`

var LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15; // Create a phone number consisting only of the digit 9 that matches the
// `number_pattern` by applying the pattern to the "longest phone number" string.

var LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH); // The digits that have not been entered yet will be represented by a \u2008,
// the punctuation space.

var DIGIT_PLACEHOLDER = 'x'; // '\u2008' (punctuation space)

var DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER); // A set of characters that, if found in a national prefix formatting rules, are an indicator to
// us that we should separate the national prefix from the number when formatting.

var NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/; // Deprecated: Google has removed some formatting pattern related code from their repo.
// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c
// "We no longer have numbers in formatting matching patterns, only \d."
// Because this library supports generating custom metadata
// some users may still be using old metadata so the relevant
// code seems to stay until some next major version update.

var SUPPORT_LEGACY_FORMATTING_PATTERNS = true; // A pattern that is used to match character classes in regular expressions.
// An example of a character class is "[1-4]".

var CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function () {
  return /\[([^\[\]])*\]/g;
}; // Any digit in a regular expression that actually denotes a digit. For
// example, in the regular expression "80[0-2]\d{6,10}", the first 2 digits
// (8 and 0) are standalone digits, but the rest are not.
// Two look-aheads are needed because the number following \\d could be a
// two-digit number, since the phone number can be as long as 15 digits.


var CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function () {
  return /\d(?=[^,}][^,}])/g;
}; // A pattern that is used to determine if a `format` is eligible
// to be used by the "as you type formatter".
// It is eligible when the `format` contains groups of the dollar sign
// followed by a single digit, separated by valid phone number punctuation.
// This prevents invalid punctuation (such as the star sign in Israeli star numbers)
// getting into the output of the "as you type formatter".


var ELIGIBLE_FORMAT_PATTERN = new RegExp('^' + '[' + VALID_PUNCTUATION + ']*' + '(\\$\\d[' + VALID_PUNCTUATION + ']*)+' + '$'); // This is the minimum length of the leading digits of a phone number
// to guarantee the first "leading digits pattern" for a phone number format
// to be preemptive.

var MIN_LEADING_DIGITS_LENGTH = 3;
var VALID_FORMATTED_PHONE_NUMBER_PART = '[' + VALID_PUNCTUATION + VALID_DIGITS + ']+';
var VALID_FORMATTED_PHONE_NUMBER_PART_PATTERN = new RegExp('^' + VALID_FORMATTED_PHONE_NUMBER_PART + '$', 'i');
var AsYouType_VALID_PHONE_NUMBER = '(?:' + '[' + PLUS_CHARS + ']' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*' + '|' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']+' + ')';
var AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = new RegExp('[^' + VALID_PUNCTUATION + VALID_DIGITS + ']+' + '.*' + '$');
var AsYouType_USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;

var AsYouType_AsYouType =
/*#__PURE__*/
function () {
  // Not setting `options` to a constructor argument
  // not to break backwards compatibility
  // for older versions of the library.

  /**
   * @param {(string|object)?} [optionsOrDefaultCountry] - The default country used for parsing non-international phone numbers. Can also be an `options` object.
   * @param {Object} metadata
   */
  function AsYouType(optionsOrDefaultCountry, metadata) {
    AsYouType_classCallCheck(this, AsYouType);

    AsYouType_defineProperty(this, "options", {});

    this.metadata = new Metadata(metadata); // Set `defaultCountry` and `defaultCallingCode` options.

    var defaultCountry;
    var defaultCallingCode; // Turns out `null` also has type "object". Weird.

    if (optionsOrDefaultCountry) {
      if (AsYouType_typeof(optionsOrDefaultCountry) === 'object') {
        defaultCountry = optionsOrDefaultCountry.defaultCountry;
        defaultCallingCode = optionsOrDefaultCountry.defaultCallingCode;
      } else {
        defaultCountry = optionsOrDefaultCountry;
      }
    }

    if (defaultCountry && this.metadata.hasCountry(defaultCountry)) {
      this.defaultCountry = defaultCountry;
    }

    if (defaultCallingCode) {
      /* istanbul ignore if */
      if (AsYouType_USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
        if (this.metadata.isNonGeographicCallingCode(defaultCallingCode)) {
          this.defaultCountry = '001';
        }
      }

      this.defaultCallingCode = defaultCallingCode;
    } // Reset.


    this.reset();
  }

  AsYouType_createClass(AsYouType, [{
    key: "reset",
    value: function reset() {
      this.formattedOutput = '';
      this.international = false;
      this.internationalPrefix = undefined;
      this.countryCallingCode = undefined;
      this.digits = '';
      this.nationalNumberDigits = '';
      this.nationalPrefix = '';
      this.carrierCode = '';
      this.setCountry(this.defaultCountry, this.defaultCallingCode);
      return this;
    }
  }, {
    key: "resetFormat",
    value: function resetFormat() {
      this.chosenFormat = undefined;
      this.template = undefined;
      this.populatedNationalNumberTemplate = undefined;
      this.populatedNationalNumberTemplatePosition = -1;
    }
    /**
     * Returns `true` if the phone number is being input in international format.
     * In other words, returns `true` if and only if the parsed phone number starts with a `"+"`.
     * @return {boolean}
     */

  }, {
    key: "isInternational",
    value: function isInternational() {
      return this.international;
    }
    /**
     * Returns the "country calling code" part of the phone number.
     * Returns `undefined` if the number is not being input in international format.
     * Returns "country calling code" for "non-geographic" phone numbering plans too.
     * @return {string} [countryCallingCode]
     */

  }, {
    key: "getCountryCallingCode",
    value: function getCountryCallingCode() {
      return this.countryCallingCode;
    }
    /**
     * Returns a two-letter country code of the phone number.
     * Returns `undefined` for "non-geographic" phone numbering plans.
     * Returns `undefined` if no phone number has been input yet.
     * @return {string} [country]
     */

  }, {
    key: "getCountry",
    value: function getCountry() {
      // If no digits have been input yet,
      // then `this.country` is the `defaultCountry`.
      // Won't return the `defaultCountry` in such case.
      if (!this.digits) {
        return;
      }

      var countryCode = this.country;
      /* istanbul ignore if */

      if (AsYouType_USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
        if (this.country === '001') {
          countryCode = undefined;
        }
      }

      return countryCode;
    }
  }, {
    key: "setCountry",
    value: function setCountry(country, callingCode) {
      this.country = country;
      this.metadata.selectNumberingPlan(country, callingCode);

      if (this.metadata.hasSelectedNumberingPlan()) {
        this.initializePhoneNumberFormatsForCountry();
      } else {
        this.matchingFormats = [];
      }

      this.resetFormat();
    }
    /**
     * Inputs "next" phone number characters.
     * @param  {string} text
     * @return {string} Formatted phone number characters that have been input so far.
     */

  }, {
    key: "input",
    value: function input(text) {
      var formattedDigits = this.extractFormattedDigits(text); // If the extracted phone number part
      // can possibly be a part of some valid phone number
      // then parse phone number characters from a formatted phone number.

      if (VALID_FORMATTED_PHONE_NUMBER_PART_PATTERN.test(formattedDigits)) {
        this.formattedOutput = this.getFullNumber(this.inputDigits(parseDigits(formattedDigits)) || this.getNonFormattedNationalNumber());
      }

      return this.formattedOutput;
    }
    /**
     * Extracts formatted phone number digits from text (if there're any).
     * @param  {string} text
     * @return {string}
     */

  }, {
    key: "extractFormattedDigits",
    value: function extractFormattedDigits(text) {
      // Extract a formatted phone number part from text.
      var extractedNumber = AsYouType_extractFormattedPhoneNumber(text) || ''; // Trim a `+`.

      if (extractedNumber[0] === '+') {
        // Trim the `+`.
        extractedNumber = extractedNumber.slice('+'.length);

        if (this.digits) {// If an out of position `+` is detected
          // (or a second `+`) then just ignore it.
        } else {
          this.formattedOutput = '+';
          this.startInternationalNumber();
        }
      }

      return extractedNumber;
    }
  }, {
    key: "startInternationalNumber",
    value: function startInternationalNumber() {
      // Prepend the `+` to parsed input.
      this.international = true; // If a default country was set then reset it
      // because an explicitly international phone
      // number is being entered.

      this.setCountry();
    }
    /**
     * Inputs "next" phone number digits.
     * @param  {string} digits
     * @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means "don't format the national phone number at this stage".
     */

  }, {
    key: "inputDigits",
    value: function inputDigits(nextDigits) {
      // Some users input their phone number in "out-of-country"
      // dialing format instead of using the leading `+`.
      // https://github.com/catamphetamine/libphonenumber-js/issues/185
      // Detect such numbers.
      if (!this.digits) {
        var numberWithoutIDD = stripIDDPrefix(nextDigits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata);

        if (numberWithoutIDD && numberWithoutIDD !== nextDigits) {
          // If an IDD prefix was stripped then
          // convert the number to international one
          // for subsequent parsing.
          this.internationalPrefix = nextDigits.slice(0, nextDigits.length - numberWithoutIDD.length);
          nextDigits = numberWithoutIDD;
          this.startInternationalNumber();
        }
      } // Append phone number digits.


      this.digits += nextDigits; // Try to format the parsed input

      if (this.isInternational()) {
        if (this.countryCallingCode) {
          this.nationalNumberDigits += nextDigits; // `this.country` could be `undefined`, for example, when there is
          // ambiguity in a form of several different countries,
          // each corresponding to the same country phone code
          // (e.g. NANPA: USA, Canada, etc), and there's not enough digits
          // to reliably determine the country the phone number belongs to.
          // Therefore, in cases of such ambiguity, each time something is input,
          // try to determine the country (if it hasn't been determined yet).

          if (!this.country || this.isCountryCallingCodeAmbiguous()) {
            this.determineTheCountry();
          }
        } else {
          // Extract country calling code from the digits entered so far.
          // There must be some digits in order to extract anything from them.
          //
          // If one looks at country phone codes
          // then they can notice that no one country phone code
          // is ever a (leftmost) substring of another country phone code.
          // So if a valid country code is extracted so far
          // then it means that this is the country code.
          //
          // If no country phone code could be extracted so far,
          // then don't format the phone number.
          //
          if (!this.extractCountryCallingCode()) {
            // Don't format the phone number.
            return;
          } // Possibly extract a national prefix.
          // Some people incorrectly input national prefix
          // in an international phone number.
          // For example, some people write British phone numbers as `+44(0)...`.
          // Also, mobile phone numbers in Mexico are supposed to be dialled
          // internationally using a `15` national prefix.
          //
          // https://www.mexperience.com/dialing-cell-phones-in-mexico/
          //
          // "Dialing a Mexican cell phone from abroad
          // When you are calling a cell phone number in Mexico from outside Mexico,
          // itâs necessary to dial an additional â1â after Mexicoâs country code
          // (which is â52â) and before the area code.
          // You also ignore the 045, and simply dial the area code and the
          // cell phoneâs number.
          //
          // If you donât add the â1â, youâll receive a recorded announcement
          // asking you to redial using it.
          //
          // For example, if you are calling from the USA to a cell phone
          // in Mexico City, you would dial +52 â 1 â 55 â 1234 5678.
          // (Note that this is different to calling a land line in Mexico City
          // from abroad, where the number dialed would be +52 â 55 â 1234 5678)".
          //


          this.nationalNumberDigits = this.digits.slice(this.countryCallingCode.length); // this.extractNationalPrefix()
          //
          // Determine the country from country calling code and national number.

          this.determineTheCountry();
        }
      } else {
        this.nationalNumberDigits += nextDigits; // If `defaultCallingCode` is set,
        // see if the `country` could be derived.

        if (!this.country) {
          this.determineTheCountry();
        } // Some national prefixes are substrings of other national prefixes
        // (for the same country), therefore try to extract national prefix each time
        // because a longer national prefix might be available at some point in time.


        var previousNationalPrefix = this.nationalPrefix;
        this.nationalNumberDigits = this.nationalPrefix + this.nationalNumberDigits; // Re-extract national prefix.

        this.extractNationalPrefix(); // If another national prefix has been extracted.

        if (this.nationalPrefix !== previousNationalPrefix) {
          // National number has changed
          // (due to another national prefix been extracted)
          // therefore national number has changed
          // therefore reset all previous formatting data.
          // (and leading digits matching state)
          this.initializePhoneNumberFormatsForCountry();
          this.resetFormat();
        }
      }

      if (this.nationalNumberDigits) {
        // Match the available formats by the currently available leading digits.
        this.matchFormats(this.nationalNumberDigits);
      } // Format the phone number (given the next digits)


      return this.formatNationalNumberWithNextDigits(nextDigits);
    }
  }, {
    key: "formatNationalNumberWithNextDigits",
    value: function formatNationalNumberWithNextDigits(nextDigits) {
      // See if the phone number digits can be formatted as a complete phone number.
      // If not, use the results from `formatNextNationalNumberDigits()`,
      // which formats based on the chosen formatting pattern.
      // Attempting to format complete phone number first is how it's done
      // in Google's `libphonenumber`.
      var formattedNumber = this.attemptToFormatCompletePhoneNumber(); // Just because a phone number doesn't have a suitable format
      // that doesn't mean that the phone number is invalid,
      // because phone number formats only format phone numbers,
      // they don't validate them and some (rare) phone numbers
      // are meant to stay non-formatted.

      if (formattedNumber) {
        return formattedNumber;
      } // Format the next phone number digits
      // using the previously chosen phone number format.
      //
      // This is done here because if `attemptToFormatCompletePhoneNumber`
      // was placed before this call then the `template`
      // wouldn't reflect the situation correctly (and would therefore be inconsistent)
      //


      var previouslyChosenFormat = this.chosenFormat; // Choose a format from the list of matching ones.

      var newlyChosenFormat = this.chooseFormat();

      if (newlyChosenFormat) {
        if (newlyChosenFormat === previouslyChosenFormat) {
          // If could format the next (current) digit
          // using the previously chosen phone number format
          // then return the formatted number so far.
          //
          // If no new phone number format could be chosen,
          // and couldn't format the supplied national number
          // using the previously chosen phone number pattern,
          // then return `undefined`.
          //
          return this.formatNextNationalNumberDigits(nextDigits);
        } else {
          // If a more appropriate phone number format
          // has been chosen for these "leading digits",
          // then format the national phone number (so far)
          // using the newly selected format.
          //
          // Will return `undefined` if it couldn't format
          // the supplied national number
          // using the selected phone number pattern.
          //
          return this.reformatNationalNumber();
        }
      }
    }
  }, {
    key: "chooseFormat",
    value: function chooseFormat() {
      // When there are multiple available formats, the formatter uses the first
      // format where a formatting template could be created.
      for (var _iterator = this.matchingFormats, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var format = _ref;

        // If this format is currently being used
        // and is still possible, then stick to it.
        if (this.chosenFormat === format) {
          break;
        }

        if (!this.createFormattingTemplate(format)) {
          continue;
        }

        this.chosenFormat = format; // With a new formatting template, the matched position
        // using the old template needs to be reset.

        this.populatedNationalNumberTemplatePosition = -1;
        break;
      }

      if (!this.chosenFormat) {
        // No format matches the national phone number entered.
        this.resetFormat();
      }

      return this.chosenFormat;
    } // Formats each digit of the national phone number (so far)
    // using the selected format.

  }, {
    key: "reformatNationalNumber",
    value: function reformatNationalNumber() {
      return this.formatNextNationalNumberDigits(this.nationalPrefix + this.nationalNumberDigits);
    }
  }, {
    key: "initializePhoneNumberFormatsForCountry",
    value: function initializePhoneNumberFormatsForCountry() {
      // Get all "eligible" phone number formats for this country
      this.matchingFormats = this.metadata.formats().filter(function (format) {
        // Compared to `libphonenumber`'s code, the two "Discard a few formats
        // that we know are not relevant based on the presence of the national prefix"
        // checks have changed: the first one has been moved to `.matchFormats()`,
        // and the second one doesn't apply to this library because it doesn't deal with
        // "incomplete" phone numbers (for example, phone numbers, entered without "area code").
        return ELIGIBLE_FORMAT_PATTERN.test(format.internationalFormat());
      });
    }
  }, {
    key: "matchFormats",
    value: function matchFormats(leadingDigits) {
      var _this = this;

      // "leading digits" pattern list starts with a
      // "leading digits" pattern fitting a maximum of 3 leading digits.
      // So, after a user inputs 3 digits of a national (significant) phone number
      // this national (significant) number can already be formatted.
      // The next "leading digits" pattern is for 4 leading digits max,
      // and the "leading digits" pattern after it is for 5 leading digits max, etc.
      // This implementation is different from Google's
      // in that it searches for a fitting format
      // even if the user has entered less than
      // `MIN_LEADING_DIGITS_LENGTH` digits of a national number.
      // Because some leading digit patterns already match for a single first digit.
      var leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH;

      if (leadingDigitsPatternIndex < 0) {
        leadingDigitsPatternIndex = 0;
      }

      this.matchingFormats = this.matchingFormats.filter(function (format) {
        // If national prefix is mandatory for this phone number format
        // and the user didn't input the national prefix
        // then this phone number format isn't suitable.
        if (!_this.isInternational() && !_this.nationalPrefix && format.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {
          return false;
        }

        var leadingDigitsPatternsCount = format.leadingDigitsPatterns().length; // If this format is not restricted to a certain
        // leading digits pattern then it fits.

        if (leadingDigitsPatternsCount === 0) {
          return true;
        } // Start excluding any non-matching formats only when the
        // national number entered so far is at least 3 digits long,
        // otherwise format matching would give false negatives.
        // For example, when the digits entered so far are `2`
        // and the leading digits pattern is `21` â
        // it's quite obvious in this case that the format could be the one
        // but due to the absence of further digits it would give false negative.


        if (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {
          return true;
        } // If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are available
        // then format matching starts narrowing down the list of possible formats
        // (only previously matched formats are considered for next digits).


        leadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1);
        var leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex]; // Brackets are required for `^` to be applied to
        // all or-ed (`|`) parts, not just the first one.

        return new RegExp("^(".concat(leadingDigitsPattern, ")")).test(leadingDigits);
      }); // If there was a phone number format chosen
      // and it no longer holds given the new leading digits then reset it.
      // The test for this `if` condition is marked as:
      // "Reset a chosen format when it no longer holds given the new leading digits".
      // To construct a valid test case for this one can find a country
      // in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`
      // and yielding another format for 4 `<leadingDigits>` (Australia in this case).

      if (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {
        this.resetFormat();
      }
    }
  }, {
    key: "getSeparatorAfterNationalPrefix",
    value: function getSeparatorAfterNationalPrefix(format) {
      if (this.metadata.countryCallingCode() === '1') {
        return ' ';
      }

      if (format && format.nationalPrefixFormattingRule() && NATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {
        return ' ';
      }

      return '';
    } // This is in accordance to how Google's `libphonenumber` does it.
    // "Check to see if there is an exact pattern match for these digits.
    // If so, we should use this instead of any other formatting template
    // whose `leadingDigitsPattern` also matches the input."

  }, {
    key: "attemptToFormatCompletePhoneNumber",
    value: function attemptToFormatCompletePhoneNumber() {
      for (var _iterator2 = this.matchingFormats, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var format = _ref2;
        var matcher = new RegExp("^(?:".concat(format.pattern(), ")$"));

        if (!matcher.test(this.nationalNumberDigits)) {
          continue;
        } // Here, national number is formatted without "national prefix
        // formatting rule", because otherwise there'd be a bug
        // when "area code" is "duplicated" during input:
        // https://github.com/catamphetamine/libphonenumber-js/issues/318


        var formattedNationalNumber = formatNationalNumberUsingFormat(this.nationalNumberDigits, format, this.isInternational(), false, // Don't prepend national prefix (it will be prepended manually).
        this.metadata); // Check if this `format` preserves all digits.
        // This is how it's done in Google's `libphonenumber`.
        // Also, it fixes the bug when "area code" is "duplicated" during input:
        // https://github.com/catamphetamine/libphonenumber-js/issues/318
        //
        // "Check that we didn't remove nor add any extra digits when we matched
        // this formatting pattern. This usually happens after we entered the last
        // digit during AYTF. Eg: In case of MX, we swallow mobile token (1) when
        // formatted but AYTF should retain all the number entered and not change
        // in order to match a format (of same leading digits and length) display
        // in that way."
        // "If it's the same (i.e entered number and format is same), then it's
        // safe to return this in formatted number as nothing is lost / added."
        // Otherwise, don't use this format.
        // https://github.com/google/libphonenumber/commit/3e7c1f04f5e7200f87fb131e6f85c6e99d60f510#diff-9149457fa9f5d608a11bb975c6ef4bc5
        // https://github.com/google/libphonenumber/commit/3ac88c7106e7dcb553bcc794b15f19185928a1c6#diff-2dcb77e833422ee304da348b905cde0b
        //

        if (parseDigits(formattedNationalNumber) !== this.nationalNumberDigits) {
          continue;
        } // Prepend national prefix (if any).


        if (this.nationalPrefix) {
          // Here, national number is formatted with "national prefix
          // formatting rule". The reason is that "national prefix
          // formatting rule" often adds parentheses, and while Google's
          // `libphonenumber` dismisses those preferring simply prepending
          // national prefix followed by a " " character, this library
          // looks if the national prefix could be formatted better.
          var formattedNationalNumberWithNationalPrefix = formatNationalNumberUsingFormat(this.nationalNumberDigits, format, this.isInternational(), true, // Prepend national prefix.
          this.metadata);

          if (parseDigits(formattedNationalNumberWithNationalPrefix) === this.nationalPrefix + this.nationalNumberDigits) {
            formattedNationalNumber = formattedNationalNumberWithNationalPrefix;
          } else {
            formattedNationalNumber = this.nationalPrefix + this.getSeparatorAfterNationalPrefix(format) + formattedNationalNumber;
          }
        } // formats national number (probably) without national prefix.
        // Formatting a national number with national prefix could result in
        // bugs when "area code" is "duplicated" during input:
        // https://github.com/catamphetamine/libphonenumber-js/issues/318
        // The "are all digits preserved" check fixes that type of bug.
        // To leave the formatter in a consistent state


        this.resetFormat();
        this.chosenFormat = format; // Set `this.template` and `this.populatedNationalNumberTemplate`.

        /* istanbul ignore else */

        if (this.createFormattingTemplate(format)) {
          // Populate `this.populatedNationalNumberTemplate` with phone number digits.
          this.reformatNationalNumber();
        } else {
          // If the formatting template couldn't be created for a format,
          // create it manually from the formatted phone number.
          // This case doesn't ever happen with the current metadata.
          this.template = this.getFullNumber(formattedNationalNumber).replace(/[\d\+]/g, DIGIT_PLACEHOLDER);
          this.populatedNationalNumberTemplate = formattedNationalNumber;
          this.populatedNationalNumberTemplatePosition = this.populatedNationalNumberTemplate.length - 1;
        }

        return formattedNationalNumber;
      }
    }
  }, {
    key: "getInternationalPrefix",
    value: function getInternationalPrefix(options) {
      return this.internationalPrefix ? options && options.spacing === false ? this.internationalPrefix : this.internationalPrefix + ' ' : '+';
    } // Prepends `+CountryCode ` in case of an international phone number

  }, {
    key: "getFullNumber",
    value: function getFullNumber(formattedNationalNumber) {
      if (this.isInternational()) {
        var prefix = this.getInternationalPrefix();

        if (!this.countryCallingCode) {
          return "".concat(prefix).concat(this.digits);
        }

        if (!formattedNationalNumber) {
          return "".concat(prefix).concat(this.countryCallingCode);
        }

        return "".concat(prefix).concat(this.countryCallingCode, " ").concat(formattedNationalNumber);
      }

      return formattedNationalNumber;
    }
  }, {
    key: "getNonFormattedNationalNumber",
    value: function getNonFormattedNationalNumber() {
      return this.nationalPrefix + (this.nationalPrefix && this.nationalNumberDigits && this.getSeparatorAfterNationalPrefix()) + this.nationalNumberDigits;
    } // Extracts the country calling code from the beginning
    // of the entered `national_number` (so far),
    // and places the remaining input into the `national_number`.

  }, {
    key: "extractCountryCallingCode",
    value: function extractCountryCallingCode() {
      var _extractCountryCallin = parse_extractCountryCallingCode('+' + this.digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata),
          countryCallingCode = _extractCountryCallin.countryCallingCode,
          number = _extractCountryCallin.number;

      if (!countryCallingCode) {
        return;
      }

      this.nationalNumberDigits = number;
      this.countryCallingCode = countryCallingCode;
      this.metadata.chooseCountryByCountryCallingCode(countryCallingCode);
      this.initializePhoneNumberFormatsForCountry();
      this.resetFormat();
      return this.metadata.hasSelectedNumberingPlan();
    }
  }, {
    key: "extractNationalPrefix",
    value: function extractNationalPrefix() {
      this.nationalPrefix = '';

      if (!this.metadata.hasSelectedNumberingPlan()) {
        return;
      } // Only strip national prefixes for non-international phone numbers
      // because national prefixes can't be present in international phone numbers.
      // While `parseNumber()` is forgiving is such cases, `AsYouType` is not.


      var _stripNationalPrefixA = stripNationalPrefixAndCarrierCode(this.nationalNumberDigits, this.metadata),
          nationalNumber = _stripNationalPrefixA.nationalNumber,
          carrierCode = _stripNationalPrefixA.carrierCode; // Sometimes `stripNationalPrefixAndCarrierCode()` won't actually
      // strip national prefix and will instead prepend some digits to the `number`:
      // for example, when number `2345678` is passed with `VI` country selected,
      // it will return `{ number: "3402345678" }`, because `340` area code is prepended.
      // So check if the `nationalNumber` is actually at the end of `this.nationalNumberDigits`.


      if (nationalNumber) {
        var index = this.nationalNumberDigits.indexOf(nationalNumber);

        if (index < 0 || index !== this.nationalNumberDigits.length - nationalNumber.length) {
          return;
        }
      }

      if (carrierCode) {
        this.carrierCode = carrierCode;
      }

      this.nationalPrefix = this.nationalNumberDigits.slice(0, this.nationalNumberDigits.length - nationalNumber.length);
      this.nationalNumberDigits = nationalNumber;
      return this.nationalPrefix;
    } // isPossibleNumber(number) {
    // 	switch (checkNumberLengthForType(number, undefined, this.metadata)) {
    // 		case 'IS_POSSIBLE':
    // 			return true
    // 		// case 'IS_POSSIBLE_LOCAL_ONLY':
    // 		// 	return !this.isInternational()
    // 		default:
    // 			return false
    // 	}
    // }

  }, {
    key: "isCountryCallingCodeAmbiguous",
    value: function isCountryCallingCodeAmbiguous() {
      var countryCodes = this.metadata.getCountryCodesForCallingCode(this.countryCallingCode);
      return countryCodes && countryCodes.length > 1;
    }
  }, {
    key: "createFormattingTemplate",
    value: function createFormattingTemplate(format) {
      // The formatter doesn't format numbers when numberPattern contains '|', e.g.
      // (20|3)\d{4}. In those cases we quickly return.
      // (Though there's no such format in current metadata)

      /* istanbul ignore if */
      if (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {
        return;
      } // Get formatting template for this phone number format


      var template = this.getTemplateForNumberFormatPattern(format, this.nationalPrefix); // If the national number entered is too long
      // for any phone number format, then abort.

      if (!template) {
        return;
      }

      this.template = template;
      this.populatedNationalNumberTemplate = template; // For convenience, the public `.template` property
      // contains the whole international number
      // if the phone number being input is international:
      // 'x' for the '+' sign, 'x'es for the country phone code,
      // a spacebar and then the template for the formatted national number.

      if (this.isInternational()) {
        this.template = this.getInternationalPrefix().replace(/[\d\+]/g, DIGIT_PLACEHOLDER) + repeat(DIGIT_PLACEHOLDER, this.countryCallingCode.length) + ' ' + template;
      }

      return this.template;
    }
    /**
     * Generates formatting template for a national phone number,
     * optionally containing a national prefix, for a format.
     * @param  {Format} format
     * @param  {string} nationalPrefix
     * @return {string}
     */

  }, {
    key: "getTemplateForNumberFormatPattern",
    value: function getTemplateForNumberFormatPattern(format, nationalPrefix) {
      var pattern = format.pattern();
      /* istanbul ignore else */

      if (SUPPORT_LEGACY_FORMATTING_PATTERNS) {
        pattern = pattern // Replace anything in the form of [..] with \d
        .replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\d') // Replace any standalone digit (not the one in `{}`) with \d
        .replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\d');
      } // Generate a dummy national number (consisting of `9`s)
      // that fits this format's `pattern`.
      //
      // This match will always succeed,
      // because the "longest dummy phone number"
      // has enough length to accomodate any possible
      // national phone number format pattern.
      //


      var digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0]; // If the national number entered is too long
      // for any phone number format, then abort.

      if (this.nationalNumberDigits.length > digits.length) {
        return;
      } // Get a formatting template which can be used to efficiently format
      // a partial number where digits are added one by one.
      // Below `strictPattern` is used for the
      // regular expression (with `^` and `$`).
      // This wasn't originally in Google's `libphonenumber`
      // and I guess they don't really need it
      // because they're not using "templates" to format phone numbers
      // but I added `strictPattern` after encountering
      // South Korean phone number formatting bug.
      //
      // Non-strict regular expression bug demonstration:
      //
      // this.nationalNumberDigits : `111111111` (9 digits)
      //
      // pattern : (\d{2})(\d{3,4})(\d{4})
      // format : `$1 $2 $3`
      // digits : `9999999999` (10 digits)
      //
      // '9999999999'.replace(new RegExp(/(\d{2})(\d{3,4})(\d{4})/g), '$1 $2 $3') = "99 9999 9999"
      //
      // template : xx xxxx xxxx
      //
      // But the correct template in this case is `xx xxx xxxx`.
      // The template was generated incorrectly because of the
      // `{3,4}` variability in the `pattern`.
      //
      // The fix is, if `this.nationalNumberDigits` has already sufficient length
      // to satisfy the `pattern` completely then `this.nationalNumberDigits`
      // is used instead of `digits`.


      var strictPattern = new RegExp('^' + pattern + '$');
      var nationalNumberDummyDigits = this.nationalNumberDigits.replace(/\d/g, DUMMY_DIGIT); // If `this.nationalNumberDigits` has already sufficient length
      // to satisfy the `pattern` completely then use it
      // instead of `digits`.

      if (strictPattern.test(nationalNumberDummyDigits)) {
        digits = nationalNumberDummyDigits;
      }

      var numberFormat = this.getFormatFormat(format);
      var includesNationalPrefix;

      if (nationalPrefix) {
        if (format.nationalPrefixFormattingRule()) {
          var numberFormatWithNationalPrefix = numberFormat.replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule());

          if (parseDigits(numberFormatWithNationalPrefix) === nationalPrefix + parseDigits(numberFormat)) {
            numberFormat = numberFormatWithNationalPrefix;
            includesNationalPrefix = true;
            var i = nationalPrefix.length;

            while (i > 0) {
              numberFormat = numberFormat.replace(/\d/, DIGIT_PLACEHOLDER);
              i--;
            }
          }
        }
      } // Generate formatting template for this phone number format.


      var template = digits // Format the dummy phone number according to the format.
      .replace(new RegExp(pattern), numberFormat) // Replace each dummy digit with a DIGIT_PLACEHOLDER.
      .replace(new RegExp(DUMMY_DIGIT, 'g'), DIGIT_PLACEHOLDER);

      if (nationalPrefix) {
        if (!includesNationalPrefix) {
          // Prepend national prefix to the template manually.
          template = repeat(DIGIT_PLACEHOLDER, nationalPrefix.length) + this.getSeparatorAfterNationalPrefix(format) + template;
        }
      }

      return template;
    }
  }, {
    key: "formatNextNationalNumberDigits",
    value: function formatNextNationalNumberDigits(digits) {
      // Using `.split('')` to iterate through a string here
      // to avoid requiring `Symbol.iterator` polyfill.
      // `.split('')` is generally not safe for Unicode,
      // but in this particular case for `digits` it is safe.
      // for (const digit of digits)
      for (var _iterator3 = digits.split(''), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var digit = _ref3;

        // If there is room for more digits in current `template`,
        // then set the next digit in the `template`,
        // and return the formatted digits so far.
        // If more digits are entered than the current format could handle.
        if (this.populatedNationalNumberTemplate.slice(this.populatedNationalNumberTemplatePosition + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {
          // Reset the format.
          this.resetFormat();
          return;
        }

        this.populatedNationalNumberTemplatePosition = this.populatedNationalNumberTemplate.search(DIGIT_PLACEHOLDER_MATCHER);
        this.populatedNationalNumberTemplate = this.populatedNationalNumberTemplate.replace(DIGIT_PLACEHOLDER_MATCHER, digit);
      } // Return the formatted phone number so far.


      return cutAndStripNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1); // The old way which was good for `input-format` but is not so good
      // for `react-phone-number-input`'s default input (`InputBasic`).
      // return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)
      // 	.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')
    }
  }, {
    key: "getFormatFormat",
    value: function getFormatFormat(format) {
      if (this.isInternational()) {
        return applyInternationalSeparatorStyle(format.internationalFormat());
      }

      return format.format();
    } // Determines the country of the phone number
    // entered so far based on the country phone code
    // and the national phone number.

  }, {
    key: "determineTheCountry",
    value: function determineTheCountry() {
      this.country = findCountryCode(this.isInternational() ? this.countryCallingCode : this.defaultCallingCode, this.nationalNumberDigits, this.metadata);
    }
    /**
     * Returns an instance of `PhoneNumber` class.
     * Will return `undefined` if no national (significant) number
     * digits have been entered so far, or if no `defaultCountry` has been
     * set and the user enters a phone number not in international format.
     */

  }, {
    key: "getNumber",
    value: function getNumber() {
      if (this.isInternational()) {
        if (!this.countryCallingCode) {
          return;
        }
      } else {
        if (!this.country && !this.defaultCallingCode) {
          return;
        }
      }

      if (!this.nationalNumberDigits) {
        return undefined;
      }

      var countryCode = this.getCountry();
      var callingCode = this.getCountryCallingCode() || this.defaultCallingCode;
      var nationalNumber = this.nationalNumberDigits;
      var carrierCode = this.carrierCode; // When an international number without a leading `+` has been autocorrected,
      // extract country calling code, because normally it's only extracted
      // for international numbers with a leading `+`.
      // Could also just use `parsePhoneNumberFromString()` here
      // instead of hacking around this single case.

      if (!this.isInternational() && this.nationalNumberDigits === this.digits) {
        var _extractCountryCallin2 = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(this.digits, countryCode, callingCode, this.metadata.metadata),
            countryCallingCode = _extractCountryCallin2.countryCallingCode,
            number = _extractCountryCallin2.number;

        if (countryCallingCode) {
          var _stripNationalPrefixA2 = stripNationalPrefixAndCarrierCodeFromCompleteNumber(number, this.metadata),
              shorterNationalNumber = _stripNationalPrefixA2.nationalNumber,
              newCarrierCode = _stripNationalPrefixA2.carrierCode;

          nationalNumber = shorterNationalNumber;
          carrierCode = newCarrierCode;
        }
      }

      var phoneNumber = new PhoneNumber_PhoneNumber(countryCode || callingCode, nationalNumber, this.metadata.metadata);

      if (carrierCode) {
        phoneNumber.carrierCode = carrierCode;
      } // Phone number extensions are not supported by "As You Type" formatter.


      return phoneNumber;
    }
    /**
     * Returns `true` if the phone number is "possible".
     * Is just a shortcut for `PhoneNumber.isPossible()`.
     * @return {boolean}
     */

  }, {
    key: "isPossible",
    value: function isPossible() {
      var phoneNumber = this.getNumber();

      if (!phoneNumber) {
        return false;
      }

      return phoneNumber.isPossible();
    }
    /**
     * Returns `true` if the phone number is "valid".
     * Is just a shortcut for `PhoneNumber.isValid()`.
     * @return {boolean}
     */

  }, {
    key: "isValid",
    value: function isValid() {
      var phoneNumber = this.getNumber();

      if (!phoneNumber) {
        return false;
      }

      return phoneNumber.isValid();
    }
    /**
     * @deprecated
     * This method is used in `react-phone-number-input/source/input-control.js`
     * in versions before `3.0.16`.
     */

  }, {
    key: "getNationalNumber",
    value: function getNationalNumber() {
      return this.nationalNumberDigits;
    }
  }, {
    key: "getNonFormattedTemplate",
    value: function getNonFormattedTemplate() {
      return this.getFullNumber(this.getNonFormattedNationalNumber()).replace(/[\+\d]/g, DIGIT_PLACEHOLDER);
    }
    /**
     * Returns formatted phone number template.
     * @return {string} [template]
     */

  }, {
    key: "getTemplate",
    value: function getTemplate() {
      if (!this.template) {
        return this.getNonFormattedTemplate();
      }

      var index = -1;
      var i = 0;

      while (i < (this.isInternational() ? this.getInternationalPrefix({
        spacing: false
      }).length : 0) + this.digits.length) {
        index = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1);
        i++;
      }

      return cutAndStripNonPairedParens(this.template, index + 1);
    }
  }]);

  return AsYouType;
}();


function stripNonPairedParens(string) {
  var dangling_braces = [];
  var i = 0;

  while (i < string.length) {
    if (string[i] === '(') {
      dangling_braces.push(i);
    } else if (string[i] === ')') {
      dangling_braces.pop();
    }

    i++;
  }

  var start = 0;
  var cleared_string = '';
  dangling_braces.push(string.length);

  for (var _i4 = 0, _dangling_braces = dangling_braces; _i4 < _dangling_braces.length; _i4++) {
    var index = _dangling_braces[_i4];
    cleared_string += string.slice(start, index);
    start = index + 1;
  }

  return cleared_string;
}
function cutAndStripNonPairedParens(string, cutBeforeIndex) {
  if (string[cutBeforeIndex] === ')') {
    cutBeforeIndex++;
  }

  return stripNonPairedParens(string.slice(0, cutBeforeIndex));
}
function closeNonPairedParens(template, cut_before) {
  var retained_template = template.slice(0, cut_before);
  var opening_braces = countOccurences('(', retained_template);
  var closing_braces = countOccurences(')', retained_template);
  var dangling_braces = opening_braces - closing_braces;

  while (dangling_braces > 0 && cut_before < template.length) {
    if (template[cut_before] === ')') {
      dangling_braces--;
    }

    cut_before++;
  }

  return template.slice(0, cut_before);
} // Counts all occurences of a symbol in a string.
// Unicode-unsafe (because using `.split()`).

function countOccurences(symbol, string) {
  var count = 0; // Using `.split('')` to iterate through a string here
  // to avoid requiring `Symbol.iterator` polyfill.
  // `.split('')` is generally not safe for Unicode,
  // but in this particular case for counting brackets it is safe.
  // for (const character of string)

  for (var _iterator4 = string.split(''), _isArray4 = Array.isArray(_iterator4), _i5 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
    var _ref4;

    if (_isArray4) {
      if (_i5 >= _iterator4.length) break;
      _ref4 = _iterator4[_i5++];
    } else {
      _i5 = _iterator4.next();
      if (_i5.done) break;
      _ref4 = _i5.value;
    }

    var character = _ref4;

    if (character === symbol) {
      count++;
    }
  }

  return count;
} // Repeats a string (or a symbol) N times.
// http://stackoverflow.com/questions/202605/repeat-string-javascript

function repeat(string, times) {
  if (times < 1) {
    return '';
  }

  var result = '';

  while (times > 1) {
    if (times & 1) {
      result += string;
    }

    times >>= 1;
    string += string;
  }

  return result + string;
}
/**
 * Extracts formatted phone number from text (if there's any).
 * @param  {string} text
 * @return {string} [formattedPhoneNumber]
 */

function AsYouType_extractFormattedPhoneNumber(text) {
  // Attempt to extract a possible number from the string passed in.
  var startsAt = text.search(AsYouType_VALID_PHONE_NUMBER);

  if (startsAt < 0) {
    return;
  } // Trim everything to the left of the phone number.


  text = text.slice(startsAt); // Trim the `+`.

  var hasPlus;

  if (text[0] === '+') {
    hasPlus = true;
    text = text.slice('+'.length);
  } // Trim everything to the right of the phone number.


  text = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, ''); // Re-add the previously trimmed `+`.

  if (hasPlus) {
    text = '+' + text;
  }

  return text;
}
//# sourceMappingURL=AsYouType.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/getCountries.js

function getCountries(metadata) {
  return new Metadata(metadata).getCountries();
}
//# sourceMappingURL=getCountries.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/es6/formatIncompletePhoneNumber.js

/**
 * Formats a (possibly incomplete) phone number.
 * The phone number can be either in E.164 format
 * or in a form of national number digits.
 * @param {string} value - A possibly incomplete phone number. Either in E.164 format or in a form of national number digits.
 * @param {string?} country - Two-letter ("ISO 3166-1 alpha-2") country code.
 * @return {string} Formatted (possibly incomplete) phone number.
 */

function formatIncompletePhoneNumber(value, country, metadata) {
  if (!metadata) {
    metadata = country;
    country = undefined;
  }

  return new AsYouType_AsYouType(country, metadata).input(value);
}
//# sourceMappingURL=formatIncompletePhoneNumber.js.map
// CONCATENATED MODULE: ./node_modules/libphonenumber-js/index.es6.js
// Deprecated.
// Use `libphonenumber-js/min` or `libphonenumber-js/max` or `libphonenumber-js/core` instead.

// Importing from `.json.js` a workaround for a bug in web browsers' "native"
// ES6 importing system which is uncapable of importing "*.json" files.
// https://github.com/catamphetamine/libphonenumber-js/issues/239













// Deprecated


















// Deprecated: remove DIGITS export in 2.0.0.
// (it was used in `react-phone-number-input`)



function index_es6_parsePhoneNumber()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return es6_parsePhoneNumber_parsePhoneNumber.apply(this, parameters)
}

function index_es6_parsePhoneNumberFromString()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return parsePhoneNumberFromString_parsePhoneNumberFromString.apply(this, parameters)
}

function index_es6_parseNumber()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return parseNumber.apply(this, parameters)
}

// Deprecated: remove `parse()` export in 2.0.0.
// (renamed to `parseNumber()`)
function index_es6_parse()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return parseNumber.apply(this, parameters)
}

function index_es6_formatNumber()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return es6_format_formatNumber.apply(this, parameters)
}

// Deprecated: remove `format()` export in 2.0.0.
// (renamed to `formatNumber()`)
function index_es6_format()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return es6_format_formatNumber.apply(this, parameters)
}

function index_es6_getNumberType()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return getNumberType_getNumberType.apply(this, parameters)
}

function index_es6_getExampleNumber()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return getExampleNumber.apply(this, parameters)
}

function index_es6_isPossibleNumber()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return isPossibleNumber_isPossibleNumber.apply(this, parameters)
}

function index_es6_isValidNumber()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return validate_isValidNumber.apply(this, parameters)
}

function index_es6_isValidNumberForRegion()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return isValidNumberForRegion_isValidNumberForRegion.apply(this, parameters)
}

// Deprecated.
function index_es6_findPhoneNumbers()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return findPhoneNumbers_findPhoneNumbers.apply(this, parameters)
}

// Deprecated.
function index_es6_searchPhoneNumbers()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return findPhoneNumbers_searchPhoneNumbers.apply(this, parameters)
}

// Deprecated.
function index_es6_PhoneNumberSearch(text, options)
{
	findPhoneNumbers_PhoneNumberSearch.call(this, text, options, metadata_min_json)
}

// Deprecated.
index_es6_PhoneNumberSearch.prototype = Object.create(findPhoneNumbers_PhoneNumberSearch.prototype, {})
index_es6_PhoneNumberSearch.prototype.constructor = index_es6_PhoneNumberSearch

function index_es6_findNumbers()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return findNumbers_findNumbers.apply(this, parameters)
}

function index_es6_searchNumbers()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return searchNumbers.apply(this, parameters)
}

function index_es6_findPhoneNumbersInText()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return findPhoneNumbersInText.apply(this, parameters)
}

function index_es6_searchPhoneNumbersInText()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return searchPhoneNumbersInText.apply(this, parameters)
}

function index_es6_PhoneNumberMatcher(text, options)
{
	PhoneNumberMatcher_PhoneNumberMatcher.call(this, text, options, metadata_min_json)
}

index_es6_PhoneNumberMatcher.prototype = Object.create(PhoneNumberMatcher_PhoneNumberMatcher.prototype, {})
index_es6_PhoneNumberMatcher.prototype.constructor = index_es6_PhoneNumberMatcher

function index_es6_AsYouType(country)
{
	AsYouType_AsYouType.call(this, country, metadata_min_json)
}

index_es6_AsYouType.prototype = Object.create(AsYouType_AsYouType.prototype, {})
index_es6_AsYouType.prototype.constructor = index_es6_AsYouType

function index_es6_isSupportedCountry()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return isSupportedCountry.apply(this, parameters)
}

function index_es6_getExtPrefix()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return getExtPrefix.apply(this, parameters)
}

function index_es6_parseRFC3966()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return parseRFC3966.apply(this, parameters)
}

function index_es6_formatRFC3966()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return formatRFC3966.apply(this, parameters)
}

function index_es6_formatIncompletePhoneNumber()
{
	var parameters = Array.prototype.slice.call(arguments)
	parameters.push(metadata_min_json)
	return formatIncompletePhoneNumber.apply(this, parameters)
}

// Deprecated: remove this in 2.0.0 and make `custom.js` in ES6
// (the old `custom.js` becomes `custom.commonjs.js`).











function index_es6_getCountries()
{
	return getCountries(metadata_min_json)
}

function index_es6_getCountryCallingCode(country)
{
	return getCountryCallingCode(country, metadata_min_json)
}

// `getPhoneCode` name is deprecated, use `getCountryCallingCode` instead.
function getPhoneCode(country)
{
	return index_es6_getCountryCallingCode(country)
}

// `getPhoneCodeCustom` name is deprecated, use `getCountryCallingCodeCustom` instead.
function getPhoneCodeCustom(country, metadata)
{
	return getCountryCallingCode(country, metadata)
}
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e3879104-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/VuePhoneNumberInput/InputTel/index.vue?vue&type=template&id=e59be3b4&scoped=true&
var InputTelvue_type_template_id_e59be3b4_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"parent",staticClass:"input-tel",class:[{
    'is-focused': _vm.isFocus,
    'is-valid': _vm.valid,
    'has-value': _vm.value,
    'has-error': _vm.error,
    'is-disabled': _vm.disabled,
    'is-dark': _vm.dark,
    'has-hint': _vm.hint
  }, _vm.size],on:{"click":_vm.focusInput,"mouseenter":function($event){return _vm.updateHoverState(true)},"mouseleave":function($event){return _vm.updateHoverState(false)}}},[((_vm.type)==='checkbox')?_c('input',_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.inputValue),expression:"inputValue"}],ref:"InputTel",staticClass:"input-tel__input",class:{ 'no-country-selector': _vm.noCountrySelector },style:([
      _vm.noCountrySelector ? _vm.radiusStyle : _vm.radiusRightStyle,
      _vm.inputCaretStyle,
      _vm.inputBorderStyle,
      _vm.inputBoxShadowStyle,
      _vm.inputBgColor,
      _vm.textColor
    ]),attrs:{"id":_vm.id,"placeholder":_vm.labelValue,"disabled":_vm.disabled,"required":_vm.required,"type":"checkbox"},domProps:{"checked":Array.isArray(_vm.inputValue)?_vm._i(_vm.inputValue,null)>-1:(_vm.inputValue)},on:{"keydown":_vm.keyDown,"keyup":_vm.keyUp,"focus":_vm.onFocus,"blur":_vm.onBlur,"click":function($event){return _vm.$emit('click', $event)},"change":function($event){var $$a=_vm.inputValue,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.inputValue=$$a.concat([$$v]))}else{$$i>-1&&(_vm.inputValue=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{_vm.inputValue=$$c}}}},'input',_vm.$attrs,false)):((_vm.type)==='radio')?_c('input',_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.inputValue),expression:"inputValue"}],ref:"InputTel",staticClass:"input-tel__input",class:{ 'no-country-selector': _vm.noCountrySelector },style:([
      _vm.noCountrySelector ? _vm.radiusStyle : _vm.radiusRightStyle,
      _vm.inputCaretStyle,
      _vm.inputBorderStyle,
      _vm.inputBoxShadowStyle,
      _vm.inputBgColor,
      _vm.textColor
    ]),attrs:{"id":_vm.id,"placeholder":_vm.labelValue,"disabled":_vm.disabled,"required":_vm.required,"type":"radio"},domProps:{"checked":_vm._q(_vm.inputValue,null)},on:{"keydown":_vm.keyDown,"keyup":_vm.keyUp,"focus":_vm.onFocus,"blur":_vm.onBlur,"click":function($event){return _vm.$emit('click', $event)},"change":function($event){_vm.inputValue=null}}},'input',_vm.$attrs,false)):_c('input',_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.inputValue),expression:"inputValue"}],ref:"InputTel",staticClass:"input-tel__input",class:{ 'no-country-selector': _vm.noCountrySelector },style:([
      _vm.noCountrySelector ? _vm.radiusStyle : _vm.radiusRightStyle,
      _vm.inputCaretStyle,
      _vm.inputBorderStyle,
      _vm.inputBoxShadowStyle,
      _vm.inputBgColor,
      _vm.textColor
    ]),attrs:{"id":_vm.id,"placeholder":_vm.labelValue,"disabled":_vm.disabled,"required":_vm.required,"type":_vm.type},domProps:{"value":(_vm.inputValue)},on:{"keydown":_vm.keyDown,"keyup":_vm.keyUp,"focus":_vm.onFocus,"blur":_vm.onBlur,"click":function($event){return _vm.$emit('click', $event)},"input":function($event){if($event.target.composing){ return; }_vm.inputValue=$event.target.value}}},'input',_vm.$attrs,false)),_c('label',{ref:"label",staticClass:"input-tel__label",class:_vm.error ? 'text-danger' : null,style:([_vm.labelColorStyle]),attrs:{"for":_vm.id},on:{"click":_vm.focusInput}},[_vm._v(" "+_vm._s(_vm.hintValue || _vm.labelValue)+" ")]),(_vm.clearable && _vm.inputValue)?_c('button',{staticClass:"input-tel__clear",attrs:{"title":"clear","type":"button","tabindex":"-1"},on:{"click":_vm.clear}},[_c('span',{staticClass:"input-tel__clear__effect"}),_c('span',[_vm._v(" â ")])]):_vm._e(),(_vm.loader)?_c('div',{staticClass:"input-tel__loader"},[_c('div',{staticClass:"input-tel__loader__progress-bar",style:([_vm.loaderBgColor])})]):_vm._e()])}
var InputTelvue_type_template_id_e59be3b4_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: ./src/VuePhoneNumberInput/InputTel/index.vue?vue&type=template&id=e59be3b4&scoped=true&

// CONCATENATED MODULE: ./src/VuePhoneNumberInput/mixins/StylesHandler.js
/* harmony default export */ var StylesHandler = ({
  props: {
    theme: {
      type: Object,
      required: true
    }
  },
  computed: {
    labelColorStyle: function labelColorStyle() {
      if (this.error) return this.theme.errorColor;else if (this.valid) return this.theme.validColor;else if (this.isFocus) return this.theme.color;else if (this.dark) return this.theme.textDarkColor;
      return null;
    },
    inputBorderStyle: function inputBorderStyle() {
      if (this.error) return this.theme.borderErrorColor;else if (this.valid) return this.theme.borderValidColor;else if (this.isHover || this.isFocus) return this.theme.borderColor;
      return null;
    },
    inputBoxShadowStyle: function inputBoxShadowStyle() {
      if (this.isFocus) {
        if (this.error) return this.theme.boxShadowError;else if (this.valid) return this.theme.boxShadowValid;
        return this.theme.boxShadowColor;
      }

      return null;
    },
    inputBgColor: function inputBgColor() {
      return !this.dark ? null : this.theme.bgDarkColor;
    },
    textColor: function textColor() {
      return this.dark ? this.theme.textDarkColor : null;
    },
    inputCaretStyle: function inputCaretStyle() {
      return {
        caretColor: this.theme.colorValue
      };
    },
    radiusStyle: function radiusStyle() {
      return this.theme.borderRadius;
    },
    radiusLeftStyle: function radiusLeftStyle() {
      return this.theme.borderLeftRadius;
    },
    radiusRightStyle: function radiusRightStyle() {
      return this.theme.borderRightRadius;
    },
    bgItemSelectedStyle: function bgItemSelectedStyle() {
      return this.theme.bgColor;
    },
    loaderBgColor: function loaderBgColor() {
      return this.theme.bgColor;
    }
  }
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/VuePhoneNumberInput/InputTel/index.vue?vue&type=script&lang=js&

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ var InputTelvue_type_script_lang_js_ = ({
  name: 'InputTel',
  mixins: [StylesHandler],
  props: {
    value: {
      type: [String, Number],
      default: null
    },
    label: {
      type: String,
      default: 'Enter text'
    },
    hint: {
      type: String,
      default: null
    },
    error: {
      type: Boolean,
      default: Boolean
    },
    disabled: {
      type: Boolean,
      default: false
    },
    dark: {
      type: Boolean,
      default: false
    },
    id: {
      type: String,
      default: 'InputTel'
    },
    size: {
      type: String,
      default: null
    },
    type: {
      type: String,
      default: 'tel'
    },
    readonly: {
      type: Boolean,
      default: false
    },
    valid: {
      type: Boolean,
      default: false
    },
    required: {
      type: Boolean,
      default: false
    },
    loader: {
      type: Boolean,
      default: false
    },
    clearable: {
      type: Boolean,
      default: false
    },
    noCountrySelector: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      isFocus: false,
      isHover: false
    };
  },
  computed: {
    inputValue: {
      get: function get() {
        return this.value;
      },
      set: function set(value) {
        this.$emit('input', value);
      }
    },
    labelValue: function labelValue() {
      var label = this.label;
      return this.required && label ? "".concat(label, " *") : label;
    },
    hintValue: function hintValue() {
      var hint = this.hint;
      return this.required && hint ? "".concat(hint, " *") : hint;
    }
  },
  methods: {
    updateHoverState: function updateHoverState(value) {
      this.isHover = value;
    },
    focusInput: function focusInput() {
      this.$refs.InputTel.focus();
    },
    onFocus: function onFocus() {
      this.$emit('focus');
      this.isFocus = true;
    },
    onBlur: function onBlur() {
      this.$emit('blur');
      this.isFocus = false;
    },
    clear: function clear() {
      this.$emit('input', null);
      this.$emit('clear');
    },
    keyUp: function keyUp(e) {
      this.$emit('keyup', e);
    },
    keyDown: function keyDown(e) {
      this.$emit('keydown', e);
    }
  }
});
// CONCATENATED MODULE: ./src/VuePhoneNumberInput/InputTel/index.vue?vue&type=script&lang=js&
 /* harmony default export */ var VuePhoneNumberInput_InputTelvue_type_script_lang_js_ = (InputTelvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/VuePhoneNumberInput/InputTel/index.vue?vue&type=style&index=0&id=e59be3b4&lang=scss&scoped=true&
var InputTelvue_type_style_index_0_id_e59be3b4_lang_scss_scoped_true_ = __nested_webpack_require_216376__("b8ac");

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

// CONCATENATED MODULE: ./src/VuePhoneNumberInput/InputTel/index.vue






/* normalize component */

var component = normalizeComponent(
  VuePhoneNumberInput_InputTelvue_type_script_lang_js_,
  InputTelvue_type_template_id_e59be3b4_scoped_true_render,
  InputTelvue_type_template_id_e59be3b4_scoped_true_staticRenderFns,
  false,
  null,
  "e59be3b4",
  null
  
)

/* harmony default export */ var InputTel = (component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e3879104-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/VuePhoneNumberInput/CountrySelector/index.vue?vue&type=template&id=46e105de&scoped=true&
var CountrySelectorvue_type_template_id_46e105de_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"parent",staticClass:"country-selector",class:[{
    'is-focused': _vm.isFocus,
    'has-value': _vm.value,
    'has-hint': _vm.hint,
    'has-error': _vm.error,
    'is-disabled': _vm.disabled,
    'is-dark': _vm.dark,
    'no-flags': _vm.noFlags,
    'has-list-open': _vm.hasListOpen,
    'is-valid': _vm.valid
  }, _vm.size],on:{"!blur":function($event){return _vm.handleBlur($event)},"mouseenter":function($event){return _vm.updateHoverState(true)},"mouseleave":function($event){return _vm.updateHoverState(false)}}},[(_vm.value && !_vm.noFlags)?_c('div',{staticClass:"country-selector__country-flag",on:{"click":function($event){$event.stopPropagation();return _vm.toggleList($event)}}},[_c('div',{class:("iti-flag-small iti-flag " + (_vm.value.toLowerCase()))})]):_vm._e(),_c('input',{ref:"CountrySelector",staticClass:"country-selector__input",style:([_vm.radiusLeftStyle, _vm.inputBorderStyle, _vm.inputBoxShadowStyle, _vm.inputBgColor]),attrs:{"id":_vm.id,"placeholder":_vm.label,"disabled":_vm.disabled,"readonly":""},domProps:{"value":_vm.callingCode},on:{"focus":function($event){_vm.isFocus = true},"keydown":_vm.keyboardNav,"click":function($event){$event.stopPropagation();return _vm.toggleList($event)}}}),_c('div',{staticClass:"country-selector__toggle",on:{"click":function($event){$event.stopPropagation();return _vm.toggleList($event)}}},[_vm._t("arrow",[_c('svg',{staticClass:"country-selector__toggle__arrow",attrs:{"mlns":"http://www.w3.org/2000/svg","width":"24","height":"24","viewBox":"0 0 24 24"}},[_c('path',{staticClass:"arrow",attrs:{"d":"M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"}}),_c('path',{attrs:{"fill":"none","d":"M0 0h24v24H0V0z"}})])])],2),_c('label',{ref:"label",staticClass:"country-selector__label",style:([_vm.labelColorStyle]),on:{"click":function($event){$event.stopPropagation();return _vm.toggleList($event)}}},[_vm._v(" "+_vm._s(_vm.hint || _vm.label)+" ")]),_c('Transition',{attrs:{"name":"slide"}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.hasListOpen),expression:"hasListOpen"}],ref:"countriesList",staticClass:"country-selector__list",class:{ 'has-calling-code': _vm.showCodeOnList },style:([_vm.radiusStyle, _vm.listHeight, _vm.inputBgColor])},[_c('RecycleScroller',{attrs:{"items":_vm.countriesSorted,"item-size":1,"key-field":"iso2"},scopedSlots:_vm._u([{key:"default",fn:function(ref){
  var item = ref.item;
return [_c('button',{key:("item-" + (item.code)),staticClass:"flex align-center country-selector__list__item",class:[
            { 'selected': _vm.value === item.iso2 },
            { 'keyboard-selected': _vm.value !== item.iso2 && _vm.tmpValue === item.iso2 }
          ],style:([
            _vm.itemHeight,
            _vm.value === item.iso2 ? _vm.bgItemSelectedStyle : null
          ]),attrs:{"tabindex":"-1","type":"button"},on:{"click":function($event){$event.stopPropagation();return _vm.updateValue(item.iso2)}}},[(!_vm.noFlags)?_c('div',{staticClass:"country-selector__list__item__flag-container"},[_c('div',{class:("iti-flag-small iti-flag " + (item.iso2.toLowerCase()))})]):_vm._e(),(_vm.showCodeOnList)?_c('span',{staticClass:"country-selector__list__item__calling-code flex-fixed"},[_vm._v("+"+_vm._s(item.dialCode))]):_vm._e(),_c('div',{staticClass:"dots-text"},[_vm._v(" "+_vm._s(item.name)+" ")])])]}}])})],1)])],1)}
var CountrySelectorvue_type_template_id_46e105de_scoped_true_staticRenderFns = []


// CONCATENATED MODULE: ./src/VuePhoneNumberInput/CountrySelector/index.vue?vue&type=template&id=46e105de&scoped=true&

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.function.name.js
var es6_function_name = __nested_webpack_require_216376__("7f7f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.starts-with.js
var es6_string_starts_with = __nested_webpack_require_216376__("f559");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.find-index.js
var es6_array_find_index = __nested_webpack_require_216376__("20d6");

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/array/is-array.js
var is_array = __nested_webpack_require_216376__("a745");
var is_array_default = /*#__PURE__*/__nested_webpack_require_216376__.n(is_array);

// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/arrayWithoutHoles.js


function _arrayWithoutHoles(arr) {
  if (is_array_default()(arr)) return _arrayLikeToArray(arr);
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/array/from.js
var from = __nested_webpack_require_216376__("774e");
var from_default = /*#__PURE__*/__nested_webpack_require_216376__.n(from);

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/is-iterable.js
var is_iterable = __nested_webpack_require_216376__("c8bb");
var is_iterable_default = /*#__PURE__*/__nested_webpack_require_216376__.n(is_iterable);

// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs2/core-js/symbol.js
var symbol = __nested_webpack_require_216376__("67bb");
var symbol_default = /*#__PURE__*/__nested_webpack_require_216376__.n(symbol);

// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/iterableToArray.js



function _iterableToArray(iter) {
  if (typeof symbol_default.a !== "undefined" && is_iterable_default()(Object(iter))) return from_default()(iter);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/unsupportedIterableToArray.js


function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return from_default()(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime-corejs2/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.find.js
var es6_array_find = __nested_webpack_require_216376__("7514");

// EXTERNAL MODULE: ./node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.esm.js
var vue_virtual_scroller_esm = __nested_webpack_require_216376__("e508");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/VuePhoneNumberInput/CountrySelector/index.vue?vue&type=script&lang=js&










//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ var CountrySelectorvue_type_script_lang_js_ = ({
  name: 'CountrySelector',
  components: {
    RecycleScroller: vue_virtual_scroller_esm["a" /* RecycleScroller */]
  },
  mixins: [StylesHandler],
  props: {
    id: {
      type: String,
      default: 'CountrySelector'
    },
    value: {
      type: [String, Object],
      default: null
    },
    label: {
      type: String,
      default: 'Choose country'
    },
    hint: {
      type: String,
      default: String
    },
    size: {
      type: String,
      default: String
    },
    error: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    valid: {
      type: Boolean,
      default: false
    },
    dark: {
      type: Boolean,
      default: false
    },
    items: {
      type: Array,
      default: Array,
      required: true
    },
    preferredCountries: {
      type: Array,
      default: null
    },
    onlyCountries: {
      type: Array,
      default: null
    },
    ignoredCountries: {
      type: Array,
      default: null
    },
    noFlags: {
      type: Boolean,
      default: false
    },
    countriesHeight: {
      type: Number,
      default: 35
    },
    showCodeOnList: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      isFocus: false,
      hasListOpen: false,
      selectedIndex: null,
      tmpValue: this.value,
      query: '',
      indexItemToShow: 0,
      isHover: false
    };
  },
  computed: {
    itemHeight: function itemHeight() {
      return {
        height: "".concat(this.countriesHeight, "px")
      };
    },
    listHeight: function listHeight() {
      return {
        height: "".concat((this.countriesHeight + 1) * 7, "px"),
        maxHeight: "".concat((this.countriesHeight + 1) * 7, "px")
      };
    },
    countriesList: function countriesList() {
      var _this = this;

      return this.items.filter(function (item) {
        return !_this.ignoredCountries.includes(item.iso2);
      });
    },
    countriesFiltered: function countriesFiltered() {
      var _this2 = this;

      var countries = this.onlyCountries || this.preferredCountries;
      return countries.map(function (country) {
        return _this2.countriesList.find(function (item) {
          return item.iso2.includes(country);
        });
      });
    },
    otherCountries: function otherCountries() {
      var _this3 = this;

      return this.countriesList.filter(function (item) {
        return !_this3.preferredCountries.includes(item.iso2);
      });
    },
    countriesSorted: function countriesSorted() {
      return this.preferredCountries ? [].concat(_toConsumableArray(this.countriesFiltered), _toConsumableArray(this.otherCountries)) : this.onlyCountries ? this.countriesFiltered : this.countriesList;
    },
    selectedValueIndex: function selectedValueIndex() {
      var _this4 = this;

      return this.value ? this.countriesSorted.findIndex(function (c) {
        return c.iso2 === _this4.value;
      }) : null;
    },
    tmpValueIndex: function tmpValueIndex() {
      var _this5 = this;

      return this.countriesSorted.findIndex(function (c) {
        return c.iso2 === _this5.tmpValue;
      });
    },
    callingCode: function callingCode() {
      return this.value ? "+".concat(index_es6_getCountryCallingCode(this.value)) : null;
    }
  },
  methods: {
    updateHoverState: function updateHoverState(value) {
      this.isHover = value;
    },
    handleBlur: function handleBlur(e) {
      if (this.$el.contains(e.relatedTarget)) return;
      this.isFocus = false;
      this.closeList();
    },
    toggleList: function toggleList() {
      this.$refs.countriesList.offsetParent ? this.closeList() : this.openList();
    },
    openList: function openList() {
      if (!this.disabled) {
        this.$refs.CountrySelector.focus();
        this.$emit('open');
        this.isFocus = true;
        this.hasListOpen = true;
        if (this.value) this.scrollToSelectedOnFocus(this.selectedValueIndex);
      }
    },
    closeList: function closeList() {
      this.$emit('close');
      this.hasListOpen = false;
    },
    updateValue: function () {
      var _updateValue = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(val) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.tmpValue = val;
                this.$emit('input', val || null);
                _context.next = 4;
                return this.$nextTick();

              case 4:
                this.closeList();

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function updateValue(_x) {
        return _updateValue.apply(this, arguments);
      }

      return updateValue;
    }(),
    scrollToSelectedOnFocus: function scrollToSelectedOnFocus(arrayIndex) {
      var _this6 = this;

      this.$nextTick(function () {
        // this.indexItemToShow = arrayIndex - 3
        _this6.$refs.countriesList.scrollTop = arrayIndex * (_this6.countriesHeight + 1) - (_this6.countriesHeight + 1) * 3;
      });
    },
    keyboardNav: function keyboardNav(e) {
      var code = e.keyCode;

      if (code === 40 || code === 38) {
        // arrow up down
        if (e.view && e.view.event) {
          // TODO : It's not compatible with FireFox
          e.view.event.preventDefault();
        }

        if (!this.hasListOpen) this.openList();
        var index = code === 40 ? this.tmpValueIndex + 1 : this.tmpValueIndex - 1;

        if (index === -1 || index >= this.countriesSorted.length) {
          index = index === -1 ? this.countriesSorted.length - 1 : 0;
        }

        this.tmpValue = this.countriesSorted[index].iso2;
        this.scrollToSelectedOnFocus(index);
      } else if (code === 13) {
        // enter
        this.hasListOpen ? this.updateValue(this.tmpValue) : this.openList();
      } else if (code === 27) {
        // escape
        this.closeList();
      } else {
        // typing a country's name
        this.searching(e);
      }
    },
    searching: function searching(e) {
      var _this7 = this;

      var code = e.keyCode;
      clearTimeout(this.queryTimer);
      this.queryTimer = setTimeout(function () {
        _this7.query = '';
      }, 1000);
      var q = String.fromCharCode(code);

      if (code === 8 && this.query !== '') {
        this.query = this.query.substring(0, this.query.length - 1);
      } else if (/[a-zA-Z-e ]/.test(q)) {
        if (!this.hasListOpen) this.openList();
        this.query += e.key;
        var countries = this.preferredCountries ? this.countriesSorted.slice(this.preferredCountries.length) : this.countriesSorted;
        var resultIndex = countries.findIndex(function (c) {
          _this7.tmpValue = c.iso2;
          return c.name.toLowerCase().startsWith(_this7.query);
        });

        if (resultIndex !== -1) {
          this.scrollToSelectedOnFocus(resultIndex + (this.preferredCountries ? this.preferredCountries.length : 0));
        }
      }
    }
  }
});
// CONCATENATED MODULE: ./src/VuePhoneNumberInput/CountrySelector/index.vue?vue&type=script&lang=js&
 /* harmony default export */ var VuePhoneNumberInput_CountrySelectorvue_type_script_lang_js_ = (CountrySelectorvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/VuePhoneNumberInput/CountrySelector/index.vue?vue&type=style&index=0&id=46e105de&lang=scss&scoped=true&
var CountrySelectorvue_type_style_index_0_id_46e105de_lang_scss_scoped_true_ = __nested_webpack_require_216376__("3314");

// CONCATENATED MODULE: ./src/VuePhoneNumberInput/CountrySelector/index.vue






/* normalize component */

var CountrySelector_component = normalizeComponent(
  VuePhoneNumberInput_CountrySelectorvue_type_script_lang_js_,
  CountrySelectorvue_type_template_id_46e105de_scoped_true_render,
  CountrySelectorvue_type_template_id_46e105de_scoped_true_staticRenderFns,
  false,
  null,
  "46e105de",
  null
  
)

/* harmony default export */ var CountrySelector = (CountrySelector_component.exports);
// CONCATENATED MODULE: ./src/VuePhoneNumberInput/assets/locales/index.js
/* harmony default export */ var locales = ({
  countrySelectorLabel: 'Country code',
  countrySelectorError: 'Choose country',
  phoneNumberLabel: 'Phone number',
  example: 'Example:'
});
// EXTERNAL MODULE: ./node_modules/color-transformer-ui/lib/index.min.js
var index_min = __nested_webpack_require_216376__("4883");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/VuePhoneNumberInput/index.vue?vue&type=script&lang=js&












function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function VuePhoneNumberInputvue_type_script_lang_js_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//








var VuePhoneNumberInputvue_type_script_lang_js_getShadowColor = function getShadowColor(color) {
  return Object(index_min["isColorName"])(color) ? Object(index_min["HexToRgba"])(Object(index_min["colorNameToHex"])(color), 0.7) : Object(index_min["HexToRgba"])(color, 0.7);
};

var browserLocale = function browserLocale() {
  if (!window) return null;
  var browserLocale = window.navigator.userLanguage || window.navigator.language;
  var locale = browserLocale ? browserLocale.substr(3, 4).toUpperCase() : null;
  if (locale === '') locale = browserLocale.substr(0, 2).toUpperCase();
  return locale;
};

var VuePhoneNumberInputvue_type_script_lang_js_isCountryAvailable = function isCountryAvailable(locale) {
  return countriesIso.includes(locale);
};

/* harmony default export */ var VuePhoneNumberInputvue_type_script_lang_js_ = ({
  name: 'MazPhoneNumberInput',
  components: {
    InputTel: InputTel,
    CountrySelector: CountrySelector
  },
  props: {
    value: {
      type: String,
      default: null
    },
    id: {
      type: String,
      default: 'MazPhoneNumberInput'
    },
    color: {
      type: String,
      default: 'dodgerblue'
    },
    validColor: {
      type: String,
      default: 'yellowgreen'
    },
    errorColor: {
      type: String,
      default: 'orangered'
    },
    darkColor: {
      type: String,
      default: '#424242'
    },
    disabled: {
      type: Boolean,
      default: false
    },
    defaultCountryCode: {
      type: String,
      default: null
    },
    size: {
      type: String,
      default: null
    },
    preferredCountries: {
      type: Array,
      default: null
    },
    onlyCountries: {
      type: Array,
      default: null
    },
    ignoredCountries: {
      type: Array,
      default: Array
    },
    translations: {
      type: Object,
      default: null
    },
    noValidatorState: {
      type: Boolean,
      default: false
    },
    noFlags: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    noExample: {
      type: Boolean,
      default: false
    },
    required: {
      type: Boolean,
      default: false
    },
    countriesHeight: {
      type: Number,
      default: 30
    },
    noUseBrowserLocale: {
      type: Boolean,
      default: false
    },
    fetchCountry: {
      type: Boolean,
      default: false
    },
    noCountrySelector: {
      type: Boolean,
      default: false
    },
    showCodeOnList: {
      type: Boolean,
      default: false
    },
    dark: {
      type: Boolean,
      default: false
    },
    borderRadius: {
      type: Number,
      default: 4
    }
  },
  data: function data() {
    return {
      results: {},
      userLocale: this.defaultCountryCode,
      lastKeyPressed: null
    };
  },
  computed: {
    uniqueId: function uniqueId() {
      return "".concat(this.id, "-").concat(this._uid);
    },
    t: function t() {
      return VuePhoneNumberInputvue_type_script_lang_js_objectSpread({}, locales, {}, this.translations);
    },
    codesCountries: function codesCountries() {
      return countries;
    },
    countryCode: {
      get: function get() {
        return this.userLocale || this.results.countryCode;
      },
      set: function set(newCountry) {
        this.setLocale(newCountry);
        this.$refs.PhoneNumberInput.$el.querySelector('input').focus();
      }
    },
    phoneNumber: {
      get: function get() {
        return this.value;
      },
      set: function set(newPhone) {
        this.emitValues({
          countryCode: this.countryCode,
          phoneNumber: newPhone
        });
      }
    },
    shouldChooseCountry: function shouldChooseCountry() {
      return !this.countryCode && !!this.phoneNumber;
    },
    phoneFormatted: function phoneFormatted() {
      return this.results.formatInternational;
    },
    isValid: function isValid() {
      return this.results.isValid;
    },
    phoneNumberExample: function phoneNumberExample() {
      var phoneNumber = this.countryCode ? index_es6_getExampleNumber(this.countryCode, examples_mobile) : null;
      return phoneNumber ? phoneNumber.formatNational() : null;
    },
    hasEmptyPhone: function hasEmptyPhone() {
      return this.phoneNumber === '' || this.phoneNumber === null;
    },
    hintValue: function hintValue() {
      return this.noExample || !this.phoneNumberExample ? null : this.hasEmptyPhone || this.isValid ? null : "".concat(this.t.example, " ").concat(this.phoneNumberExample);
    },
    theme: function theme() {
      return {
        colorValue: this.color,
        color: {
          color: this.color
        },
        textColor: {
          color: '#747474'
        },
        textDarkColor: {
          color: 'rgba(255, 255, 255, 0.7)'
        },
        validColor: {
          color: this.validColor
        },
        errorColor: {
          color: this.errorColor
        },
        darkColor: {
          color: this.darkColor
        },
        bgColor: {
          backgroundColor: this.color
        },
        bgValidColor: {
          backgroundColor: this.validColor
        },
        bgErrorColor: {
          backgroundColor: this.errorColor
        },
        bgDarkColor: {
          backgroundColor: this.darkColor
        },
        borderColor: {
          borderColor: this.color
        },
        borderValidColor: {
          borderColor: this.validColor
        },
        borderErrorColor: {
          borderColor: this.errorColor
        },
        borderDarkColor: {
          borderColor: this.darkColor
        },
        boxShadowColor: {
          boxShadow: "0 0 0 0.125rem ".concat(VuePhoneNumberInputvue_type_script_lang_js_getShadowColor(this.color))
        },
        boxShadowValid: {
          boxShadow: "0 0 0 0.125rem ".concat(VuePhoneNumberInputvue_type_script_lang_js_getShadowColor(this.validColor))
        },
        boxShadowError: {
          boxShadow: "0 0 0 0.125rem ".concat(VuePhoneNumberInputvue_type_script_lang_js_getShadowColor(this.errorColor))
        },
        borderRadius: {
          borderRadius: "".concat(this.borderRadius, "px")
        },
        borderLeftRadius: {
          borderTopLeftRadius: "".concat(this.borderRadius, "px"),
          borderBottomLeftRadius: "".concat(this.borderRadius, "px")
        },
        borderRightRadius: {
          borderTopRightRadius: "".concat(this.borderRadius, "px"),
          borderBottomRightRadius: "".concat(this.borderRadius, "px")
        }
      };
    }
  },
  watch: {
    defaultCountryCode: function defaultCountryCode(newValue, oldValue) {
      if (newValue === oldValue) return;
      this.setLocale(newValue);
    },
    phoneNumber: {
      handler: function handler(newValue, oldValue) {
        // init component (countryCode & phoneNumber) if phone number is provide
        if (newValue && newValue !== oldValue) {
          var phoneNumber = index_es6_parsePhoneNumberFromString(newValue);

          if (phoneNumber) {
            this.emitValues({
              phoneNumber: phoneNumber.nationalNumber,
              countryCode: this.countryCode ? this.countryCode : phoneNumber.country
            });
          }
        }
      },
      immediate: true
    }
  },
  mounted: function () {
    var _mounted = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              if (this.phoneNumber && this.defaultCountryCode) this.emitValues({
                countryCode: this.defaultCountryCode,
                phoneNumber: this.phoneNumber
              });

              if (!(this.defaultCountryCode && this.fetchCountry)) {
                _context.next = 4;
                break;
              }

              throw new Error('MazPhoneNumberInput: Do not use "fetch-country" and "default-country-code" options in the same time');

            case 4:
              if (!(this.defaultCountryCode && this.noUseBrowserLocale)) {
                _context.next = 6;
                break;
              }

              throw new Error('MazPhoneNumberInput: If you use a "default-country-code", do not use "no-use-browser-locale" options');

            case 6:
              if (!this.defaultCountryCode) {
                _context.next = 8;
                break;
              }

              return _context.abrupt("return");

            case 8:
              this.fetchCountry ? this.fetchCountryCode() : !this.noUseBrowserLocale ? this.setLocale(browserLocale()) : null;
              _context.next = 14;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](0);
              throw new Error(_context.t0);

            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[0, 11]]);
    }));

    function mounted() {
      return _mounted.apply(this, arguments);
    }

    return mounted;
  }(),
  methods: {
    getAsYouTypeFormat: function getAsYouTypeFormat(payload) {
      var countryCode = payload.countryCode,
          phoneNumber = payload.phoneNumber;
      var asYouType = new index_es6_AsYouType(countryCode);
      return phoneNumber ? asYouType.input(phoneNumber) : null;
    },
    getParsePhoneNumberFromString: function getParsePhoneNumberFromString(_ref) {
      var phoneNumber = _ref.phoneNumber,
          countryCode = _ref.countryCode;
      var parsing = phoneNumber && countryCode ? index_es6_parsePhoneNumberFromString(phoneNumber, countryCode) : null;
      return VuePhoneNumberInputvue_type_script_lang_js_objectSpread({
        countryCode: countryCode,
        isValid: false
      }, phoneNumber && phoneNumber !== '' ? {
        phoneNumber: phoneNumber
      } : null, {}, parsing ? {
        countryCallingCode: parsing.countryCallingCode,
        formattedNumber: parsing.number,
        nationalNumber: parsing.nationalNumber,
        isValid: parsing.isValid(),
        type: parsing.getType(),
        formatInternational: parsing.formatInternational(),
        formatNational: parsing.formatNational(),
        uri: parsing.getURI(),
        e164: parsing.format('E.164')
      } : null);
    },
    emitValues: function emitValues(payload) {
      var _this = this;

      var asYouType = this.getAsYouTypeFormat(payload);
      var backSpacePressed = this.lastKeyPressed === 8;
      this.$nextTick(function () {
        var lastCharacOfPhoneNumber = _this.phoneNumber ? _this.phoneNumber.trim().slice(-1) : false;

        if (backSpacePressed && lastCharacOfPhoneNumber && lastCharacOfPhoneNumber.slice(-1) === ')') {
          asYouType = _this.phoneNumber.slice(0, -2);
          payload.phoneNumber = _this.phoneNumber.slice(0, -2);
        }

        _this.results = _this.getParsePhoneNumberFromString(payload);

        _this.$emit('update', _this.results);

        _this.$emit('input', asYouType);
      });
    },
    setLocale: function setLocale(locale) {
      var countryAvailable = VuePhoneNumberInputvue_type_script_lang_js_isCountryAvailable(locale);

      if (countryAvailable && locale) {
        this.userLocale = countryAvailable ? locale : null;
        this.emitValues({
          countryCode: locale,
          phoneNumber: this.phoneNumber
        });
      } else if (!countryAvailable && locale) {
        window.console.warn("The locale ".concat(locale, " is not available"));
      }
    },
    fetchCountryCode: function () {
      var _fetchCountryCode = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var response, responseText, result;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return fetch('https://ip2c.org/s');

              case 3:
                response = _context2.sent;
                _context2.next = 6;
                return response.text();

              case 6:
                responseText = _context2.sent;
                result = (responseText || '').toString();
                if (result && result[0] === '1') this.setLocale(result.substr(2, 2));
                _context2.next = 14;
                break;

              case 11:
                _context2.prev = 11;
                _context2.t0 = _context2["catch"](0);
                throw new Error(_context2.t0);

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 11]]);
      }));

      function fetchCountryCode() {
        return _fetchCountryCode.apply(this, arguments);
      }

      return fetchCountryCode;
    }()
  }
});
// CONCATENATED MODULE: ./src/VuePhoneNumberInput/index.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_VuePhoneNumberInputvue_type_script_lang_js_ = (VuePhoneNumberInputvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/VuePhoneNumberInput/index.vue?vue&type=style&index=0&id=19c9a1c7&lang=scss&scoped=true&
var VuePhoneNumberInputvue_type_style_index_0_id_19c9a1c7_lang_scss_scoped_true_ = __nested_webpack_require_216376__("6996");

// CONCATENATED MODULE: ./src/VuePhoneNumberInput/index.vue






/* normalize component */

var VuePhoneNumberInput_component = normalizeComponent(
  src_VuePhoneNumberInputvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  "19c9a1c7",
  null
  
)

/* harmony default export */ var VuePhoneNumberInput = (VuePhoneNumberInput_component.exports);
// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = __webpack_exports__["default"] = (VuePhoneNumberInput);



/***/ }),

/***/ "fdef":
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ })

/******/ })["default"];
//# sourceMappingURL=vue-phone-number-input.common.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY2hhcnRpc3QtcGx1Z2luLXRvb2x0aXBzX2Rpc3RfY2hhcnRpc3QtcGx1Z2luLXRvb2x0aXBfanMtbm9kZV9tb2R1bGVzX2NvLWY2MWNjNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sQ0FBQywrRUFBVSxDQUFDLG1DQUFFO0FBQ3pCO0FBQ0EsS0FBSztBQUFBLGtHQUFDO0FBQ04sSUFBSSxLQUFLLEVBT047QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLHVFQUF1RSxFQUFFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxDQUFDLFNBQVMscUJBQU07QUFDaEIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsUUFBUTtBQUNyQixjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsU0FBUztBQUN0QixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQSxDQUFDLFNBQVMscUJBQU07QUFDaEIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxDQUFDLFNBQVMscUJBQU07QUFDaEIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsQ0FBQyxTQUFTLHFCQUFNO0FBQ2hCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxDQUFDLFNBQVMscUJBQU07QUFDaEIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnSEFBZ0g7QUFDaEg7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLHFIQUFxSDtBQUNySDtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsQ0FBQyxTQUFTLHFCQUFNO0FBQ2hCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRyxXQUFXO0FBQ3ZCLE9BQU87O0FBRVA7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUk7QUFDbkk7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1IsMElBQTBJO0FBQzFJO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLG1JQUFtSTtBQUNuSTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUiwwSUFBMEk7QUFDMUk7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsQ0FBQyxTQUFTLHFCQUFNO0FBQ2hCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7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QVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxPQUFPO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQ7QUFDN0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFlBQVk7O0FBRVo7QUFDQSwwQkFBMEI7O0FBRTFCLG9EQUFvRDs7QUFFcEQsNkJBQTZCLDhEQUE4RDtBQUMzRjs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1IsNENBQTRDLFVBQVU7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrRkFBa0Y7O0FBRWxGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxzRUFBc0U7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7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QUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG1HQUFtRztBQUNwSyw0RUFBNEUsYUFBYSwwQkFBMEIsd0JBQXdCLGlCQUFpQjtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0JBQWdCLHFEQUFxRCxrQ0FBa0MsK0JBQStCLHFDQUFxQywrQ0FBK0MsYUFBYSw4RUFBOEUsd0RBQXdELDhDQUE4QztBQUM5WjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJHQUEyRyxXQUFXLHdGQUF3RixLQUFLLHVHQUF1RyxrQ0FBa0MsMkJBQTJCLDBFQUEwRSx1QkFBdUIsaUNBQWlDLGlCQUFpQiwwQ0FBMEMsS0FBSyxvRUFBb0UsS0FBSyxzQkFBc0Isc0VBQXNFLGFBQWEsOEVBQThFLHdEQUF3RCw4Q0FBOEM7QUFDNzZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0dBQXdHLFdBQVcsc0NBQXNDLEtBQUssdUdBQXVHLGtDQUFrQywyQkFBMkIsc0JBQXNCLCtDQUErQyxhQUFhLDhFQUE4RSx3REFBd0QsOENBQThDO0FBQ3RsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlHQUF5RyxXQUFXLHlCQUF5QixLQUFLLHVHQUF1RyxrQ0FBa0MsMEJBQTBCLDZCQUE2QixTQUFTLHFDQUFxQyx3Q0FBd0MsdUhBQXVILGFBQWEsS0FBSyx3QkFBd0IsMkdBQTJHLHNDQUFzQyxnREFBZ0QsS0FBSyxtQkFBbUIsYUFBYSx1Q0FBdUMsK0RBQStELGdDQUFnQyxZQUFZLDBFQUEwRTtBQUN6aEM7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtREFBbUQsa0RBQWtELCtDQUErQztBQUNwSjtBQUNBLEtBQUs7QUFDTDtBQUNBLHlEQUF5RCx3REFBd0Q7QUFDakg7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsaUNBQW1COztBQUUzRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNCQUFzQjtBQUN0QjtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxpQ0FBbUI7O0FBRWxHOzs7Ozs7O0FBT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnQkFBZ0IsaUNBQW1COztBQUVuQzs7Ozs7Ozs7Ozs7OztBQWFBLDJDQUEyQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw4REFBOEQsaUVBQWlFLEdBQUcsa0NBQWtDOztBQUV2VSwyRUFBMkUsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLCtDQUErQyw0Q0FBNEMsS0FBSyw2Q0FBNkMsNkVBQTZFLE9BQU8seUNBQXlDLG1GQUFtRixPQUFPOztBQUVoaUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsUUFBUSxVQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsaUNBQW1COztBQUV0Rzs7Ozs7OztBQU9BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7O0FBSUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVAsVUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoYXJ0aXN0LXBsdWdpbi10b29sdGlwcy9kaXN0L2NoYXJ0aXN0LXBsdWdpbi10b29sdGlwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGFydGlzdC9kaXN0L2NoYXJ0aXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItY2xvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21hdGgtc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXRoLnNpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1jaGFydGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWNsaWNrLW91dHNpZGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1lbGxpcHNlLXByb2dyZXNzL2Rpc3QvdnVlLWVsbGlwc2UtcHJvZ3Jlc3MudW1kLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXBob25lLW51bWJlci1pbnB1dC9kaXN0L3Z1ZS1waG9uZS1udW1iZXItaW5wdXQuY29tbW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbXCJjaGFydGlzdFwiXSwgZnVuY3Rpb24gKENoYXJ0aXN0KSB7XG4gICAgICByZXR1cm4gKHJvb3QucmV0dXJuRXhwb3J0c0dsb2JhbCA9IGZhY3RvcnkoQ2hhcnRpc3QpKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgIC8vIGxpa2UgTm9kZS5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImNoYXJ0aXN0XCIpKTtcbiAgfSBlbHNlIHtcbiAgICByb290WydDaGFydGlzdC5wbHVnaW5zLnRvb2x0aXBzJ10gPSBmYWN0b3J5KENoYXJ0aXN0KTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAoQ2hhcnRpc3QpIHtcblxuICAvKipcbiAgICogQ2hhcnRpc3QuanMgcGx1Z2luIHRvIGRpc3BsYXkgYSBkYXRhIGxhYmVsIG9uIHRvcCBvZiB0aGUgcG9pbnRzIGluIGEgbGluZSBjaGFydC5cbiAgICpcbiAgICovXG4gIC8qIGdsb2JhbCBDaGFydGlzdCAqL1xuICAoZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIENoYXJ0aXN0KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgY3VycmVuY3k6IHVuZGVmaW5lZCxcbiAgICAgIGN1cnJlbmN5Rm9ybWF0Q2FsbGJhY2s6IHVuZGVmaW5lZCxcbiAgICAgIHRvb2x0aXBPZmZzZXQ6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogLTIwXG4gICAgICB9LFxuICAgICAgYW5jaG9yVG9Qb2ludDogZmFsc2UsXG4gICAgICBhcHBlbmRUb0JvZHk6IGZhbHNlLFxuICAgICAgY2xhc3M6IHVuZGVmaW5lZCxcbiAgICAgIHBvaW50Q2xhc3M6ICdjdC1wb2ludCdcbiAgICB9O1xuXG4gICAgQ2hhcnRpc3QucGx1Z2lucyA9IENoYXJ0aXN0LnBsdWdpbnMgfHwge307XG4gICAgQ2hhcnRpc3QucGx1Z2lucy50b29sdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBDaGFydGlzdC5leHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRvb2x0aXAoY2hhcnQpIHtcbiAgICAgICAgdmFyIHRvb2x0aXBTZWxlY3RvciA9IG9wdGlvbnMucG9pbnRDbGFzcztcbiAgICAgICAgaWYgKGNoYXJ0IGluc3RhbmNlb2YgQ2hhcnRpc3QuQmFyKSB7XG4gICAgICAgICAgdG9vbHRpcFNlbGVjdG9yID0gJ2N0LWJhcic7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhcnQgaW5zdGFuY2VvZiBDaGFydGlzdC5QaWUpIHtcbiAgICAgICAgICAvLyBBZGRlZCBzdXBwb3J0IGZvciBkb251dCBncmFwaFxuICAgICAgICAgIGlmIChjaGFydC5vcHRpb25zLmRvbnV0KSB7XG4gICAgICAgICAgICB0b29sdGlwU2VsZWN0b3IgPSAnY3Qtc2xpY2UtZG9udXQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b29sdGlwU2VsZWN0b3IgPSAnY3Qtc2xpY2UtcGllJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgJGNoYXJ0ID0gY2hhcnQuY29udGFpbmVyO1xuICAgICAgICB2YXIgJHRvb2xUaXAgPSAkY2hhcnQucXVlcnlTZWxlY3RvcignLmNoYXJ0aXN0LXRvb2x0aXAnKTtcbiAgICAgICAgaWYgKCEkdG9vbFRpcCkge1xuICAgICAgICAgICR0b29sVGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgJHRvb2xUaXAuY2xhc3NOYW1lID0gKCFvcHRpb25zLmNsYXNzKSA/ICdjaGFydGlzdC10b29sdGlwJyA6ICdjaGFydGlzdC10b29sdGlwICcgKyBvcHRpb25zLmNsYXNzO1xuICAgICAgICAgIGlmICghb3B0aW9ucy5hcHBlbmRUb0JvZHkpIHtcbiAgICAgICAgICAgICRjaGFydC5hcHBlbmRDaGlsZCgkdG9vbFRpcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoJHRvb2xUaXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVpZ2h0ID0gJHRvb2xUaXAub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSAkdG9vbFRpcC5vZmZzZXRXaWR0aDtcblxuICAgICAgICBoaWRlKCR0b29sVGlwKTtcblxuICAgICAgICBmdW5jdGlvbiBvbihldmVudCwgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgJGNoYXJ0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yIHx8IGhhc0NsYXNzKGUudGFyZ2V0LCBzZWxlY3RvcikpXG4gICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgb24oJ21vdXNlb3ZlcicsIHRvb2x0aXBTZWxlY3RvciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgdmFyICRwb2ludCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICB2YXIgdG9vbHRpcFRleHQgPSAnJztcblxuICAgICAgICAgIHZhciBpc1BpZUNoYXJ0ID0gKGNoYXJ0IGluc3RhbmNlb2YgQ2hhcnRpc3QuUGllKSA/ICRwb2ludCA6ICRwb2ludC5wYXJlbnROb2RlO1xuICAgICAgICAgIHZhciBzZXJpZXNOYW1lID0gKGlzUGllQ2hhcnQpID8gJHBvaW50LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdjdDptZXRhJykgfHwgJHBvaW50LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdjdDpzZXJpZXMtbmFtZScpIDogJyc7XG4gICAgICAgICAgdmFyIG1ldGEgPSAkcG9pbnQuZ2V0QXR0cmlidXRlKCdjdDptZXRhJykgfHwgc2VyaWVzTmFtZSB8fCAnJztcbiAgICAgICAgICB2YXIgaGFzTWV0YSA9ICEhbWV0YTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkcG9pbnQuZ2V0QXR0cmlidXRlKCdjdDp2YWx1ZScpO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMudHJhbnNmb3JtVG9vbHRpcFRleHRGbmMgJiYgdHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtVG9vbHRpcFRleHRGbmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gb3B0aW9ucy50cmFuc2Zvcm1Ub29sdGlwVGV4dEZuYyh2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcEZuYyAmJiB0eXBlb2Ygb3B0aW9ucy50b29sdGlwRm5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0b29sdGlwVGV4dCA9IG9wdGlvbnMudG9vbHRpcEZuYyhtZXRhLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGFJc0hUTUwpIHtcbiAgICAgICAgICAgICAgdmFyIHR4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgICAgICAgICAgIHR4dC5pbm5lckhUTUwgPSBtZXRhO1xuICAgICAgICAgICAgICBtZXRhID0gdHh0LnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZXRhID0gJzxzcGFuIGNsYXNzPVwiY2hhcnRpc3QtdG9vbHRpcC1tZXRhXCI+JyArIG1ldGEgKyAnPC9zcGFuPic7XG5cbiAgICAgICAgICAgIGlmIChoYXNNZXRhKSB7XG4gICAgICAgICAgICAgIHRvb2x0aXBUZXh0ICs9IG1ldGEgKyAnPGJyPic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBGb3IgUGllIENoYXJ0cyBhbHNvIHRha2UgdGhlIGxhYmVscyBpbnRvIGFjY291bnRcbiAgICAgICAgICAgICAgLy8gQ291bGQgYWRkIHN1cHBvcnQgZm9yIG1vcmUgY2hhcnRzIGhlcmUgYXMgd2VsbCFcbiAgICAgICAgICAgICAgaWYgKGNoYXJ0IGluc3RhbmNlb2YgQ2hhcnRpc3QuUGllKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gbmV4dCgkcG9pbnQsICdjdC1sYWJlbCcpO1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgdG9vbHRpcFRleHQgKz0gdGV4dChsYWJlbCkgKyAnPGJyPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmN1cnJlbmN5Rm9ybWF0Q2FsbGJhY2sgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9wdGlvbnMuY3VycmVuY3lGb3JtYXRDYWxsYmFjayh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gb3B0aW9ucy5jdXJyZW5jeSArIHZhbHVlLnJlcGxhY2UoLyhcXGQpKD89KFxcZHszfSkrKD86XFwuXFxkKyk/JCkvZywgJyQxLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YWx1ZSA9ICc8c3BhbiBjbGFzcz1cImNoYXJ0aXN0LXRvb2x0aXAtdmFsdWVcIj4nICsgdmFsdWUgKyAnPC9zcGFuPic7XG4gICAgICAgICAgICAgIHRvb2x0aXBUZXh0ICs9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKHRvb2x0aXBUZXh0KSB7XG4gICAgICAgICAgICAkdG9vbFRpcC5pbm5lckhUTUwgPSB0b29sdGlwVGV4dDtcbiAgICAgICAgICAgIHNldFBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgIHNob3coJHRvb2xUaXApO1xuXG4gICAgICAgICAgICAvLyBSZW1lbWJlciBoZWlnaHQgYW5kIHdpZHRoIHRvIGF2b2lkIHdyb25nIHBvc2l0aW9uIGluIElFXG4gICAgICAgICAgICBoZWlnaHQgPSAkdG9vbFRpcC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9ICR0b29sVGlwLm9mZnNldFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgb24oJ21vdXNlb3V0JywgdG9vbHRpcFNlbGVjdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaGlkZSgkdG9vbFRpcCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9uKCdtb3VzZW1vdmUnLCBudWxsLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZmFsc2UgPT09IG9wdGlvbnMuYW5jaG9yVG9Qb2ludClcbiAgICAgICAgICAgIHNldFBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0UG9zaXRpb24oZXZlbnQpIHtcbiAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgJHRvb2xUaXAub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIHdpZHRoID0gd2lkdGggfHwgJHRvb2xUaXAub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgdmFyIG9mZnNldFggPSAtIHdpZHRoIC8gMiArIG9wdGlvbnMudG9vbHRpcE9mZnNldC54XG4gICAgICAgICAgdmFyIG9mZnNldFkgPSAtIGhlaWdodCArIG9wdGlvbnMudG9vbHRpcE9mZnNldC55O1xuICAgICAgICAgIHZhciBhbmNob3JYLCBhbmNob3JZO1xuXG4gICAgICAgICAgaWYgKCFvcHRpb25zLmFwcGVuZFRvQm9keSkge1xuICAgICAgICAgICAgdmFyIGJveCA9ICRjaGFydC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gZXZlbnQucGFnZVggLSBib3gubGVmdCAtIHdpbmRvdy5wYWdlWE9mZnNldCA7XG4gICAgICAgICAgICB2YXIgdG9wID0gZXZlbnQucGFnZVkgLSBib3gudG9wIC0gd2luZG93LnBhZ2VZT2Zmc2V0IDtcblxuICAgICAgICAgICAgaWYgKHRydWUgPT09IG9wdGlvbnMuYW5jaG9yVG9Qb2ludCAmJiBldmVudC50YXJnZXQueDIgJiYgZXZlbnQudGFyZ2V0LnkyKSB7XG4gICAgICAgICAgICAgIGFuY2hvclggPSBwYXJzZUludChldmVudC50YXJnZXQueDIuYmFzZVZhbC52YWx1ZSk7XG4gICAgICAgICAgICAgIGFuY2hvclkgPSBwYXJzZUludChldmVudC50YXJnZXQueTIuYmFzZVZhbC52YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICR0b29sVGlwLnN0eWxlLnRvcCA9IChhbmNob3JZIHx8IHRvcCkgKyBvZmZzZXRZICsgJ3B4JztcbiAgICAgICAgICAgICR0b29sVGlwLnN0eWxlLmxlZnQgPSAoYW5jaG9yWCB8fCBsZWZ0KSArIG9mZnNldFggKyAncHgnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkdG9vbFRpcC5zdHlsZS50b3AgPSBldmVudC5wYWdlWSArIG9mZnNldFkgKyAncHgnO1xuICAgICAgICAgICAgJHRvb2xUaXAuc3R5bGUubGVmdCA9IGV2ZW50LnBhZ2VYICsgb2Zmc2V0WCArICdweCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNob3coZWxlbWVudCkge1xuICAgICAgaWYoIWhhc0NsYXNzKGVsZW1lbnQsICd0b29sdGlwLXNob3cnKSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lICsgJyB0b29sdGlwLXNob3cnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhpZGUoZWxlbWVudCkge1xuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgndG9vbHRpcC1zaG93JyArICdcXFxccyonLCAnZ2knKTtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShyZWdleCwgJycpLnRyaW0oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiAoJyAnICsgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSA+IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHQoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5leHRTaWJsaW5nO1xuICAgICAgfSB3aGlsZSAoZWxlbWVudCAmJiAhaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSk7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXh0KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmlubmVyVGV4dCB8fCBlbGVtZW50LnRleHRDb250ZW50O1xuICAgIH1cblxuICB9ICh3aW5kb3csIGRvY3VtZW50LCBDaGFydGlzdCkpO1xuXG4gIHJldHVybiBDaGFydGlzdC5wbHVnaW5zLnRvb2x0aXBzO1xuXG59KSk7XG4iLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSB1bmxlc3MgYW1kTW9kdWxlSWQgaXMgc2V0XG4gICAgZGVmaW5lKCdDaGFydGlzdCcsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHJvb3RbJ0NoYXJ0aXN0J10gPSBmYWN0b3J5KCkpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgLy8gbGlrZSBOb2RlLlxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHJvb3RbJ0NoYXJ0aXN0J10gPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG4vKiBDaGFydGlzdC5qcyAwLjExLjRcbiAqIENvcHlyaWdodCDCqSAyMDE5IEdpb24gS3VuelxuICogRnJlZSB0byB1c2UgdW5kZXIgZWl0aGVyIHRoZSBXVEZQTCBsaWNlbnNlIG9yIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9naW9ua3Vuei9jaGFydGlzdC1qcy9tYXN0ZXIvTElDRU5TRS1XVEZQTFxuICogaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2dpb25rdW56L2NoYXJ0aXN0LWpzL21hc3Rlci9MSUNFTlNFLU1JVFxuICovXG4vKipcbiAqIFRoZSBjb3JlIG1vZHVsZSBvZiBDaGFydGlzdCB0aGF0IGlzIG1haW5seSBwcm92aWRpbmcgc3RhdGljIGZ1bmN0aW9ucyBhbmQgaGlnaGVyIGxldmVsIGZ1bmN0aW9ucyBmb3IgY2hhcnQgbW9kdWxlcy5cbiAqXG4gKiBAbW9kdWxlIENoYXJ0aXN0LkNvcmVcbiAqL1xudmFyIENoYXJ0aXN0ID0ge1xuICB2ZXJzaW9uOiAnMC4xMS40J1xufTtcblxuKGZ1bmN0aW9uIChnbG9iYWxSb290LCBDaGFydGlzdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHdpbmRvdyA9IGdsb2JhbFJvb3Qud2luZG93O1xuICB2YXIgZG9jdW1lbnQgPSBnbG9iYWxSb290LmRvY3VtZW50O1xuXG4gIC8qKlxuICAgKiBUaGlzIG9iamVjdCBjb250YWlucyBhbGwgbmFtZXNwYWNlcyB1c2VkIHdpdGhpbiBDaGFydGlzdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHR5cGUge3tzdmc6IHN0cmluZywgeG1sbnM6IHN0cmluZywgeGh0bWw6IHN0cmluZywgeGxpbms6IHN0cmluZywgY3Q6IHN0cmluZ319XG4gICAqL1xuICBDaGFydGlzdC5uYW1lc3BhY2VzID0ge1xuICAgIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICB4bWxuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJyxcbiAgICB4aHRtbDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLFxuICAgIHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICAgY3Q6ICdodHRwOi8vZ2lvbmt1bnouZ2l0aHViLmNvbS9jaGFydGlzdC1qcy9jdCdcbiAgfTtcblxuICAvKipcbiAgICogSGVscHMgdG8gc2ltcGxpZnkgZnVuY3Rpb25hbCBzdHlsZSBjb2RlXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5Db3JlXG4gICAqIEBwYXJhbSB7Kn0gbiBUaGlzIGV4YWN0IHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgYnkgdGhlIG5vb3AgZnVuY3Rpb25cbiAgICogQHJldHVybiB7Kn0gVGhlIHNhbWUgdmFsdWUgdGhhdCB3YXMgcHJvdmlkZWQgdG8gdGhlIG4gcGFyYW1ldGVyXG4gICAqL1xuICBDaGFydGlzdC5ub29wID0gZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbjtcbiAgfTtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEteiBmcm9tIGEgbnVtYmVyIDAgdG8gMjZcbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG4gQSBudW1iZXIgZnJvbSAwIHRvIDI2IHRoYXQgd2lsbCByZXN1bHQgaW4gYSBsZXR0ZXIgYS16XG4gICAqIEByZXR1cm4ge1N0cmluZ30gQSBjaGFyYWN0ZXIgZnJvbSBhLXogYmFzZWQgb24gdGhlIGlucHV0IG51bWJlciBuXG4gICAqL1xuICBDaGFydGlzdC5hbHBoYU51bWVyYXRlID0gZnVuY3Rpb24gKG4pIHtcbiAgICAvLyBMaW1pdCB0byBhLXpcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5NyArIG4gJSAyNik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpbXBsZSByZWN1cnNpdmUgb2JqZWN0IGV4dGVuZFxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuQ29yZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3Qgd2hlcmUgdGhlIHNvdXJjZSB3aWxsIGJlIG1lcmdlZCBpbnRvXG4gICAqIEBwYXJhbSB7T2JqZWN0Li4ufSBzb3VyY2VzIFRoaXMgb2JqZWN0IChvYmplY3RzKSB3aWxsIGJlIG1lcmdlZCBpbnRvIHRhcmdldCBhbmQgdGhlbiB0YXJnZXQgaXMgcmV0dXJuZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgdGhhdCBoYXMgdGhlIHNhbWUgcmVmZXJlbmNlIGFzIHRhcmdldCBidXQgaXMgZXh0ZW5kZWQgYW5kIG1lcmdlZCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICAgKi9cbiAgQ2hhcnRpc3QuZXh0ZW5kID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBpLCBzb3VyY2UsIHNvdXJjZVByb3A7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHt9O1xuXG4gICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgc291cmNlUHJvcCA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wID09PSAnb2JqZWN0JyAmJiBzb3VyY2VQcm9wICE9PSBudWxsICYmICEoc291cmNlUHJvcCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgIHRhcmdldFtwcm9wXSA9IENoYXJ0aXN0LmV4dGVuZCh0YXJnZXRbcHJvcF0sIHNvdXJjZVByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVByb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2NjdXJyZW5jZXMgb2Ygc3ViU3RyIGluIHN0ciB3aXRoIG5ld1N1YlN0ciBhbmQgcmV0dXJucyBhIG5ldyBzdHJpbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5Db3JlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN1YlN0clxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3U3ViU3RyXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIENoYXJ0aXN0LnJlcGxhY2VBbGwgPSBmdW5jdGlvbihzdHIsIHN1YlN0ciwgbmV3U3ViU3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoc3ViU3RyLCAnZycpLCBuZXdTdWJTdHIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIG51bWJlciB0byBhIHN0cmluZyB3aXRoIGEgdW5pdC4gSWYgYSBzdHJpbmcgaXMgcGFzc2VkIHRoZW4gdGhpcyB3aWxsIGJlIHJldHVybmVkIHVubW9kaWZpZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5Db3JlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdW5pdFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgdGhlIHBhc3NlZCBudW1iZXIgdmFsdWUgd2l0aCB1bml0LlxuICAgKi9cbiAgQ2hhcnRpc3QuZW5zdXJlVW5pdCA9IGZ1bmN0aW9uKHZhbHVlLCB1bml0KSB7XG4gICAgaWYodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSArIHVuaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIG51bWJlciBvciBzdHJpbmcgdG8gYSBxdWFudGl0eSBvYmplY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5Db3JlXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaW5wdXRcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB2YWx1ZSBhcyBudW1iZXIgYW5kIHRoZSB1bml0IGFzIHN0cmluZy5cbiAgICovXG4gIENoYXJ0aXN0LnF1YW50aXR5ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIG1hdGNoID0gKC9eKFxcZCspXFxzKiguKikkL2cpLmV4ZWMoaW5wdXQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUgOiArbWF0Y2hbMV0sXG4gICAgICAgIHVuaXQ6IG1hdGNoWzJdIHx8IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsdWU6IGlucHV0IH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSB3cmFwcGVyIGFyb3VuZCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yIHRoYXQgd2lsbCByZXR1cm4gdGhlIHF1ZXJ5IGlmIGl0J3MgYWxyZWFkeSBvZiB0eXBlIE5vZGVcbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIHtTdHJpbmd8Tm9kZX0gcXVlcnkgVGhlIHF1ZXJ5IHRvIHVzZSBmb3Igc2VsZWN0aW5nIGEgTm9kZSBvciBhIERPTSBub2RlIHRoYXQgd2lsbCBiZSByZXR1cm5lZCBkaXJlY3RseVxuICAgKiBAcmV0dXJuIHtOb2RlfVxuICAgKi9cbiAgQ2hhcnRpc3QucXVlcnlTZWxlY3RvciA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgcmV0dXJuIHF1ZXJ5IGluc3RhbmNlb2YgTm9kZSA/IHF1ZXJ5IDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uYWwgc3R5bGUgaGVscGVyIHRvIHByb2R1Y2UgYXJyYXkgd2l0aCBnaXZlbiBsZW5ndGggaW5pdGlhbGl6ZWQgd2l0aCB1bmRlZmluZWQgdmFsdWVzXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5Db3JlXG4gICAqIEBwYXJhbSBsZW5ndGhcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBDaGFydGlzdC50aW1lcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHJldHVybiBBcnJheS5hcHBseShudWxsLCBuZXcgQXJyYXkobGVuZ3RoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN1bSBoZWxwZXIgdG8gYmUgdXNlZCBpbiByZWR1Y2UgZnVuY3Rpb25zXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5Db3JlXG4gICAqIEBwYXJhbSBwcmV2aW91c1xuICAgKiBAcGFyYW0gY3VycmVudFxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgQ2hhcnRpc3Quc3VtID0gZnVuY3Rpb24ocHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICByZXR1cm4gcHJldmlvdXMgKyAoY3VycmVudCA/IGN1cnJlbnQgOiAwKTtcbiAgfTtcblxuICAvKipcbiAgICogTXVsdGlwbHkgaGVscGVyIHRvIGJlIHVzZWQgaW4gYEFycmF5Lm1hcGAgZm9yIG11bHRpcGx5aW5nIGVhY2ggdmFsdWUgb2YgYW4gYXJyYXkgd2l0aCBhIGZhY3Rvci5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZhY3RvclxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgaW4gYEFycmF5Lm1hcGAgdG8gbXVsdGlwbHkgZWFjaCB2YWx1ZSBpbiBhbiBhcnJheVxuICAgKi9cbiAgQ2hhcnRpc3QubWFwTXVsdGlwbHkgPSBmdW5jdGlvbihmYWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obnVtKSB7XG4gICAgICByZXR1cm4gbnVtICogZmFjdG9yO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBoZWxwZXIgdG8gYmUgdXNlZCBpbiBgQXJyYXkubWFwYCBmb3IgYWRkaW5nIGEgYWRkZW5kIHRvIGVhY2ggdmFsdWUgb2YgYW4gYXJyYXkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5Db3JlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhZGRlbmRcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGluIGBBcnJheS5tYXBgIHRvIGFkZCBhIGFkZGVuZCB0byBlYWNoIHZhbHVlIGluIGFuIGFycmF5XG4gICAqL1xuICBDaGFydGlzdC5tYXBBZGQgPSBmdW5jdGlvbihhZGRlbmQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obnVtKSB7XG4gICAgICByZXR1cm4gbnVtICsgYWRkZW5kO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hcCBmb3IgbXVsdGkgZGltZW5zaW9uYWwgYXJyYXlzIHdoZXJlIHRoZWlyIG5lc3RlZCBhcnJheXMgd2lsbCBiZSBtYXBwZWQgaW4gc2VyaWFsLiBUaGUgb3V0cHV0IGFycmF5IHdpbGwgaGF2ZSB0aGUgbGVuZ3RoIG9mIHRoZSBsYXJnZXN0IG5lc3RlZCBhcnJheS4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHZhcmlhYmxlIGFyZ3VtZW50cyB3aGVyZSBlYWNoIGFyZ3VtZW50IGlzIHRoZSBuZXN0ZWQgYXJyYXkgdmFsdWUgKG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbm8gbW9yZSB2YWx1ZXMpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuQ29yZVxuICAgKiBAcGFyYW0gYXJyXG4gICAqIEBwYXJhbSBjYlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIENoYXJ0aXN0LnNlcmlhbE1hcCA9IGZ1bmN0aW9uKGFyciwgY2IpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGxlbmd0aCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGFyci5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiBlLmxlbmd0aDtcbiAgICAgICAgfSkpO1xuXG4gICAgQ2hhcnRpc3QudGltZXMobGVuZ3RoKS5mb3JFYWNoKGZ1bmN0aW9uKGUsIGluZGV4KSB7XG4gICAgICB2YXIgYXJncyA9IGFyci5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gZVtpbmRleF07XG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0W2luZGV4XSA9IGNiLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBoZWxwZXIgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gcm91bmQgdmFsdWVzIHdpdGggY2VydGFpbiBwcmVjaXNpb24gbGV2ZWwgYWZ0ZXIgZGVjaW1hbC4gVGhpcyBpcyB1c2VkIHRvIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzIG5lYXIgZmxvYXQgcG9pbnQgcHJlY2lzaW9uIGxpbWl0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuQ29yZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHJvdW5kZWQgd2l0aCBwcmVjaXNpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkaWdpdHNdIFRoZSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIGRlY2ltYWwgdXNlZCB0byBkbyB0aGUgcm91bmRpbmdcbiAgICogQHJldHVybnMge251bWJlcn0gUm91bmRlZCB2YWx1ZVxuICAgKi9cbiAgQ2hhcnRpc3Qucm91bmRXaXRoUHJlY2lzaW9uID0gZnVuY3Rpb24odmFsdWUsIGRpZ2l0cykge1xuICAgIHZhciBwcmVjaXNpb24gPSBNYXRoLnBvdygxMCwgZGlnaXRzIHx8IENoYXJ0aXN0LnByZWNpc2lvbik7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcmVjaXNpb24gbGV2ZWwgdXNlZCBpbnRlcm5hbGx5IGluIENoYXJ0aXN0IGZvciByb3VuZGluZy4gSWYgeW91IHJlcXVpcmUgbW9yZSBkZWNpbWFsIHBsYWNlcyB5b3UgY2FuIGluY3JlYXNlIHRoaXMgbnVtYmVyLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuQ29yZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgQ2hhcnRpc3QucHJlY2lzaW9uID0gODtcblxuICAvKipcbiAgICogQSBtYXAgd2l0aCBjaGFyYWN0ZXJzIHRvIGVzY2FwZSBmb3Igc3RyaW5ncyB0byBiZSBzYWZlbHkgdXNlZCBhcyBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuQ29yZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgQ2hhcnRpc3QuZXNjYXBpbmdNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgICdcXCcnOiAnJiMwMzk7J1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNlcmlhbGl6ZXMgYXJiaXRyYXJ5IGRhdGEgdG8gYSBzdHJpbmcuIEluIGNhc2Ugb2YgZGF0YSB0aGF0IGNhbid0IGJlIGVhc2lseSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcsIHRoaXMgZnVuY3Rpb24gd2lsbCBjcmVhdGUgYSB3cmFwcGVyIG9iamVjdCBhbmQgc2VyaWFsaXplIHRoZSBkYXRhIHVzaW5nIEpTT04uc3RyaW5naWZ5LiBUaGUgb3V0Y29taW5nIHN0cmluZyB3aWxsIGFsd2F5cyBiZSBlc2NhcGVkIHVzaW5nIENoYXJ0aXN0LmVzY2FwaW5nTWFwLlxuICAgKiBJZiBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gaW1tZWRpYXRlbHkgd2l0aCBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfE9iamVjdH0gZGF0YVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBDaGFydGlzdC5zZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gZWxzZSBpZih0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGRhdGEgPSAnJytkYXRhO1xuICAgIH0gZWxzZSBpZih0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRhdGEgPSBKU09OLnN0cmluZ2lmeSh7ZGF0YTogZGF0YX0pO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhDaGFydGlzdC5lc2NhcGluZ01hcCkucmVkdWNlKGZ1bmN0aW9uKHJlc3VsdCwga2V5KSB7XG4gICAgICByZXR1cm4gQ2hhcnRpc3QucmVwbGFjZUFsbChyZXN1bHQsIGtleSwgQ2hhcnRpc3QuZXNjYXBpbmdNYXBba2V5XSk7XG4gICAgfSwgZGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gZGUtc2VyaWFsaXplcyBhIHN0cmluZyBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgd2l0aCBDaGFydGlzdC5zZXJpYWxpemUuIFRoZSBzdHJpbmcgd2lsbCBhbHdheXMgYmUgdW5lc2NhcGVkIHVzaW5nIENoYXJ0aXN0LmVzY2FwaW5nTWFwIGJlZm9yZSBpdCdzIHJldHVybmVkLiBCYXNlZCBvbiB0aGUgaW5wdXQgdmFsdWUgdGhlIHJldHVybiB0eXBlIGNhbiBiZSBOdW1iZXIsIFN0cmluZyBvciBPYmplY3QuIEpTT04ucGFyc2UgaXMgdXNlZCB3aXRoIHRyeSAvIGNhdGNoIHRvIHNlZSBpZiB0aGUgdW5lc2NhcGVkIHN0cmluZyBjYW4gYmUgcGFyc2VkIGludG8gYW4gT2JqZWN0IGFuZCB0aGlzIE9iamVjdCB3aWxsIGJlIHJldHVybmVkIG9uIHN1Y2Nlc3MuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5Db3JlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gICAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ8T2JqZWN0fVxuICAgKi9cbiAgQ2hhcnRpc3QuZGVzZXJpYWxpemUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhID0gT2JqZWN0LmtleXMoQ2hhcnRpc3QuZXNjYXBpbmdNYXApLnJlZHVjZShmdW5jdGlvbihyZXN1bHQsIGtleSkge1xuICAgICAgcmV0dXJuIENoYXJ0aXN0LnJlcGxhY2VBbGwocmVzdWx0LCBDaGFydGlzdC5lc2NhcGluZ01hcFtrZXldLCBrZXkpO1xuICAgIH0sIGRhdGEpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgZGF0YSA9IGRhdGEuZGF0YSAhPT0gdW5kZWZpbmVkID8gZGF0YS5kYXRhIDogZGF0YTtcbiAgICB9IGNhdGNoKGUpIHt9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIG9yIHJlaW5pdGlhbGl6ZSB0aGUgU1ZHIGVsZW1lbnQgZm9yIHRoZSBjaGFydFxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuQ29yZVxuICAgKiBAcGFyYW0ge05vZGV9IGNvbnRhaW5lciBUaGUgY29udGFpbmluZyBET00gTm9kZSBvYmplY3QgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcGxhbnQgdGhlIFNWRyBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB3aWR0aCBTZXQgdGhlIHdpZHRoIG9mIHRoZSBTVkcgZWxlbWVudC4gRGVmYXVsdCBpcyAxMDAlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBoZWlnaHQgU2V0IHRoZSBoZWlnaHQgb2YgdGhlIFNWRyBlbGVtZW50LiBEZWZhdWx0IGlzIDEwMCVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSBTcGVjaWZ5IGEgY2xhc3MgdG8gYmUgYWRkZWQgdG8gdGhlIFNWRyBlbGVtZW50XG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNyZWF0ZWQvcmVpbml0aWFsaXplZCBTVkcgZWxlbWVudFxuICAgKi9cbiAgQ2hhcnRpc3QuY3JlYXRlU3ZnID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgd2lkdGgsIGhlaWdodCwgY2xhc3NOYW1lKSB7XG4gICAgdmFyIHN2ZztcblxuICAgIHdpZHRoID0gd2lkdGggfHwgJzEwMCUnO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCAnMTAwJSc7XG5cbiAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhIHByZXZpb3VzIFNWRyBlbGVtZW50IGluIHRoZSBjb250YWluZXIgdGhhdCBjb250YWlucyB0aGUgQ2hhcnRpc3QgWE1MIG5hbWVzcGFjZSBhbmQgcmVtb3ZlIGl0XG4gICAgLy8gU2luY2UgdGhlIERPTSBBUEkgZG9lcyBub3Qgc3VwcG9ydCBuYW1lc3BhY2VzIHdlIG5lZWQgdG8gbWFudWFsbHkgc2VhcmNoIHRoZSByZXR1cm5lZCBsaXN0IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy1hcGkvXG4gICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N2ZycpKS5maWx0ZXIoZnVuY3Rpb24gZmlsdGVyQ2hhcnRpc3RTdmdPYmplY3RzKHN2Zykge1xuICAgICAgcmV0dXJuIHN2Zy5nZXRBdHRyaWJ1dGVOUyhDaGFydGlzdC5uYW1lc3BhY2VzLnhtbG5zLCAnY3QnKTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIHJlbW92ZVByZXZpb3VzRWxlbWVudChzdmcpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdmcpO1xuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIHN2ZyBvYmplY3Qgd2l0aCB3aWR0aCBhbmQgaGVpZ2h0IG9yIHVzZSAxMDAlIGFzIGRlZmF1bHRcbiAgICBzdmcgPSBuZXcgQ2hhcnRpc3QuU3ZnKCdzdmcnKS5hdHRyKHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfSkuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcblxuICAgIHN2Zy5fbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgIHN2Zy5fbm9kZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAvLyBBZGQgdGhlIERPTSBub2RlIHRvIG91ciBjb250YWluZXJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc3ZnLl9ub2RlKTtcblxuICAgIHJldHVybiBzdmc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhhdCB0aGUgZGF0YSBvYmplY3QgcGFzc2VkIGFzIHNlY29uZCBhcmd1bWVudCB0byB0aGUgY2hhcnRzIGlzIHByZXNlbnQgYW5kIGNvcnJlY3RseSBpbml0aWFsaXplZC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIG9iamVjdCB0aGF0IGlzIHBhc3NlZCBhcyBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIGNoYXJ0c1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBub3JtYWxpemVkIGRhdGEgb2JqZWN0XG4gICAqL1xuICBDaGFydGlzdC5ub3JtYWxpemVEYXRhID0gZnVuY3Rpb24oZGF0YSwgcmV2ZXJzZSwgbXVsdGkpIHtcbiAgICB2YXIgbGFiZWxDb3VudDtcbiAgICB2YXIgb3V0cHV0ID0ge1xuICAgICAgcmF3OiBkYXRhLFxuICAgICAgbm9ybWFsaXplZDoge31cbiAgICB9O1xuXG4gICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIGdlbmVyYXRlIHNvbWUgbGFiZWxzIGJhc2VkIG9uIGV4aXN0aW5nIHNlcmllcyBkYXRhXG4gICAgb3V0cHV0Lm5vcm1hbGl6ZWQuc2VyaWVzID0gQ2hhcnRpc3QuZ2V0RGF0YUFycmF5KHtcbiAgICAgIHNlcmllczogZGF0YS5zZXJpZXMgfHwgW11cbiAgICB9LCByZXZlcnNlLCBtdWx0aSk7XG5cbiAgICAvLyBJZiBhbGwgZWxlbWVudHMgb2YgdGhlIG5vcm1hbGl6ZWQgZGF0YSBhcnJheSBhcmUgYXJyYXlzIHdlJ3JlIGRlYWxpbmcgd2l0aFxuICAgIC8vIG11bHRpIHNlcmllcyBkYXRhIGFuZCB3ZSBuZWVkIHRvIGZpbmQgdGhlIGxhcmdlc3Qgc2VyaWVzIGlmIHRoZXkgYXJlIHVuLWV2ZW5cbiAgICBpZiAob3V0cHV0Lm5vcm1hbGl6ZWQuc2VyaWVzLmV2ZXJ5KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5O1xuICAgICAgfSkpIHtcbiAgICAgIC8vIEdldHRpbmcgdGhlIHNlcmllcyB3aXRoIHRoZSB0aGUgbW9zdCBlbGVtZW50c1xuICAgICAgbGFiZWxDb3VudCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIG91dHB1dC5ub3JtYWxpemVkLnNlcmllcy5tYXAoZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgIHJldHVybiBzZXJpZXMubGVuZ3RoO1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSdyZSBkZWFsaW5nIHdpdGggUGllIGRhdGEgc28gd2UganVzdCB0YWtlIHRoZSBub3JtYWxpemVkIGFycmF5IGxlbmd0aFxuICAgICAgbGFiZWxDb3VudCA9IG91dHB1dC5ub3JtYWxpemVkLnNlcmllcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgb3V0cHV0Lm5vcm1hbGl6ZWQubGFiZWxzID0gKGRhdGEubGFiZWxzIHx8IFtdKS5zbGljZSgpO1xuICAgIC8vIFBhZGRpbmcgdGhlIGxhYmVscyB0byBsYWJlbENvdW50IHdpdGggZW1wdHkgc3RyaW5nc1xuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KFxuICAgICAgb3V0cHV0Lm5vcm1hbGl6ZWQubGFiZWxzLFxuICAgICAgQ2hhcnRpc3QudGltZXMoTWF0aC5tYXgoMCwgbGFiZWxDb3VudCAtIG91dHB1dC5ub3JtYWxpemVkLmxhYmVscy5sZW5ndGgpKS5tYXAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGlmKHJldmVyc2UpIHtcbiAgICAgIENoYXJ0aXN0LnJldmVyc2VEYXRhKG91dHB1dC5ub3JtYWxpemVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNhZmVseSBjaGVja3MgaWYgYW4gb2JqZWN0cyBoYXMgYW4gb3duZWQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB3aGVyZSB0byBjaGVjayBmb3IgYSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IG5hbWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IG93bnMgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eVxuICAgKi9cbiAgQ2hhcnRpc3Quc2FmZUhhc1Byb3BlcnR5ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBjb25zaWRlcmVkIGEgaG9sZSBpbiB0aGUgZGF0YSBzZXJpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIGNvbnNpZGVyZWQgYSBkYXRhIGhvbGVcbiAgICovXG4gIENoYXJ0aXN0LmlzRGF0YUhvbGVWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8XG4gICAgICB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXZlcnNlcyB0aGUgc2VyaWVzLCBsYWJlbHMgYW5kIHNlcmllcyBkYXRhIGFycmF5cy5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIGRhdGFcbiAgICovXG4gIENoYXJ0aXN0LnJldmVyc2VEYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGRhdGEubGFiZWxzLnJldmVyc2UoKTtcbiAgICBkYXRhLnNlcmllcy5yZXZlcnNlKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYodHlwZW9mKGRhdGEuc2VyaWVzW2ldKSA9PT0gJ29iamVjdCcgJiYgZGF0YS5zZXJpZXNbaV0uZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRhdGEuc2VyaWVzW2ldLmRhdGEucmV2ZXJzZSgpO1xuICAgICAgfSBlbHNlIGlmKGRhdGEuc2VyaWVzW2ldIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZGF0YS5zZXJpZXNbaV0ucmV2ZXJzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBkYXRhIHNlcmllcyBpbnRvIHBsYWluIGFycmF5XG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5Db3JlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBzZXJpZXMgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGRhdGEgdG8gYmUgdmlzdWFsaXplZCBpbiB0aGUgY2hhcnRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbcmV2ZXJzZV0gSWYgdHJ1ZSB0aGUgd2hvbGUgZGF0YSBpcyByZXZlcnNlZCBieSB0aGUgZ2V0RGF0YUFycmF5IGNhbGwuIFRoaXMgd2lsbCBtb2RpZnkgdGhlIGRhdGEgb2JqZWN0IHBhc3NlZCBhcyBmaXJzdCBwYXJhbWV0ZXIuIFRoZSBsYWJlbHMgYXMgd2VsbCBhcyB0aGUgc2VyaWVzIG9yZGVyIGlzIHJldmVyc2VkLiBUaGUgd2hvbGUgc2VyaWVzIGRhdGEgYXJyYXlzIGFyZSByZXZlcnNlZCB0b28uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW211bHRpXSBDcmVhdGUgYSBtdWx0aSBkaW1lbnNpb25hbCBhcnJheSBmcm9tIGEgc2VyaWVzIGRhdGEgYXJyYXkgd2hlcmUgYSB2YWx1ZSBvYmplY3Qgd2l0aCBgeGAgYW5kIGB5YCB2YWx1ZXMgd2lsbCBiZSBjcmVhdGVkLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQSBwbGFpbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhIHRvIGJlIHZpc3VhbGl6ZWQgaW4gdGhlIGNoYXJ0XG4gICAqL1xuICBDaGFydGlzdC5nZXREYXRhQXJyYXkgPSBmdW5jdGlvbihkYXRhLCByZXZlcnNlLCBtdWx0aSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IHdhbGtzIHRocm91Z2ggbmVzdGVkIGFycmF5cyBhbmQgY29udmVydCBzdHJpbmcgdmFsdWVzIHRvIG51bWJlcnMgYW5kIG9iamVjdHMgd2l0aCB2YWx1ZSBwcm9wZXJ0aWVzXG4gICAgLy8gdG8gdmFsdWVzLiBDaGVjayB0aGUgdGVzdHMgaW4gZGF0YSBjb3JlIC0+IGRhdGEgbm9ybWFsaXphdGlvbiBmb3IgYSBkZXRhaWxlZCBzcGVjaWZpY2F0aW9uIG9mIGV4cGVjdGVkIHZhbHVlc1xuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZUNvbnZlcnQodmFsdWUpIHtcbiAgICAgIGlmKENoYXJ0aXN0LnNhZmVIYXNQcm9wZXJ0eSh2YWx1ZSwgJ3ZhbHVlJykpIHtcbiAgICAgICAgLy8gV2UgYXJlIGRlYWxpbmcgd2l0aCB2YWx1ZSBvYmplY3Qgbm90YXRpb24gc28gd2UgbmVlZCB0byByZWN1cnNlIG9uIHZhbHVlIHByb3BlcnR5XG4gICAgICAgIHJldHVybiByZWN1cnNpdmVDb252ZXJ0KHZhbHVlLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZihDaGFydGlzdC5zYWZlSGFzUHJvcGVydHkodmFsdWUsICdkYXRhJykpIHtcbiAgICAgICAgLy8gV2UgYXJlIGRlYWxpbmcgd2l0aCBzZXJpZXMgb2JqZWN0IG5vdGF0aW9uIHNvIHdlIG5lZWQgdG8gcmVjdXJzZSBvbiBkYXRhIHByb3BlcnR5XG4gICAgICAgIHJldHVybiByZWN1cnNpdmVDb252ZXJ0KHZhbHVlLmRhdGEpO1xuICAgICAgfSBlbHNlIGlmKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgLy8gRGF0YSBpcyBvZiB0eXBlIGFycmF5IHNvIHdlIG5lZWQgdG8gcmVjdXJzZSBvbiB0aGUgc2VyaWVzXG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAocmVjdXJzaXZlQ29udmVydCk7XG4gICAgICB9IGVsc2UgaWYoQ2hhcnRpc3QuaXNEYXRhSG9sZVZhbHVlKHZhbHVlKSkge1xuICAgICAgICAvLyBXZSdyZSBkZWFsaW5nIHdpdGggYSBob2xlIGluIHRoZSBkYXRhIGFuZCB0aGVyZWZvcmUgbmVlZCB0byByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIC8vIFdlJ3JlIGFsc28gcmV0dXJuaW5nIHVuZGVmaW5lZCBmb3IgbXVsdGkgdmFsdWUgb3V0cHV0XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHByZXBhcmUgbXVsdGkgdmFsdWUgb3V0cHV0ICh4IGFuZCB5IGRhdGEpXG4gICAgICAgIGlmKG11bHRpKSB7XG4gICAgICAgICAgdmFyIG11bHRpVmFsdWUgPSB7fTtcblxuICAgICAgICAgIC8vIFNpbmdsZSBzZXJpZXMgdmFsdWUgYXJyYXlzIGFyZSBhc3N1bWVkIHRvIHNwZWNpZnkgdGhlIFktQXhpcyB2YWx1ZVxuICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBbMSwgMl0gPT4gW3t4OiB1bmRlZmluZWQsIHk6IDF9LCB7eDogdW5kZWZpbmVkLCB5OiAyfV1cbiAgICAgICAgICAvLyBJZiBtdWx0aSBpcyBhIHN0cmluZyB0aGVuIGl0J3MgYXNzdW1lZCB0aGF0IGl0IHNwZWNpZmllZCB3aGljaCBkaW1lbnNpb24gc2hvdWxkIGJlIGZpbGxlZCBhcyBkZWZhdWx0XG4gICAgICAgICAgaWYodHlwZW9mIG11bHRpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbXVsdGlWYWx1ZVttdWx0aV0gPSBDaGFydGlzdC5nZXROdW1iZXJPclVuZGVmaW5lZCh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG11bHRpVmFsdWUueSA9IENoYXJ0aXN0LmdldE51bWJlck9yVW5kZWZpbmVkKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtdWx0aVZhbHVlLnggPSB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgneCcpID8gQ2hhcnRpc3QuZ2V0TnVtYmVyT3JVbmRlZmluZWQodmFsdWUueCkgOiBtdWx0aVZhbHVlLng7XG4gICAgICAgICAgbXVsdGlWYWx1ZS55ID0gdmFsdWUuaGFzT3duUHJvcGVydHkoJ3knKSA/IENoYXJ0aXN0LmdldE51bWJlck9yVW5kZWZpbmVkKHZhbHVlLnkpIDogbXVsdGlWYWx1ZS55O1xuXG4gICAgICAgICAgcmV0dXJuIG11bHRpVmFsdWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXZSBjYW4gcmV0dXJuIHNpbXBsZSBkYXRhXG4gICAgICAgICAgcmV0dXJuIENoYXJ0aXN0LmdldE51bWJlck9yVW5kZWZpbmVkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhLnNlcmllcy5tYXAocmVjdXJzaXZlQ29udmVydCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgbnVtYmVyIGludG8gYSBwYWRkaW5nIG9iamVjdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIHtPYmplY3R8TnVtYmVyfSBwYWRkaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZmFsbGJhY2tdIFRoaXMgdmFsdWUgaXMgdXNlZCB0byBmaWxsIG1pc3NpbmcgdmFsdWVzIGlmIGEgaW5jb21wbGV0ZSBwYWRkaW5nIG9iamVjdCB3YXMgcGFzc2VkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBwYWRkaW5nIG9iamVjdCBjb250YWluaW5nIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCBwcm9wZXJ0aWVzIGZpbGxlZCB3aXRoIHRoZSBwYWRkaW5nIG51bWJlciBwYXNzZWQgaW4gYXMgYXJndW1lbnQuIElmIHRoZSBhcmd1bWVudCBpcyBzb21ldGhpbmcgZWxzZSB0aGFuIGEgbnVtYmVyIChwcmVzdW1hYmx5IGFscmVhZHkgYSBjb3JyZWN0IHBhZGRpbmcgb2JqZWN0KSB0aGVuIHRoaXMgYXJndW1lbnQgaXMgZGlyZWN0bHkgcmV0dXJuZWQuXG4gICAqL1xuICBDaGFydGlzdC5ub3JtYWxpemVQYWRkaW5nID0gZnVuY3Rpb24ocGFkZGluZywgZmFsbGJhY2spIHtcbiAgICBmYWxsYmFjayA9IGZhbGxiYWNrIHx8IDA7XG5cbiAgICByZXR1cm4gdHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInID8ge1xuICAgICAgdG9wOiBwYWRkaW5nLFxuICAgICAgcmlnaHQ6IHBhZGRpbmcsXG4gICAgICBib3R0b206IHBhZGRpbmcsXG4gICAgICBsZWZ0OiBwYWRkaW5nXG4gICAgfSA6IHtcbiAgICAgIHRvcDogdHlwZW9mIHBhZGRpbmcudG9wID09PSAnbnVtYmVyJyA/IHBhZGRpbmcudG9wIDogZmFsbGJhY2ssXG4gICAgICByaWdodDogdHlwZW9mIHBhZGRpbmcucmlnaHQgPT09ICdudW1iZXInID8gcGFkZGluZy5yaWdodCA6IGZhbGxiYWNrLFxuICAgICAgYm90dG9tOiB0eXBlb2YgcGFkZGluZy5ib3R0b20gPT09ICdudW1iZXInID8gcGFkZGluZy5ib3R0b20gOiBmYWxsYmFjayxcbiAgICAgIGxlZnQ6IHR5cGVvZiBwYWRkaW5nLmxlZnQgPT09ICdudW1iZXInID8gcGFkZGluZy5sZWZ0IDogZmFsbGJhY2tcbiAgICB9O1xuICB9O1xuXG4gIENoYXJ0aXN0LmdldE1ldGFEYXRhID0gZnVuY3Rpb24oc2VyaWVzLCBpbmRleCkge1xuICAgIHZhciB2YWx1ZSA9IHNlcmllcy5kYXRhID8gc2VyaWVzLmRhdGFbaW5kZXhdIDogc2VyaWVzW2luZGV4XTtcbiAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZS5tZXRhIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG9yZGVyIG9mIG1hZ25pdHVkZSBmb3IgdGhlIGNoYXJ0IHNjYWxlXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5Db3JlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgUmFuZ2Ugb2YgdGhlIGNoYXJ0XG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG9yZGVyIG9mIG1hZ25pdHVkZVxuICAgKi9cbiAgQ2hhcnRpc3Qub3JkZXJPZk1hZ25pdHVkZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKHZhbHVlKSkgLyBNYXRoLkxOMTApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9qZWN0IGEgZGF0YSBsZW5ndGggaW50byBzY3JlZW4gY29vcmRpbmF0ZXMgKHBpeGVscylcbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIHtPYmplY3R9IGF4aXNMZW5ndGggVGhlIHN2ZyBlbGVtZW50IGZvciB0aGUgY2hhcnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBTaW5nbGUgZGF0YSB2YWx1ZSBmcm9tIGEgc2VyaWVzIGFycmF5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib3VuZHMgQWxsIHRoZSB2YWx1ZXMgdG8gc2V0IHRoZSBib3VuZHMgb2YgdGhlIGNoYXJ0XG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHByb2plY3RlZCBkYXRhIGxlbmd0aCBpbiBwaXhlbHNcbiAgICovXG4gIENoYXJ0aXN0LnByb2plY3RMZW5ndGggPSBmdW5jdGlvbiAoYXhpc0xlbmd0aCwgbGVuZ3RoLCBib3VuZHMpIHtcbiAgICByZXR1cm4gbGVuZ3RoIC8gYm91bmRzLnJhbmdlICogYXhpc0xlbmd0aDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBoZWlnaHQgb2YgdGhlIGFyZWEgaW4gdGhlIGNoYXJ0IGZvciB0aGUgZGF0YSBzZXJpZXNcbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHN2ZyBUaGUgc3ZnIGVsZW1lbnQgZm9yIHRoZSBjaGFydFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgT2JqZWN0IHRoYXQgY29udGFpbnMgYWxsIHRoZSBvcHRpb25hbCB2YWx1ZXMgZm9yIHRoZSBjaGFydFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIGFyZWEgaW4gdGhlIGNoYXJ0IGZvciB0aGUgZGF0YSBzZXJpZXNcbiAgICovXG4gIENoYXJ0aXN0LmdldEF2YWlsYWJsZUhlaWdodCA9IGZ1bmN0aW9uIChzdmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoKENoYXJ0aXN0LnF1YW50aXR5KG9wdGlvbnMuaGVpZ2h0KS52YWx1ZSB8fCBzdmcuaGVpZ2h0KCkpIC0gKG9wdGlvbnMuY2hhcnRQYWRkaW5nLnRvcCArICBvcHRpb25zLmNoYXJ0UGFkZGluZy5ib3R0b20pIC0gb3B0aW9ucy5heGlzWC5vZmZzZXQsIDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgaGlnaGVzdCBhbmQgbG93ZXN0IHZhbHVlIG9mIGRhdGEgYXJyYXkuIFRoaXMgQXJyYXkgY29udGFpbnMgdGhlIGRhdGEgdGhhdCB3aWxsIGJlIHZpc3VhbGl6ZWQgaW4gdGhlIGNoYXJ0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuQ29yZVxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIFRoZSBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhIHRvIGJlIHZpc3VhbGl6ZWQgaW4gdGhlIGNoYXJ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBPYmplY3QgdGhhdCBjb250YWlucyB0aGUgY2hhcnQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZGltZW5zaW9uIEF4aXMgZGltZW5zaW9uICd4JyBvciAneScgdXNlZCB0byBhY2Nlc3MgdGhlIGNvcnJlY3QgdmFsdWUgYW5kIGhpZ2ggLyBsb3cgY29uZmlndXJhdGlvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBoaWdoZXN0IGFuZCBsb3dlc3QgdmFsdWUgdGhhdCB3aWxsIGJlIHZpc3VhbGl6ZWQgb24gdGhlIGNoYXJ0LlxuICAgKi9cbiAgQ2hhcnRpc3QuZ2V0SGlnaExvdyA9IGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zLCBkaW1lbnNpb24pIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgd29ya2Fyb3VuZCBmb3IgZGVwcmVjYXRlZCBnbG9iYWwgaGlnaCAvIGxvdyBjb25maWcuIEF4aXMgaGlnaCAvIGxvdyBjb25maWd1cmF0aW9uIGlzIHByZWZlcnJlZFxuICAgIG9wdGlvbnMgPSBDaGFydGlzdC5leHRlbmQoe30sIG9wdGlvbnMsIGRpbWVuc2lvbiA/IG9wdGlvbnNbJ2F4aXMnICsgZGltZW5zaW9uLnRvVXBwZXJDYXNlKCldIDoge30pO1xuXG4gICAgdmFyIGhpZ2hMb3cgPSB7XG4gICAgICAgIGhpZ2g6IG9wdGlvbnMuaGlnaCA9PT0gdW5kZWZpbmVkID8gLU51bWJlci5NQVhfVkFMVUUgOiArb3B0aW9ucy5oaWdoLFxuICAgICAgICBsb3c6IG9wdGlvbnMubG93ID09PSB1bmRlZmluZWQgPyBOdW1iZXIuTUFYX1ZBTFVFIDogK29wdGlvbnMubG93XG4gICAgICB9O1xuICAgIHZhciBmaW5kSGlnaCA9IG9wdGlvbnMuaGlnaCA9PT0gdW5kZWZpbmVkO1xuICAgIHZhciBmaW5kTG93ID0gb3B0aW9ucy5sb3cgPT09IHVuZGVmaW5lZDtcblxuICAgIC8vIEZ1bmN0aW9uIHRvIHJlY3Vyc2l2ZWx5IHdhbGsgdGhyb3VnaCBhcnJheXMgYW5kIGZpbmQgaGlnaGVzdCBhbmQgbG93ZXN0IG51bWJlclxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZUhpZ2hMb3coZGF0YSkge1xuICAgICAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlY3Vyc2l2ZUhpZ2hMb3coZGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRpbWVuc2lvbiA/ICtkYXRhW2RpbWVuc2lvbl0gOiArZGF0YTtcblxuICAgICAgICBpZiAoZmluZEhpZ2ggJiYgdmFsdWUgPiBoaWdoTG93LmhpZ2gpIHtcbiAgICAgICAgICBoaWdoTG93LmhpZ2ggPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaW5kTG93ICYmIHZhbHVlIDwgaGlnaExvdy5sb3cpIHtcbiAgICAgICAgICBoaWdoTG93LmxvdyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgdG8gZmluZCBoaWdoZXN0IGFuZCBsb3dlc3QgbnVtYmVyIHJlY3Vyc2l2ZWx5XG4gICAgaWYoZmluZEhpZ2ggfHwgZmluZExvdykge1xuICAgICAgcmVjdXJzaXZlSGlnaExvdyhkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZXMgb2YgaGlnaCAvIGxvdyBiYXNlZCBvbiByZWZlcmVuY2UgdmFsdWUsIGl0IHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIGludmlzaWJsZSByZWZlcmVuY2UgdmFsdWUgaXNcbiAgICAvLyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjaGFydC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB0aGUgY2hhcnQgYWx3YXlzIG5lZWRzIHRvIGNvbnRhaW4gdGhlIHBvc2l0aW9uIG9mIHRoZVxuICAgIC8vIGludmlzaWJsZSByZWZlcmVuY2UgdmFsdWUgaW4gdGhlIHZpZXcgaS5lLiBmb3IgYmlwb2xhciBzY2FsZXMuXG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlVmFsdWUgfHwgb3B0aW9ucy5yZWZlcmVuY2VWYWx1ZSA9PT0gMCkge1xuICAgICAgaGlnaExvdy5oaWdoID0gTWF0aC5tYXgob3B0aW9ucy5yZWZlcmVuY2VWYWx1ZSwgaGlnaExvdy5oaWdoKTtcbiAgICAgIGhpZ2hMb3cubG93ID0gTWF0aC5taW4ob3B0aW9ucy5yZWZlcmVuY2VWYWx1ZSwgaGlnaExvdy5sb3cpO1xuICAgIH1cblxuICAgIC8vIElmIGhpZ2ggYW5kIGxvdyBhcmUgdGhlIHNhbWUgYmVjYXVzZSBvZiBtaXNjb25maWd1cmF0aW9uIG9yIGZsYXQgZGF0YSAob25seSB0aGUgc2FtZSB2YWx1ZSkgd2UgbmVlZFxuICAgIC8vIHRvIHNldCB0aGUgaGlnaCBvciBsb3cgdG8gMCBkZXBlbmRpbmcgb24gdGhlIHBvbGFyaXR5XG4gICAgaWYgKGhpZ2hMb3cuaGlnaCA8PSBoaWdoTG93Lmxvdykge1xuICAgICAgLy8gSWYgYm90aCB2YWx1ZXMgYXJlIDAgd2Ugc2V0IGhpZ2ggdG8gMVxuICAgICAgaWYgKGhpZ2hMb3cubG93ID09PSAwKSB7XG4gICAgICAgIGhpZ2hMb3cuaGlnaCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGhpZ2hMb3cubG93IDwgMCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIHRoZSBzYW1lIG5lZ2F0aXZlIHZhbHVlIGZvciB0aGUgYm91bmRzIHdlIHNldCBib3VuZHMuaGlnaCB0byAwXG4gICAgICAgIGhpZ2hMb3cuaGlnaCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGhpZ2hMb3cuaGlnaCA+IDApIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSB0aGUgc2FtZSBwb3NpdGl2ZSB2YWx1ZSBmb3IgdGhlIGJvdW5kcyB3ZSBzZXQgYm91bmRzLmxvdyB0byAwXG4gICAgICAgIGhpZ2hMb3cubG93ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGRhdGEgYXJyYXkgd2FzIGVtcHR5LCB2YWx1ZXMgYXJlIE51bWJlci5NQVhfVkFMVUUgYW5kIC1OdW1iZXIuTUFYX1ZBTFVFLiBTZXQgYm91bmRzIHRvIHByZXZlbnQgZXJyb3JzXG4gICAgICAgIGhpZ2hMb3cuaGlnaCA9IDE7XG4gICAgICAgIGhpZ2hMb3cubG93ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGlnaExvdztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgdmFsdWUgY2FuIGJlIHNhZmVseSBjb2VyY2VkIHRvIGEgbnVtYmVyLiBUaGlzIGluY2x1ZGVzIGFsbCB2YWx1ZXMgZXhjZXB0IG51bGwgd2hpY2ggcmVzdWx0IGluIGZpbml0ZSBudW1iZXJzIHdoZW4gY29lcmNlZC4gVGhpcyBleGNsdWRlcyBOYU4sIHNpbmNlIGl0J3Mgbm90IGZpbml0ZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgQ2hhcnRpc3QuaXNOdW1lcmljID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBmYWxzZSA6IGlzRmluaXRlKHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIG9uIGFsbCBmYWxzZXkgdmFsdWVzIGV4Y2VwdCB0aGUgbnVtZXJpYyB2YWx1ZSAwLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuQ29yZVxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBDaGFydGlzdC5pc0ZhbHNleUJ1dFplcm8gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAhdmFsdWUgJiYgdmFsdWUgIT09IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBudW1iZXIgaWYgdGhlIHBhc3NlZCBwYXJhbWV0ZXIgaXMgYSB2YWxpZCBudW1iZXIgb3IgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHVuZGVmaW5lZC4gT24gYWxsIG90aGVyIHZhbHVlcyB0aGFuIGEgdmFsaWQgbnVtYmVyLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgQ2hhcnRpc3QuZ2V0TnVtYmVyT3JVbmRlZmluZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBDaGFydGlzdC5pc051bWVyaWModmFsdWUpID8gK3ZhbHVlIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcHJvdmlkZWQgdmFsdWUgb2JqZWN0IGlzIG11bHRpIHZhbHVlIChjb250YWlucyB4IG9yIHkgcHJvcGVydGllcylcbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBDaGFydGlzdC5pc011bHRpVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICgneCcgaW4gdmFsdWUgfHwgJ3knIGluIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhIHZhbHVlIGZyb20gYSBkaW1lbnNpb24gYHZhbHVlLnhgIG9yIGB2YWx1ZS55YCB3aGlsZSByZXR1cm5pbmcgdmFsdWUgZGlyZWN0bHkgaWYgaXQncyBhIHZhbGlkIG51bWVyaWMgdmFsdWUuIElmIHRoZSB2YWx1ZSBpcyBub3QgbnVtZXJpYyBhbmQgaXQncyBmYWxzZXkgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBgZGVmYXVsdFZhbHVlYC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBkaW1lbnNpb25cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIENoYXJ0aXN0LmdldE11bHRpVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgZGltZW5zaW9uKSB7XG4gICAgaWYoQ2hhcnRpc3QuaXNNdWx0aVZhbHVlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIENoYXJ0aXN0LmdldE51bWJlck9yVW5kZWZpbmVkKHZhbHVlW2RpbWVuc2lvbiB8fCAneSddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIENoYXJ0aXN0LmdldE51bWJlck9yVW5kZWZpbmVkKHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFBvbGxhcmQgUmhvIEFsZ29yaXRobSB0byBmaW5kIHNtYWxsZXN0IGZhY3RvciBvZiBhbiBpbnRlZ2VyIHZhbHVlLiBUaGVyZSBhcmUgbW9yZSBlZmZpY2llbnQgYWxnb3JpdGhtcyBmb3IgZmFjdG9yaXphdGlvbiwgYnV0IHRoaXMgb25lIGlzIHF1aXRlIGVmZmljaWVudCBhbmQgbm90IHNvIGNvbXBsZXguXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5Db3JlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBudW0gQW4gaW50ZWdlciBudW1iZXIgd2hlcmUgdGhlIHNtYWxsZXN0IGZhY3RvciBzaG91bGQgYmUgc2VhcmNoZWQgZm9yXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBzbWFsbGVzdCBpbnRlZ2VyIGZhY3RvciBvZiB0aGUgcGFyYW1ldGVyIG51bS5cbiAgICovXG4gIENoYXJ0aXN0LnJobyA9IGZ1bmN0aW9uKG51bSkge1xuICAgIGlmKG51bSA9PT0gMSkge1xuICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnY2QocCwgcSkge1xuICAgICAgaWYgKHAgJSBxID09PSAwKSB7XG4gICAgICAgIHJldHVybiBxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdjZChxLCBwICUgcSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZih4KSB7XG4gICAgICByZXR1cm4geCAqIHggKyAxO1xuICAgIH1cblxuICAgIHZhciB4MSA9IDIsIHgyID0gMiwgZGl2aXNvcjtcbiAgICBpZiAobnVtICUgMiA9PT0gMCkge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgeDEgPSBmKHgxKSAlIG51bTtcbiAgICAgIHgyID0gZihmKHgyKSkgJSBudW07XG4gICAgICBkaXZpc29yID0gZ2NkKE1hdGguYWJzKHgxIC0geDIpLCBudW0pO1xuICAgIH0gd2hpbGUgKGRpdmlzb3IgPT09IDEpO1xuXG4gICAgcmV0dXJuIGRpdmlzb3I7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBhbmQgcmV0cmlldmUgYWxsIHRoZSBib3VuZHMgZm9yIHRoZSBjaGFydCBhbmQgcmV0dXJuIHRoZW0gaW4gb25lIGFycmF5XG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5Db3JlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBheGlzTGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIEF4aXMgdXNlZCBmb3JcbiAgICogQHBhcmFtIHtPYmplY3R9IGhpZ2hMb3cgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBoaWdoIGFuZCBsb3cgcHJvcGVydHkgaW5kaWNhdGluZyB0aGUgdmFsdWUgcmFuZ2Ugb2YgdGhlIGNoYXJ0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVNaW5TcGFjZSBUaGUgbWluaW11bSBwcm9qZWN0ZWQgbGVuZ3RoIGEgc3RlcCBzaG91bGQgcmVzdWx0IGluXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb25seUludGVnZXJcbiAgICogQHJldHVybiB7T2JqZWN0fSBBbGwgdGhlIHZhbHVlcyB0byBzZXQgdGhlIGJvdW5kcyBvZiB0aGUgY2hhcnRcbiAgICovXG4gIENoYXJ0aXN0LmdldEJvdW5kcyA9IGZ1bmN0aW9uIChheGlzTGVuZ3RoLCBoaWdoTG93LCBzY2FsZU1pblNwYWNlLCBvbmx5SW50ZWdlcikge1xuICAgIHZhciBpLFxuICAgICAgb3B0aW1pemF0aW9uQ291bnRlciA9IDAsXG4gICAgICBuZXdNaW4sXG4gICAgICBuZXdNYXgsXG4gICAgICBib3VuZHMgPSB7XG4gICAgICAgIGhpZ2g6IGhpZ2hMb3cuaGlnaCxcbiAgICAgICAgbG93OiBoaWdoTG93Lmxvd1xuICAgICAgfTtcblxuICAgIGJvdW5kcy52YWx1ZVJhbmdlID0gYm91bmRzLmhpZ2ggLSBib3VuZHMubG93O1xuICAgIGJvdW5kcy5vb20gPSBDaGFydGlzdC5vcmRlck9mTWFnbml0dWRlKGJvdW5kcy52YWx1ZVJhbmdlKTtcbiAgICBib3VuZHMuc3RlcCA9IE1hdGgucG93KDEwLCBib3VuZHMub29tKTtcbiAgICBib3VuZHMubWluID0gTWF0aC5mbG9vcihib3VuZHMubG93IC8gYm91bmRzLnN0ZXApICogYm91bmRzLnN0ZXA7XG4gICAgYm91bmRzLm1heCA9IE1hdGguY2VpbChib3VuZHMuaGlnaCAvIGJvdW5kcy5zdGVwKSAqIGJvdW5kcy5zdGVwO1xuICAgIGJvdW5kcy5yYW5nZSA9IGJvdW5kcy5tYXggLSBib3VuZHMubWluO1xuICAgIGJvdW5kcy5udW1iZXJPZlN0ZXBzID0gTWF0aC5yb3VuZChib3VuZHMucmFuZ2UgLyBib3VuZHMuc3RlcCk7XG5cbiAgICAvLyBPcHRpbWl6ZSBzY2FsZSBzdGVwIGJ5IGNoZWNraW5nIGlmIHN1YmRpdmlzaW9uIGlzIHBvc3NpYmxlIGJhc2VkIG9uIGhvcml6b250YWxHcmlkTWluU3BhY2VcbiAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBiZWxvdyB0aGUgc2NhbGVNaW5TcGFjZSB2YWx1ZSB3ZSB3aWxsIHNjYWxlIHVwXG4gICAgdmFyIGxlbmd0aCA9IENoYXJ0aXN0LnByb2plY3RMZW5ndGgoYXhpc0xlbmd0aCwgYm91bmRzLnN0ZXAsIGJvdW5kcyk7XG4gICAgdmFyIHNjYWxlVXAgPSBsZW5ndGggPCBzY2FsZU1pblNwYWNlO1xuICAgIHZhciBzbWFsbGVzdEZhY3RvciA9IG9ubHlJbnRlZ2VyID8gQ2hhcnRpc3QucmhvKGJvdW5kcy5yYW5nZSkgOiAwO1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgd2Ugc2hvdWxkIG9ubHkgdXNlIGludGVnZXIgc3RlcHMgYW5kIGlmIHN0ZXAgMSBpcyBzdGlsbCBsYXJnZXIgdGhhbiBzY2FsZU1pblNwYWNlIHNvIHdlIGNhbiB1c2UgMVxuICAgIGlmKG9ubHlJbnRlZ2VyICYmIENoYXJ0aXN0LnByb2plY3RMZW5ndGgoYXhpc0xlbmd0aCwgMSwgYm91bmRzKSA+PSBzY2FsZU1pblNwYWNlKSB7XG4gICAgICBib3VuZHMuc3RlcCA9IDE7XG4gICAgfSBlbHNlIGlmKG9ubHlJbnRlZ2VyICYmIHNtYWxsZXN0RmFjdG9yIDwgYm91bmRzLnN0ZXAgJiYgQ2hhcnRpc3QucHJvamVjdExlbmd0aChheGlzTGVuZ3RoLCBzbWFsbGVzdEZhY3RvciwgYm91bmRzKSA+PSBzY2FsZU1pblNwYWNlKSB7XG4gICAgICAvLyBJZiBzdGVwIDEgd2FzIHRvbyBzbWFsbCwgd2UgY2FuIHRyeSB0aGUgc21hbGxlc3QgZmFjdG9yIG9mIHJhbmdlXG4gICAgICAvLyBJZiB0aGUgc21hbGxlc3QgZmFjdG9yIGlzIHNtYWxsZXIgdGhhbiB0aGUgY3VycmVudCBib3VuZHMuc3RlcCBhbmQgdGhlIHByb2plY3RlZCBsZW5ndGggb2Ygc21hbGxlc3QgZmFjdG9yXG4gICAgICAvLyBpcyBsYXJnZXIgdGhhbiB0aGUgc2NhbGVNaW5TcGFjZSB3ZSBzaG91bGQgZ28gZm9yIGl0LlxuICAgICAgYm91bmRzLnN0ZXAgPSBzbWFsbGVzdEZhY3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJ5aW5nIHRvIGRpdmlkZSBvciBtdWx0aXBseSBieSAyIGFuZCBmaW5kIHRoZSBiZXN0IHN0ZXAgdmFsdWVcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChzY2FsZVVwICYmIENoYXJ0aXN0LnByb2plY3RMZW5ndGgoYXhpc0xlbmd0aCwgYm91bmRzLnN0ZXAsIGJvdW5kcykgPD0gc2NhbGVNaW5TcGFjZSkge1xuICAgICAgICAgIGJvdW5kcy5zdGVwICo9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAoIXNjYWxlVXAgJiYgQ2hhcnRpc3QucHJvamVjdExlbmd0aChheGlzTGVuZ3RoLCBib3VuZHMuc3RlcCAvIDIsIGJvdW5kcykgPj0gc2NhbGVNaW5TcGFjZSkge1xuICAgICAgICAgIGJvdW5kcy5zdGVwIC89IDI7XG4gICAgICAgICAgaWYob25seUludGVnZXIgJiYgYm91bmRzLnN0ZXAgJSAxICE9PSAwKSB7XG4gICAgICAgICAgICBib3VuZHMuc3RlcCAqPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYob3B0aW1pemF0aW9uQ291bnRlcisrID4gMTAwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhjZWVkZWQgbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB3aGlsZSBvcHRpbWl6aW5nIHNjYWxlIHN0ZXAhJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgRVBTSUxPTiA9IDIuMjIxRS0xNjtcbiAgICBib3VuZHMuc3RlcCA9IE1hdGgubWF4KGJvdW5kcy5zdGVwLCBFUFNJTE9OKTtcbiAgICBmdW5jdGlvbiBzYWZlSW5jcmVtZW50KHZhbHVlLCBpbmNyZW1lbnQpIHtcbiAgICAgIC8vIElmIGluY3JlbWVudCBpcyB0b28gc21hbGwgdXNlICo9ICgxK0VQU0lMT04pIGFzIGEgc2ltcGxlIG5leHRhZnRlclxuICAgICAgaWYgKHZhbHVlID09PSAodmFsdWUgKz0gaW5jcmVtZW50KSkge1xuICAgICAgXHR2YWx1ZSAqPSAoMSArIChpbmNyZW1lbnQgPiAwID8gRVBTSUxPTiA6IC1FUFNJTE9OKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gTmFycm93IG1pbiBhbmQgbWF4IGJhc2VkIG9uIG5ldyBzdGVwXG4gICAgbmV3TWluID0gYm91bmRzLm1pbjtcbiAgICBuZXdNYXggPSBib3VuZHMubWF4O1xuICAgIHdoaWxlIChuZXdNaW4gKyBib3VuZHMuc3RlcCA8PSBib3VuZHMubG93KSB7XG4gICAgXHRuZXdNaW4gPSBzYWZlSW5jcmVtZW50KG5ld01pbiwgYm91bmRzLnN0ZXApO1xuICAgIH1cbiAgICB3aGlsZSAobmV3TWF4IC0gYm91bmRzLnN0ZXAgPj0gYm91bmRzLmhpZ2gpIHtcbiAgICBcdG5ld01heCA9IHNhZmVJbmNyZW1lbnQobmV3TWF4LCAtYm91bmRzLnN0ZXApO1xuICAgIH1cbiAgICBib3VuZHMubWluID0gbmV3TWluO1xuICAgIGJvdW5kcy5tYXggPSBuZXdNYXg7XG4gICAgYm91bmRzLnJhbmdlID0gYm91bmRzLm1heCAtIGJvdW5kcy5taW47XG5cbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yIChpID0gYm91bmRzLm1pbjsgaSA8PSBib3VuZHMubWF4OyBpID0gc2FmZUluY3JlbWVudChpLCBib3VuZHMuc3RlcCkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IENoYXJ0aXN0LnJvdW5kV2l0aFByZWNpc2lvbihpKTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGJvdW5kcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGNhcnRlc2lhbiBjb29yZGluYXRlcyBvZiBwb2xhciBjb29yZGluYXRlc1xuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuQ29yZVxuICAgKiBAcGFyYW0ge051bWJlcn0gY2VudGVyWCBYLWF4aXMgY29vcmRpbmF0ZXMgb2YgY2VudGVyIHBvaW50IG9mIGNpcmNsZSBzZWdtZW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjZW50ZXJZIFgtYXhpcyBjb29yZGluYXRlcyBvZiBjZW50ZXIgcG9pbnQgb2YgY2lyY2xlIHNlZ21lbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgY2lyY2xlIHNlZ21lbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlSW5EZWdyZWVzIEFuZ2xlIG9mIGNpcmNsZSBzZWdtZW50IGluIGRlZ3JlZXNcbiAgICogQHJldHVybiB7e3g6TnVtYmVyLCB5Ok51bWJlcn19IENvb3JkaW5hdGVzIG9mIHBvaW50IG9uIGNpcmN1bWZlcmVuY2VcbiAgICovXG4gIENoYXJ0aXN0LnBvbGFyVG9DYXJ0ZXNpYW4gPSBmdW5jdGlvbiAoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzLCBhbmdsZUluRGVncmVlcykge1xuICAgIHZhciBhbmdsZUluUmFkaWFucyA9IChhbmdsZUluRGVncmVlcyAtIDkwKSAqIE1hdGguUEkgLyAxODAuMDtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiBjZW50ZXJYICsgKHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKSksXG4gICAgICB5OiBjZW50ZXJZICsgKHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKSlcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGNoYXJ0IGRyYXdpbmcgcmVjdGFuZ2xlIChhcmVhIHdoZXJlIGNoYXJ0IGlzIGRyYXduKSB4MSx5MSA9IGJvdHRvbSBsZWZ0IC8geDIseTIgPSB0b3AgcmlnaHRcbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHN2ZyBUaGUgc3ZnIGVsZW1lbnQgZm9yIHRoZSBjaGFydFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgT2JqZWN0IHRoYXQgY29udGFpbnMgYWxsIHRoZSBvcHRpb25hbCB2YWx1ZXMgZm9yIHRoZSBjaGFydFxuICAgKiBAcGFyYW0ge051bWJlcn0gW2ZhbGxiYWNrUGFkZGluZ10gVGhlIGZhbGxiYWNrIHBhZGRpbmcgaWYgcGFydGlhbCBwYWRkaW5nIG9iamVjdHMgYXJlIHVzZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2hhcnQgcmVjdGFuZ2xlcyBjb29yZGluYXRlcyBpbnNpZGUgdGhlIHN2ZyBlbGVtZW50IHBsdXMgdGhlIHJlY3RhbmdsZXMgbWVhc3VyZW1lbnRzXG4gICAqL1xuICBDaGFydGlzdC5jcmVhdGVDaGFydFJlY3QgPSBmdW5jdGlvbiAoc3ZnLCBvcHRpb25zLCBmYWxsYmFja1BhZGRpbmcpIHtcbiAgICB2YXIgaGFzQXhpcyA9ICEhKG9wdGlvbnMuYXhpc1ggfHwgb3B0aW9ucy5heGlzWSk7XG4gICAgdmFyIHlBeGlzT2Zmc2V0ID0gaGFzQXhpcyA/IG9wdGlvbnMuYXhpc1kub2Zmc2V0IDogMDtcbiAgICB2YXIgeEF4aXNPZmZzZXQgPSBoYXNBeGlzID8gb3B0aW9ucy5heGlzWC5vZmZzZXQgOiAwO1xuICAgIC8vIElmIHdpZHRoIG9yIGhlaWdodCByZXN1bHRzIGluIGludmFsaWQgdmFsdWUgKGluY2x1ZGluZyAwKSB3ZSBmYWxsYmFjayB0byB0aGUgdW5pdGxlc3Mgc2V0dGluZ3Mgb3IgZXZlbiAwXG4gICAgdmFyIHdpZHRoID0gc3ZnLndpZHRoKCkgfHwgQ2hhcnRpc3QucXVhbnRpdHkob3B0aW9ucy53aWR0aCkudmFsdWUgfHwgMDtcbiAgICB2YXIgaGVpZ2h0ID0gc3ZnLmhlaWdodCgpIHx8IENoYXJ0aXN0LnF1YW50aXR5KG9wdGlvbnMuaGVpZ2h0KS52YWx1ZSB8fCAwO1xuICAgIHZhciBub3JtYWxpemVkUGFkZGluZyA9IENoYXJ0aXN0Lm5vcm1hbGl6ZVBhZGRpbmcob3B0aW9ucy5jaGFydFBhZGRpbmcsIGZhbGxiYWNrUGFkZGluZyk7XG5cbiAgICAvLyBJZiBzZXR0aW5ncyB3ZXJlIHRvIHNtYWxsIHRvIGNvcGUgd2l0aCBvZmZzZXQgKGxlZ2FjeSkgYW5kIHBhZGRpbmcsIHdlJ2xsIGFkanVzdFxuICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHlBeGlzT2Zmc2V0ICsgbm9ybWFsaXplZFBhZGRpbmcubGVmdCArIG5vcm1hbGl6ZWRQYWRkaW5nLnJpZ2h0KTtcbiAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIHhBeGlzT2Zmc2V0ICsgbm9ybWFsaXplZFBhZGRpbmcudG9wICsgbm9ybWFsaXplZFBhZGRpbmcuYm90dG9tKTtcblxuICAgIHZhciBjaGFydFJlY3QgPSB7XG4gICAgICBwYWRkaW5nOiBub3JtYWxpemVkUGFkZGluZyxcbiAgICAgIHdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLngyIC0gdGhpcy54MTtcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueTEgLSB0aGlzLnkyO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZihoYXNBeGlzKSB7XG4gICAgICBpZiAob3B0aW9ucy5heGlzWC5wb3NpdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBjaGFydFJlY3QueTIgPSBub3JtYWxpemVkUGFkZGluZy50b3AgKyB4QXhpc09mZnNldDtcbiAgICAgICAgY2hhcnRSZWN0LnkxID0gTWF0aC5tYXgoaGVpZ2h0IC0gbm9ybWFsaXplZFBhZGRpbmcuYm90dG9tLCBjaGFydFJlY3QueTIgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYXJ0UmVjdC55MiA9IG5vcm1hbGl6ZWRQYWRkaW5nLnRvcDtcbiAgICAgICAgY2hhcnRSZWN0LnkxID0gTWF0aC5tYXgoaGVpZ2h0IC0gbm9ybWFsaXplZFBhZGRpbmcuYm90dG9tIC0geEF4aXNPZmZzZXQsIGNoYXJ0UmVjdC55MiArIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5heGlzWS5wb3NpdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBjaGFydFJlY3QueDEgPSBub3JtYWxpemVkUGFkZGluZy5sZWZ0ICsgeUF4aXNPZmZzZXQ7XG4gICAgICAgIGNoYXJ0UmVjdC54MiA9IE1hdGgubWF4KHdpZHRoIC0gbm9ybWFsaXplZFBhZGRpbmcucmlnaHQsIGNoYXJ0UmVjdC54MSArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhcnRSZWN0LngxID0gbm9ybWFsaXplZFBhZGRpbmcubGVmdDtcbiAgICAgICAgY2hhcnRSZWN0LngyID0gTWF0aC5tYXgod2lkdGggLSBub3JtYWxpemVkUGFkZGluZy5yaWdodCAtIHlBeGlzT2Zmc2V0LCBjaGFydFJlY3QueDEgKyAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2hhcnRSZWN0LngxID0gbm9ybWFsaXplZFBhZGRpbmcubGVmdDtcbiAgICAgIGNoYXJ0UmVjdC54MiA9IE1hdGgubWF4KHdpZHRoIC0gbm9ybWFsaXplZFBhZGRpbmcucmlnaHQsIGNoYXJ0UmVjdC54MSArIDEpO1xuICAgICAgY2hhcnRSZWN0LnkyID0gbm9ybWFsaXplZFBhZGRpbmcudG9wO1xuICAgICAgY2hhcnRSZWN0LnkxID0gTWF0aC5tYXgoaGVpZ2h0IC0gbm9ybWFsaXplZFBhZGRpbmcuYm90dG9tLCBjaGFydFJlY3QueTIgKyAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcnRSZWN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZ3JpZCBsaW5lIGJhc2VkIG9uIGEgcHJvamVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuQ29yZVxuICAgKiBAcGFyYW0gcG9zaXRpb25cbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEBwYXJhbSBheGlzXG4gICAqIEBwYXJhbSBvZmZzZXRcbiAgICogQHBhcmFtIGxlbmd0aFxuICAgKiBAcGFyYW0gZ3JvdXBcbiAgICogQHBhcmFtIGNsYXNzZXNcbiAgICogQHBhcmFtIGV2ZW50RW1pdHRlclxuICAgKi9cbiAgQ2hhcnRpc3QuY3JlYXRlR3JpZCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCwgYXhpcywgb2Zmc2V0LCBsZW5ndGgsIGdyb3VwLCBjbGFzc2VzLCBldmVudEVtaXR0ZXIpIHtcbiAgICB2YXIgcG9zaXRpb25hbERhdGEgPSB7fTtcbiAgICBwb3NpdGlvbmFsRGF0YVtheGlzLnVuaXRzLnBvcyArICcxJ10gPSBwb3NpdGlvbjtcbiAgICBwb3NpdGlvbmFsRGF0YVtheGlzLnVuaXRzLnBvcyArICcyJ10gPSBwb3NpdGlvbjtcbiAgICBwb3NpdGlvbmFsRGF0YVtheGlzLmNvdW50ZXJVbml0cy5wb3MgKyAnMSddID0gb2Zmc2V0O1xuICAgIHBvc2l0aW9uYWxEYXRhW2F4aXMuY291bnRlclVuaXRzLnBvcyArICcyJ10gPSBvZmZzZXQgKyBsZW5ndGg7XG5cbiAgICB2YXIgZ3JpZEVsZW1lbnQgPSBncm91cC5lbGVtKCdsaW5lJywgcG9zaXRpb25hbERhdGEsIGNsYXNzZXMuam9pbignICcpKTtcblxuICAgIC8vIEV2ZW50IGZvciBncmlkIGRyYXdcbiAgICBldmVudEVtaXR0ZXIuZW1pdCgnZHJhdycsXG4gICAgICBDaGFydGlzdC5leHRlbmQoe1xuICAgICAgICB0eXBlOiAnZ3JpZCcsXG4gICAgICAgIGF4aXM6IGF4aXMsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgZ3JvdXA6IGdyb3VwLFxuICAgICAgICBlbGVtZW50OiBncmlkRWxlbWVudFxuICAgICAgfSwgcG9zaXRpb25hbERhdGEpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGdyaWQgYmFja2dyb3VuZCByZWN0IGFuZCBlbWl0cyB0aGUgZHJhdyBldmVudC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIGdyaWRHcm91cFxuICAgKiBAcGFyYW0gY2hhcnRSZWN0XG4gICAqIEBwYXJhbSBjbGFzc05hbWVcbiAgICogQHBhcmFtIGV2ZW50RW1pdHRlclxuICAgKi9cbiAgQ2hhcnRpc3QuY3JlYXRlR3JpZEJhY2tncm91bmQgPSBmdW5jdGlvbiAoZ3JpZEdyb3VwLCBjaGFydFJlY3QsIGNsYXNzTmFtZSwgZXZlbnRFbWl0dGVyKSB7XG4gICAgdmFyIGdyaWRCYWNrZ3JvdW5kID0gZ3JpZEdyb3VwLmVsZW0oJ3JlY3QnLCB7XG4gICAgICAgIHg6IGNoYXJ0UmVjdC54MSxcbiAgICAgICAgeTogY2hhcnRSZWN0LnkyLFxuICAgICAgICB3aWR0aDogY2hhcnRSZWN0LndpZHRoKCksXG4gICAgICAgIGhlaWdodDogY2hhcnRSZWN0LmhlaWdodCgpLFxuICAgICAgfSwgY2xhc3NOYW1lLCB0cnVlKTtcblxuICAgICAgLy8gRXZlbnQgZm9yIGdyaWQgYmFja2dyb3VuZCBkcmF3XG4gICAgICBldmVudEVtaXR0ZXIuZW1pdCgnZHJhdycsIHtcbiAgICAgICAgdHlwZTogJ2dyaWRCYWNrZ3JvdW5kJyxcbiAgICAgICAgZ3JvdXA6IGdyaWRHcm91cCxcbiAgICAgICAgZWxlbWVudDogZ3JpZEJhY2tncm91bmRcbiAgICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbGFiZWwgYmFzZWQgb24gYSBwcm9qZWN0ZWQgdmFsdWUgYW5kIGFuIGF4aXMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5Db3JlXG4gICAqIEBwYXJhbSBwb3NpdGlvblxuICAgKiBAcGFyYW0gbGVuZ3RoXG4gICAqIEBwYXJhbSBpbmRleFxuICAgKiBAcGFyYW0gbGFiZWxzXG4gICAqIEBwYXJhbSBheGlzXG4gICAqIEBwYXJhbSBheGlzT2Zmc2V0XG4gICAqIEBwYXJhbSBsYWJlbE9mZnNldFxuICAgKiBAcGFyYW0gZ3JvdXBcbiAgICogQHBhcmFtIGNsYXNzZXNcbiAgICogQHBhcmFtIHVzZUZvcmVpZ25PYmplY3RcbiAgICogQHBhcmFtIGV2ZW50RW1pdHRlclxuICAgKi9cbiAgQ2hhcnRpc3QuY3JlYXRlTGFiZWwgPSBmdW5jdGlvbihwb3NpdGlvbiwgbGVuZ3RoLCBpbmRleCwgbGFiZWxzLCBheGlzLCBheGlzT2Zmc2V0LCBsYWJlbE9mZnNldCwgZ3JvdXAsIGNsYXNzZXMsIHVzZUZvcmVpZ25PYmplY3QsIGV2ZW50RW1pdHRlcikge1xuICAgIHZhciBsYWJlbEVsZW1lbnQ7XG4gICAgdmFyIHBvc2l0aW9uYWxEYXRhID0ge307XG5cbiAgICBwb3NpdGlvbmFsRGF0YVtheGlzLnVuaXRzLnBvc10gPSBwb3NpdGlvbiArIGxhYmVsT2Zmc2V0W2F4aXMudW5pdHMucG9zXTtcbiAgICBwb3NpdGlvbmFsRGF0YVtheGlzLmNvdW50ZXJVbml0cy5wb3NdID0gbGFiZWxPZmZzZXRbYXhpcy5jb3VudGVyVW5pdHMucG9zXTtcbiAgICBwb3NpdGlvbmFsRGF0YVtheGlzLnVuaXRzLmxlbl0gPSBsZW5ndGg7XG4gICAgcG9zaXRpb25hbERhdGFbYXhpcy5jb3VudGVyVW5pdHMubGVuXSA9IE1hdGgubWF4KDAsIGF4aXNPZmZzZXQgLSAxMCk7XG5cbiAgICBpZih1c2VGb3JlaWduT2JqZWN0KSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHNldCB3aWR0aCBhbmQgaGVpZ2h0IGV4cGxpY2l0bHkgdG8gcHggYXMgc3BhbiB3aWxsIG5vdCBleHBhbmQgd2l0aCB3aWR0aCBhbmQgaGVpZ2h0IGJlaW5nXG4gICAgICAvLyAxMDAlIGluIGFsbCBicm93c2Vyc1xuICAgICAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBjb250ZW50LmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xuICAgICAgY29udGVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgQ2hhcnRpc3QubmFtZXNwYWNlcy54aHRtbCk7XG4gICAgICBjb250ZW50LmlubmVyVGV4dCA9IGxhYmVsc1tpbmRleF07XG4gICAgICBjb250ZW50LnN0eWxlW2F4aXMudW5pdHMubGVuXSA9IE1hdGgucm91bmQocG9zaXRpb25hbERhdGFbYXhpcy51bml0cy5sZW5dKSArICdweCc7XG4gICAgICBjb250ZW50LnN0eWxlW2F4aXMuY291bnRlclVuaXRzLmxlbl0gPSBNYXRoLnJvdW5kKHBvc2l0aW9uYWxEYXRhW2F4aXMuY291bnRlclVuaXRzLmxlbl0pICsgJ3B4JztcblxuICAgICAgbGFiZWxFbGVtZW50ID0gZ3JvdXAuZm9yZWlnbk9iamVjdChjb250ZW50LCBDaGFydGlzdC5leHRlbmQoe1xuICAgICAgICBzdHlsZTogJ292ZXJmbG93OiB2aXNpYmxlOydcbiAgICAgIH0sIHBvc2l0aW9uYWxEYXRhKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsRWxlbWVudCA9IGdyb3VwLmVsZW0oJ3RleHQnLCBwb3NpdGlvbmFsRGF0YSwgY2xhc3Nlcy5qb2luKCcgJykpLnRleHQobGFiZWxzW2luZGV4XSk7XG4gICAgfVxuXG4gICAgZXZlbnRFbWl0dGVyLmVtaXQoJ2RyYXcnLCBDaGFydGlzdC5leHRlbmQoe1xuICAgICAgdHlwZTogJ2xhYmVsJyxcbiAgICAgIGF4aXM6IGF4aXMsXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBncm91cDogZ3JvdXAsXG4gICAgICBlbGVtZW50OiBsYWJlbEVsZW1lbnQsXG4gICAgICB0ZXh0OiBsYWJlbHNbaW5kZXhdXG4gICAgfSwgcG9zaXRpb25hbERhdGEpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGVscGVyIHRvIHJlYWQgc2VyaWVzIHNwZWNpZmljIG9wdGlvbnMgZnJvbSBvcHRpb25zIG9iamVjdC4gSXQgYXV0b21hdGljYWxseSBmYWxscyBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uIGlmXG4gICAqIHRoZXJlIGlzIG5vIG9wdGlvbiBpbiB0aGUgc2VyaWVzIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpZXMgU2VyaWVzIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDaGFydGlzdCBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBvcHRpb25zIGtleSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIG9idGFpbiB0aGUgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIENoYXJ0aXN0LmdldFNlcmllc09wdGlvbiA9IGZ1bmN0aW9uKHNlcmllcywgb3B0aW9ucywga2V5KSB7XG4gICAgaWYoc2VyaWVzLm5hbWUgJiYgb3B0aW9ucy5zZXJpZXMgJiYgb3B0aW9ucy5zZXJpZXNbc2VyaWVzLm5hbWVdKSB7XG4gICAgICB2YXIgc2VyaWVzT3B0aW9ucyA9IG9wdGlvbnMuc2VyaWVzW3Nlcmllcy5uYW1lXTtcbiAgICAgIHJldHVybiBzZXJpZXNPcHRpb25zLmhhc093blByb3BlcnR5KGtleSkgPyBzZXJpZXNPcHRpb25zW2tleV0gOiBvcHRpb25zW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb25zW2tleV07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBvcHRpb25zIGhhbmRsaW5nIGZ1bmN0aW9uYWxpdHkgd2l0aCBjYWxsYmFjayBmb3Igb3B0aW9ucyBjaGFuZ2VzIHRyaWdnZXJlZCBieSByZXNwb25zaXZlIG9wdGlvbnMgYW5kIG1lZGlhIHF1ZXJ5IG1hdGNoZXNcbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBzZXQgYnkgdXNlclxuICAgKiBAcGFyYW0ge0FycmF5fSByZXNwb25zaXZlT3B0aW9ucyBPcHRpb25hbCBmdW5jdGlvbnMgdG8gYWRkIHJlc3BvbnNpdmUgYmVoYXZpb3IgdG8gY2hhcnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RW1pdHRlciBUaGUgZXZlbnQgZW1pdHRlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBlbWl0IHRoZSBvcHRpb25zIGNoYW5nZWQgZXZlbnRzXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnNvbGlkYXRlZCBvcHRpb25zIG9iamVjdCBmcm9tIHRoZSBkZWZhdWx0cywgYmFzZSBhbmQgbWF0Y2hpbmcgcmVzcG9uc2l2ZSBvcHRpb25zXG4gICAqL1xuICBDaGFydGlzdC5vcHRpb25zUHJvdmlkZXIgPSBmdW5jdGlvbiAob3B0aW9ucywgcmVzcG9uc2l2ZU9wdGlvbnMsIGV2ZW50RW1pdHRlcikge1xuICAgIHZhciBiYXNlT3B0aW9ucyA9IENoYXJ0aXN0LmV4dGVuZCh7fSwgb3B0aW9ucyksXG4gICAgICBjdXJyZW50T3B0aW9ucyxcbiAgICAgIG1lZGlhUXVlcnlMaXN0ZW5lcnMgPSBbXSxcbiAgICAgIGk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVDdXJyZW50T3B0aW9ucyhtZWRpYUV2ZW50KSB7XG4gICAgICB2YXIgcHJldmlvdXNPcHRpb25zID0gY3VycmVudE9wdGlvbnM7XG4gICAgICBjdXJyZW50T3B0aW9ucyA9IENoYXJ0aXN0LmV4dGVuZCh7fSwgYmFzZU9wdGlvbnMpO1xuXG4gICAgICBpZiAocmVzcG9uc2l2ZU9wdGlvbnMpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlc3BvbnNpdmVPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG1xbCA9IHdpbmRvdy5tYXRjaE1lZGlhKHJlc3BvbnNpdmVPcHRpb25zW2ldWzBdKTtcbiAgICAgICAgICBpZiAobXFsLm1hdGNoZXMpIHtcbiAgICAgICAgICAgIGN1cnJlbnRPcHRpb25zID0gQ2hhcnRpc3QuZXh0ZW5kKGN1cnJlbnRPcHRpb25zLCByZXNwb25zaXZlT3B0aW9uc1tpXVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGV2ZW50RW1pdHRlciAmJiBtZWRpYUV2ZW50KSB7XG4gICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdvcHRpb25zQ2hhbmdlZCcsIHtcbiAgICAgICAgICBwcmV2aW91c09wdGlvbnM6IHByZXZpb3VzT3B0aW9ucyxcbiAgICAgICAgICBjdXJyZW50T3B0aW9uczogY3VycmVudE9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlTWVkaWFRdWVyeUxpc3RlbmVycygpIHtcbiAgICAgIG1lZGlhUXVlcnlMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbihtcWwpIHtcbiAgICAgICAgbXFsLnJlbW92ZUxpc3RlbmVyKHVwZGF0ZUN1cnJlbnRPcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghd2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICAgIHRocm93ICd3aW5kb3cubWF0Y2hNZWRpYSBub3QgZm91bmQhIE1ha2Ugc3VyZSB5b3VcXCdyZSB1c2luZyBhIHBvbHlmaWxsLic7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zaXZlT3B0aW9ucykge1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcmVzcG9uc2l2ZU9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG1xbCA9IHdpbmRvdy5tYXRjaE1lZGlhKHJlc3BvbnNpdmVPcHRpb25zW2ldWzBdKTtcbiAgICAgICAgbXFsLmFkZExpc3RlbmVyKHVwZGF0ZUN1cnJlbnRPcHRpb25zKTtcbiAgICAgICAgbWVkaWFRdWVyeUxpc3RlbmVycy5wdXNoKG1xbCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEV4ZWN1dGUgaW5pdGlhbGx5IHdpdGhvdXQgYW4gZXZlbnQgYXJndW1lbnQgc28gd2UgZ2V0IHRoZSBjb3JyZWN0IG9wdGlvbnNcbiAgICB1cGRhdGVDdXJyZW50T3B0aW9ucygpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbW92ZU1lZGlhUXVlcnlMaXN0ZW5lcnM6IHJlbW92ZU1lZGlhUXVlcnlMaXN0ZW5lcnMsXG4gICAgICBnZXRDdXJyZW50T3B0aW9uczogZnVuY3Rpb24gZ2V0Q3VycmVudE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBDaGFydGlzdC5leHRlbmQoe30sIGN1cnJlbnRPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhIGxpc3Qgb2YgY29vcmRpbmF0ZXMgYW5kIGFzc29jaWF0ZWQgdmFsdWVzIGludG8gc2VnbWVudHMuIEVhY2ggcmV0dXJuZWQgc2VnbWVudCBjb250YWlucyBhIHBhdGhDb29yZGluYXRlc1xuICAgKiB2YWx1ZURhdGEgcHJvcGVydHkgZGVzY3JpYmluZyB0aGUgc2VnbWVudC5cbiAgICpcbiAgICogV2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zLCBzZWdtZW50cyBjb25zaXN0IG9mIGNvbnRpZ3VvdXMgc2V0cyBvZiBwb2ludHMgdGhhdCBkbyBub3QgaGF2ZSBhbiB1bmRlZmluZWQgdmFsdWUuIEFueVxuICAgKiBwb2ludHMgd2l0aCB1bmRlZmluZWQgdmFsdWVzIGFyZSBkaXNjYXJkZWQuXG4gICAqXG4gICAqICoqT3B0aW9ucyoqXG4gICAqIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgdXNlZCB0byBkZXRlcm1pbmUgaG93IHNlZ21lbnRzIGFyZSBmb3JtZWRcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgb3B0aW9ucyA9IHtcbiAgICogICAvLyBJZiBmaWxsSG9sZXMgaXMgdHJ1ZSwgdW5kZWZpbmVkIHZhbHVlcyBhcmUgc2ltcGx5IGRpc2NhcmRlZCB3aXRob3V0IGNyZWF0aW5nIGEgbmV3IHNlZ21lbnQuIEFzc3VtaW5nIG90aGVyIG9wdGlvbnMgYXJlIGRlZmF1bHQsIHRoaXMgcmV0dXJucyBzaW5nbGUgc2VnbWVudC5cbiAgICogICBmaWxsSG9sZXM6IGZhbHNlLFxuICAgKiAgIC8vIElmIGluY3JlYXNpbmdYIGlzIHRydWUsIHRoZSBjb29yZGluYXRlcyBpbiBhbGwgc2VnbWVudHMgaGF2ZSBzdHJpY3RseSBpbmNyZWFzaW5nIHgtdmFsdWVzLlxuICAgKiAgIGluY3JlYXNpbmdYOiBmYWxzZVxuICAgKiB9O1xuICAgKiBgYGBcbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHBhcmFtIHtBcnJheX0gcGF0aENvb3JkaW5hdGVzIExpc3Qgb2YgcG9pbnQgY29vcmRpbmF0ZXMgdG8gYmUgc3BsaXQgaW4gdGhlIGZvcm0gW3gxLCB5MSwgeDIsIHkyIC4uLiB4biwgeW5dXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBMaXN0IG9mIGFzc29jaWF0ZWQgcG9pbnQgdmFsdWVzIGluIHRoZSBmb3JtIFt2MSwgdjIgLi4gdm5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgc2V0IGJ5IHVzZXJcbiAgICogQHJldHVybiB7QXJyYXl9IExpc3Qgb2Ygc2VnbWVudHMsIGVhY2ggY29udGFpbmluZyBhIHBhdGhDb29yZGluYXRlcyBhbmQgdmFsdWVEYXRhIHByb3BlcnR5LlxuICAgKi9cbiAgQ2hhcnRpc3Quc3BsaXRJbnRvU2VnbWVudHMgPSBmdW5jdGlvbihwYXRoQ29vcmRpbmF0ZXMsIHZhbHVlRGF0YSwgb3B0aW9ucykge1xuICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGluY3JlYXNpbmdYOiBmYWxzZSxcbiAgICAgIGZpbGxIb2xlczogZmFsc2VcbiAgICB9O1xuXG4gICAgb3B0aW9ucyA9IENoYXJ0aXN0LmV4dGVuZCh7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgdmFyIGhvbGUgPSB0cnVlO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHBhdGhDb29yZGluYXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgLy8gSWYgdGhpcyB2YWx1ZSBpcyBhIFwiaG9sZVwiIHdlIHNldCB0aGUgaG9sZSBmbGFnXG4gICAgICBpZihDaGFydGlzdC5nZXRNdWx0aVZhbHVlKHZhbHVlRGF0YVtpIC8gMl0udmFsdWUpID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGlmKHZhbHVlRGF0YVtpIC8gMl0udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZighb3B0aW9ucy5maWxsSG9sZXMpIHtcbiAgICAgICAgICBob2xlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYob3B0aW9ucy5pbmNyZWFzaW5nWCAmJiBpID49IDIgJiYgcGF0aENvb3JkaW5hdGVzW2ldIDw9IHBhdGhDb29yZGluYXRlc1tpLTJdKSB7XG4gICAgICAgICAgLy8gWCBpcyBub3QgaW5jcmVhc2luZywgc28gd2UgbmVlZCB0byBtYWtlIHN1cmUgd2Ugc3RhcnQgYSBuZXcgc2VnbWVudFxuICAgICAgICAgIGhvbGUgPSB0cnVlO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBJZiBpdCdzIGEgdmFsaWQgdmFsdWUgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSdyZSBjb21pbmcgb3V0IG9mIGEgaG9sZSBhbmQgY3JlYXRlIGEgbmV3IGVtcHR5IHNlZ21lbnRcbiAgICAgICAgaWYoaG9sZSkge1xuICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgcGF0aENvb3JkaW5hdGVzOiBbXSxcbiAgICAgICAgICAgIHZhbHVlRGF0YTogW11cbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBBcyB3ZSBoYXZlIGEgdmFsaWQgdmFsdWUgbm93LCB3ZSBhcmUgbm90IGluIGEgXCJob2xlXCIgYW55bW9yZVxuICAgICAgICAgIGhvbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0byB0aGUgc2VnbWVudCBwYXRoQ29vcmRpbmF0ZXMgYW5kIHZhbHVlRGF0YVxuICAgICAgICBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS5wYXRoQ29vcmRpbmF0ZXMucHVzaChwYXRoQ29vcmRpbmF0ZXNbaV0sIHBhdGhDb29yZGluYXRlc1tpICsgMV0pO1xuICAgICAgICBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS52YWx1ZURhdGEucHVzaCh2YWx1ZURhdGFbaSAvIDJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VnbWVudHM7XG4gIH07XG59KHRoaXMgfHwgZ2xvYmFsLCBDaGFydGlzdCkpO1xuOy8qKlxuICogQ2hhcnRpc3QgcGF0aCBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9ucy5cbiAqXG4gKiBAbW9kdWxlIENoYXJ0aXN0LkludGVycG9sYXRpb25cbiAqL1xuLyogZ2xvYmFsIENoYXJ0aXN0ICovXG4oZnVuY3Rpb24oZ2xvYmFsUm9vdCwgQ2hhcnRpc3QpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIENoYXJ0aXN0LkludGVycG9sYXRpb24gPSB7fTtcblxuICAvKipcbiAgICogVGhpcyBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uIGRvZXMgbm90IHNtb290aCB0aGUgcGF0aCBhbmQgdGhlIHJlc3VsdCBpcyBvbmx5IGNvbnRhaW5pbmcgbGluZXMgYW5kIG5vIGN1cnZlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGNoYXJ0ID0gbmV3IENoYXJ0aXN0LkxpbmUoJy5jdC1jaGFydCcsIHtcbiAgICogICBsYWJlbHM6IFsxLCAyLCAzLCA0LCA1XSxcbiAgICogICBzZXJpZXM6IFtbMSwgMiwgOCwgMSwgN11dXG4gICAqIH0sIHtcbiAgICogICBsaW5lU21vb3RoOiBDaGFydGlzdC5JbnRlcnBvbGF0aW9uLm5vbmUoe1xuICAgKiAgICAgZmlsbEhvbGVzOiBmYWxzZVxuICAgKiAgIH0pXG4gICAqIH0pO1xuICAgKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuSW50ZXJwb2xhdGlvblxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4gIENoYXJ0aXN0LkludGVycG9sYXRpb24ubm9uZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBmaWxsSG9sZXM6IGZhbHNlXG4gICAgfTtcbiAgICBvcHRpb25zID0gQ2hhcnRpc3QuZXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5vbmUocGF0aENvb3JkaW5hdGVzLCB2YWx1ZURhdGEpIHtcbiAgICAgIHZhciBwYXRoID0gbmV3IENoYXJ0aXN0LlN2Zy5QYXRoKCk7XG4gICAgICB2YXIgaG9sZSA9IHRydWU7XG5cbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYXRoQ29vcmRpbmF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGN1cnJYID0gcGF0aENvb3JkaW5hdGVzW2ldO1xuICAgICAgICB2YXIgY3VyclkgPSBwYXRoQ29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgICB2YXIgY3VyckRhdGEgPSB2YWx1ZURhdGFbaSAvIDJdO1xuXG4gICAgICAgIGlmKENoYXJ0aXN0LmdldE11bHRpVmFsdWUoY3VyckRhdGEudmFsdWUpICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgIGlmKGhvbGUpIHtcbiAgICAgICAgICAgIHBhdGgubW92ZShjdXJyWCwgY3VyclksIGZhbHNlLCBjdXJyRGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgubGluZShjdXJyWCwgY3VyclksIGZhbHNlLCBjdXJyRGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaG9sZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYoIW9wdGlvbnMuZmlsbEhvbGVzKSB7XG4gICAgICAgICAgaG9sZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogU2ltcGxlIHNtb290aGluZyBjcmVhdGVzIGhvcml6b250YWwgaGFuZGxlcyB0aGF0IGFyZSBwb3NpdGlvbmVkIHdpdGggYSBmcmFjdGlvbiBvZiB0aGUgbGVuZ3RoIGJldHdlZW4gdHdvIGRhdGEgcG9pbnRzLiBZb3UgY2FuIHVzZSB0aGUgZGl2aXNvciBvcHRpb24gdG8gc3BlY2lmeSB0aGUgYW1vdW50IG9mIHNtb290aGluZy5cbiAgICpcbiAgICogU2ltcGxlIHNtb290aGluZyBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIGBDaGFydGlzdC5TbW9vdGhpbmcuY2FyZGluYWxgIGlmIHlvdSdkIGxpa2UgdG8gZ2V0IHJpZCBvZiB0aGUgYXJ0aWZhY3RzIGl0IHByb2R1Y2VzIHNvbWV0aW1lcy4gU2ltcGxlIHNtb290aGluZyBwcm9kdWNlcyBsZXNzIGZsb3dpbmcgbGluZXMgYnV0IGlzIGFjY3VyYXRlIGJ5IGhpdHRpbmcgdGhlIHBvaW50cyBhbmQgaXQgYWxzbyBkb2Vzbid0IHN3aW5nIGJlbG93IG9yIGFib3ZlIHRoZSBnaXZlbiBkYXRhIHBvaW50LlxuICAgKlxuICAgKiBBbGwgc21vb3RoaW5nIGZ1bmN0aW9ucyB3aXRoaW4gQ2hhcnRpc3QgYXJlIGZhY3RvcnkgZnVuY3Rpb25zIHRoYXQgYWNjZXB0IGFuIG9wdGlvbnMgcGFyYW1ldGVyLiBUaGUgc2ltcGxlIGludGVycG9sYXRpb24gZnVuY3Rpb24gYWNjZXB0cyBvbmUgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXIgYGRpdmlzb3JgLCBiZXR3ZWVuIDEgYW5kIOKIniwgd2hpY2ggY29udHJvbHMgdGhlIHNtb290aGluZyBjaGFyYWN0ZXJpc3RpY3MuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBjaGFydCA9IG5ldyBDaGFydGlzdC5MaW5lKCcuY3QtY2hhcnQnLCB7XG4gICAqICAgbGFiZWxzOiBbMSwgMiwgMywgNCwgNV0sXG4gICAqICAgc2VyaWVzOiBbWzEsIDIsIDgsIDEsIDddXVxuICAgKiB9LCB7XG4gICAqICAgbGluZVNtb290aDogQ2hhcnRpc3QuSW50ZXJwb2xhdGlvbi5zaW1wbGUoe1xuICAgKiAgICAgZGl2aXNvcjogMixcbiAgICogICAgIGZpbGxIb2xlczogZmFsc2VcbiAgICogICB9KVxuICAgKiB9KTtcbiAgICpcbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkludGVycG9sYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgb2YgdGhlIHNpbXBsZSBpbnRlcnBvbGF0aW9uIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgQ2hhcnRpc3QuSW50ZXJwb2xhdGlvbi5zaW1wbGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgZGl2aXNvcjogMixcbiAgICAgIGZpbGxIb2xlczogZmFsc2VcbiAgICB9O1xuICAgIG9wdGlvbnMgPSBDaGFydGlzdC5leHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblxuICAgIHZhciBkID0gMSAvIE1hdGgubWF4KDEsIG9wdGlvbnMuZGl2aXNvcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc2ltcGxlKHBhdGhDb29yZGluYXRlcywgdmFsdWVEYXRhKSB7XG4gICAgICB2YXIgcGF0aCA9IG5ldyBDaGFydGlzdC5TdmcuUGF0aCgpO1xuICAgICAgdmFyIHByZXZYLCBwcmV2WSwgcHJldkRhdGE7XG5cbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYXRoQ29vcmRpbmF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGN1cnJYID0gcGF0aENvb3JkaW5hdGVzW2ldO1xuICAgICAgICB2YXIgY3VyclkgPSBwYXRoQ29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgICB2YXIgbGVuZ3RoID0gKGN1cnJYIC0gcHJldlgpICogZDtcbiAgICAgICAgdmFyIGN1cnJEYXRhID0gdmFsdWVEYXRhW2kgLyAyXTtcblxuICAgICAgICBpZihjdXJyRGF0YS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICBpZihwcmV2RGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXRoLm1vdmUoY3VyclgsIGN1cnJZLCBmYWxzZSwgY3VyckRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoLmN1cnZlKFxuICAgICAgICAgICAgICBwcmV2WCArIGxlbmd0aCxcbiAgICAgICAgICAgICAgcHJldlksXG4gICAgICAgICAgICAgIGN1cnJYIC0gbGVuZ3RoLFxuICAgICAgICAgICAgICBjdXJyWSxcbiAgICAgICAgICAgICAgY3VyclgsXG4gICAgICAgICAgICAgIGN1cnJZLFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgY3VyckRhdGFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJldlggPSBjdXJyWDtcbiAgICAgICAgICBwcmV2WSA9IGN1cnJZO1xuICAgICAgICAgIHByZXZEYXRhID0gY3VyckRhdGE7XG4gICAgICAgIH0gZWxzZSBpZighb3B0aW9ucy5maWxsSG9sZXMpIHtcbiAgICAgICAgICBwcmV2WCA9IGN1cnJYID0gcHJldkRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FyZGluYWwgLyBDYXRtdWxsLVJvbWUgc3BsaW5lIGludGVycG9sYXRpb24gaXMgdGhlIGRlZmF1bHQgc21vb3RoaW5nIGZ1bmN0aW9uIGluIENoYXJ0aXN0LiBJdCBwcm9kdWNlcyBuaWNlIHJlc3VsdHMgd2hlcmUgdGhlIHNwbGluZXMgd2lsbCBhbHdheXMgbWVldCB0aGUgcG9pbnRzLiBJdCBwcm9kdWNlcyBzb21lIGFydGlmYWN0cyB0aG91Z2ggd2hlbiBkYXRhIHZhbHVlcyBhcmUgaW5jcmVhc2VkIG9yIGRlY3JlYXNlZCByYXBpZGx5LiBUaGUgbGluZSBtYXkgbm90IGZvbGxvdyBhIHZlcnkgYWNjdXJhdGUgcGF0aCBhbmQgaWYgdGhlIGxpbmUgc2hvdWxkIGJlIGFjY3VyYXRlIHRoaXMgc21vb3RoaW5nIGZ1bmN0aW9uIGRvZXMgbm90IHByb2R1Y2UgdGhlIGJlc3QgcmVzdWx0cy5cbiAgICpcbiAgICogQ2FyZGluYWwgc3BsaW5lcyBjYW4gb25seSBiZSBjcmVhdGVkIGlmIHRoZXJlIGFyZSBtb3JlIHRoYW4gdHdvIGRhdGEgcG9pbnRzLiBJZiB0aGlzIGlzIG5vdCB0aGUgY2FzZSB0aGlzIHNtb290aGluZyB3aWxsIGZhbGxiYWNrIHRvIGBDaGFydGlzdC5TbW9vdGhpbmcubm9uZWAuXG4gICAqXG4gICAqIEFsbCBzbW9vdGhpbmcgZnVuY3Rpb25zIHdpdGhpbiBDaGFydGlzdCBhcmUgZmFjdG9yeSBmdW5jdGlvbnMgdGhhdCBhY2NlcHQgYW4gb3B0aW9ucyBwYXJhbWV0ZXIuIFRoZSBjYXJkaW5hbCBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uIGFjY2VwdHMgb25lIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyIGB0ZW5zaW9uYCwgYmV0d2VlbiAwIGFuZCAxLCB3aGljaCBjb250cm9scyB0aGUgc21vb3RoaW5nIGludGVuc2l0eS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGNoYXJ0ID0gbmV3IENoYXJ0aXN0LkxpbmUoJy5jdC1jaGFydCcsIHtcbiAgICogICBsYWJlbHM6IFsxLCAyLCAzLCA0LCA1XSxcbiAgICogICBzZXJpZXM6IFtbMSwgMiwgOCwgMSwgN11dXG4gICAqIH0sIHtcbiAgICogICBsaW5lU21vb3RoOiBDaGFydGlzdC5JbnRlcnBvbGF0aW9uLmNhcmRpbmFsKHtcbiAgICogICAgIHRlbnNpb246IDEsXG4gICAqICAgICBmaWxsSG9sZXM6IGZhbHNlXG4gICAqICAgfSlcbiAgICogfSk7XG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5JbnRlcnBvbGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIG9mIHRoZSBjYXJkaW5hbCBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4gIENoYXJ0aXN0LkludGVycG9sYXRpb24uY2FyZGluYWwgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgdGVuc2lvbjogMSxcbiAgICAgIGZpbGxIb2xlczogZmFsc2VcbiAgICB9O1xuXG4gICAgb3B0aW9ucyA9IENoYXJ0aXN0LmV4dGVuZCh7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgdmFyIHQgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBvcHRpb25zLnRlbnNpb24pKSxcbiAgICAgIGMgPSAxIC0gdDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBjYXJkaW5hbChwYXRoQ29vcmRpbmF0ZXMsIHZhbHVlRGF0YSkge1xuICAgICAgLy8gRmlyc3Qgd2UgdHJ5IHRvIHNwbGl0IHRoZSBjb29yZGluYXRlcyBpbnRvIHNlZ21lbnRzXG4gICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byB0cmVhdCBcImhvbGVzXCIgaW4gbGluZSBjaGFydHNcbiAgICAgIHZhciBzZWdtZW50cyA9IENoYXJ0aXN0LnNwbGl0SW50b1NlZ21lbnRzKHBhdGhDb29yZGluYXRlcywgdmFsdWVEYXRhLCB7XG4gICAgICAgIGZpbGxIb2xlczogb3B0aW9ucy5maWxsSG9sZXNcbiAgICAgIH0pO1xuXG4gICAgICBpZighc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIHdlcmUgbm8gc2VnbWVudHMgcmV0dXJuICdDaGFydGlzdC5JbnRlcnBvbGF0aW9uLm5vbmUnXG4gICAgICAgIHJldHVybiBDaGFydGlzdC5JbnRlcnBvbGF0aW9uLm5vbmUoKShbXSk7XG4gICAgICB9IGVsc2UgaWYoc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBJZiB0aGUgc3BsaXQgcmVzdWx0ZWQgaW4gbW9yZSB0aGF0IG9uZSBzZWdtZW50IHdlIG5lZWQgdG8gaW50ZXJwb2xhdGUgZWFjaCBzZWdtZW50IGluZGl2aWR1YWxseSBhbmQgam9pbiB0aGVtXG4gICAgICAgIC8vIGFmdGVyd2FyZHMgdG9nZXRoZXIgaW50byBhIHNpbmdsZSBwYXRoLlxuICAgICAgICAgIHZhciBwYXRocyA9IFtdO1xuICAgICAgICAvLyBGb3IgZWFjaCBzZWdtZW50IHdlIHdpbGwgcmVjdXJzZSB0aGUgY2FyZGluYWwgZnVuY3Rpb25cbiAgICAgICAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbihzZWdtZW50KSB7XG4gICAgICAgICAgcGF0aHMucHVzaChjYXJkaW5hbChzZWdtZW50LnBhdGhDb29yZGluYXRlcywgc2VnbWVudC52YWx1ZURhdGEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEpvaW4gdGhlIHNlZ21lbnQgcGF0aCBkYXRhIGludG8gYSBzaW5nbGUgcGF0aCBhbmQgcmV0dXJuXG4gICAgICAgIHJldHVybiBDaGFydGlzdC5TdmcuUGF0aC5qb2luKHBhdGhzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBvbmx5IG9uZSBzZWdtZW50IHdlIGNhbiBwcm9jZWVkIHJlZ3VsYXJseSBieSB1c2luZyBwYXRoQ29vcmRpbmF0ZXMgYW5kIHZhbHVlRGF0YSBmcm9tIHRoZSBmaXJzdFxuICAgICAgICAvLyBzZWdtZW50XG4gICAgICAgIHBhdGhDb29yZGluYXRlcyA9IHNlZ21lbnRzWzBdLnBhdGhDb29yZGluYXRlcztcbiAgICAgICAgdmFsdWVEYXRhID0gc2VnbWVudHNbMF0udmFsdWVEYXRhO1xuXG4gICAgICAgIC8vIElmIGxlc3MgdGhhbiB0d28gcG9pbnRzIHdlIG5lZWQgdG8gZmFsbGJhY2sgdG8gbm8gc21vb3RoaW5nXG4gICAgICAgIGlmKHBhdGhDb29yZGluYXRlcy5sZW5ndGggPD0gNCkge1xuICAgICAgICAgIHJldHVybiBDaGFydGlzdC5JbnRlcnBvbGF0aW9uLm5vbmUoKShwYXRoQ29vcmRpbmF0ZXMsIHZhbHVlRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aCA9IG5ldyBDaGFydGlzdC5TdmcuUGF0aCgpLm1vdmUocGF0aENvb3JkaW5hdGVzWzBdLCBwYXRoQ29vcmRpbmF0ZXNbMV0sIGZhbHNlLCB2YWx1ZURhdGFbMF0pLFxuICAgICAgICAgIHo7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBwYXRoQ29vcmRpbmF0ZXMubGVuZ3RoOyBpTGVuIC0gMiAqICF6ID4gaTsgaSArPSAyKSB7XG4gICAgICAgICAgdmFyIHAgPSBbXG4gICAgICAgICAgICB7eDogK3BhdGhDb29yZGluYXRlc1tpIC0gMl0sIHk6ICtwYXRoQ29vcmRpbmF0ZXNbaSAtIDFdfSxcbiAgICAgICAgICAgIHt4OiArcGF0aENvb3JkaW5hdGVzW2ldLCB5OiArcGF0aENvb3JkaW5hdGVzW2kgKyAxXX0sXG4gICAgICAgICAgICB7eDogK3BhdGhDb29yZGluYXRlc1tpICsgMl0sIHk6ICtwYXRoQ29vcmRpbmF0ZXNbaSArIDNdfSxcbiAgICAgICAgICAgIHt4OiArcGF0aENvb3JkaW5hdGVzW2kgKyA0XSwgeTogK3BhdGhDb29yZGluYXRlc1tpICsgNV19XG4gICAgICAgICAgXTtcbiAgICAgICAgICBpZiAoeikge1xuICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgIHBbMF0gPSB7eDogK3BhdGhDb29yZGluYXRlc1tpTGVuIC0gMl0sIHk6ICtwYXRoQ29vcmRpbmF0ZXNbaUxlbiAtIDFdfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaUxlbiAtIDQgPT09IGkpIHtcbiAgICAgICAgICAgICAgcFszXSA9IHt4OiArcGF0aENvb3JkaW5hdGVzWzBdLCB5OiArcGF0aENvb3JkaW5hdGVzWzFdfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaUxlbiAtIDIgPT09IGkpIHtcbiAgICAgICAgICAgICAgcFsyXSA9IHt4OiArcGF0aENvb3JkaW5hdGVzWzBdLCB5OiArcGF0aENvb3JkaW5hdGVzWzFdfTtcbiAgICAgICAgICAgICAgcFszXSA9IHt4OiArcGF0aENvb3JkaW5hdGVzWzJdLCB5OiArcGF0aENvb3JkaW5hdGVzWzNdfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlMZW4gLSA0ID09PSBpKSB7XG4gICAgICAgICAgICAgIHBbM10gPSBwWzJdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaSkge1xuICAgICAgICAgICAgICBwWzBdID0ge3g6ICtwYXRoQ29vcmRpbmF0ZXNbaV0sIHk6ICtwYXRoQ29vcmRpbmF0ZXNbaSArIDFdfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoLmN1cnZlKFxuICAgICAgICAgICAgKHQgKiAoLXBbMF0ueCArIDYgKiBwWzFdLnggKyBwWzJdLngpIC8gNikgKyAoYyAqIHBbMl0ueCksXG4gICAgICAgICAgICAodCAqICgtcFswXS55ICsgNiAqIHBbMV0ueSArIHBbMl0ueSkgLyA2KSArIChjICogcFsyXS55KSxcbiAgICAgICAgICAgICh0ICogKHBbMV0ueCArIDYgKiBwWzJdLnggLSBwWzNdLngpIC8gNikgKyAoYyAqIHBbMl0ueCksXG4gICAgICAgICAgICAodCAqIChwWzFdLnkgKyA2ICogcFsyXS55IC0gcFszXS55KSAvIDYpICsgKGMgKiBwWzJdLnkpLFxuICAgICAgICAgICAgcFsyXS54LFxuICAgICAgICAgICAgcFsyXS55LFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZURhdGFbKGkgKyAyKSAvIDJdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vbm90b25lIEN1YmljIHNwbGluZSBpbnRlcnBvbGF0aW9uIHByb2R1Y2VzIGEgc21vb3RoIGN1cnZlIHdoaWNoIHByZXNlcnZlcyBtb25vdG9uaWNpdHkuIFVubGlrZSBjYXJkaW5hbCBzcGxpbmVzLCB0aGUgY3VydmUgd2lsbCBub3QgZXh0ZW5kIGJleW9uZCB0aGUgcmFuZ2Ugb2YgeS12YWx1ZXMgb2YgdGhlIG9yaWdpbmFsIGRhdGEgcG9pbnRzLlxuICAgKlxuICAgKiBNb25vdG9uZSBDdWJpYyBzcGxpbmVzIGNhbiBvbmx5IGJlIGNyZWF0ZWQgaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiB0d28gZGF0YSBwb2ludHMuIElmIHRoaXMgaXMgbm90IHRoZSBjYXNlIHRoaXMgc21vb3RoaW5nIHdpbGwgZmFsbGJhY2sgdG8gYENoYXJ0aXN0LlNtb290aGluZy5ub25lYC5cbiAgICpcbiAgICogVGhlIHgtdmFsdWVzIG9mIHN1YnNlcXVlbnQgcG9pbnRzIG11c3QgYmUgaW5jcmVhc2luZyB0byBmaXQgYSBNb25vdG9uZSBDdWJpYyBzcGxpbmUuIElmIHRoaXMgY29uZGl0aW9uIGlzIG5vdCBtZXQgZm9yIGEgcGFpciBvZiBhZGphY2VudCBwb2ludHMsIHRoZW4gdGhlcmUgd2lsbCBiZSBhIGJyZWFrIGluIHRoZSBjdXJ2ZSBiZXR3ZWVuIHRob3NlIGRhdGEgcG9pbnRzLlxuICAgKlxuICAgKiBBbGwgc21vb3RoaW5nIGZ1bmN0aW9ucyB3aXRoaW4gQ2hhcnRpc3QgYXJlIGZhY3RvcnkgZnVuY3Rpb25zIHRoYXQgYWNjZXB0IGFuIG9wdGlvbnMgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgY2hhcnQgPSBuZXcgQ2hhcnRpc3QuTGluZSgnLmN0LWNoYXJ0Jywge1xuICAgKiAgIGxhYmVsczogWzEsIDIsIDMsIDQsIDVdLFxuICAgKiAgIHNlcmllczogW1sxLCAyLCA4LCAxLCA3XV1cbiAgICogfSwge1xuICAgKiAgIGxpbmVTbW9vdGg6IENoYXJ0aXN0LkludGVycG9sYXRpb24ubW9ub3RvbmVDdWJpYyh7XG4gICAqICAgICBmaWxsSG9sZXM6IGZhbHNlXG4gICAqICAgfSlcbiAgICogfSk7XG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5JbnRlcnBvbGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIG9mIHRoZSBtb25vdG9uZUN1YmljIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgQ2hhcnRpc3QuSW50ZXJwb2xhdGlvbi5tb25vdG9uZUN1YmljID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGZpbGxIb2xlczogZmFsc2VcbiAgICB9O1xuXG4gICAgb3B0aW9ucyA9IENoYXJ0aXN0LmV4dGVuZCh7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1vbm90b25lQ3ViaWMocGF0aENvb3JkaW5hdGVzLCB2YWx1ZURhdGEpIHtcbiAgICAgIC8vIEZpcnN0IHdlIHRyeSB0byBzcGxpdCB0aGUgY29vcmRpbmF0ZXMgaW50byBzZWdtZW50c1xuICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gdHJlYXQgXCJob2xlc1wiIGluIGxpbmUgY2hhcnRzXG4gICAgICB2YXIgc2VnbWVudHMgPSBDaGFydGlzdC5zcGxpdEludG9TZWdtZW50cyhwYXRoQ29vcmRpbmF0ZXMsIHZhbHVlRGF0YSwge1xuICAgICAgICBmaWxsSG9sZXM6IG9wdGlvbnMuZmlsbEhvbGVzLFxuICAgICAgICBpbmNyZWFzaW5nWDogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgd2VyZSBubyBzZWdtZW50cyByZXR1cm4gJ0NoYXJ0aXN0LkludGVycG9sYXRpb24ubm9uZSdcbiAgICAgICAgcmV0dXJuIENoYXJ0aXN0LkludGVycG9sYXRpb24ubm9uZSgpKFtdKTtcbiAgICAgIH0gZWxzZSBpZihzZWdtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIElmIHRoZSBzcGxpdCByZXN1bHRlZCBpbiBtb3JlIHRoYXQgb25lIHNlZ21lbnQgd2UgbmVlZCB0byBpbnRlcnBvbGF0ZSBlYWNoIHNlZ21lbnQgaW5kaXZpZHVhbGx5IGFuZCBqb2luIHRoZW1cbiAgICAgICAgLy8gYWZ0ZXJ3YXJkcyB0b2dldGhlciBpbnRvIGEgc2luZ2xlIHBhdGguXG4gICAgICAgICAgdmFyIHBhdGhzID0gW107XG4gICAgICAgIC8vIEZvciBlYWNoIHNlZ21lbnQgd2Ugd2lsbCByZWN1cnNlIHRoZSBtb25vdG9uZUN1YmljIGZuIGZ1bmN0aW9uXG4gICAgICAgIHNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24oc2VnbWVudCkge1xuICAgICAgICAgIHBhdGhzLnB1c2gobW9ub3RvbmVDdWJpYyhzZWdtZW50LnBhdGhDb29yZGluYXRlcywgc2VnbWVudC52YWx1ZURhdGEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEpvaW4gdGhlIHNlZ21lbnQgcGF0aCBkYXRhIGludG8gYSBzaW5nbGUgcGF0aCBhbmQgcmV0dXJuXG4gICAgICAgIHJldHVybiBDaGFydGlzdC5TdmcuUGF0aC5qb2luKHBhdGhzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBvbmx5IG9uZSBzZWdtZW50IHdlIGNhbiBwcm9jZWVkIHJlZ3VsYXJseSBieSB1c2luZyBwYXRoQ29vcmRpbmF0ZXMgYW5kIHZhbHVlRGF0YSBmcm9tIHRoZSBmaXJzdFxuICAgICAgICAvLyBzZWdtZW50XG4gICAgICAgIHBhdGhDb29yZGluYXRlcyA9IHNlZ21lbnRzWzBdLnBhdGhDb29yZGluYXRlcztcbiAgICAgICAgdmFsdWVEYXRhID0gc2VnbWVudHNbMF0udmFsdWVEYXRhO1xuXG4gICAgICAgIC8vIElmIGxlc3MgdGhhbiB0aHJlZSBwb2ludHMgd2UgbmVlZCB0byBmYWxsYmFjayB0byBubyBzbW9vdGhpbmdcbiAgICAgICAgaWYocGF0aENvb3JkaW5hdGVzLmxlbmd0aCA8PSA0KSB7XG4gICAgICAgICAgcmV0dXJuIENoYXJ0aXN0LkludGVycG9sYXRpb24ubm9uZSgpKHBhdGhDb29yZGluYXRlcywgdmFsdWVEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4cyA9IFtdLFxuICAgICAgICAgIHlzID0gW10sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBuID0gcGF0aENvb3JkaW5hdGVzLmxlbmd0aCAvIDIsXG4gICAgICAgICAgbXMgPSBbXSxcbiAgICAgICAgICBkcyA9IFtdLCBkeXMgPSBbXSwgZHhzID0gW10sXG4gICAgICAgICAgcGF0aDtcblxuICAgICAgICAvLyBQb3B1bGF0ZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGludG8gc2VwYXJhdGUgYXJyYXlzLCBmb3IgcmVhZGFiaWxpdHlcblxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICB4c1tpXSA9IHBhdGhDb29yZGluYXRlc1tpICogMl07XG4gICAgICAgICAgeXNbaV0gPSBwYXRoQ29vcmRpbmF0ZXNbaSAqIDIgKyAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBkZWx0YXMgYW5kIGRlcml2YXRpdmVcblxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBuIC0gMTsgaSsrKSB7XG4gICAgICAgICAgZHlzW2ldID0geXNbaSArIDFdIC0geXNbaV07XG4gICAgICAgICAgZHhzW2ldID0geHNbaSArIDFdIC0geHNbaV07XG4gICAgICAgICAgZHNbaV0gPSBkeXNbaV0gLyBkeHNbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgZGVzaXJlZCBzbG9wZSAobSkgYXQgZWFjaCBwb2ludCB1c2luZyBGcml0c2NoLUNhcmxzb24gbWV0aG9kXG4gICAgICAgIC8vIFNlZTogaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzQ1MjE4L2ltcGxlbWVudGF0aW9uLW9mLW1vbm90b25lLWN1YmljLWludGVycG9sYXRpb25cblxuICAgICAgICBtc1swXSA9IGRzWzBdO1xuICAgICAgICBtc1tuIC0gMV0gPSBkc1tuIC0gMl07XG5cbiAgICAgICAgZm9yKGkgPSAxOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgICAgIGlmKGRzW2ldID09PSAwIHx8IGRzW2kgLSAxXSA9PT0gMCB8fCAoZHNbaSAtIDFdID4gMCkgIT09IChkc1tpXSA+IDApKSB7XG4gICAgICAgICAgICBtc1tpXSA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1zW2ldID0gMyAqIChkeHNbaSAtIDFdICsgZHhzW2ldKSAvIChcbiAgICAgICAgICAgICAgKDIgKiBkeHNbaV0gKyBkeHNbaSAtIDFdKSAvIGRzW2kgLSAxXSArXG4gICAgICAgICAgICAgIChkeHNbaV0gKyAyICogZHhzW2kgLSAxXSkgLyBkc1tpXSk7XG5cbiAgICAgICAgICAgIGlmKCFpc0Zpbml0ZShtc1tpXSkpIHtcbiAgICAgICAgICAgICAgbXNbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyBidWlsZCBhIHBhdGggZnJvbSB0aGUgc2xvcGVzXG5cbiAgICAgICAgcGF0aCA9IG5ldyBDaGFydGlzdC5TdmcuUGF0aCgpLm1vdmUoeHNbMF0sIHlzWzBdLCBmYWxzZSwgdmFsdWVEYXRhWzBdKTtcblxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBuIC0gMTsgaSsrKSB7XG4gICAgICAgICAgcGF0aC5jdXJ2ZShcbiAgICAgICAgICAgIC8vIEZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgIHhzW2ldICsgZHhzW2ldIC8gMyxcbiAgICAgICAgICAgIHlzW2ldICsgbXNbaV0gKiBkeHNbaV0gLyAzLFxuICAgICAgICAgICAgLy8gU2Vjb25kIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgIHhzW2kgKyAxXSAtIGR4c1tpXSAvIDMsXG4gICAgICAgICAgICB5c1tpICsgMV0gLSBtc1tpICsgMV0gKiBkeHNbaV0gLyAzLFxuICAgICAgICAgICAgLy8gRW5kIHBvaW50XG4gICAgICAgICAgICB4c1tpICsgMV0sXG4gICAgICAgICAgICB5c1tpICsgMV0sXG5cbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgdmFsdWVEYXRhW2kgKyAxXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdGVwIGludGVycG9sYXRpb24gd2lsbCBjYXVzZSB0aGUgbGluZSBjaGFydCB0byBtb3ZlIGluIHN0ZXBzIHJhdGhlciB0aGFuIGRpYWdvbmFsIG9yIHNtb290aGVkIGxpbmVzLiBUaGlzIGludGVycG9sYXRpb24gd2lsbCBjcmVhdGUgYWRkaXRpb25hbCBwb2ludHMgdGhhdCB3aWxsIGFsc28gYmUgZHJhd24gd2hlbiB0aGUgYHNob3dQb2ludGAgb3B0aW9uIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEFsbCBzbW9vdGhpbmcgZnVuY3Rpb25zIHdpdGhpbiBDaGFydGlzdCBhcmUgZmFjdG9yeSBmdW5jdGlvbnMgdGhhdCBhY2NlcHQgYW4gb3B0aW9ucyBwYXJhbWV0ZXIuIFRoZSBzdGVwIGludGVycG9sYXRpb24gZnVuY3Rpb24gYWNjZXB0cyBvbmUgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXIgYHBvc3Rwb25lYCwgdGhhdCBjYW4gYmUgYHRydWVgIG9yIGBmYWxzZWAuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlYCBhbmQgd2lsbCBjYXVzZSB0aGUgc3RlcCB0byBvY2N1ciB3aGVyZSB0aGUgdmFsdWUgYWN0dWFsbHkgY2hhbmdlcy4gSWYgYSBkaWZmZXJlbnQgYmVoYXZpb3VyIGlzIG5lZWRlZCB3aGVyZSB0aGUgc3RlcCBpcyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGFuZCBoYXBwZW5zIGJlZm9yZSB0aGUgYWN0dWFsIHZhbHVlLCB0aGlzIG9wdGlvbiBjYW4gYmUgc2V0IHRvIGBmYWxzZWAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBjaGFydCA9IG5ldyBDaGFydGlzdC5MaW5lKCcuY3QtY2hhcnQnLCB7XG4gICAqICAgbGFiZWxzOiBbMSwgMiwgMywgNCwgNV0sXG4gICAqICAgc2VyaWVzOiBbWzEsIDIsIDgsIDEsIDddXVxuICAgKiB9LCB7XG4gICAqICAgbGluZVNtb290aDogQ2hhcnRpc3QuSW50ZXJwb2xhdGlvbi5zdGVwKHtcbiAgICogICAgIHBvc3Rwb25lOiB0cnVlLFxuICAgKiAgICAgZmlsbEhvbGVzOiBmYWxzZVxuICAgKiAgIH0pXG4gICAqIH0pO1xuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuSW50ZXJwb2xhdGlvblxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqL1xuICBDaGFydGlzdC5JbnRlcnBvbGF0aW9uLnN0ZXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgcG9zdHBvbmU6IHRydWUsXG4gICAgICBmaWxsSG9sZXM6IGZhbHNlXG4gICAgfTtcblxuICAgIG9wdGlvbnMgPSBDaGFydGlzdC5leHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBzdGVwKHBhdGhDb29yZGluYXRlcywgdmFsdWVEYXRhKSB7XG4gICAgICB2YXIgcGF0aCA9IG5ldyBDaGFydGlzdC5TdmcuUGF0aCgpO1xuXG4gICAgICB2YXIgcHJldlgsIHByZXZZLCBwcmV2RGF0YTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoQ29vcmRpbmF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGN1cnJYID0gcGF0aENvb3JkaW5hdGVzW2ldO1xuICAgICAgICB2YXIgY3VyclkgPSBwYXRoQ29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgICB2YXIgY3VyckRhdGEgPSB2YWx1ZURhdGFbaSAvIDJdO1xuXG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IHBvaW50IGlzIGFsc28gbm90IGEgaG9sZSB3ZSBjYW4gZHJhdyB0aGUgc3RlcCBsaW5lc1xuICAgICAgICBpZihjdXJyRGF0YS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYocHJldkRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGF0aC5tb3ZlKGN1cnJYLCBjdXJyWSwgZmFsc2UsIGN1cnJEYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYob3B0aW9ucy5wb3N0cG9uZSkge1xuICAgICAgICAgICAgICAvLyBJZiBwb3N0cG9uZWQgd2Ugc2hvdWxkIGRyYXcgdGhlIHN0ZXAgbGluZSB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICAgICAgICAgICAgcGF0aC5saW5lKGN1cnJYLCBwcmV2WSwgZmFsc2UsIHByZXZEYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIElmIG5vdCBwb3N0cG9uZWQgd2Ugc2hvdWxkIGRyYXcgdGhlIHN0ZXAgbGluZSB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCB2YWx1ZVxuICAgICAgICAgICAgICBwYXRoLmxpbmUocHJldlgsIGN1cnJZLCBmYWxzZSwgY3VyckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGluZSB0byB0aGUgYWN0dWFsIHBvaW50ICh0aGlzIHNob3VsZCBvbmx5IGJlIGEgWS1BeGlzIG1vdmVtZW50XG4gICAgICAgICAgICBwYXRoLmxpbmUoY3VyclgsIGN1cnJZLCBmYWxzZSwgY3VyckRhdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHByZXZYID0gY3Vyclg7XG4gICAgICAgICAgcHJldlkgPSBjdXJyWTtcbiAgICAgICAgICBwcmV2RGF0YSA9IGN1cnJEYXRhO1xuICAgICAgICB9IGVsc2UgaWYoIW9wdGlvbnMuZmlsbEhvbGVzKSB7XG4gICAgICAgICAgcHJldlggPSBwcmV2WSA9IHByZXZEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG4gIH07XG5cbn0odGhpcyB8fCBnbG9iYWwsIENoYXJ0aXN0KSk7XG47LyoqXG4gKiBBIHZlcnkgYmFzaWMgZXZlbnQgbW9kdWxlIHRoYXQgaGVscHMgdG8gZ2VuZXJhdGUgYW5kIGNhdGNoIGV2ZW50cy5cbiAqXG4gKiBAbW9kdWxlIENoYXJ0aXN0LkV2ZW50XG4gKi9cbi8qIGdsb2JhbCBDaGFydGlzdCAqL1xuKGZ1bmN0aW9uIChnbG9iYWxSb290LCBDaGFydGlzdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgQ2hhcnRpc3QuRXZlbnRFbWl0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVycyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IGhhbmRsZXIgZm9yIGEgc3BlY2lmaWMgZXZlbnRcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDaGFydGlzdC5FdmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgQSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICBoYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgaGFuZGxlciBvZiBhIHNwZWNpZmljIGV2ZW50IG5hbWUgb3IgcmVtb3ZlIGFsbCBldmVudCBoYW5kbGVycyBmb3IgYSBzcGVjaWZpYyBldmVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDaGFydGlzdC5FdmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZSB3aGVyZSBhIHNwZWNpZmljIG9yIGFsbCBoYW5kbGVycyBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXSBBbiBvcHRpb25hbCBldmVudCBoYW5kbGVyIGZ1bmN0aW9uLiBJZiBzcGVjaWZpZWQgb25seSB0aGlzIHNwZWNpZmljIGhhbmRsZXIgd2lsbCBiZSByZW1vdmVkIGFuZCBvdGhlcndpc2UgYWxsIGhhbmRsZXJzIGFyZSByZW1vdmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcikge1xuICAgICAgLy8gT25seSBkbyBzb21ldGhpbmcgaWYgdGhlcmUgYXJlIGV2ZW50IGhhbmRsZXJzIHdpdGggdGhpcyBuYW1lIGV4aXN0aW5nXG4gICAgICBpZihoYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgLy8gSWYgaGFuZGxlciBpcyBzZXQgd2Ugd2lsbCBsb29rIGZvciBhIHNwZWNpZmljIGhhbmRsZXIgYW5kIG9ubHkgcmVtb3ZlIHRoaXNcbiAgICAgICAgaWYoaGFuZGxlcikge1xuICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaGFuZGxlcnNbZXZlbnRdLmluZGV4T2YoaGFuZGxlciksIDEpO1xuICAgICAgICAgIGlmKGhhbmRsZXJzW2V2ZW50XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIG5vIGhhbmRsZXIgaXMgc3BlY2lmaWVkIHdlIHJlbW92ZSBhbGwgaGFuZGxlcnMgZm9yIHRoaXMgZXZlbnRcbiAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgZnVuY3Rpb24gdG8gZW1pdCBhbiBldmVudC4gQWxsIGhhbmRsZXJzIHRoYXQgYXJlIGxpc3RlbmluZyBmb3IgdGhpcyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCB3aXRoIHRoZSBkYXRhIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDaGFydGlzdC5FdmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZSB0aGF0IHNob3VsZCBiZSB0cmlnZ2VyZWRcbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgQXJiaXRyYXJ5IGRhdGEgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZXZlbnQgaGFuZGxlciBjYWxsYmFjayBmdW5jdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbWl0KGV2ZW50LCBkYXRhKSB7XG4gICAgICAvLyBPbmx5IGRvIHNvbWV0aGluZyBpZiB0aGVyZSBhcmUgZXZlbnQgaGFuZGxlcnMgd2l0aCB0aGlzIG5hbWUgZXhpc3RpbmdcbiAgICAgIGlmKGhhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICBoYW5kbGVyc1tldmVudF0uZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgaGFuZGxlcihkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEVtaXQgZXZlbnQgdG8gc3RhciBldmVudCBoYW5kbGVyc1xuICAgICAgaWYoaGFuZGxlcnNbJyonXSkge1xuICAgICAgICBoYW5kbGVyc1snKiddLmZvckVhY2goZnVuY3Rpb24oc3RhckhhbmRsZXIpIHtcbiAgICAgICAgICBzdGFySGFuZGxlcihldmVudCwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhZGRFdmVudEhhbmRsZXI6IGFkZEV2ZW50SGFuZGxlcixcbiAgICAgIHJlbW92ZUV2ZW50SGFuZGxlcjogcmVtb3ZlRXZlbnRIYW5kbGVyLFxuICAgICAgZW1pdDogZW1pdFxuICAgIH07XG4gIH07XG5cbn0odGhpcyB8fCBnbG9iYWwsIENoYXJ0aXN0KSk7XG47LyoqXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBzb21lIGJhc2ljIHByb3RvdHlwZSBpbmhlcml0YW5jZSB1dGlsaXRpZXMuXG4gKlxuICogQG1vZHVsZSBDaGFydGlzdC5DbGFzc1xuICovXG4vKiBnbG9iYWwgQ2hhcnRpc3QgKi9cbihmdW5jdGlvbihnbG9iYWxSb290LCBDaGFydGlzdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gbGlzdFRvQXJyYXkobGlzdCkge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBpZiAobGlzdC5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnIucHVzaChsaXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gZXh0ZW5kIGZyb20gY3VycmVudCBwcm90b3R5cGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5DbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBUaGUgb2JqZWN0IHRoYXQgc2VydmVzIGFzIGRlZmluaXRpb24gZm9yIHRoZSBwcm90b3R5cGUgdGhhdCBnZXRzIGNyZWF0ZWQgZm9yIHRoZSBuZXcgY2xhc3MuIFRoaXMgb2JqZWN0IHNob3VsZCBhbHdheXMgY29udGFpbiBhIGNvbnN0cnVjdG9yIHByb3BlcnR5IHRoYXQgaXMgdGhlIGRlc2lyZWQgY29uc3RydWN0b3IgZm9yIHRoZSBuZXdseSBjcmVhdGVkIGNsYXNzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3N1cGVyUHJvdG9PdmVycmlkZV0gQnkgZGVmYXVsdCBleHRlbnMgd2lsbCB1c2UgdGhlIGN1cnJlbnQgY2xhc3MgcHJvdG90eXBlIG9yIENoYXJ0aXN0LmNsYXNzLiBXaXRoIHRoaXMgcGFyYW1ldGVyIHlvdSBjYW4gc3BlY2lmeSBhbnkgc3VwZXIgcHJvdG90eXBlIHRoYXQgd2lsbCBiZSB1c2VkLlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQ29uc3RydWN0b3IgZnVuY3Rpb24gb2YgdGhlIG5ldyBjbGFzc1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgRnJ1aXQgPSBDbGFzcy5leHRlbmQoe1xuICAgICAqIGNvbG9yOiB1bmRlZmluZWQsXG4gICAgICogICBzdWdhcjogdW5kZWZpbmVkLFxuICAgICAqXG4gICAgICogICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oY29sb3IsIHN1Z2FyKSB7XG4gICAgICogICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgKiAgICAgdGhpcy5zdWdhciA9IHN1Z2FyO1xuICAgICAqICAgfSxcbiAgICAgKlxuICAgICAqICAgZWF0OiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgdGhpcy5zdWdhciA9IDA7XG4gICAgICogICAgIHJldHVybiB0aGlzO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgKlxuICAgKiB2YXIgQmFuYW5hID0gRnJ1aXQuZXh0ZW5kKHtcbiAgICAgKiAgIGxlbmd0aDogdW5kZWZpbmVkLFxuICAgICAqXG4gICAgICogICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24obGVuZ3RoLCBzdWdhcikge1xuICAgICAqICAgICBCYW5hbmEuc3VwZXIuY29uc3RydWN0b3IuY2FsbCh0aGlzLCAnWWVsbG93Jywgc3VnYXIpO1xuICAgICAqICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICpcbiAgICogdmFyIGJhbmFuYSA9IG5ldyBCYW5hbmEoMjAsIDQwKTtcbiAgICogY29uc29sZS5sb2coJ2JhbmFuYSBpbnN0YW5jZW9mIEZydWl0JywgYmFuYW5hIGluc3RhbmNlb2YgRnJ1aXQpO1xuICAgKiBjb25zb2xlLmxvZygnRnJ1aXQgaXMgcHJvdG90eXBlIG9mIGJhbmFuYScsIEZydWl0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJhbmFuYSkpO1xuICAgKiBjb25zb2xlLmxvZygnYmFuYW5hcyBwcm90b3R5cGUgaXMgRnJ1aXQnLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFuYW5hKSA9PT0gRnJ1aXQucHJvdG90eXBlKTtcbiAgICogY29uc29sZS5sb2coYmFuYW5hLnN1Z2FyKTtcbiAgICogY29uc29sZS5sb2coYmFuYW5hLmVhdCgpLnN1Z2FyKTtcbiAgICogY29uc29sZS5sb2coYmFuYW5hLmNvbG9yKTtcbiAgICovXG4gIGZ1bmN0aW9uIGV4dGVuZChwcm9wZXJ0aWVzLCBzdXBlclByb3RvT3ZlcnJpZGUpIHtcbiAgICB2YXIgc3VwZXJQcm90byA9IHN1cGVyUHJvdG9PdmVycmlkZSB8fCB0aGlzLnByb3RvdHlwZSB8fCBDaGFydGlzdC5DbGFzcztcbiAgICB2YXIgcHJvdG8gPSBPYmplY3QuY3JlYXRlKHN1cGVyUHJvdG8pO1xuXG4gICAgQ2hhcnRpc3QuQ2xhc3MuY2xvbmVEZWZpbml0aW9ucyhwcm90bywgcHJvcGVydGllcyk7XG5cbiAgICB2YXIgY29uc3RyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZm4gPSBwcm90by5jb25zdHJ1Y3RvciB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgaW5zdGFuY2U7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgbGlua2VkIHRvIHRoZSBDaGFydGlzdCBuYW1lc3BhY2UgdGhlIGNvbnN0cnVjdG9yIHdhcyBub3QgY2FsbGVkIHdpdGggbmV3XG4gICAgICAvLyBUbyBwcm92aWRlIGEgZmFsbGJhY2sgd2Ugd2lsbCBpbnN0YW50aWF0ZSBoZXJlIGFuZCByZXR1cm4gdGhlIGluc3RhbmNlXG4gICAgICBpbnN0YW5jZSA9IHRoaXMgPT09IENoYXJ0aXN0ID8gT2JqZWN0LmNyZWF0ZShwcm90bykgOiB0aGlzO1xuICAgICAgZm4uYXBwbHkoaW5zdGFuY2UsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAvLyBJZiB0aGlzIGNvbnN0cnVjdG9yIHdhcyBub3QgY2FsbGVkIHdpdGggbmV3IHdlIG5lZWQgdG8gcmV0dXJuIHRoZSBpbnN0YW5jZVxuICAgICAgLy8gVGhpcyB3aWxsIG5vdCBoYXJtIHdoZW4gdGhlIGNvbnN0cnVjdG9yIGhhcyBiZWVuIGNhbGxlZCB3aXRoIG5ldyBhcyB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgaWdub3JlZFxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG5cbiAgICBjb25zdHIucHJvdG90eXBlID0gcHJvdG87XG4gICAgY29uc3RyLnN1cGVyID0gc3VwZXJQcm90bztcbiAgICBjb25zdHIuZXh0ZW5kID0gdGhpcy5leHRlbmQ7XG5cbiAgICByZXR1cm4gY29uc3RyO1xuICB9XG5cbiAgLy8gVmFyaWFibGUgYXJndW1lbnQgbGlzdCBjbG9uZXMgYXJncyA+IDAgaW50byBhcmdzWzBdIGFuZCByZXRydW5zIG1vZGlmaWVkIGFyZ3NbMF1cbiAgZnVuY3Rpb24gY2xvbmVEZWZpbml0aW9ucygpIHtcbiAgICB2YXIgYXJncyA9IGxpc3RUb0FycmF5KGFyZ3VtZW50cyk7XG4gICAgdmFyIHRhcmdldCA9IGFyZ3NbMF07XG5cbiAgICBhcmdzLnNwbGljZSgxLCBhcmdzLmxlbmd0aCAtIDEpLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAvLyBJZiB0aGlzIHByb3BlcnR5IGFscmVhZHkgZXhpc3QgaW4gdGFyZ2V0IHdlIGRlbGV0ZSBpdCBmaXJzdFxuICAgICAgICBkZWxldGUgdGFyZ2V0W3Byb3BOYW1lXTtcbiAgICAgICAgLy8gRGVmaW5lIHRoZSBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNjcmlwdG9yIGZyb20gc291cmNlXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BOYW1lLFxuICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBwcm9wTmFtZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgQ2hhcnRpc3QuQ2xhc3MgPSB7XG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgY2xvbmVEZWZpbml0aW9uczogY2xvbmVEZWZpbml0aW9uc1xuICB9O1xuXG59KHRoaXMgfHwgZ2xvYmFsLCBDaGFydGlzdCkpO1xuOy8qKlxuICogQmFzZSBmb3IgYWxsIGNoYXJ0IHR5cGVzLiBUaGUgbWV0aG9kcyBpbiBDaGFydGlzdC5CYXNlIGFyZSBpbmhlcml0ZWQgdG8gYWxsIGNoYXJ0IHR5cGVzLlxuICpcbiAqIEBtb2R1bGUgQ2hhcnRpc3QuQmFzZVxuICovXG4vKiBnbG9iYWwgQ2hhcnRpc3QgKi9cbihmdW5jdGlvbihnbG9iYWxSb290LCBDaGFydGlzdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHdpbmRvdyA9IGdsb2JhbFJvb3Qud2luZG93O1xuXG4gIC8vIFRPRE86IEN1cnJlbnRseSB3ZSBuZWVkIHRvIHJlLWRyYXcgdGhlIGNoYXJ0IG9uIHdpbmRvdyByZXNpemUuIFRoaXMgaXMgdXN1YWxseSB2ZXJ5IGJhZCBhbmQgd2lsbCBhZmZlY3QgcGVyZm9ybWFuY2UuXG4gIC8vIFRoaXMgaXMgZG9uZSBiZWNhdXNlIHdlIGNhbid0IHdvcmsgd2l0aCByZWxhdGl2ZSBjb29yZGluYXRlcyB3aGVuIGRyYXdpbmcgdGhlIGNoYXJ0IGJlY2F1c2UgU1ZHIFBhdGggZG9lcyBub3RcbiAgLy8gd29yayB3aXRoIHJlbGF0aXZlIHBvc2l0aW9ucyB5ZXQuIFdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgY2FuIGRvIGEgdmlld0JveCBoYWNrIHRvIHN3aXRjaCB0byBwZXJjZW50YWdlLlxuICAvLyBTZWUgaHR0cDovL21vemlsbGEuNjUwNi5uNy5uYWJibGUuY29tL1NwZWN5ZmluZy1wYXRocy13aXRoLXBlcmNlbnRhZ2VzLXVuaXQtdGQyNDc0NzQuaHRtbFxuICAvLyBVcGRhdGU6IGNhbiBiZSBkb25lIHVzaW5nIHRoZSBhYm92ZSBtZXRob2QgdGVzdGVkIGhlcmU6IGh0dHA6Ly9jb2RlcGVuLmlvL2dpb25rdW56L3Blbi9LRHZMalxuICAvLyBUaGUgcHJvYmxlbSBpcyB3aXRoIHRoZSBsYWJlbCBvZmZzZXRzIHRoYXQgY2FuJ3QgYmUgY29udmVydGVkIGludG8gcGVyY2VudGFnZSBhbmQgYWZmZWN0aW5nIHRoZSBjaGFydCBjb250YWluZXJcbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNoYXJ0IHdoaWNoIGN1cnJlbnRseSBkb2VzIGEgZnVsbCByZWNvbnN0cnVjdGlvbiBvZiB0aGUgU1ZHIERPTVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIE9wdGlvbmFsIGRhdGEgeW91J2QgbGlrZSB0byBzZXQgZm9yIHRoZSBjaGFydCBiZWZvcmUgaXQgd2lsbCB1cGRhdGUuIElmIG5vdCBzcGVjaWZpZWQgdGhlIHVwZGF0ZSBtZXRob2Qgd2lsbCB1c2UgdGhlIGRhdGEgdGhhdCBpcyBhbHJlYWR5IGNvbmZpZ3VyZWQgd2l0aCB0aGUgY2hhcnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyB5b3UnZCBsaWtlIHRvIGFkZCB0byB0aGUgcHJldmlvdXMgb3B0aW9ucyBmb3IgdGhlIGNoYXJ0IGJlZm9yZSBpdCB3aWxsIHVwZGF0ZS4gSWYgbm90IHNwZWNpZmllZCB0aGUgdXBkYXRlIG1ldGhvZCB3aWxsIHVzZSB0aGUgb3B0aW9ucyB0aGF0IGhhdmUgYmVlbiBhbHJlYWR5IGNvbmZpZ3VyZWQgd2l0aCB0aGUgY2hhcnQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW292ZXJyaWRlXSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHBhc3NlZCBvcHRpb25zIHdpbGwgYmUgdXNlZCB0byBleHRlbmQgdGhlIG9wdGlvbnMgdGhhdCBoYXZlIGJlZW4gY29uZmlndXJlZCBhbHJlYWR5LiBPdGhlcndpc2UgdGhlIGNoYXJ0IGRlZmF1bHQgb3B0aW9ucyB3aWxsIGJlIHVzZWQgYXMgdGhlIGJhc2VcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkJhc2VcbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZShkYXRhLCBvcHRpb25zLCBvdmVycmlkZSkge1xuICAgIGlmKGRhdGEpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwge307XG4gICAgICB0aGlzLmRhdGEubGFiZWxzID0gdGhpcy5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICAgIHRoaXMuZGF0YS5zZXJpZXMgPSB0aGlzLmRhdGEuc2VyaWVzIHx8IFtdO1xuICAgICAgLy8gRXZlbnQgZm9yIGRhdGEgdHJhbnNmb3JtYXRpb24gdGhhdCBhbGxvd3MgdG8gbWFuaXB1bGF0ZSB0aGUgZGF0YSBiZWZvcmUgaXQgZ2V0cyByZW5kZXJlZCBpbiB0aGUgY2hhcnRzXG4gICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdkYXRhJywge1xuICAgICAgICB0eXBlOiAndXBkYXRlJyxcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZihvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBDaGFydGlzdC5leHRlbmQoe30sIG92ZXJyaWRlID8gdGhpcy5vcHRpb25zIDogdGhpcy5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIElmIGNoYXJ0aXN0IHdhcyBub3QgaW5pdGlhbGl6ZWQgeWV0LCB3ZSBqdXN0IHNldCB0aGUgb3B0aW9ucyBhbmQgbGVhdmUgdGhlIHJlc3QgdG8gdGhlIGluaXRpYWxpemF0aW9uXG4gICAgICAvLyBPdGhlcndpc2Ugd2UgcmUtY3JlYXRlIHRoZSBvcHRpb25zUHJvdmlkZXIgYXQgdGhpcyBwb2ludFxuICAgICAgaWYoIXRoaXMuaW5pdGlhbGl6ZVRpbWVvdXRJZCkge1xuICAgICAgICB0aGlzLm9wdGlvbnNQcm92aWRlci5yZW1vdmVNZWRpYVF1ZXJ5TGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMub3B0aW9uc1Byb3ZpZGVyID0gQ2hhcnRpc3Qub3B0aW9uc1Byb3ZpZGVyKHRoaXMub3B0aW9ucywgdGhpcy5yZXNwb25zaXZlT3B0aW9ucywgdGhpcy5ldmVudEVtaXR0ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9ubHkgcmUtY3JlYXRlZCB0aGUgY2hhcnQgaWYgaXQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYoIXRoaXMuaW5pdGlhbGl6ZVRpbWVvdXRJZCkge1xuICAgICAgdGhpcy5jcmVhdGVDaGFydCh0aGlzLm9wdGlvbnNQcm92aWRlci5nZXRDdXJyZW50T3B0aW9ucygpKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGNoYXJ0IG9iamVjdCB0byBjaGFpbiB1cCBjYWxsc1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgb24gdGhlIEFQSSBvYmplY3Qgb2YgZWFjaCBjaGFydCBhbmQgd2lsbCB1bi1yZWdpc3RlciBhbGwgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZCB0byBvdGhlciBjb21wb25lbnRzLiBUaGlzIGN1cnJlbnRseSBpbmNsdWRlcyBhIHdpbmRvdy5yZXNpemUgbGlzdGVuZXIgYXMgd2VsbCBhcyBtZWRpYSBxdWVyeSBsaXN0ZW5lcnMgaWYgYW55IHJlc3BvbnNpdmUgb3B0aW9ucyBoYXZlIGJlZW4gcHJvdmlkZWQuIFVzZSB0aGlzIGZ1bmN0aW9uIGlmIHlvdSBuZWVkIHRvIGRlc3Ryb3kgYW5kIHJlY3JlYXRlIENoYXJ0aXN0IGNoYXJ0cyBkeW5hbWljYWxseS5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkJhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAvLyBPbmx5IGRldGFjaCBpZiBpbml0aWFsaXphdGlvbiBhbHJlYWR5IG9jY3VycmVkIG9uIHRoaXMgY2hhcnQuIElmIHRoaXMgY2hhcnQgc3RpbGwgaGFzbid0IGluaXRpYWxpemVkICh0aGVyZWZvcmVcbiAgICAvLyB0aGUgaW5pdGlhbGl6YXRpb25UaW1lb3V0SWQgaXMgc3RpbGwgYSB2YWxpZCB0aW1lb3V0IHJlZmVyZW5jZSwgd2Ugd2lsbCBjbGVhciB0aGUgdGltZW91dFxuICAgIGlmKCF0aGlzLmluaXRpYWxpemVUaW1lb3V0SWQpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZUxpc3RlbmVyKTtcbiAgICAgIHRoaXMub3B0aW9uc1Byb3ZpZGVyLnJlbW92ZU1lZGlhUXVlcnlMaXN0ZW5lcnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmluaXRpYWxpemVUaW1lb3V0SWQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzLiBUaGUgaGFuZGxlciBjYWxsYmFja3MgYXJlIHN5bmNocm9ub3VzIGFuZCB3aWxsIHJ1biBpbiB0aGUgbWFpbiB0aHJlYWQgcmF0aGVyIHRoYW4gdGhlIGV2ZW50IGxvb3AuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5CYXNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBOYW1lIG9mIHRoZSBldmVudC4gQ2hlY2sgdGhlIGV4YW1wbGVzIGZvciBzdXBwb3J0ZWQgZXZlbnRzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiBhbiBldmVudCB3aXRoIHRoZSBnaXZlbiBuYW1lIHdhcyBlbWl0dGVkLiBUaGlzIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBhIGRhdGEgYXJndW1lbnQgd2hpY2ggY29udGFpbnMgZXZlbnQgZGF0YS4gU2VlIHRoZSBleGFtcGxlIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBmdW5jdGlvbiBvbihldmVudCwgaGFuZGxlcikge1xuICAgIHRoaXMuZXZlbnRFbWl0dGVyLmFkZEV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgZnVuY3Rpb24gdG8gdW4tcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnMuIElmIHRoZSBoYW5kbGVyIGZ1bmN0aW9uIHBhcmFtZXRlciBpcyBvbWl0dGVkIGFsbCBoYW5kbGVycyBmb3IgdGhlIGdpdmVuIGV2ZW50IHdpbGwgYmUgdW4tcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkJhc2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IE5hbWUgb2YgdGhlIGV2ZW50IGZvciB3aGljaCBhIGhhbmRsZXIgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIHRoYXQgdGhhdCB3YXMgcHJldmlvdXNseSB1c2VkIHRvIHJlZ2lzdGVyIGEgbmV3IGV2ZW50IGhhbmRsZXIuIFRoaXMgaGFuZGxlciB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZXZlbnQgaGFuZGxlciBsaXN0LiBJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkIHRoZW4gYWxsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgZ2l2ZW4gZXZlbnQgYXJlIHJlbW92ZWQgZnJvbSB0aGUgbGlzdC5cbiAgICovXG4gIGZ1bmN0aW9uIG9mZihldmVudCwgaGFuZGxlcikge1xuICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIC8vIEFkZCB3aW5kb3cgcmVzaXplIGxpc3RlbmVyIHRoYXQgcmUtY3JlYXRlcyB0aGUgY2hhcnRcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemVMaXN0ZW5lcik7XG5cbiAgICAvLyBPYnRhaW4gY3VycmVudCBvcHRpb25zIGJhc2VkIG9uIG1hdGNoaW5nIG1lZGlhIHF1ZXJpZXMgKGlmIHJlc3BvbnNpdmUgb3B0aW9ucyBhcmUgZ2l2ZW4pXG4gICAgLy8gVGhpcyB3aWxsIGFsc28gcmVnaXN0ZXIgYSBsaXN0ZW5lciB0aGF0IGlzIHJlLWNyZWF0aW5nIHRoZSBjaGFydCBiYXNlZCBvbiBtZWRpYSBjaGFuZ2VzXG4gICAgdGhpcy5vcHRpb25zUHJvdmlkZXIgPSBDaGFydGlzdC5vcHRpb25zUHJvdmlkZXIodGhpcy5vcHRpb25zLCB0aGlzLnJlc3BvbnNpdmVPcHRpb25zLCB0aGlzLmV2ZW50RW1pdHRlcik7XG4gICAgLy8gUmVnaXN0ZXIgb3B0aW9ucyBjaGFuZ2UgbGlzdGVuZXIgdGhhdCB3aWxsIHRyaWdnZXIgYSBjaGFydCB1cGRhdGVcbiAgICB0aGlzLmV2ZW50RW1pdHRlci5hZGRFdmVudEhhbmRsZXIoJ29wdGlvbnNDaGFuZ2VkJywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAvLyBCZWZvcmUgdGhlIGZpcnN0IGNoYXJ0IGNyZWF0aW9uIHdlIG5lZWQgdG8gcmVnaXN0ZXIgdXMgd2l0aCBhbGwgcGx1Z2lucyB0aGF0IGFyZSBjb25maWd1cmVkXG4gICAgLy8gSW5pdGlhbGl6ZSBhbGwgcmVsZXZhbnQgcGx1Z2lucyB3aXRoIG91ciBjaGFydCBvYmplY3QgYW5kIHRoZSBwbHVnaW4gb3B0aW9ucyBzcGVjaWZpZWQgaW4gdGhlIGNvbmZpZ1xuICAgIGlmKHRoaXMub3B0aW9ucy5wbHVnaW5zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMucGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xuICAgICAgICBpZihwbHVnaW4gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIHBsdWdpblswXSh0aGlzLCBwbHVnaW5bMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBsdWdpbih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvLyBFdmVudCBmb3IgZGF0YSB0cmFuc2Zvcm1hdGlvbiB0aGF0IGFsbG93cyB0byBtYW5pcHVsYXRlIHRoZSBkYXRhIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkIGluIHRoZSBjaGFydHNcbiAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdkYXRhJywge1xuICAgICAgdHlwZTogJ2luaXRpYWwnLFxuICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIGZpcnN0IGNoYXJ0XG4gICAgdGhpcy5jcmVhdGVDaGFydCh0aGlzLm9wdGlvbnNQcm92aWRlci5nZXRDdXJyZW50T3B0aW9ucygpKTtcblxuICAgIC8vIEFzIGNoYXJ0IGlzIGluaXRpYWxpemVkIGZyb20gdGhlIGV2ZW50IGxvb3Agbm93IHdlIGNhbiByZXNldCBvdXIgdGltZW91dCByZWZlcmVuY2VcbiAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBpZiB0aGUgY2hhcnQgZ2V0cyBpbml0aWFsaXplZCBvbiB0aGUgc2FtZSBlbGVtZW50IHR3aWNlXG4gICAgdGhpcy5pbml0aWFsaXplVGltZW91dElkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIG9mIGNoYXJ0IGJhc2UgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSBxdWVyeVxuICAgKiBAcGFyYW0gZGF0YVxuICAgKiBAcGFyYW0gZGVmYXVsdE9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHBhcmFtIHJlc3BvbnNpdmVPcHRpb25zXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gQmFzZShxdWVyeSwgZGF0YSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMsIHJlc3BvbnNpdmVPcHRpb25zKSB7XG4gICAgdGhpcy5jb250YWluZXIgPSBDaGFydGlzdC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIHRoaXMuZGF0YS5sYWJlbHMgPSB0aGlzLmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIHRoaXMuZGF0YS5zZXJpZXMgPSB0aGlzLmRhdGEuc2VyaWVzIHx8IFtdO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucmVzcG9uc2l2ZU9wdGlvbnMgPSByZXNwb25zaXZlT3B0aW9ucztcbiAgICB0aGlzLmV2ZW50RW1pdHRlciA9IENoYXJ0aXN0LkV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXMuc3VwcG9ydHNGb3JlaWduT2JqZWN0ID0gQ2hhcnRpc3QuU3ZnLmlzU3VwcG9ydGVkKCdFeHRlbnNpYmlsaXR5Jyk7XG4gICAgdGhpcy5zdXBwb3J0c0FuaW1hdGlvbnMgPSBDaGFydGlzdC5TdmcuaXNTdXBwb3J0ZWQoJ0FuaW1hdGlvbkV2ZW50c0F0dHJpYnV0ZScpO1xuICAgIHRoaXMucmVzaXplTGlzdGVuZXIgPSBmdW5jdGlvbiByZXNpemVMaXN0ZW5lcigpe1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBpZih0aGlzLmNvbnRhaW5lcikge1xuICAgICAgLy8gSWYgY2hhcnRpc3Qgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQgaW4gdGhpcyBjb250YWluZXIgd2UgYXJlIGRldGFjaGluZyBhbGwgZXZlbnQgbGlzdGVuZXJzIGZpcnN0XG4gICAgICBpZih0aGlzLmNvbnRhaW5lci5fX2NoYXJ0aXN0X18pIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuX19jaGFydGlzdF9fLmRldGFjaCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRhaW5lci5fX2NoYXJ0aXN0X18gPSB0aGlzO1xuICAgIH1cblxuICAgIC8vIFVzaW5nIGV2ZW50IGxvb3AgZm9yIGZpcnN0IGRyYXcgdG8gbWFrZSBpdCBwb3NzaWJsZSB0byByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgaW4gdGhlIHNhbWUgY2FsbCBzdGFjayB3aGVyZVxuICAgIC8vIHRoZSBjaGFydCB3YXMgY3JlYXRlZC5cbiAgICB0aGlzLmluaXRpYWxpemVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGluaXRpYWxpemUuYmluZCh0aGlzKSwgMCk7XG4gIH1cblxuICAvLyBDcmVhdGluZyB0aGUgY2hhcnQgYmFzZSBjbGFzc1xuICBDaGFydGlzdC5CYXNlID0gQ2hhcnRpc3QuQ2xhc3MuZXh0ZW5kKHtcbiAgICBjb25zdHJ1Y3RvcjogQmFzZSxcbiAgICBvcHRpb25zUHJvdmlkZXI6IHVuZGVmaW5lZCxcbiAgICBjb250YWluZXI6IHVuZGVmaW5lZCxcbiAgICBzdmc6IHVuZGVmaW5lZCxcbiAgICBldmVudEVtaXR0ZXI6IHVuZGVmaW5lZCxcbiAgICBjcmVhdGVDaGFydDogZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jhc2UgY2hhcnQgdHlwZSBjYW5cXCd0IGJlIGluc3RhbnRpYXRlZCEnKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgIGRldGFjaDogZGV0YWNoLFxuICAgIG9uOiBvbixcbiAgICBvZmY6IG9mZixcbiAgICB2ZXJzaW9uOiBDaGFydGlzdC52ZXJzaW9uLFxuICAgIHN1cHBvcnRzRm9yZWlnbk9iamVjdDogZmFsc2VcbiAgfSk7XG5cbn0odGhpcyB8fCBnbG9iYWwsIENoYXJ0aXN0KSk7XG47LyoqXG4gKiBDaGFydGlzdCBTVkcgbW9kdWxlIGZvciBzaW1wbGUgU1ZHIERPTSBhYnN0cmFjdGlvblxuICpcbiAqIEBtb2R1bGUgQ2hhcnRpc3QuU3ZnXG4gKi9cbi8qIGdsb2JhbCBDaGFydGlzdCAqL1xuKGZ1bmN0aW9uKGdsb2JhbFJvb3QsIENoYXJ0aXN0KSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZG9jdW1lbnQgPSBnbG9iYWxSb290LmRvY3VtZW50O1xuXG4gIC8qKlxuICAgKiBDaGFydGlzdC5TdmcgY3JlYXRlcyBhIG5ldyBTVkcgb2JqZWN0IHdyYXBwZXIgd2l0aCBhIHN0YXJ0aW5nIGVsZW1lbnQuIFlvdSBjYW4gdXNlIHRoZSB3cmFwcGVyIHRvIGZsdWVudGx5IGNyZWF0ZSBzdWItZWxlbWVudHMgYW5kIG1vZGlmeSB0aGVtLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBTVkcgZWxlbWVudCB0byBjcmVhdGUgb3IgYW4gU1ZHIGRvbSBlbGVtZW50IHdoaWNoIHNob3VsZCBiZSB3cmFwcGVkIGludG8gQ2hhcnRpc3QuU3ZnXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIGFkZGVkIGFzIGF0dHJpYnV0ZXMgdG8gdGhlIFNWRyBlbGVtZW50IHRoYXQgaXMgY3JlYXRlZC4gQXR0cmlidXRlcyB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMgd2lsbCBub3QgYmUgYWRkZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgVGhpcyBjbGFzcyBvciBjbGFzcyBsaXN0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIFNWRyBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgVGhlIHBhcmVudCBTVkcgd3JhcHBlciBvYmplY3Qgd2hlcmUgdGhpcyBuZXdseSBjcmVhdGVkIHdyYXBwZXIgYW5kIGl0J3MgZWxlbWVudCB3aWxsIGJlIGF0dGFjaGVkIHRvIGFzIGNoaWxkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5zZXJ0Rmlyc3QgSWYgdGhpcyBwYXJhbSBpcyBzZXQgdG8gdHJ1ZSBpbiBjb25qdW5jdGlvbiB3aXRoIGEgcGFyZW50IGVsZW1lbnQgdGhlIG5ld2x5IGNyZWF0ZWQgZWxlbWVudCB3aWxsIGJlIGFkZGVkIGFzIGZpcnN0IGNoaWxkIGVsZW1lbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiBTdmcobmFtZSwgYXR0cmlidXRlcywgY2xhc3NOYW1lLCBwYXJlbnQsIGluc2VydEZpcnN0KSB7XG4gICAgLy8gSWYgU3ZnIGlzIGdldHRpbmcgY2FsbGVkIHdpdGggYW4gU1ZHIGVsZW1lbnQgd2UganVzdCByZXR1cm4gdGhlIHdyYXBwZXJcbiAgICBpZihuYW1lIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgdGhpcy5fbm9kZSA9IG5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX25vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoQ2hhcnRpc3QubmFtZXNwYWNlcy5zdmcsIG5hbWUpO1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIGFuIFNWRyBlbGVtZW50IGNyZWF0ZWQgdGhlbiBjdXN0b20gbmFtZXNwYWNlXG4gICAgICBpZihuYW1lID09PSAnc3ZnJykge1xuICAgICAgICB0aGlzLmF0dHIoe1xuICAgICAgICAgICd4bWxuczpjdCc6IENoYXJ0aXN0Lm5hbWVzcGFjZXMuY3RcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoYXR0cmlidXRlcykge1xuICAgICAgdGhpcy5hdHRyKGF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIGlmKGNsYXNzTmFtZSkge1xuICAgICAgdGhpcy5hZGRDbGFzcyhjbGFzc05hbWUpO1xuICAgIH1cblxuICAgIGlmKHBhcmVudCkge1xuICAgICAgaWYgKGluc2VydEZpcnN0ICYmIHBhcmVudC5fbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIHBhcmVudC5fbm9kZS5pbnNlcnRCZWZvcmUodGhpcy5fbm9kZSwgcGFyZW50Ll9ub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50Ll9ub2RlLmFwcGVuZENoaWxkKHRoaXMuX25vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYXR0cmlidXRlcyBvbiB0aGUgY3VycmVudCBTVkcgZWxlbWVudCBvZiB0aGUgd3JhcHBlciB5b3UncmUgY3VycmVudGx5IHdvcmtpbmcgb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5TdmdcbiAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBhdHRyaWJ1dGVzIEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIGFkZGVkIGFzIGF0dHJpYnV0ZXMgdG8gdGhlIFNWRyBlbGVtZW50IHRoYXQgaXMgY3JlYXRlZC4gQXR0cmlidXRlcyB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMgd2lsbCBub3QgYmUgYWRkZWQuIElmIHRoaXMgcGFyYW1ldGVyIGlzIGEgU3RyaW5nIHRoZW4gdGhlIGZ1bmN0aW9uIGlzIHVzZWQgYXMgYSBnZXR0ZXIgYW5kIHdpbGwgcmV0dXJuIHRoZSBhdHRyaWJ1dGUgdmFsdWUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbnNdIElmIHNwZWNpZmllZCwgdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIG9idGFpbmVkIHVzaW5nIGdldEF0dHJpYnV0ZU5zLiBJbiBvcmRlciB0byB3cml0ZSBuYW1lcHNhY2VkIGF0dHJpYnV0ZXMgeW91IGNhbiB1c2UgdGhlIG5hbWVzcGFjZTphdHRyaWJ1dGUgbm90YXRpb24gd2l0aGluIHRoZSBhdHRyaWJ1dGVzIG9iamVjdC5cbiAgICogQHJldHVybiB7T2JqZWN0fFN0cmluZ30gVGhlIGN1cnJlbnQgd3JhcHBlciBvYmplY3Qgd2lsbCBiZSByZXR1cm5lZCBzbyBpdCBjYW4gYmUgdXNlZCBmb3IgY2hhaW5pbmcgb3IgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBpZiB1c2VkIGFzIGdldHRlciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGF0dHIoYXR0cmlidXRlcywgbnMpIHtcbiAgICBpZih0eXBlb2YgYXR0cmlidXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmKG5zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlLmdldEF0dHJpYnV0ZU5TKG5zLCBhdHRyaWJ1dGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgLy8gSWYgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBpcyB1bmRlZmluZWQgd2UgY2FuIHNraXAgdGhpcyBvbmVcbiAgICAgIGlmKGF0dHJpYnV0ZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgICAgIHZhciBuYW1lc3BhY2VkQXR0cmlidXRlID0ga2V5LnNwbGl0KCc6Jyk7XG4gICAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlTlMoQ2hhcnRpc3QubmFtZXNwYWNlc1tuYW1lc3BhY2VkQXR0cmlidXRlWzBdXSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgU1ZHIGVsZW1lbnQgd2hvc2Ugd3JhcHBlciBvYmplY3Qgd2lsbCBiZSBzZWxlY3RlZCBmb3IgZnVydGhlciBvcGVyYXRpb25zLiBUaGlzIHdheSB5b3UgY2FuIGFsc28gY3JlYXRlIG5lc3RlZCBncm91cHMgZWFzaWx5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBTVkcgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBjcmVhdGVkIGFzIGNoaWxkIGVsZW1lbnQgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBlbGVtZW50IHdyYXBwZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBBbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBhZGRlZCBhcyBhdHRyaWJ1dGVzIHRvIHRoZSBTVkcgZWxlbWVudCB0aGF0IGlzIGNyZWF0ZWQuIEF0dHJpYnV0ZXMgd2l0aCB1bmRlZmluZWQgdmFsdWVzIHdpbGwgbm90IGJlIGFkZGVkLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NsYXNzTmFtZV0gVGhpcyBjbGFzcyBvciBjbGFzcyBsaXN0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIFNWRyBlbGVtZW50XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2luc2VydEZpcnN0XSBJZiB0aGlzIHBhcmFtIGlzIHNldCB0byB0cnVlIGluIGNvbmp1bmN0aW9uIHdpdGggYSBwYXJlbnQgZWxlbWVudCB0aGUgbmV3bHkgY3JlYXRlZCBlbGVtZW50IHdpbGwgYmUgYWRkZWQgYXMgZmlyc3QgY2hpbGQgZWxlbWVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICogQHJldHVybiB7Q2hhcnRpc3QuU3ZnfSBSZXR1cm5zIGEgQ2hhcnRpc3QuU3ZnIHdyYXBwZXIgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gbW9kaWZ5IHRoZSBjb250YWluaW5nIFNWRyBkYXRhXG4gICAqL1xuICBmdW5jdGlvbiBlbGVtKG5hbWUsIGF0dHJpYnV0ZXMsIGNsYXNzTmFtZSwgaW5zZXJ0Rmlyc3QpIHtcbiAgICByZXR1cm4gbmV3IENoYXJ0aXN0LlN2ZyhuYW1lLCBhdHRyaWJ1dGVzLCBjbGFzc05hbWUsIHRoaXMsIGluc2VydEZpcnN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgQ2hhcnRpc3QuU1ZHIHdyYXBwZXIgb2JqZWN0XG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5TdmdcbiAgICogQHJldHVybiB7Q2hhcnRpc3QuU3ZnfSBSZXR1cm5zIGEgQ2hhcnRpc3QuU3ZnIHdyYXBwZXIgYXJvdW5kIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgY3VycmVudCBub2RlLiBJZiB0aGUgcGFyZW50IG5vZGUgaXMgbm90IGV4aXN0aW5nIG9yIGl0J3Mgbm90IGFuIFNWRyBub2RlIHRoZW4gdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBudWxsLlxuICAgKi9cbiAgZnVuY3Rpb24gcGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlLnBhcmVudE5vZGUgaW5zdGFuY2VvZiBTVkdFbGVtZW50ID8gbmV3IENoYXJ0aXN0LlN2Zyh0aGlzLl9ub2RlLnBhcmVudE5vZGUpIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgQ2hhcnRpc3QuU3ZnIHdyYXBwZXIgYXJvdW5kIHRoZSByb290IFNWRyBlbGVtZW50IG9mIHRoZSBjdXJyZW50IHRyZWUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5TdmdcbiAgICogQHJldHVybiB7Q2hhcnRpc3QuU3ZnfSBUaGUgcm9vdCBTVkcgZWxlbWVudCB3cmFwcGVkIGluIGEgQ2hhcnRpc3QuU3ZnIGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIHJvb3QoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9ub2RlO1xuICAgIHdoaWxlKG5vZGUubm9kZU5hbWUgIT09ICdzdmcnKSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENoYXJ0aXN0LlN2Zyhub2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBmaXJzdCBjaGlsZCBTVkcgZWxlbWVudCBvZiB0aGUgY3VycmVudCBlbGVtZW50IHRoYXQgbWF0Y2hlcyBhIENTUyBzZWxlY3Rvci4gVGhlIHJldHVybmVkIG9iamVjdCBpcyBhIENoYXJ0aXN0LlN2ZyB3cmFwcGVyLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBBIENTUyBzZWxlY3RvciB0aGF0IGlzIHVzZWQgdG8gcXVlcnkgZm9yIGNoaWxkIFNWRyBlbGVtZW50c1xuICAgKiBAcmV0dXJuIHtDaGFydGlzdC5Tdmd9IFRoZSBTVkcgd3JhcHBlciBmb3IgdGhlIGVsZW1lbnQgZm91bmQgb3IgbnVsbCBpZiBubyBlbGVtZW50IHdhcyBmb3VuZFxuICAgKi9cbiAgZnVuY3Rpb24gcXVlcnlTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHZhciBmb3VuZE5vZGUgPSB0aGlzLl9ub2RlLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIHJldHVybiBmb3VuZE5vZGUgPyBuZXcgQ2hhcnRpc3QuU3ZnKGZvdW5kTm9kZSkgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGFsbCBjaGlsZCBTVkcgZWxlbWVudHMgb2YgdGhlIGN1cnJlbnQgZWxlbWVudCB0aGF0IG1hdGNoIGEgQ1NTIHNlbGVjdG9yLiBUaGUgcmV0dXJuZWQgb2JqZWN0IGlzIGEgQ2hhcnRpc3QuU3ZnLkxpc3Qgd3JhcHBlci5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LlN2Z1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgQSBDU1Mgc2VsZWN0b3IgdGhhdCBpcyB1c2VkIHRvIHF1ZXJ5IGZvciBjaGlsZCBTVkcgZWxlbWVudHNcbiAgICogQHJldHVybiB7Q2hhcnRpc3QuU3ZnLkxpc3R9IFRoZSBTVkcgd3JhcHBlciBsaXN0IGZvciB0aGUgZWxlbWVudCBmb3VuZCBvciBudWxsIGlmIG5vIGVsZW1lbnQgd2FzIGZvdW5kXG4gICAqL1xuICBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSB7XG4gICAgdmFyIGZvdW5kTm9kZXMgPSB0aGlzLl9ub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIHJldHVybiBmb3VuZE5vZGVzLmxlbmd0aCA/IG5ldyBDaGFydGlzdC5TdmcuTGlzdChmb3VuZE5vZGVzKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBTVkcgbm9kZSBmb3IgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LlN2Z1xuICAgKiBAcmV0dXJucyB7Tm9kZX1cbiAgICovXG4gIGZ1bmN0aW9uIGdldE5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGU7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIGZvcmVpZ25PYmplY3QgKHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvRWxlbWVudC9mb3JlaWduT2JqZWN0KSB0aGF0IGFsbG93cyB0byBlbWJlZCBIVE1MIGNvbnRlbnQgaW50byBhIFNWRyBncmFwaGljLiBXaXRoIHRoZSBoZWxwIG9mIGZvcmVpZ25PYmplY3RzIHlvdSBjYW4gZW5hYmxlIHRoZSB1c2FnZSBvZiByZWd1bGFyIEhUTUwgZWxlbWVudHMgaW5zaWRlIG9mIFNWRyB3aGVyZSB0aGV5IGFyZSBzdWJqZWN0IGZvciBTVkcgcG9zaXRpb25pbmcgYW5kIHRyYW5zZm9ybWF0aW9uIGJ1dCB0aGUgQnJvd3NlciB3aWxsIHVzZSB0aGUgSFRNTCByZW5kZXJpbmcgY2FwYWJpbGl0aWVzIGZvciB0aGUgY29udGFpbmluZyBET00uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5TdmdcbiAgICogQHBhcmFtIHtOb2RlfFN0cmluZ30gY29udGVudCBUaGUgRE9NIE5vZGUsIG9yIEhUTUwgc3RyaW5nIHRoYXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBET00gTm9kZSwgdGhhdCBpcyB0aGVuIHBsYWNlZCBpbnRvIGFuZCB3cmFwcGVkIGJ5IHRoZSBmb3JlaWduT2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbYXR0cmlidXRlc10gQW4gb2JqZWN0IHdpdGggcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgYWRkZWQgYXMgYXR0cmlidXRlcyB0byB0aGUgZm9yZWlnbk9iamVjdCBlbGVtZW50IHRoYXQgaXMgY3JlYXRlZC4gQXR0cmlidXRlcyB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMgd2lsbCBub3QgYmUgYWRkZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY2xhc3NOYW1lXSBUaGlzIGNsYXNzIG9yIGNsYXNzIGxpc3Qgd2lsbCBiZSBhZGRlZCB0byB0aGUgU1ZHIGVsZW1lbnRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaW5zZXJ0Rmlyc3RdIFNwZWNpZmllcyBpZiB0aGUgZm9yZWlnbk9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgYXMgZmlyc3QgY2hpbGRcbiAgICogQHJldHVybiB7Q2hhcnRpc3QuU3ZnfSBOZXcgd3JhcHBlciBvYmplY3QgdGhhdCB3cmFwcyB0aGUgZm9yZWlnbk9iamVjdCBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiBmb3JlaWduT2JqZWN0KGNvbnRlbnQsIGF0dHJpYnV0ZXMsIGNsYXNzTmFtZSwgaW5zZXJ0Rmlyc3QpIHtcbiAgICAvLyBJZiBjb250ZW50IGlzIHN0cmluZyB0aGVuIHdlIGNvbnZlcnQgaXQgdG8gRE9NXG4gICAgLy8gVE9ETzogSGFuZGxlIGNhc2Ugd2hlcmUgY29udGVudCBpcyBub3QgYSBzdHJpbmcgbm9yIGEgRE9NIE5vZGVcbiAgICBpZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgICAgY29udGVudCA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZGluZyBuYW1lc3BhY2UgdG8gY29udGVudCBlbGVtZW50XG4gICAgY29udGVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgQ2hhcnRpc3QubmFtZXNwYWNlcy54bWxucyk7XG5cbiAgICAvLyBDcmVhdGluZyB0aGUgZm9yZWlnbk9iamVjdCB3aXRob3V0IHJlcXVpcmVkIGV4dGVuc2lvbiBhdHRyaWJ1dGUgKGFzIGRlc2NyaWJlZCBoZXJlXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2V4dGVuZC5odG1sI0ZvcmVpZ25PYmplY3RFbGVtZW50KVxuICAgIHZhciBmbk9iaiA9IHRoaXMuZWxlbSgnZm9yZWlnbk9iamVjdCcsIGF0dHJpYnV0ZXMsIGNsYXNzTmFtZSwgaW5zZXJ0Rmlyc3QpO1xuXG4gICAgLy8gQWRkIGNvbnRlbnQgdG8gZm9yZWlnbk9iamVjdEVsZW1lbnRcbiAgICBmbk9iai5fbm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICAgIHJldHVybiBmbk9iajtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBhZGRzIGEgbmV3IHRleHQgZWxlbWVudCB0byB0aGUgY3VycmVudCBDaGFydGlzdC5Tdmcgd3JhcHBlci5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LlN2Z1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdCBUaGUgdGV4dCB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB0aGUgdGV4dCBlbGVtZW50IHRoYXQgaXMgY3JlYXRlZFxuICAgKiBAcmV0dXJuIHtDaGFydGlzdC5Tdmd9IFRoZSBzYW1lIHdyYXBwZXIgb2JqZWN0IHRoYXQgd2FzIHVzZWQgdG8gYWRkIHRoZSBuZXdseSBjcmVhdGVkIGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIHRleHQodCkge1xuICAgIHRoaXMuX25vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgY2xlYXIgYWxsIGNoaWxkIG5vZGVzIG9mIHRoZSBjdXJyZW50IHdyYXBwZXIgb2JqZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnXG4gICAqIEByZXR1cm4ge0NoYXJ0aXN0LlN2Z30gVGhlIHNhbWUgd3JhcHBlciBvYmplY3QgdGhhdCBnb3QgZW1wdGllZFxuICAgKi9cbiAgZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgd2hpbGUgKHRoaXMuX25vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgdGhpcy5fbm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9ub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGN1cnJlbnQgd3JhcHBlciB0byByZW1vdmUgaXRzZWxmIGZyb20gaXRzIHBhcmVudCB3cmFwcGVyLiBVc2UgdGhpcyBtZXRob2QgaWYgeW91J2QgbGlrZSB0byBnZXQgcmlkIG9mIGFuIGVsZW1lbnQgaW4gYSBnaXZlbiBET00gc3RydWN0dXJlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnXG4gICAqIEByZXR1cm4ge0NoYXJ0aXN0LlN2Z30gVGhlIHBhcmVudCB3cmFwcGVyIG9iamVjdCBvZiB0aGUgZWxlbWVudCB0aGF0IGdvdCByZW1vdmVkXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgdGhpcy5fbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX25vZGUpO1xuICAgIHJldHVybiB0aGlzLnBhcmVudCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgcmVwbGFjZSB0aGUgZWxlbWVudCB3aXRoIGEgbmV3IGVsZW1lbnQgdGhhdCBjYW4gYmUgY3JlYXRlZCBvdXRzaWRlIG9mIHRoZSBjdXJyZW50IERPTS5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LlN2Z1xuICAgKiBAcGFyYW0ge0NoYXJ0aXN0LlN2Z30gbmV3RWxlbWVudCBUaGUgbmV3IENoYXJ0aXN0LlN2ZyBvYmplY3QgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVwbGFjZSB0aGUgY3VycmVudCB3cmFwcGVyIG9iamVjdFxuICAgKiBAcmV0dXJuIHtDaGFydGlzdC5Tdmd9IFRoZSB3cmFwcGVyIG9mIHRoZSBuZXcgZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZShuZXdFbGVtZW50KSB7XG4gICAgdGhpcy5fbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdFbGVtZW50Ll9ub2RlLCB0aGlzLl9ub2RlKTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFwcGVuZCBhbiBlbGVtZW50IHRvIHRoZSBjdXJyZW50IGVsZW1lbnQgYXMgYSBjaGlsZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LlN2Z1xuICAgKiBAcGFyYW0ge0NoYXJ0aXN0LlN2Z30gZWxlbWVudCBUaGUgQ2hhcnRpc3QuU3ZnIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgYWRkZWQgYXMgYSBjaGlsZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnNlcnRGaXJzdF0gU3BlY2lmaWVzIGlmIHRoZSBlbGVtZW50IHNob3VsZCBiZSBpbnNlcnRlZCBhcyBmaXJzdCBjaGlsZFxuICAgKiBAcmV0dXJuIHtDaGFydGlzdC5Tdmd9IFRoZSB3cmFwcGVyIG9mIHRoZSBhcHBlbmRlZCBvYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIGFwcGVuZChlbGVtZW50LCBpbnNlcnRGaXJzdCkge1xuICAgIGlmKGluc2VydEZpcnN0ICYmIHRoaXMuX25vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgdGhpcy5fbm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudC5fbm9kZSwgdGhpcy5fbm9kZS5maXJzdENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbm9kZS5hcHBlbmRDaGlsZChlbGVtZW50Ll9ub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNsYXNzIG5hbWVzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIHRoZSBjdXJyZW50IHdyYXBwZXIgZWxlbWVudC4gVGhpcyBtZXRob2QgY2FuIG5vdCBiZSBjaGFpbmVkIGZ1cnRoZXIuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5TdmdcbiAgICogQHJldHVybiB7QXJyYXl9IEEgbGlzdCBvZiBjbGFzc2VzIG9yIGFuIGVtcHR5IGFycmF5IGlmIHRoZXJlIGFyZSBubyBjbGFzc2VzIG9uIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIGNsYXNzZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpID8gdGhpcy5fbm9kZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykudHJpbSgpLnNwbGl0KC9cXHMrLykgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG9uZSBvciBhIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzZXMgdG8gdGhlIGN1cnJlbnQgZWxlbWVudCBhbmQgZW5zdXJlcyB0aGUgY2xhc3NlcyBhcmUgb25seSBleGlzdGluZyBvbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lcyBBIHdoaXRlIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzIG5hbWVzXG4gICAqIEByZXR1cm4ge0NoYXJ0aXN0LlN2Z30gVGhlIHdyYXBwZXIgb2YgdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gYWRkQ2xhc3MobmFtZXMpIHtcbiAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLFxuICAgICAgdGhpcy5jbGFzc2VzKHRoaXMuX25vZGUpXG4gICAgICAgIC5jb25jYXQobmFtZXMudHJpbSgpLnNwbGl0KC9cXHMrLykpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZWxlbSwgcG9zLCBzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZihlbGVtKSA9PT0gcG9zO1xuICAgICAgICB9KS5qb2luKCcgJylcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBvbmUgb3IgYSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBjbGFzc2VzIGZyb20gdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LlN2Z1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXMgQSB3aGl0ZSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBjbGFzcyBuYW1lc1xuICAgKiBAcmV0dXJuIHtDaGFydGlzdC5Tdmd9IFRoZSB3cmFwcGVyIG9mIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKG5hbWVzKSB7XG4gICAgdmFyIHJlbW92ZWRDbGFzc2VzID0gbmFtZXMudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG5cbiAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0aGlzLmNsYXNzZXModGhpcy5fbm9kZSkuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiByZW1vdmVkQ2xhc3Nlcy5pbmRleE9mKG5hbWUpID09PSAtMTtcbiAgICB9KS5qb2luKCcgJykpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgY2xhc3NlcyBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5TdmdcbiAgICogQHJldHVybiB7Q2hhcnRpc3QuU3ZnfSBUaGUgd3JhcHBlciBvZiB0aGUgY3VycmVudCBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmVBbGxDbGFzc2VzKCkge1xuICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKCdjbGFzcycsICcnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBlbGVtZW50IGhlaWdodCB1c2luZyBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YFxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGVsZW1lbnRzIGhlaWdodCBpbiBwaXhlbHNcbiAgICovXG4gIGZ1bmN0aW9uIGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGVsZW1lbnQgd2lkdGggdXNpbmcgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGBcbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkNvcmVcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgZWxlbWVudHMgd2lkdGggaW4gcGl4ZWxzXG4gICAqL1xuICBmdW5jdGlvbiB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYW5pbWF0ZSBmdW5jdGlvbiBsZXRzIHlvdSBhbmltYXRlIHRoZSBjdXJyZW50IGVsZW1lbnQgd2l0aCBTTUlMIGFuaW1hdGlvbnMuIFlvdSBjYW4gYWRkIGFuaW1hdGlvbnMgZm9yIG11bHRpcGxlIGF0dHJpYnV0ZXMgYXQgdGhlIHNhbWUgdGltZSBieSB1c2luZyBhbiBhbmltYXRpb24gZGVmaW5pdGlvbiBvYmplY3QuIFRoaXMgb2JqZWN0IHNob3VsZCBjb250YWluIFNNSUwgYW5pbWF0aW9uIGF0dHJpYnV0ZXMuIFBsZWFzZSByZWZlciB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvYW5pbWF0ZS5odG1sIGZvciBhIGRldGFpbGVkIHNwZWNpZmljYXRpb24gYWJvdXQgdGhlIGF2YWlsYWJsZSBhbmltYXRpb24gYXR0cmlidXRlcy4gQWRkaXRpb25hbGx5IGFuIGVhc2luZyBwcm9wZXJ0eSBjYW4gYmUgcGFzc2VkIGluIHRoZSBhbmltYXRpb24gZGVmaW5pdGlvbiBvYmplY3QuIFRoaXMgY2FuIGJlIGEgc3RyaW5nIHdpdGggYSBuYW1lIG9mIGFuIGVhc2luZyBmdW5jdGlvbiBpbiBgQ2hhcnRpc3QuU3ZnLkVhc2luZ2Agb3IgYW4gYXJyYXkgd2l0aCBmb3VyIG51bWJlcnMgc3BlY2lmeWluZyBhIGN1YmljIELDqXppZXIgY3VydmUuXG4gICAqICoqQW4gYW5pbWF0aW9ucyBvYmplY3QgY291bGQgbG9vayBsaWtlIHRoaXM6KipcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBlbGVtZW50LmFuaW1hdGUoe1xuICAgKiAgIG9wYWNpdHk6IHtcbiAgICogICAgIGR1cjogMTAwMCxcbiAgICogICAgIGZyb206IDAsXG4gICAqICAgICB0bzogMVxuICAgKiAgIH0sXG4gICAqICAgeDE6IHtcbiAgICogICAgIGR1cjogJzEwMDBtcycsXG4gICAqICAgICBmcm9tOiAxMDAsXG4gICAqICAgICB0bzogMjAwLFxuICAgKiAgICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0J1xuICAgKiAgIH0sXG4gICAqICAgeTE6IHtcbiAgICogICAgIGR1cjogJzJzJyxcbiAgICogICAgIGZyb206IDAsXG4gICAqICAgICB0bzogMTAwXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqICoqQXV0b21hdGljIHVuaXQgY29udmVyc2lvbioqXG4gICAqIEZvciB0aGUgYGR1cmAgYW5kIHRoZSBgYmVnaW5gIGFuaW1hdGUgYXR0cmlidXRlIHlvdSBjYW4gYWxzbyBvbWl0IGEgdW5pdCBieSBwYXNzaW5nIGEgbnVtYmVyLiBUaGUgbnVtYmVyIHdpbGwgYXV0b21hdGljYWxseSBiZSBjb252ZXJ0ZWQgdG8gbWlsbGkgc2Vjb25kcy5cbiAgICogKipHdWlkZWQgbW9kZSoqXG4gICAqIFRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIFNNSUwgYW5pbWF0aW9ucyB3aXRoIG9mZnNldCB1c2luZyB0aGUgYGJlZ2luYCBhdHRyaWJ1dGUgaXMgdGhhdCB0aGUgYXR0cmlidXRlIHdpbGwga2VlcCBpdCdzIG9yaWdpbmFsIHZhbHVlIHVudGlsIHRoZSBhbmltYXRpb24gc3RhcnRzLiBNb3N0bHkgdGhpcyBiZWhhdmlvciBpcyBub3QgZGVzaXJlZCBhcyB5b3UnZCBsaWtlIHRvIGhhdmUgeW91ciBlbGVtZW50IGF0dHJpYnV0ZXMgYWxyZWFkeSBpbml0aWFsaXplZCB3aXRoIHRoZSBhbmltYXRpb24gYGZyb21gIHZhbHVlIGV2ZW4gYmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzLiBBbHNvIGlmIHlvdSBkb24ndCBzcGVjaWZ5IGBmaWxsPVwiZnJlZXplXCJgIG9uIGFuIGFuaW1hdGUgZWxlbWVudCBvciBpZiB5b3UgZGVsZXRlIHRoZSBhbmltYXRpb24gYWZ0ZXIgaXQncyBkb25lICh3aGljaCBpcyBkb25lIGluIGd1aWRlZCBtb2RlKSB0aGUgYXR0cmlidXRlIHdpbGwgc3dpdGNoIGJhY2sgdG8gdGhlIGluaXRpYWwgdmFsdWUuIFRoaXMgYmVoYXZpb3IgaXMgYWxzbyBub3QgZGVzaXJlZCB3aGVuIHBlcmZvcm1pbmcgc2ltcGxlIG9uZS10aW1lIGFuaW1hdGlvbnMuIEZvciBvbmUtdGltZSBhbmltYXRpb25zIHlvdSdkIHdhbnQgdG8gdHJpZ2dlciBhbmltYXRpb25zIGltbWVkaWF0ZWx5IGluc3RlYWQgb2YgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50IGJlZ2luIHRpbWUuIFRoYXQncyB3aHkgaW4gZ3VpZGVkIG1vZGUgQ2hhcnRpc3QuU3ZnIHdpbGwgYWxzbyB1c2UgdGhlIGBiZWdpbmAgcHJvcGVydHkgdG8gc2NoZWR1bGUgYSB0aW1lb3V0IGFuZCBtYW51YWxseSBzdGFydCB0aGUgYW5pbWF0aW9uIGFmdGVyIHRoZSB0aW1lb3V0LiBJZiB5b3UncmUgdXNpbmcgbXVsdGlwbGUgU01JTCBkZWZpbml0aW9uIG9iamVjdHMgZm9yIGFuIGF0dHJpYnV0ZSAoaW4gYW4gYXJyYXkpLCBndWlkZWQgbW9kZSB3aWxsIGJlIGRpc2FibGVkIGZvciB0aGlzIGF0dHJpYnV0ZSwgZXZlbiBpZiB5b3UgZXhwbGljaXRseSBlbmFibGVkIGl0LlxuICAgKiBJZiBndWlkZWQgbW9kZSBpcyBlbmFibGVkIHRoZSBmb2xsb3dpbmcgYmVoYXZpb3IgaXMgYWRkZWQ6XG4gICAqIC0gQmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzIChldmVuIHdoZW4gZGVsYXllZCB3aXRoIGBiZWdpbmApIHRoZSBhbmltYXRlZCBhdHRyaWJ1dGUgd2lsbCBiZSBzZXQgYWxyZWFkeSB0byB0aGUgYGZyb21gIHZhbHVlIG9mIHRoZSBhbmltYXRpb25cbiAgICogLSBgYmVnaW5gIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGBpbmRlZmluaXRlYCBzbyBpdCBjYW4gYmUgc3RhcnRlZCBtYW51YWxseSB3aXRob3V0IHJlbHlpbmcgb24gZG9jdW1lbnQgYmVnaW4gdGltZSAoY3JlYXRpb24pXG4gICAqIC0gVGhlIGFuaW1hdGUgZWxlbWVudCB3aWxsIGJlIGZvcmNlZCB0byB1c2UgYGZpbGw9XCJmcmVlemVcImBcbiAgICogLSBUaGUgYW5pbWF0aW9uIHdpbGwgYmUgdHJpZ2dlcmVkIHdpdGggYGJlZ2luRWxlbWVudCgpYCBpbiBhIHRpbWVvdXQgd2hlcmUgYGJlZ2luYCBvZiB0aGUgZGVmaW5pdGlvbiBvYmplY3QgaXMgaW50ZXJwcmV0ZWQgaW4gbWlsbGkgc2Vjb25kcy4gSWYgbm8gYGJlZ2luYCB3YXMgc3BlY2lmaWVkIHRoZSB0aW1lb3V0IGlzIHRyaWdnZXJlZCBpbW1lZGlhdGVseS5cbiAgICogLSBBZnRlciB0aGUgYW5pbWF0aW9uIHRoZSBlbGVtZW50IGF0dHJpYnV0ZSB2YWx1ZSB3aWxsIGJlIHNldCB0byB0aGUgYHRvYCB2YWx1ZSBvZiB0aGUgYW5pbWF0aW9uXG4gICAqIC0gVGhlIGFuaW1hdGUgZWxlbWVudCBpcyBkZWxldGVkIGZyb20gdGhlIERPTVxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhbmltYXRpb25zIEFuIGFuaW1hdGlvbnMgb2JqZWN0IHdoZXJlIHRoZSBwcm9wZXJ0eSBrZXlzIGFyZSB0aGUgYXR0cmlidXRlcyB5b3UnZCBsaWtlIHRvIGFuaW1hdGUuIFRoZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSBvYmplY3RzIGFnYWluIHRoYXQgY29udGFpbiB0aGUgU01JTCBhbmltYXRpb24gYXR0cmlidXRlcyAodXN1YWxseSBiZWdpbiwgZHVyLCBmcm9tLCBhbmQgdG8pLiBUaGUgcHJvcGVydHkgYmVnaW4gYW5kIGR1ciBpcyBhdXRvIGNvbnZlcnRlZCAoc2VlIEF1dG9tYXRpYyB1bml0IGNvbnZlcnNpb24pLiBZb3UgY2FuIGFsc28gc2NoZWR1bGUgbXVsdGlwbGUgYW5pbWF0aW9ucyBmb3IgdGhlIHNhbWUgYXR0cmlidXRlIGJ5IHBhc3NpbmcgYW4gQXJyYXkgb2YgU01JTCBkZWZpbml0aW9uIG9iamVjdHMuIEF0dHJpYnV0ZXMgdGhhdCBjb250YWluIGFuIGFycmF5IG9mIFNNSUwgZGVmaW5pdGlvbiBvYmplY3RzIHdpbGwgbm90IGJlIGV4ZWN1dGVkIGluIGd1aWRlZCBtb2RlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGd1aWRlZCBTcGVjaWZ5IGlmIGd1aWRlZCBtb2RlIHNob3VsZCBiZSBhY3RpdmF0ZWQgZm9yIHRoaXMgYW5pbWF0aW9uIChzZWUgR3VpZGVkIG1vZGUpLiBJZiBub3Qgb3RoZXJ3aXNlIHNwZWNpZmllZCwgZ3VpZGVkIG1vZGUgd2lsbCBiZSBhY3RpdmF0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudEVtaXR0ZXIgSWYgc3BlY2lmaWVkLCB0aGlzIGV2ZW50IGVtaXR0ZXIgd2lsbCBiZSBub3RpZmllZCB3aGVuIGFuIGFuaW1hdGlvbiBzdGFydHMgb3IgZW5kcy5cbiAgICogQHJldHVybiB7Q2hhcnRpc3QuU3ZnfSBUaGUgY3VycmVudCBlbGVtZW50IHdoZXJlIHRoZSBhbmltYXRpb24gd2FzIGFkZGVkXG4gICAqL1xuICBmdW5jdGlvbiBhbmltYXRlKGFuaW1hdGlvbnMsIGd1aWRlZCwgZXZlbnRFbWl0dGVyKSB7XG4gICAgaWYoZ3VpZGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGd1aWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoYW5pbWF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiBjcmVhdGVBbmltYXRlRm9yQXR0cmlidXRlcyhhdHRyaWJ1dGUpIHtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlQW5pbWF0ZShhbmltYXRpb25EZWZpbml0aW9uLCBndWlkZWQpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZVByb3BlcnRpZXMgPSB7fSxcbiAgICAgICAgICBhbmltYXRlLFxuICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgZWFzaW5nO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGFuIGVhc2luZyBpcyBzcGVjaWZpZWQgaW4gdGhlIGRlZmluaXRpb24gb2JqZWN0IGFuZCBkZWxldGUgaXQgZnJvbSB0aGUgb2JqZWN0IGFzIGl0IHdpbGwgbm90XG4gICAgICAgIC8vIGJlIHBhcnQgb2YgdGhlIGFuaW1hdGUgZWxlbWVudCBhdHRyaWJ1dGVzLlxuICAgICAgICBpZihhbmltYXRpb25EZWZpbml0aW9uLmVhc2luZykge1xuICAgICAgICAgIC8vIElmIGFscmVhZHkgYW4gZWFzaW5nIELDqXppZXIgY3VydmUgYXJyYXkgd2UgdGFrZSBpdCBvciB3ZSBsb29rdXAgYSBlYXNpbmcgYXJyYXkgaW4gdGhlIEVhc2luZyBvYmplY3RcbiAgICAgICAgICBlYXNpbmcgPSBhbmltYXRpb25EZWZpbml0aW9uLmVhc2luZyBpbnN0YW5jZW9mIEFycmF5ID9cbiAgICAgICAgICAgIGFuaW1hdGlvbkRlZmluaXRpb24uZWFzaW5nIDpcbiAgICAgICAgICAgIENoYXJ0aXN0LlN2Zy5FYXNpbmdbYW5pbWF0aW9uRGVmaW5pdGlvbi5lYXNpbmddO1xuICAgICAgICAgIGRlbGV0ZSBhbmltYXRpb25EZWZpbml0aW9uLmVhc2luZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG51bWVyaWMgZHVyIG9yIGJlZ2luIHdhcyBwcm92aWRlZCB3ZSBhc3N1bWUgbWlsbGkgc2Vjb25kc1xuICAgICAgICBhbmltYXRpb25EZWZpbml0aW9uLmJlZ2luID0gQ2hhcnRpc3QuZW5zdXJlVW5pdChhbmltYXRpb25EZWZpbml0aW9uLmJlZ2luLCAnbXMnKTtcbiAgICAgICAgYW5pbWF0aW9uRGVmaW5pdGlvbi5kdXIgPSBDaGFydGlzdC5lbnN1cmVVbml0KGFuaW1hdGlvbkRlZmluaXRpb24uZHVyLCAnbXMnKTtcblxuICAgICAgICBpZihlYXNpbmcpIHtcbiAgICAgICAgICBhbmltYXRpb25EZWZpbml0aW9uLmNhbGNNb2RlID0gJ3NwbGluZSc7XG4gICAgICAgICAgYW5pbWF0aW9uRGVmaW5pdGlvbi5rZXlTcGxpbmVzID0gZWFzaW5nLmpvaW4oJyAnKTtcbiAgICAgICAgICBhbmltYXRpb25EZWZpbml0aW9uLmtleVRpbWVzID0gJzA7MSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGRpbmcgXCJmaWxsOiBmcmVlemVcIiBpZiB3ZSBhcmUgaW4gZ3VpZGVkIG1vZGUgYW5kIHNldCBpbml0aWFsIGF0dHJpYnV0ZSB2YWx1ZXNcbiAgICAgICAgaWYoZ3VpZGVkKSB7XG4gICAgICAgICAgYW5pbWF0aW9uRGVmaW5pdGlvbi5maWxsID0gJ2ZyZWV6ZSc7XG4gICAgICAgICAgLy8gQW5pbWF0ZWQgcHJvcGVydHkgb24gb3VyIGVsZW1lbnQgc2hvdWxkIGFscmVhZHkgYmUgc2V0IHRvIHRoZSBhbmltYXRpb24gZnJvbSB2YWx1ZSBpbiBndWlkZWQgbW9kZVxuICAgICAgICAgIGF0dHJpYnV0ZVByb3BlcnRpZXNbYXR0cmlidXRlXSA9IGFuaW1hdGlvbkRlZmluaXRpb24uZnJvbTtcbiAgICAgICAgICB0aGlzLmF0dHIoYXR0cmlidXRlUHJvcGVydGllcyk7XG5cbiAgICAgICAgICAvLyBJbiBndWlkZWQgbW9kZSB3ZSBhbHNvIHNldCBiZWdpbiB0byBpbmRlZmluaXRlIHNvIHdlIGNhbiB0cmlnZ2VyIHRoZSBzdGFydCBtYW51YWxseSBhbmQgcHV0IHRoZSBiZWdpblxuICAgICAgICAgIC8vIHdoaWNoIG5lZWRzIHRvIGJlIGluIG1zIGFzaWRlXG4gICAgICAgICAgdGltZW91dCA9IENoYXJ0aXN0LnF1YW50aXR5KGFuaW1hdGlvbkRlZmluaXRpb24uYmVnaW4gfHwgMCkudmFsdWU7XG4gICAgICAgICAgYW5pbWF0aW9uRGVmaW5pdGlvbi5iZWdpbiA9ICdpbmRlZmluaXRlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW1hdGUgPSB0aGlzLmVsZW0oJ2FuaW1hdGUnLCBDaGFydGlzdC5leHRlbmQoe1xuICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6IGF0dHJpYnV0ZVxuICAgICAgICB9LCBhbmltYXRpb25EZWZpbml0aW9uKSk7XG5cbiAgICAgICAgaWYoZ3VpZGVkKSB7XG4gICAgICAgICAgLy8gSWYgZ3VpZGVkIHdlIHRha2UgdGhlIHZhbHVlIHRoYXQgd2FzIHB1dCBhc2lkZSBpbiB0aW1lb3V0IGFuZCB0cmlnZ2VyIHRoZSBhbmltYXRpb24gbWFudWFsbHkgd2l0aCBhIHRpbWVvdXRcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gSWYgYmVnaW5FbGVtZW50IGZhaWxzIHdlIHNldCB0aGUgYW5pbWF0ZWQgYXR0cmlidXRlIHRvIHRoZSBlbmQgcG9zaXRpb24gYW5kIHJlbW92ZSB0aGUgYW5pbWF0ZSBlbGVtZW50XG4gICAgICAgICAgICAvLyBUaGlzIGhhcHBlbnMgaWYgdGhlIFNNSUwgRWxlbWVudFRpbWVDb250cm9sIGludGVyZmFjZSBpcyBub3Qgc3VwcG9ydGVkIG9yIGFueSBvdGhlciBwcm9ibGVtcyBvY2N1cmVkIGluXG4gICAgICAgICAgICAvLyB0aGUgYnJvd3Nlci4gKEN1cnJlbnRseSBGRiAzNCBkb2VzIG5vdCBzdXBwb3J0IGFuaW1hdGUgZWxlbWVudHMgaW4gZm9yZWlnbk9iamVjdHMpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhbmltYXRlLl9ub2RlLmJlZ2luRWxlbWVudCgpO1xuICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgLy8gU2V0IGFuaW1hdGVkIGF0dHJpYnV0ZSB0byBjdXJyZW50IGFuaW1hdGVkIHZhbHVlXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZVByb3BlcnRpZXNbYXR0cmlidXRlXSA9IGFuaW1hdGlvbkRlZmluaXRpb24udG87XG4gICAgICAgICAgICAgIHRoaXMuYXR0cihhdHRyaWJ1dGVQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBhbmltYXRlIGVsZW1lbnQgYXMgaXQncyBubyBsb25nZXIgcmVxdWlyZWRcbiAgICAgICAgICAgICAgYW5pbWF0ZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LmJpbmQodGhpcyksIHRpbWVvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZXZlbnRFbWl0dGVyKSB7XG4gICAgICAgICAgYW5pbWF0ZS5fbm9kZS5hZGRFdmVudExpc3RlbmVyKCdiZWdpbkV2ZW50JywgZnVuY3Rpb24gaGFuZGxlQmVnaW5FdmVudCgpIHtcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdhbmltYXRpb25CZWdpbicsIHtcbiAgICAgICAgICAgICAgZWxlbWVudDogdGhpcyxcbiAgICAgICAgICAgICAgYW5pbWF0ZTogYW5pbWF0ZS5fbm9kZSxcbiAgICAgICAgICAgICAgcGFyYW1zOiBhbmltYXRpb25EZWZpbml0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5pbWF0ZS5fbm9kZS5hZGRFdmVudExpc3RlbmVyKCdlbmRFdmVudCcsIGZ1bmN0aW9uIGhhbmRsZUVuZEV2ZW50KCkge1xuICAgICAgICAgIGlmKGV2ZW50RW1pdHRlcikge1xuICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ2FuaW1hdGlvbkVuZCcsIHtcbiAgICAgICAgICAgICAgZWxlbWVudDogdGhpcyxcbiAgICAgICAgICAgICAgYW5pbWF0ZTogYW5pbWF0ZS5fbm9kZSxcbiAgICAgICAgICAgICAgcGFyYW1zOiBhbmltYXRpb25EZWZpbml0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZihndWlkZWQpIHtcbiAgICAgICAgICAgIC8vIFNldCBhbmltYXRlZCBhdHRyaWJ1dGUgdG8gY3VycmVudCBhbmltYXRlZCB2YWx1ZVxuICAgICAgICAgICAgYXR0cmlidXRlUHJvcGVydGllc1thdHRyaWJ1dGVdID0gYW5pbWF0aW9uRGVmaW5pdGlvbi50bztcbiAgICAgICAgICAgIHRoaXMuYXR0cihhdHRyaWJ1dGVQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgYW5pbWF0ZSBlbGVtZW50IGFzIGl0J3Mgbm8gbG9uZ2VyIHJlcXVpcmVkXG4gICAgICAgICAgICBhbmltYXRlLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgY3VycmVudCBhdHRyaWJ1dGUgaXMgYW4gYXJyYXkgb2YgZGVmaW5pdGlvbiBvYmplY3RzIHdlIGNyZWF0ZSBhbiBhbmltYXRlIGZvciBlYWNoIGFuZCBkaXNhYmxlIGd1aWRlZCBtb2RlXG4gICAgICBpZihhbmltYXRpb25zW2F0dHJpYnV0ZV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBhbmltYXRpb25zW2F0dHJpYnV0ZV0uZm9yRWFjaChmdW5jdGlvbihhbmltYXRpb25EZWZpbml0aW9uKSB7XG4gICAgICAgICAgY3JlYXRlQW5pbWF0ZS5iaW5kKHRoaXMpKGFuaW1hdGlvbkRlZmluaXRpb24sIGZhbHNlKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZUFuaW1hdGUuYmluZCh0aGlzKShhbmltYXRpb25zW2F0dHJpYnV0ZV0sIGd1aWRlZCk7XG4gICAgICB9XG5cbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBDaGFydGlzdC5TdmcgPSBDaGFydGlzdC5DbGFzcy5leHRlbmQoe1xuICAgIGNvbnN0cnVjdG9yOiBTdmcsXG4gICAgYXR0cjogYXR0cixcbiAgICBlbGVtOiBlbGVtLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIHJvb3Q6IHJvb3QsXG4gICAgcXVlcnlTZWxlY3RvcjogcXVlcnlTZWxlY3RvcixcbiAgICBxdWVyeVNlbGVjdG9yQWxsOiBxdWVyeVNlbGVjdG9yQWxsLFxuICAgIGdldE5vZGU6IGdldE5vZGUsXG4gICAgZm9yZWlnbk9iamVjdDogZm9yZWlnbk9iamVjdCxcbiAgICB0ZXh0OiB0ZXh0LFxuICAgIGVtcHR5OiBlbXB0eSxcbiAgICByZW1vdmU6IHJlbW92ZSxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGFwcGVuZDogYXBwZW5kLFxuICAgIGNsYXNzZXM6IGNsYXNzZXMsXG4gICAgYWRkQ2xhc3M6IGFkZENsYXNzLFxuICAgIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcbiAgICByZW1vdmVBbGxDbGFzc2VzOiByZW1vdmVBbGxDbGFzc2VzLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBhbmltYXRlOiBhbmltYXRlXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjaGVja3MgZm9yIHN1cHBvcnQgb2YgYSBnaXZlbiBTVkcgZmVhdHVyZSBsaWtlIEV4dGVuc2liaWxpdHksIFNWRy1hbmltYXRpb24gb3IgdGhlIGxpa2UuIENoZWNrIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUgZm9yIGEgZGV0YWlsZWQgbGlzdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LlN2Z1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZmVhdHVyZSBUaGUgU1ZHIDEuMSBmZWF0dXJlIHRoYXQgc2hvdWxkIGJlIGNoZWNrZWQgZm9yIHN1cHBvcnQuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgb2YgZmFsc2UgaWYgdGhlIGZlYXR1cmUgaXMgc3VwcG9ydGVkIG9yIG5vdFxuICAgKi9cbiAgQ2hhcnRpc3QuU3ZnLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlIycgKyBmZWF0dXJlLCAnMS4xJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgT2JqZWN0IGNvbnRhaW5zIHNvbWUgc3RhbmRhcmQgZWFzaW5nIGN1YmljIGJlemllciBjdXJ2ZXMuIFRoZW4gY2FuIGJlIHVzZWQgd2l0aCB0aGVpciBuYW1lIGluIHRoZSBgQ2hhcnRpc3QuU3ZnLmFuaW1hdGVgLiBZb3UgY2FuIGFsc28gZXh0ZW5kIHRoZSBsaXN0IGFuZCB1c2UgeW91ciBvd24gbmFtZSBpbiB0aGUgYGFuaW1hdGVgIGZ1bmN0aW9uLiBDbGljayB0aGUgc2hvdyBjb2RlIGJ1dHRvbiB0byBzZWUgdGhlIGF2YWlsYWJsZSBiZXppZXIgZnVuY3Rpb25zLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnXG4gICAqL1xuICB2YXIgZWFzaW5nQ3ViaWNCZXppZXJzID0ge1xuICAgIGVhc2VJblNpbmU6IFswLjQ3LCAwLCAwLjc0NSwgMC43MTVdLFxuICAgIGVhc2VPdXRTaW5lOiBbMC4zOSwgMC41NzUsIDAuNTY1LCAxXSxcbiAgICBlYXNlSW5PdXRTaW5lOiBbMC40NDUsIDAuMDUsIDAuNTUsIDAuOTVdLFxuICAgIGVhc2VJblF1YWQ6IFswLjU1LCAwLjA4NSwgMC42OCwgMC41M10sXG4gICAgZWFzZU91dFF1YWQ6IFswLjI1LCAwLjQ2LCAwLjQ1LCAwLjk0XSxcbiAgICBlYXNlSW5PdXRRdWFkOiBbMC40NTUsIDAuMDMsIDAuNTE1LCAwLjk1NV0sXG4gICAgZWFzZUluQ3ViaWM6IFswLjU1LCAwLjA1NSwgMC42NzUsIDAuMTldLFxuICAgIGVhc2VPdXRDdWJpYzogWzAuMjE1LCAwLjYxLCAwLjM1NSwgMV0sXG4gICAgZWFzZUluT3V0Q3ViaWM6IFswLjY0NSwgMC4wNDUsIDAuMzU1LCAxXSxcbiAgICBlYXNlSW5RdWFydDogWzAuODk1LCAwLjAzLCAwLjY4NSwgMC4yMl0sXG4gICAgZWFzZU91dFF1YXJ0OiBbMC4xNjUsIDAuODQsIDAuNDQsIDFdLFxuICAgIGVhc2VJbk91dFF1YXJ0OiBbMC43NywgMCwgMC4xNzUsIDFdLFxuICAgIGVhc2VJblF1aW50OiBbMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2XSxcbiAgICBlYXNlT3V0UXVpbnQ6IFswLjIzLCAxLCAwLjMyLCAxXSxcbiAgICBlYXNlSW5PdXRRdWludDogWzAuODYsIDAsIDAuMDcsIDFdLFxuICAgIGVhc2VJbkV4cG86IFswLjk1LCAwLjA1LCAwLjc5NSwgMC4wMzVdLFxuICAgIGVhc2VPdXRFeHBvOiBbMC4xOSwgMSwgMC4yMiwgMV0sXG4gICAgZWFzZUluT3V0RXhwbzogWzEsIDAsIDAsIDFdLFxuICAgIGVhc2VJbkNpcmM6IFswLjYsIDAuMDQsIDAuOTgsIDAuMzM1XSxcbiAgICBlYXNlT3V0Q2lyYzogWzAuMDc1LCAwLjgyLCAwLjE2NSwgMV0sXG4gICAgZWFzZUluT3V0Q2lyYzogWzAuNzg1LCAwLjEzNSwgMC4xNSwgMC44Nl0sXG4gICAgZWFzZUluQmFjazogWzAuNiwgLTAuMjgsIDAuNzM1LCAwLjA0NV0sXG4gICAgZWFzZU91dEJhY2s6IFswLjE3NSwgMC44ODUsIDAuMzIsIDEuMjc1XSxcbiAgICBlYXNlSW5PdXRCYWNrOiBbMC42OCwgLTAuNTUsIDAuMjY1LCAxLjU1XVxuICB9O1xuXG4gIENoYXJ0aXN0LlN2Zy5FYXNpbmcgPSBlYXNpbmdDdWJpY0JlemllcnM7XG5cbiAgLyoqXG4gICAqIFRoaXMgaGVscGVyIGNsYXNzIGlzIHRvIHdyYXAgbXVsdGlwbGUgYENoYXJ0aXN0LlN2Z2AgZWxlbWVudHMgaW50byBhIGxpc3Qgd2hlcmUgeW91IGNhbiBjYWxsIHRoZSBgQ2hhcnRpc3QuU3ZnYCBmdW5jdGlvbnMgb24gYWxsIGVsZW1lbnRzIGluIHRoZSBsaXN0IHdpdGggb25lIGNhbGwuIFRoaXMgaXMgaGVscGZ1bCB3aGVuIHlvdSdkIGxpa2UgdG8gcGVyZm9ybSBjYWxscyB3aXRoIGBDaGFydGlzdC5TdmdgIG9uIG11bHRpcGxlIGVsZW1lbnRzLlxuICAgKiBBbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGlzIGFsc28gcmV0dXJuZWQgYnkgYENoYXJ0aXN0LlN2Zy5xdWVyeVNlbGVjdG9yQWxsYC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LlN2Z1xuICAgKiBAcGFyYW0ge0FycmF5PE5vZGU+fE5vZGVMaXN0fSBub2RlTGlzdCBBbiBBcnJheSBvZiBTVkcgRE9NIG5vZGVzIG9yIGEgU1ZHIERPTSBOb2RlTGlzdCAoYXMgcmV0dXJuZWQgYnkgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbClcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBTdmdMaXN0KG5vZGVMaXN0KSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzO1xuXG4gICAgdGhpcy5zdmdFbGVtZW50cyA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBub2RlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdmdFbGVtZW50cy5wdXNoKG5ldyBDaGFydGlzdC5Tdmcobm9kZUxpc3RbaV0pKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgZGVsZWdhdGlvbiBtZXRob2RzIGZvciBDaGFydGlzdC5TdmdcbiAgICBPYmplY3Qua2V5cyhDaGFydGlzdC5TdmcucHJvdG90eXBlKS5maWx0ZXIoZnVuY3Rpb24ocHJvdG90eXBlUHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBbJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgICAncGFyZW50JyxcbiAgICAgICAgICAncXVlcnlTZWxlY3RvcicsXG4gICAgICAgICAgJ3F1ZXJ5U2VsZWN0b3JBbGwnLFxuICAgICAgICAgICdyZXBsYWNlJyxcbiAgICAgICAgICAnYXBwZW5kJyxcbiAgICAgICAgICAnY2xhc3NlcycsXG4gICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgJ3dpZHRoJ10uaW5kZXhPZihwcm90b3R5cGVQcm9wZXJ0eSkgPT09IC0xO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24ocHJvdG90eXBlUHJvcGVydHkpIHtcbiAgICAgIGxpc3RbcHJvdG90eXBlUHJvcGVydHldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgbGlzdC5zdmdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICBDaGFydGlzdC5TdmcucHJvdG90eXBlW3Byb3RvdHlwZVByb3BlcnR5XS5hcHBseShlbGVtZW50LCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIENoYXJ0aXN0LlN2Zy5MaXN0ID0gQ2hhcnRpc3QuQ2xhc3MuZXh0ZW5kKHtcbiAgICBjb25zdHJ1Y3RvcjogU3ZnTGlzdFxuICB9KTtcbn0odGhpcyB8fCBnbG9iYWwsIENoYXJ0aXN0KSk7XG47LyoqXG4gKiBDaGFydGlzdCBTVkcgcGF0aCBtb2R1bGUgZm9yIFNWRyBwYXRoIGRlc2NyaXB0aW9uIGNyZWF0aW9uIGFuZCBtb2RpZmljYXRpb24uXG4gKlxuICogQG1vZHVsZSBDaGFydGlzdC5TdmcuUGF0aFxuICovXG4vKiBnbG9iYWwgQ2hhcnRpc3QgKi9cbihmdW5jdGlvbihnbG9iYWxSb290LCBDaGFydGlzdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIENvbnRhaW5zIHRoZSBkZXNjcmlwdG9ycyBvZiBzdXBwb3J0ZWQgZWxlbWVudCB0eXBlcyBpbiBhIFNWRyBwYXRoLiBDdXJyZW50bHkgb25seSBtb3ZlLCBsaW5lIGFuZCBjdXJ2ZSBhcmUgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnLlBhdGhcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHZhciBlbGVtZW50RGVzY3JpcHRpb25zID0ge1xuICAgIG06IFsneCcsICd5J10sXG4gICAgbDogWyd4JywgJ3knXSxcbiAgICBjOiBbJ3gxJywgJ3kxJywgJ3gyJywgJ3kyJywgJ3gnLCAneSddLFxuICAgIGE6IFsncngnLCAncnknLCAneEFyJywgJ2xBZicsICdzZicsICd4JywgJ3knXVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IG9wdGlvbnMgZm9yIG5ld2x5IGNyZWF0ZWQgU1ZHIHBhdGggb2JqZWN0cy5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LlN2Zy5QYXRoXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgLy8gVGhlIGFjY3VyYWN5IGluIGRpZ2l0IGNvdW50IGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBUaGlzIHdpbGwgYmUgdXNlZCB0byByb3VuZCBudW1iZXJzIGluIHRoZSBTVkcgcGF0aC4gSWYgdGhpcyBvcHRpb24gaXMgc2V0IHRvIGZhbHNlIHRoZW4gbm8gcm91bmRpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG4gICAgYWNjdXJhY3k6IDNcbiAgfTtcblxuICBmdW5jdGlvbiBlbGVtZW50KGNvbW1hbmQsIHBhcmFtcywgcGF0aEVsZW1lbnRzLCBwb3MsIHJlbGF0aXZlLCBkYXRhKSB7XG4gICAgdmFyIHBhdGhFbGVtZW50ID0gQ2hhcnRpc3QuZXh0ZW5kKHtcbiAgICAgIGNvbW1hbmQ6IHJlbGF0aXZlID8gY29tbWFuZC50b0xvd2VyQ2FzZSgpIDogY29tbWFuZC50b1VwcGVyQ2FzZSgpXG4gICAgfSwgcGFyYW1zLCBkYXRhID8geyBkYXRhOiBkYXRhIH0gOiB7fSApO1xuXG4gICAgcGF0aEVsZW1lbnRzLnNwbGljZShwb3MsIDAsIHBhdGhFbGVtZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvckVhY2hQYXJhbShwYXRoRWxlbWVudHMsIGNiKSB7XG4gICAgcGF0aEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24ocGF0aEVsZW1lbnQsIHBhdGhFbGVtZW50SW5kZXgpIHtcbiAgICAgIGVsZW1lbnREZXNjcmlwdGlvbnNbcGF0aEVsZW1lbnQuY29tbWFuZC50b0xvd2VyQ2FzZSgpXS5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtTmFtZSwgcGFyYW1JbmRleCkge1xuICAgICAgICBjYihwYXRoRWxlbWVudCwgcGFyYW1OYW1lLCBwYXRoRWxlbWVudEluZGV4LCBwYXJhbUluZGV4LCBwYXRoRWxlbWVudHMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBjb25zdHJ1Y3QgYSBuZXcgcGF0aCBvYmplY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5TdmcuUGF0aFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsb3NlIElmIHNldCB0byB0cnVlIHRoZW4gdGhpcyBwYXRoIHdpbGwgYmUgY2xvc2VkIHdoZW4gc3RyaW5naWZpZWQgKHdpdGggYSBaIGF0IHRoZSBlbmQpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0IHRoYXQgb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IG9iamVjdHMuIFNlZSBkZWZhdWx0IG9wdGlvbnMgZm9yIG1vcmUgZGV0YWlscy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBTdmdQYXRoKGNsb3NlLCBvcHRpb25zKSB7XG4gICAgdGhpcy5wYXRoRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5jbG9zZSA9IGNsb3NlO1xuICAgIHRoaXMub3B0aW9ucyA9IENoYXJ0aXN0LmV4dGVuZCh7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBwb3NpdGlvbiAoY3Vyc29yKSBpbnNpZGUgb2YgdGhlIHBhdGguIFlvdSBjYW4gbW92ZSBhcm91bmQgdGhlIGN1cnNvciBmcmVlbHkgYnV0IGxpbWl0ZWQgdG8gMCBvciB0aGUgY291bnQgb2YgZXhpc3RpbmcgZWxlbWVudHMuIEFsbCBtb2RpZmljYXRpb25zIHdpdGggZWxlbWVudCBmdW5jdGlvbnMgd2lsbCBpbnNlcnQgbmV3IGVsZW1lbnRzIGF0IHRoZSBwb3NpdGlvbiBvZiB0aGlzIGN1cnNvci5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LlN2Zy5QYXRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zXSBJZiBhIG51bWJlciBpcyBwYXNzZWQgdGhlbiB0aGUgY3Vyc29yIGlzIHNldCB0byB0aGlzIHBvc2l0aW9uIGluIHRoZSBwYXRoIGVsZW1lbnQgYXJyYXkuXG4gICAqIEByZXR1cm4ge0NoYXJ0aXN0LlN2Zy5QYXRofE51bWJlcn0gSWYgdGhlIHBvc2l0aW9uIHBhcmFtZXRlciB3YXMgcGFzc2VkIHRoZW4gdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHRoZSBwYXRoIG9iamVjdCBmb3IgZWFzeSBjYWxsIGNoYWluaW5nLiBJZiBubyBwb3NpdGlvbiBwYXJhbWV0ZXIgd2FzIHBhc3NlZCB0aGVuIHRoZSBjdXJyZW50IHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZnVuY3Rpb24gcG9zaXRpb24ocG9zKSB7XG4gICAgaWYocG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucG9zID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5wYXRoRWxlbWVudHMubGVuZ3RoLCBwb3MpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3M7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSB0aGUgcGF0aCBzdGFydGluZyBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LlN2Zy5QYXRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgcGF0aCBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSByZW1vdmVkIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqIEByZXR1cm4ge0NoYXJ0aXN0LlN2Zy5QYXRofSBUaGUgY3VycmVudCBwYXRoIG9iamVjdCBmb3IgZWFzeSBjYWxsIGNoYWluaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlKGNvdW50KSB7XG4gICAgdGhpcy5wYXRoRWxlbWVudHMuc3BsaWNlKHRoaXMucG9zLCBjb3VudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgZnVuY3Rpb24gdG8gYWRkIGEgbmV3IG1vdmUgU1ZHIHBhdGggZWxlbWVudC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LlN2Zy5QYXRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgZm9yIHRoZSBtb3ZlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgZm9yIHRoZSBtb3ZlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbGF0aXZlXSBJZiBzZXQgdG8gdHJ1ZSB0aGUgbW92ZSBlbGVtZW50IHdpbGwgYmUgY3JlYXRlZCB3aXRoIHJlbGF0aXZlIGNvb3JkaW5hdGVzIChsb3dlcmNhc2UgbGV0dGVyKVxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBBbnkgZGF0YSB0aGF0IHNob3VsZCBiZSBzdG9yZWQgd2l0aCB0aGUgZWxlbWVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGFjY2Vzc2libGUgaW4gcGF0aEVsZW1lbnRcbiAgICogQHJldHVybiB7Q2hhcnRpc3QuU3ZnLlBhdGh9IFRoZSBjdXJyZW50IHBhdGggb2JqZWN0IGZvciBlYXN5IGNhbGwgY2hhaW5pbmcuXG4gICAqL1xuICBmdW5jdGlvbiBtb3ZlKHgsIHksIHJlbGF0aXZlLCBkYXRhKSB7XG4gICAgZWxlbWVudCgnTScsIHtcbiAgICAgIHg6ICt4LFxuICAgICAgeTogK3lcbiAgICB9LCB0aGlzLnBhdGhFbGVtZW50cywgdGhpcy5wb3MrKywgcmVsYXRpdmUsIGRhdGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIGFkZCBhIG5ldyBsaW5lIFNWRyBwYXRoIGVsZW1lbnQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5TdmcuUGF0aFxuICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIGZvciB0aGUgbGluZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIGZvciB0aGUgbGluZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWxhdGl2ZV0gSWYgc2V0IHRvIHRydWUgdGhlIGxpbmUgZWxlbWVudCB3aWxsIGJlIGNyZWF0ZWQgd2l0aCByZWxhdGl2ZSBjb29yZGluYXRlcyAobG93ZXJjYXNlIGxldHRlcilcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gQW55IGRhdGEgdGhhdCBzaG91bGQgYmUgc3RvcmVkIHdpdGggdGhlIGVsZW1lbnQgb2JqZWN0IHRoYXQgd2lsbCBiZSBhY2Nlc3NpYmxlIGluIHBhdGhFbGVtZW50XG4gICAqIEByZXR1cm4ge0NoYXJ0aXN0LlN2Zy5QYXRofSBUaGUgY3VycmVudCBwYXRoIG9iamVjdCBmb3IgZWFzeSBjYWxsIGNoYWluaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gbGluZSh4LCB5LCByZWxhdGl2ZSwgZGF0YSkge1xuICAgIGVsZW1lbnQoJ0wnLCB7XG4gICAgICB4OiAreCxcbiAgICAgIHk6ICt5XG4gICAgfSwgdGhpcy5wYXRoRWxlbWVudHMsIHRoaXMucG9zKyssIHJlbGF0aXZlLCBkYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBmdW5jdGlvbiB0byBhZGQgYSBuZXcgY3VydmUgU1ZHIHBhdGggZWxlbWVudC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LlN2Zy5QYXRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MSBUaGUgeCBjb29yZGluYXRlIGZvciB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBvZiB0aGUgYmV6aWVyIGN1cnZlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geTEgVGhlIHkgY29vcmRpbmF0ZSBmb3IgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgb2YgdGhlIGJlemllciBjdXJ2ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIFRoZSB4IGNvb3JkaW5hdGUgZm9yIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvZiB0aGUgYmV6aWVyIGN1cnZlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geTIgVGhlIHkgY29vcmRpbmF0ZSBmb3IgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9mIHRoZSBiZXppZXIgY3VydmUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0YXJnZXQgcG9pbnQgb2YgdGhlIGN1cnZlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgZm9yIHRoZSB0YXJnZXQgcG9pbnQgb2YgdGhlIGN1cnZlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbGF0aXZlXSBJZiBzZXQgdG8gdHJ1ZSB0aGUgY3VydmUgZWxlbWVudCB3aWxsIGJlIGNyZWF0ZWQgd2l0aCByZWxhdGl2ZSBjb29yZGluYXRlcyAobG93ZXJjYXNlIGxldHRlcilcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gQW55IGRhdGEgdGhhdCBzaG91bGQgYmUgc3RvcmVkIHdpdGggdGhlIGVsZW1lbnQgb2JqZWN0IHRoYXQgd2lsbCBiZSBhY2Nlc3NpYmxlIGluIHBhdGhFbGVtZW50XG4gICAqIEByZXR1cm4ge0NoYXJ0aXN0LlN2Zy5QYXRofSBUaGUgY3VycmVudCBwYXRoIG9iamVjdCBmb3IgZWFzeSBjYWxsIGNoYWluaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY3VydmUoeDEsIHkxLCB4MiwgeTIsIHgsIHksIHJlbGF0aXZlLCBkYXRhKSB7XG4gICAgZWxlbWVudCgnQycsIHtcbiAgICAgIHgxOiAreDEsXG4gICAgICB5MTogK3kxLFxuICAgICAgeDI6ICt4MixcbiAgICAgIHkyOiAreTIsXG4gICAgICB4OiAreCxcbiAgICAgIHk6ICt5XG4gICAgfSwgdGhpcy5wYXRoRWxlbWVudHMsIHRoaXMucG9zKyssIHJlbGF0aXZlLCBkYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBmdW5jdGlvbiB0byBhZGQgYSBuZXcgbm9uLWJlemllciBjdXJ2ZSBTVkcgcGF0aCBlbGVtZW50LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnLlBhdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJ4IFRoZSByYWRpdXMgdG8gYmUgdXNlZCBmb3IgdGhlIHgtYXhpcyBvZiB0aGUgYXJjLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcnkgVGhlIHJhZGl1cyB0byBiZSB1c2VkIGZvciB0aGUgeS1heGlzIG9mIHRoZSBhcmMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4QXIgRGVmaW5lcyB0aGUgb3JpZW50YXRpb24gb2YgdGhlIGFyY1xuICAgKiBAcGFyYW0ge051bWJlcn0gbEFmIExhcmdlIGFyYyBmbGFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzZiBTd2VlcCBmbGFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgZm9yIHRoZSB0YXJnZXQgcG9pbnQgb2YgdGhlIGN1cnZlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgZm9yIHRoZSB0YXJnZXQgcG9pbnQgb2YgdGhlIGN1cnZlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbGF0aXZlXSBJZiBzZXQgdG8gdHJ1ZSB0aGUgY3VydmUgZWxlbWVudCB3aWxsIGJlIGNyZWF0ZWQgd2l0aCByZWxhdGl2ZSBjb29yZGluYXRlcyAobG93ZXJjYXNlIGxldHRlcilcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gQW55IGRhdGEgdGhhdCBzaG91bGQgYmUgc3RvcmVkIHdpdGggdGhlIGVsZW1lbnQgb2JqZWN0IHRoYXQgd2lsbCBiZSBhY2Nlc3NpYmxlIGluIHBhdGhFbGVtZW50XG4gICAqIEByZXR1cm4ge0NoYXJ0aXN0LlN2Zy5QYXRofSBUaGUgY3VycmVudCBwYXRoIG9iamVjdCBmb3IgZWFzeSBjYWxsIGNoYWluaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJjKHJ4LCByeSwgeEFyLCBsQWYsIHNmLCB4LCB5LCByZWxhdGl2ZSwgZGF0YSkge1xuICAgIGVsZW1lbnQoJ0EnLCB7XG4gICAgICByeDogK3J4LFxuICAgICAgcnk6ICtyeSxcbiAgICAgIHhBcjogK3hBcixcbiAgICAgIGxBZjogK2xBZixcbiAgICAgIHNmOiArc2YsXG4gICAgICB4OiAreCxcbiAgICAgIHk6ICt5XG4gICAgfSwgdGhpcy5wYXRoRWxlbWVudHMsIHRoaXMucG9zKyssIHJlbGF0aXZlLCBkYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gU1ZHIHBhdGggc2VlbiBpbiB0aGUgZCBhdHRyaWJ1dGUgb2YgcGF0aCBlbGVtZW50cywgYW5kIGluc2VydHMgdGhlIHBhcnNlZCBlbGVtZW50cyBpbnRvIHRoZSBleGlzdGluZyBwYXRoIG9iamVjdCBhdCB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb24uIEFueSBjbG9zaW5nIHBhdGggaW5kaWNhdG9ycyAoWiBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoKSB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIHBhcnNlciBhcyB0aGlzIGlzIHByb3ZpZGVkIGJ5IHRoZSBjbG9zZSBvcHRpb24gaW4gdGhlIG9wdGlvbnMgb2YgdGhlIHBhdGggb2JqZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnLlBhdGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggQW55IFNWRyBwYXRoIHRoYXQgY29udGFpbnMgbW92ZSAobSksIGxpbmUgKGwpIG9yIGN1cnZlIChjKSBjb21wb25lbnRzLlxuICAgKiBAcmV0dXJuIHtDaGFydGlzdC5TdmcuUGF0aH0gVGhlIGN1cnJlbnQgcGF0aCBvYmplY3QgZm9yIGVhc3kgY2FsbCBjaGFpbmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcbiAgICAvLyBQYXJzaW5nIHRoZSBTVkcgcGF0aCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBhcnJheXMgW1snTScsICcxMCcsICcxMCddLCBbJ0wnLCAnMTAwJywgJzEwMCddXVxuICAgIHZhciBjaHVua3MgPSBwYXRoLnJlcGxhY2UoLyhbQS1aYS16XSkoWzAtOV0pL2csICckMSAkMicpXG4gICAgICAucmVwbGFjZSgvKFswLTldKShbQS1aYS16XSkvZywgJyQxICQyJylcbiAgICAgIC5zcGxpdCgvW1xccyxdKy8pXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uKHJlc3VsdCwgZWxlbWVudCkge1xuICAgICAgICBpZihlbGVtZW50Lm1hdGNoKC9bQS1aYS16XS8pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwgW10pO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhIGNsb3NlZCBwYXRoIHdlIHJlbW92ZSB0aGUgWiBhdCB0aGUgZW5kIGJlY2F1c2UgdGhpcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBjbG9zZSBvcHRpb25cbiAgICBpZihjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdWzBdLnRvVXBwZXJDYXNlKCkgPT09ICdaJykge1xuICAgICAgY2h1bmtzLnBvcCgpO1xuICAgIH1cblxuICAgIC8vIFVzaW5nIHN2Z1BhdGhFbGVtZW50RGVzY3JpcHRpb25zIHRvIG1hcCByYXcgcGF0aCBhcnJheXMgaW50byBvYmplY3RzIHRoYXQgY29udGFpbiB0aGUgY29tbWFuZCBhbmQgdGhlIHBhcmFtZXRlcnNcbiAgICAvLyBGb3IgZXhhbXBsZSB7Y29tbWFuZDogJ00nLCB4OiAnMTAnLCB5OiAnMTAnfVxuICAgIHZhciBlbGVtZW50cyA9IGNodW5rcy5tYXAoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgdmFyIGNvbW1hbmQgPSBjaHVuay5zaGlmdCgpLFxuICAgICAgICAgIGRlc2NyaXB0aW9uID0gZWxlbWVudERlc2NyaXB0aW9uc1tjb21tYW5kLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIHJldHVybiBDaGFydGlzdC5leHRlbmQoe1xuICAgICAgICAgIGNvbW1hbmQ6IGNvbW1hbmRcbiAgICAgICAgfSwgZGVzY3JpcHRpb24ucmVkdWNlKGZ1bmN0aW9uKHJlc3VsdCwgcGFyYW1OYW1lLCBpbmRleCkge1xuICAgICAgICAgIHJlc3VsdFtwYXJhbU5hbWVdID0gK2NodW5rW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCB7fSkpO1xuICAgICAgfSk7XG5cbiAgICAvLyBQcmVwYXJpbmcgYSBzcGxpY2UgY2FsbCB3aXRoIHRoZSBlbGVtZW50cyBhcnJheSBhcyB2YXIgYXJnIHBhcmFtcyBhbmQgaW5zZXJ0IHRoZSBwYXJzZWQgZWxlbWVudHMgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICB2YXIgc3BsaWNlQXJncyA9IFt0aGlzLnBvcywgMF07XG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoc3BsaWNlQXJncywgZWxlbWVudHMpO1xuICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkodGhpcy5wYXRoRWxlbWVudHMsIHNwbGljZUFyZ3MpO1xuICAgIC8vIEluY3JlYXNlIHRoZSBpbnRlcm5hbCBwb3NpdGlvbiBieSB0aGUgZWxlbWVudCBjb3VudFxuICAgIHRoaXMucG9zICs9IGVsZW1lbnRzLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gcmVuZGVycyB0byBjdXJyZW50IFNWRyBwYXRoIG9iamVjdCBpbnRvIGEgZmluYWwgU1ZHIHN0cmluZyB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBkIGF0dHJpYnV0ZSBvZiBTVkcgcGF0aCBlbGVtZW50cy4gSXQgdXNlcyB0aGUgYWNjdXJhY3kgb3B0aW9uIHRvIHJvdW5kIGJpZyBkZWNpbWFscy4gSWYgdGhlIGNsb3NlIHBhcmFtZXRlciB3YXMgc2V0IGluIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGlzIHBhdGggb2JqZWN0IHRoZW4gYSBwYXRoIGNsb3NpbmcgWiB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBvdXRwdXQgc3RyaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnLlBhdGhcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5naWZ5KCkge1xuICAgIHZhciBhY2N1cmFjeU11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgdGhpcy5vcHRpb25zLmFjY3VyYWN5KTtcblxuICAgIHJldHVybiB0aGlzLnBhdGhFbGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24ocGF0aCwgcGF0aEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGVsZW1lbnREZXNjcmlwdGlvbnNbcGF0aEVsZW1lbnQuY29tbWFuZC50b0xvd2VyQ2FzZSgpXS5tYXAoZnVuY3Rpb24ocGFyYW1OYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hY2N1cmFjeSA/XG4gICAgICAgICAgICAoTWF0aC5yb3VuZChwYXRoRWxlbWVudFtwYXJhbU5hbWVdICogYWNjdXJhY3lNdWx0aXBsaWVyKSAvIGFjY3VyYWN5TXVsdGlwbGllcikgOlxuICAgICAgICAgICAgcGF0aEVsZW1lbnRbcGFyYW1OYW1lXTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gcGF0aCArIHBhdGhFbGVtZW50LmNvbW1hbmQgKyBwYXJhbXMuam9pbignLCcpO1xuICAgICAgfS5iaW5kKHRoaXMpLCAnJykgKyAodGhpcy5jbG9zZSA/ICdaJyA6ICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsZXMgYWxsIGVsZW1lbnRzIGluIHRoZSBjdXJyZW50IFNWRyBwYXRoIG9iamVjdC4gVGhlcmUgaXMgYW4gaW5kaXZpZHVhbCBwYXJhbWV0ZXIgZm9yIGVhY2ggY29vcmRpbmF0ZS4gU2NhbGluZyB3aWxsIGFsc28gYmUgZG9uZSBmb3IgY29udHJvbCBwb2ludHMgb2YgY3VydmVzLCBhZmZlY3RpbmcgdGhlIGdpdmVuIGNvb3JkaW5hdGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5TdmcuUGF0aFxuICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgbnVtYmVyIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBzY2FsZSB0aGUgeCwgeDEgYW5kIHgyIG9mIGFsbCBwYXRoIGVsZW1lbnRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgbnVtYmVyIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBzY2FsZSB0aGUgeSwgeTEgYW5kIHkyIG9mIGFsbCBwYXRoIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJuIHtDaGFydGlzdC5TdmcuUGF0aH0gVGhlIGN1cnJlbnQgcGF0aCBvYmplY3QgZm9yIGVhc3kgY2FsbCBjaGFpbmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlKHgsIHkpIHtcbiAgICBmb3JFYWNoUGFyYW0odGhpcy5wYXRoRWxlbWVudHMsIGZ1bmN0aW9uKHBhdGhFbGVtZW50LCBwYXJhbU5hbWUpIHtcbiAgICAgIHBhdGhFbGVtZW50W3BhcmFtTmFtZV0gKj0gcGFyYW1OYW1lWzBdID09PSAneCcgPyB4IDogeTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGVzIGFsbCBlbGVtZW50cyBpbiB0aGUgY3VycmVudCBTVkcgcGF0aCBvYmplY3QuIFRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSBhbmQgdGhlcmUgaXMgYW4gaW5kaXZpZHVhbCBwYXJhbWV0ZXIgZm9yIGVhY2ggY29vcmRpbmF0ZS4gVHJhbnNsYXRpb24gd2lsbCBhbHNvIGJlIGRvbmUgZm9yIGNvbnRyb2wgcG9pbnRzIG9mIGN1cnZlcywgYWZmZWN0aW5nIHRoZSBnaXZlbiBjb29yZGluYXRlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnLlBhdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIG51bWJlciB3aGljaCB3aWxsIGJlIHVzZWQgdG8gdHJhbnNsYXRlIHRoZSB4LCB4MSBhbmQgeDIgb2YgYWxsIHBhdGggZWxlbWVudHMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBudW1iZXIgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHRyYW5zbGF0ZSB0aGUgeSwgeTEgYW5kIHkyIG9mIGFsbCBwYXRoIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJuIHtDaGFydGlzdC5TdmcuUGF0aH0gVGhlIGN1cnJlbnQgcGF0aCBvYmplY3QgZm9yIGVhc3kgY2FsbCBjaGFpbmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgZm9yRWFjaFBhcmFtKHRoaXMucGF0aEVsZW1lbnRzLCBmdW5jdGlvbihwYXRoRWxlbWVudCwgcGFyYW1OYW1lKSB7XG4gICAgICBwYXRoRWxlbWVudFtwYXJhbU5hbWVdICs9IHBhcmFtTmFtZVswXSA9PT0gJ3gnID8geCA6IHk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHJ1biBvdmVyIGFsbCBleGlzdGluZyBwYXRoIGVsZW1lbnRzIGFuZCB0aGVuIGxvb3Agb3ZlciB0aGVpciBhdHRyaWJ1dGVzLiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGV2ZXJ5IHBhdGggZWxlbWVudCBhdHRyaWJ1dGUgdGhhdCBleGlzdHMgaW4gdGhlIGN1cnJlbnQgcGF0aC5cbiAgICogVGhlIG1ldGhvZCBzaWduYXR1cmUgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGxvb2tzIGxpa2UgdGhpczpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBmdW5jdGlvbihwYXRoRWxlbWVudCwgcGFyYW1OYW1lLCBwYXRoRWxlbWVudEluZGV4LCBwYXJhbUluZGV4LCBwYXRoRWxlbWVudHMpXG4gICAqIGBgYFxuICAgKiBJZiBzb21ldGhpbmcgZWxzZSB0aGFuIHVuZGVmaW5lZCBpcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24sIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkIHRvIHJlcGxhY2UgdGhlIG9sZCB2YWx1ZS4gVGhpcyBhbGxvd3MgeW91IHRvIGJ1aWxkIGN1c3RvbSB0cmFuc2Zvcm1hdGlvbnMgb2YgcGF0aCBvYmplY3RzIHRoYXQgY2FuJ3QgYmUgYWNoaWV2ZWQgdXNpbmcgdGhlIGJhc2ljIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyBzY2FsZSBhbmQgdHJhbnNsYXRlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnLlBhdGhcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtRm5jIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIHRyYW5zZm9ybWF0aW9uLiBDaGVjayB0aGUgc2lnbmF0dXJlIGluIHRoZSBmdW5jdGlvbiBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybiB7Q2hhcnRpc3QuU3ZnLlBhdGh9IFRoZSBjdXJyZW50IHBhdGggb2JqZWN0IGZvciBlYXN5IGNhbGwgY2hhaW5pbmcuXG4gICAqL1xuICBmdW5jdGlvbiB0cmFuc2Zvcm0odHJhbnNmb3JtRm5jKSB7XG4gICAgZm9yRWFjaFBhcmFtKHRoaXMucGF0aEVsZW1lbnRzLCBmdW5jdGlvbihwYXRoRWxlbWVudCwgcGFyYW1OYW1lLCBwYXRoRWxlbWVudEluZGV4LCBwYXJhbUluZGV4LCBwYXRoRWxlbWVudHMpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybUZuYyhwYXRoRWxlbWVudCwgcGFyYW1OYW1lLCBwYXRoRWxlbWVudEluZGV4LCBwYXJhbUluZGV4LCBwYXRoRWxlbWVudHMpO1xuICAgICAgaWYodHJhbnNmb3JtZWQgfHwgdHJhbnNmb3JtZWQgPT09IDApIHtcbiAgICAgICAgcGF0aEVsZW1lbnRbcGFyYW1OYW1lXSA9IHRyYW5zZm9ybWVkO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gY2xvbmVzIGEgd2hvbGUgcGF0aCBvYmplY3Qgd2l0aCBhbGwgaXRzIHByb3BlcnRpZXMuIFRoaXMgaXMgYSBkZWVwIGNsb25lIGFuZCBwYXRoIGVsZW1lbnQgb2JqZWN0cyB3aWxsIGFsc28gYmUgY2xvbmVkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnLlBhdGhcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY2xvc2VdIE9wdGlvbmFsIG9wdGlvbiB0byBzZXQgdGhlIG5ldyBjbG9uZWQgcGF0aCB0byBjbG9zZWQuIElmIG5vdCBzcGVjaWZpZWQgb3IgZmFsc2UsIHRoZSBvcmlnaW5hbCBwYXRoIGNsb3NlIG9wdGlvbiB3aWxsIGJlIHVzZWQuXG4gICAqIEByZXR1cm4ge0NoYXJ0aXN0LlN2Zy5QYXRofVxuICAgKi9cbiAgZnVuY3Rpb24gY2xvbmUoY2xvc2UpIHtcbiAgICB2YXIgYyA9IG5ldyBDaGFydGlzdC5TdmcuUGF0aChjbG9zZSB8fCB0aGlzLmNsb3NlKTtcbiAgICBjLnBvcyA9IHRoaXMucG9zO1xuICAgIGMucGF0aEVsZW1lbnRzID0gdGhpcy5wYXRoRWxlbWVudHMuc2xpY2UoKS5tYXAoZnVuY3Rpb24gY2xvbmVFbGVtZW50cyhwYXRoRWxlbWVudCkge1xuICAgICAgcmV0dXJuIENoYXJ0aXN0LmV4dGVuZCh7fSwgcGF0aEVsZW1lbnQpO1xuICAgIH0pO1xuICAgIGMub3B0aW9ucyA9IENoYXJ0aXN0LmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zKTtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCBhIFN2Zy5QYXRoIG9iamVjdCBieSBhIHNwZWNpZmljIGNvbW1hbmQgaW4gdGhlIHBhdGggY2hhaW4uIFRoZSBwYXRoIGNoYWluIHdpbGwgYmUgc3BsaXQgYW5kIGFuIGFycmF5IG9mIG5ld2x5IGNyZWF0ZWQgcGF0aHMgb2JqZWN0cyB3aWxsIGJlIHJldHVybmVkLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3UnZCBsaWtlIHRvIHNwbGl0IGFuIFNWRyBwYXRoIGJ5IGl0J3MgbW92ZSBjb21tYW5kcywgZm9yIGV4YW1wbGUsIGluIG9yZGVyIHRvIGlzb2xhdGUgY2h1bmtzIG9mIGRyYXdpbmdzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnLlBhdGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbW1hbmQgVGhlIGNvbW1hbmQgeW91J2QgbGlrZSB0byB1c2UgdG8gc3BsaXQgdGhlIHBhdGhcbiAgICogQHJldHVybiB7QXJyYXk8Q2hhcnRpc3QuU3ZnLlBhdGg+fVxuICAgKi9cbiAgZnVuY3Rpb24gc3BsaXRCeUNvbW1hbmQoY29tbWFuZCkge1xuICAgIHZhciBzcGxpdCA9IFtcbiAgICAgIG5ldyBDaGFydGlzdC5TdmcuUGF0aCgpXG4gICAgXTtcblxuICAgIHRoaXMucGF0aEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24ocGF0aEVsZW1lbnQpIHtcbiAgICAgIGlmKHBhdGhFbGVtZW50LmNvbW1hbmQgPT09IGNvbW1hbmQudG9VcHBlckNhc2UoKSAmJiBzcGxpdFtzcGxpdC5sZW5ndGggLSAxXS5wYXRoRWxlbWVudHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHNwbGl0LnB1c2gobmV3IENoYXJ0aXN0LlN2Zy5QYXRoKCkpO1xuICAgICAgfVxuXG4gICAgICBzcGxpdFtzcGxpdC5sZW5ndGggLSAxXS5wYXRoRWxlbWVudHMucHVzaChwYXRoRWxlbWVudCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3BsaXQ7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBzdGF0aWMgZnVuY3Rpb24gb24gYENoYXJ0aXN0LlN2Zy5QYXRoYCBpcyBqb2luaW5nIG11bHRpcGxlIHBhdGhzIHRvZ2V0aGVyIGludG8gb25lIHBhdGhzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuU3ZnLlBhdGhcbiAgICogQHBhcmFtIHtBcnJheTxDaGFydGlzdC5TdmcuUGF0aD59IHBhdGhzIEEgbGlzdCBvZiBwYXRocyB0byBiZSBqb2luZWQgdG9nZXRoZXIuIFRoZSBvcmRlciBpcyBpbXBvcnRhbnQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xvc2UgSWYgdGhlIG5ld2x5IGNyZWF0ZWQgcGF0aCBzaG91bGQgYmUgYSBjbG9zZWQgcGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQYXRoIG9wdGlvbnMgZm9yIHRoZSBuZXdseSBjcmVhdGVkIHBhdGguXG4gICAqIEByZXR1cm4ge0NoYXJ0aXN0LlN2Zy5QYXRofVxuICAgKi9cblxuICBmdW5jdGlvbiBqb2luKHBhdGhzLCBjbG9zZSwgb3B0aW9ucykge1xuICAgIHZhciBqb2luZWRQYXRoID0gbmV3IENoYXJ0aXN0LlN2Zy5QYXRoKGNsb3NlLCBvcHRpb25zKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXRoID0gcGF0aHNbaV07XG4gICAgICBmb3IodmFyIGogPSAwOyBqIDwgcGF0aC5wYXRoRWxlbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgam9pbmVkUGF0aC5wYXRoRWxlbWVudHMucHVzaChwYXRoLnBhdGhFbGVtZW50c1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqb2luZWRQYXRoO1xuICB9XG5cbiAgQ2hhcnRpc3QuU3ZnLlBhdGggPSBDaGFydGlzdC5DbGFzcy5leHRlbmQoe1xuICAgIGNvbnN0cnVjdG9yOiBTdmdQYXRoLFxuICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICByZW1vdmU6IHJlbW92ZSxcbiAgICBtb3ZlOiBtb3ZlLFxuICAgIGxpbmU6IGxpbmUsXG4gICAgY3VydmU6IGN1cnZlLFxuICAgIGFyYzogYXJjLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICB0cmFuc2xhdGU6IHRyYW5zbGF0ZSxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnksXG4gICAgY2xvbmU6IGNsb25lLFxuICAgIHNwbGl0QnlDb21tYW5kOiBzcGxpdEJ5Q29tbWFuZFxuICB9KTtcblxuICBDaGFydGlzdC5TdmcuUGF0aC5lbGVtZW50RGVzY3JpcHRpb25zID0gZWxlbWVudERlc2NyaXB0aW9ucztcbiAgQ2hhcnRpc3QuU3ZnLlBhdGguam9pbiA9IGpvaW47XG59KHRoaXMgfHwgZ2xvYmFsLCBDaGFydGlzdCkpO1xuOy8qIGdsb2JhbCBDaGFydGlzdCAqL1xuKGZ1bmN0aW9uIChnbG9iYWxSb290LCBDaGFydGlzdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHdpbmRvdyA9IGdsb2JhbFJvb3Qud2luZG93O1xuICB2YXIgZG9jdW1lbnQgPSBnbG9iYWxSb290LmRvY3VtZW50O1xuXG4gIHZhciBheGlzVW5pdHMgPSB7XG4gICAgeDoge1xuICAgICAgcG9zOiAneCcsXG4gICAgICBsZW46ICd3aWR0aCcsXG4gICAgICBkaXI6ICdob3Jpem9udGFsJyxcbiAgICAgIHJlY3RTdGFydDogJ3gxJyxcbiAgICAgIHJlY3RFbmQ6ICd4MicsXG4gICAgICByZWN0T2Zmc2V0OiAneTInXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICBwb3M6ICd5JyxcbiAgICAgIGxlbjogJ2hlaWdodCcsXG4gICAgICBkaXI6ICd2ZXJ0aWNhbCcsXG4gICAgICByZWN0U3RhcnQ6ICd5MicsXG4gICAgICByZWN0RW5kOiAneTEnLFxuICAgICAgcmVjdE9mZnNldDogJ3gxJ1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBBeGlzKHVuaXRzLCBjaGFydFJlY3QsIHRpY2tzLCBvcHRpb25zKSB7XG4gICAgdGhpcy51bml0cyA9IHVuaXRzO1xuICAgIHRoaXMuY291bnRlclVuaXRzID0gdW5pdHMgPT09IGF4aXNVbml0cy54ID8gYXhpc1VuaXRzLnkgOiBheGlzVW5pdHMueDtcbiAgICB0aGlzLmNoYXJ0UmVjdCA9IGNoYXJ0UmVjdDtcbiAgICB0aGlzLmF4aXNMZW5ndGggPSBjaGFydFJlY3RbdW5pdHMucmVjdEVuZF0gLSBjaGFydFJlY3RbdW5pdHMucmVjdFN0YXJ0XTtcbiAgICB0aGlzLmdyaWRPZmZzZXQgPSBjaGFydFJlY3RbdW5pdHMucmVjdE9mZnNldF07XG4gICAgdGhpcy50aWNrcyA9IHRpY2tzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVHcmlkQW5kTGFiZWxzKGdyaWRHcm91cCwgbGFiZWxHcm91cCwgdXNlRm9yZWlnbk9iamVjdCwgY2hhcnRPcHRpb25zLCBldmVudEVtaXR0ZXIpIHtcbiAgICB2YXIgYXhpc09wdGlvbnMgPSBjaGFydE9wdGlvbnNbJ2F4aXMnICsgdGhpcy51bml0cy5wb3MudG9VcHBlckNhc2UoKV07XG4gICAgdmFyIHByb2plY3RlZFZhbHVlcyA9IHRoaXMudGlja3MubWFwKHRoaXMucHJvamVjdFZhbHVlLmJpbmQodGhpcykpO1xuICAgIHZhciBsYWJlbFZhbHVlcyA9IHRoaXMudGlja3MubWFwKGF4aXNPcHRpb25zLmxhYmVsSW50ZXJwb2xhdGlvbkZuYyk7XG5cbiAgICBwcm9qZWN0ZWRWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbihwcm9qZWN0ZWRWYWx1ZSwgaW5kZXgpIHtcbiAgICAgIHZhciBsYWJlbE9mZnNldCA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcblxuICAgICAgLy8gVE9ETzogRmluZCBiZXR0ZXIgc29sdXRpb24gZm9yIHNvbHZpbmcgdGhpcyBwcm9ibGVtXG4gICAgICAvLyBDYWxjdWxhdGUgaG93IG11Y2ggc3BhY2Ugd2UgaGF2ZSBhdmFpbGFibGUgZm9yIHRoZSBsYWJlbFxuICAgICAgdmFyIGxhYmVsTGVuZ3RoO1xuICAgICAgaWYocHJvamVjdGVkVmFsdWVzW2luZGV4ICsgMV0pIHtcbiAgICAgICAgLy8gSWYgd2Ugc3RpbGwgaGF2ZSBvbmUgbGFiZWwgYWhlYWQsIHdlIGNhbiBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIHRvIHRoZSBuZXh0IHRpY2sgLyBsYWJlbFxuICAgICAgICBsYWJlbExlbmd0aCA9IHByb2plY3RlZFZhbHVlc1tpbmRleCArIDFdIC0gcHJvamVjdGVkVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgbGFiZWwgYWhlYWQgYW5kIHdlIGhhdmUgb25seSB0d28gbGFiZWxzIGluIHRvdGFsLCB3ZSBqdXN0IHRha2UgdGhlIHJlbWFpbmluZyBkaXN0YW5jZSB0b1xuICAgICAgICAvLyBvbiB0aGUgd2hvbGUgYXhpcyBsZW5ndGguIFdlIGxpbWl0IHRoYXQgdG8gYSBtaW5pbXVtIG9mIDMwIHBpeGVsLCBzbyB0aGF0IGxhYmVscyBjbG9zZSB0byB0aGUgYm9yZGVyIHdpbGxcbiAgICAgICAgLy8gc3RpbGwgYmUgdmlzaWJsZSBpbnNpZGUgb2YgdGhlIGNoYXJ0IHBhZGRpbmcuXG4gICAgICAgIGxhYmVsTGVuZ3RoID0gTWF0aC5tYXgodGhpcy5heGlzTGVuZ3RoIC0gcHJvamVjdGVkVmFsdWUsIDMwKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBncmlkIGxpbmVzIGFuZCBsYWJlbHMgd2hlcmUgaW50ZXJwb2xhdGVkIGxhYmVsIHZhbHVlcyBhcmUgZmFsc2V5IChleGVjcHQgZm9yIDApXG4gICAgICBpZihDaGFydGlzdC5pc0ZhbHNleUJ1dFplcm8obGFiZWxWYWx1ZXNbaW5kZXhdKSAmJiBsYWJlbFZhbHVlc1tpbmRleF0gIT09ICcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVHJhbnNmb3JtIHRvIGdsb2JhbCBjb29yZGluYXRlcyB1c2luZyB0aGUgY2hhcnRSZWN0XG4gICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSBsYWJlbCBvZmZzZXQgZm9yIHRoZSBjcmVhdGVMYWJlbCBmdW5jdGlvblxuICAgICAgaWYodGhpcy51bml0cy5wb3MgPT09ICd4Jykge1xuICAgICAgICBwcm9qZWN0ZWRWYWx1ZSA9IHRoaXMuY2hhcnRSZWN0LngxICsgcHJvamVjdGVkVmFsdWU7XG4gICAgICAgIGxhYmVsT2Zmc2V0LnggPSBjaGFydE9wdGlvbnMuYXhpc1gubGFiZWxPZmZzZXQueDtcblxuICAgICAgICAvLyBJZiB0aGUgbGFiZWxzIHNob3VsZCBiZSBwb3NpdGlvbmVkIGluIHN0YXJ0IHBvc2l0aW9uICh0b3Agc2lkZSBmb3IgdmVydGljYWwgYXhpcykgd2UgbmVlZCB0byBzZXQgYVxuICAgICAgICAvLyBkaWZmZXJlbnQgb2Zmc2V0IGFzIGZvciBwb3NpdGlvbmVkIHdpdGggZW5kIChib3R0b20pXG4gICAgICAgIGlmKGNoYXJ0T3B0aW9ucy5heGlzWC5wb3NpdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgIGxhYmVsT2Zmc2V0LnkgPSB0aGlzLmNoYXJ0UmVjdC5wYWRkaW5nLnRvcCArIGNoYXJ0T3B0aW9ucy5heGlzWC5sYWJlbE9mZnNldC55ICsgKHVzZUZvcmVpZ25PYmplY3QgPyA1IDogMjApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhYmVsT2Zmc2V0LnkgPSB0aGlzLmNoYXJ0UmVjdC55MSArIGNoYXJ0T3B0aW9ucy5heGlzWC5sYWJlbE9mZnNldC55ICsgKHVzZUZvcmVpZ25PYmplY3QgPyA1IDogMjApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9qZWN0ZWRWYWx1ZSA9IHRoaXMuY2hhcnRSZWN0LnkxIC0gcHJvamVjdGVkVmFsdWU7XG4gICAgICAgIGxhYmVsT2Zmc2V0LnkgPSBjaGFydE9wdGlvbnMuYXhpc1kubGFiZWxPZmZzZXQueSAtICh1c2VGb3JlaWduT2JqZWN0ID8gbGFiZWxMZW5ndGggOiAwKTtcblxuICAgICAgICAvLyBJZiB0aGUgbGFiZWxzIHNob3VsZCBiZSBwb3NpdGlvbmVkIGluIHN0YXJ0IHBvc2l0aW9uIChsZWZ0IHNpZGUgZm9yIGhvcml6b250YWwgYXhpcykgd2UgbmVlZCB0byBzZXQgYVxuICAgICAgICAvLyBkaWZmZXJlbnQgb2Zmc2V0IGFzIGZvciBwb3NpdGlvbmVkIHdpdGggZW5kIChyaWdodCBzaWRlKVxuICAgICAgICBpZihjaGFydE9wdGlvbnMuYXhpc1kucG9zaXRpb24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgICBsYWJlbE9mZnNldC54ID0gdXNlRm9yZWlnbk9iamVjdCA/IHRoaXMuY2hhcnRSZWN0LnBhZGRpbmcubGVmdCArIGNoYXJ0T3B0aW9ucy5heGlzWS5sYWJlbE9mZnNldC54IDogdGhpcy5jaGFydFJlY3QueDEgLSAxMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbE9mZnNldC54ID0gdGhpcy5jaGFydFJlY3QueDIgKyBjaGFydE9wdGlvbnMuYXhpc1kubGFiZWxPZmZzZXQueCArIDEwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGF4aXNPcHRpb25zLnNob3dHcmlkKSB7XG4gICAgICAgIENoYXJ0aXN0LmNyZWF0ZUdyaWQocHJvamVjdGVkVmFsdWUsIGluZGV4LCB0aGlzLCB0aGlzLmdyaWRPZmZzZXQsIHRoaXMuY2hhcnRSZWN0W3RoaXMuY291bnRlclVuaXRzLmxlbl0oKSwgZ3JpZEdyb3VwLCBbXG4gICAgICAgICAgY2hhcnRPcHRpb25zLmNsYXNzTmFtZXMuZ3JpZCxcbiAgICAgICAgICBjaGFydE9wdGlvbnMuY2xhc3NOYW1lc1t0aGlzLnVuaXRzLmRpcl1cbiAgICAgICAgXSwgZXZlbnRFbWl0dGVyKTtcbiAgICAgIH1cblxuICAgICAgaWYoYXhpc09wdGlvbnMuc2hvd0xhYmVsKSB7XG4gICAgICAgIENoYXJ0aXN0LmNyZWF0ZUxhYmVsKHByb2plY3RlZFZhbHVlLCBsYWJlbExlbmd0aCwgaW5kZXgsIGxhYmVsVmFsdWVzLCB0aGlzLCBheGlzT3B0aW9ucy5vZmZzZXQsIGxhYmVsT2Zmc2V0LCBsYWJlbEdyb3VwLCBbXG4gICAgICAgICAgY2hhcnRPcHRpb25zLmNsYXNzTmFtZXMubGFiZWwsXG4gICAgICAgICAgY2hhcnRPcHRpb25zLmNsYXNzTmFtZXNbdGhpcy51bml0cy5kaXJdLFxuICAgICAgICAgIChheGlzT3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3N0YXJ0JyA/IGNoYXJ0T3B0aW9ucy5jbGFzc05hbWVzW2F4aXNPcHRpb25zLnBvc2l0aW9uXSA6IGNoYXJ0T3B0aW9ucy5jbGFzc05hbWVzWydlbmQnXSlcbiAgICAgICAgXSwgdXNlRm9yZWlnbk9iamVjdCwgZXZlbnRFbWl0dGVyKTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG5cbiAgQ2hhcnRpc3QuQXhpcyA9IENoYXJ0aXN0LkNsYXNzLmV4dGVuZCh7XG4gICAgY29uc3RydWN0b3I6IEF4aXMsXG4gICAgY3JlYXRlR3JpZEFuZExhYmVsczogY3JlYXRlR3JpZEFuZExhYmVscyxcbiAgICBwcm9qZWN0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYXNlIGF4aXMgY2FuXFwndCBiZSBpbnN0YW50aWF0ZWQhJyk7XG4gICAgfVxuICB9KTtcblxuICBDaGFydGlzdC5BeGlzLnVuaXRzID0gYXhpc1VuaXRzO1xuXG59KHRoaXMgfHwgZ2xvYmFsLCBDaGFydGlzdCkpO1xuOy8qKlxuICogVGhlIGF1dG8gc2NhbGUgYXhpcyB1c2VzIHN0YW5kYXJkIGxpbmVhciBzY2FsZSBwcm9qZWN0aW9uIG9mIHZhbHVlcyBhbG9uZyBhbiBheGlzLiBJdCB1c2VzIG9yZGVyIG9mIG1hZ25pdHVkZSB0byBmaW5kIGEgc2NhbGUgYXV0b21hdGljYWxseSBhbmQgZXZhbHVhdGVzIHRoZSBhdmFpbGFibGUgc3BhY2UgaW4gb3JkZXIgdG8gZmluZCB0aGUgcGVyZmVjdCBhbW91bnQgb2YgdGlja3MgZm9yIHlvdXIgY2hhcnQuXG4gKiAqKk9wdGlvbnMqKlxuICogVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSB1c2VkIGJ5IHRoaXMgYXhpcyBpbiBhZGRpdGlvbiB0byB0aGUgZGVmYXVsdCBheGlzIG9wdGlvbnMgb3V0bGluZWQgaW4gdGhlIGF4aXMgY29uZmlndXJhdGlvbiBvZiB0aGUgY2hhcnQgZGVmYXVsdCBzZXR0aW5ncy5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBvcHRpb25zID0ge1xuICogICAvLyBJZiBoaWdoIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBheGlzIHdpbGwgZGlzcGxheSB2YWx1ZXMgZXhwbGljaXRseSB1cCB0byB0aGlzIHZhbHVlIGFuZCB0aGUgY29tcHV0ZWQgbWF4aW11bSBmcm9tIHRoZSBkYXRhIGlzIGlnbm9yZWRcbiAqICAgaGlnaDogMTAwLFxuICogICAvLyBJZiBsb3cgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGF4aXMgd2lsbCBkaXNwbGF5IHZhbHVlcyBleHBsaWNpdGx5IGRvd24gdG8gdGhpcyB2YWx1ZSBhbmQgdGhlIGNvbXB1dGVkIG1pbmltdW0gZnJvbSB0aGUgZGF0YSBpcyBpZ25vcmVkXG4gKiAgIGxvdzogMCxcbiAqICAgLy8gVGhpcyBvcHRpb24gd2lsbCBiZSB1c2VkIHdoZW4gZmluZGluZyB0aGUgcmlnaHQgc2NhbGUgZGl2aXNpb24gc2V0dGluZ3MuIFRoZSBhbW91bnQgb2YgdGlja3Mgb24gdGhlIHNjYWxlIHdpbGwgYmUgZGV0ZXJtaW5lZCBzbyB0aGF0IGFzIG1hbnkgdGlja3MgYXMgcG9zc2libGUgd2lsbCBiZSBkaXNwbGF5ZWQsIHdoaWxlIG5vdCB2aW9sYXRpbmcgdGhpcyBtaW5pbXVtIHJlcXVpcmVkIHNwYWNlIChpbiBwaXhlbCkuXG4gKiAgIHNjYWxlTWluU3BhY2U6IDIwLFxuICogICAvLyBDYW4gYmUgc2V0IHRvIHRydWUgb3IgZmFsc2UuIElmIHNldCB0byB0cnVlLCB0aGUgc2NhbGUgd2lsbCBiZSBnZW5lcmF0ZWQgd2l0aCB3aG9sZSBudW1iZXJzIG9ubHkuXG4gKiAgIG9ubHlJbnRlZ2VyOiB0cnVlLFxuICogICAvLyBUaGUgcmVmZXJlbmNlIHZhbHVlIGNhbiBiZSB1c2VkIHRvIG1ha2Ugc3VyZSB0aGF0IHRoaXMgdmFsdWUgd2lsbCBhbHdheXMgYmUgb24gdGhlIGNoYXJ0LiBUaGlzIGlzIGVzcGVjaWFsbHkgdXNlZnVsIG9uIGJpcG9sYXIgY2hhcnRzIHdoZXJlIHRoZSBiaXBvbGFyIGNlbnRlciBhbHdheXMgbmVlZHMgdG8gYmUgcGFydCBvZiB0aGUgY2hhcnQuXG4gKiAgIHJlZmVyZW5jZVZhbHVlOiA1XG4gKiB9O1xuICogYGBgXG4gKlxuICogQG1vZHVsZSBDaGFydGlzdC5BdXRvU2NhbGVBeGlzXG4gKi9cbi8qIGdsb2JhbCBDaGFydGlzdCAqL1xuKGZ1bmN0aW9uIChnbG9iYWxSb290LCBDaGFydGlzdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHdpbmRvdyA9IGdsb2JhbFJvb3Qud2luZG93O1xuICB2YXIgZG9jdW1lbnQgPSBnbG9iYWxSb290LmRvY3VtZW50O1xuXG4gIGZ1bmN0aW9uIEF1dG9TY2FsZUF4aXMoYXhpc1VuaXQsIGRhdGEsIGNoYXJ0UmVjdCwgb3B0aW9ucykge1xuICAgIC8vIFVzdWFsbHkgd2UgY2FsY3VsYXRlIGhpZ2hMb3cgYmFzZWQgb24gdGhlIGRhdGEgYnV0IHRoaXMgY2FuIGJlIG92ZXJyaWRlbiBieSBhIGhpZ2hMb3cgb2JqZWN0IGluIHRoZSBvcHRpb25zXG4gICAgdmFyIGhpZ2hMb3cgPSBvcHRpb25zLmhpZ2hMb3cgfHwgQ2hhcnRpc3QuZ2V0SGlnaExvdyhkYXRhLCBvcHRpb25zLCBheGlzVW5pdC5wb3MpO1xuICAgIHRoaXMuYm91bmRzID0gQ2hhcnRpc3QuZ2V0Qm91bmRzKGNoYXJ0UmVjdFtheGlzVW5pdC5yZWN0RW5kXSAtIGNoYXJ0UmVjdFtheGlzVW5pdC5yZWN0U3RhcnRdLCBoaWdoTG93LCBvcHRpb25zLnNjYWxlTWluU3BhY2UgfHwgMjAsIG9wdGlvbnMub25seUludGVnZXIpO1xuICAgIHRoaXMucmFuZ2UgPSB7XG4gICAgICBtaW46IHRoaXMuYm91bmRzLm1pbixcbiAgICAgIG1heDogdGhpcy5ib3VuZHMubWF4XG4gICAgfTtcblxuICAgIENoYXJ0aXN0LkF1dG9TY2FsZUF4aXMuc3VwZXIuY29uc3RydWN0b3IuY2FsbCh0aGlzLFxuICAgICAgYXhpc1VuaXQsXG4gICAgICBjaGFydFJlY3QsXG4gICAgICB0aGlzLmJvdW5kcy52YWx1ZXMsXG4gICAgICBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2plY3RWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmF4aXNMZW5ndGggKiAoK0NoYXJ0aXN0LmdldE11bHRpVmFsdWUodmFsdWUsIHRoaXMudW5pdHMucG9zKSAtIHRoaXMuYm91bmRzLm1pbikgLyB0aGlzLmJvdW5kcy5yYW5nZTtcbiAgfVxuXG4gIENoYXJ0aXN0LkF1dG9TY2FsZUF4aXMgPSBDaGFydGlzdC5BeGlzLmV4dGVuZCh7XG4gICAgY29uc3RydWN0b3I6IEF1dG9TY2FsZUF4aXMsXG4gICAgcHJvamVjdFZhbHVlOiBwcm9qZWN0VmFsdWVcbiAgfSk7XG5cbn0odGhpcyB8fCBnbG9iYWwsIENoYXJ0aXN0KSk7XG47LyoqXG4gKiBUaGUgZml4ZWQgc2NhbGUgYXhpcyB1c2VzIHN0YW5kYXJkIGxpbmVhciBwcm9qZWN0aW9uIG9mIHZhbHVlcyBhbG9uZyBhbiBheGlzLiBJdCBtYWtlcyB1c2Ugb2YgYSBkaXZpc29yIG9wdGlvbiB0byBkaXZpZGUgdGhlIHJhbmdlIHByb3ZpZGVkIGZyb20gdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWUgb3IgdGhlIG9wdGlvbnMgaGlnaCBhbmQgbG93IHRoYXQgd2lsbCBvdmVycmlkZSB0aGUgY29tcHV0ZWQgbWluaW11bSBhbmQgbWF4aW11bS5cbiAqICoqT3B0aW9ucyoqXG4gKiBUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIHVzZWQgYnkgdGhpcyBheGlzIGluIGFkZGl0aW9uIHRvIHRoZSBkZWZhdWx0IGF4aXMgb3B0aW9ucyBvdXRsaW5lZCBpbiB0aGUgYXhpcyBjb25maWd1cmF0aW9uIG9mIHRoZSBjaGFydCBkZWZhdWx0IHNldHRpbmdzLlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG9wdGlvbnMgPSB7XG4gKiAgIC8vIElmIGhpZ2ggaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGF4aXMgd2lsbCBkaXNwbGF5IHZhbHVlcyBleHBsaWNpdGx5IHVwIHRvIHRoaXMgdmFsdWUgYW5kIHRoZSBjb21wdXRlZCBtYXhpbXVtIGZyb20gdGhlIGRhdGEgaXMgaWdub3JlZFxuICogICBoaWdoOiAxMDAsXG4gKiAgIC8vIElmIGxvdyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgYXhpcyB3aWxsIGRpc3BsYXkgdmFsdWVzIGV4cGxpY2l0bHkgZG93biB0byB0aGlzIHZhbHVlIGFuZCB0aGUgY29tcHV0ZWQgbWluaW11bSBmcm9tIHRoZSBkYXRhIGlzIGlnbm9yZWRcbiAqICAgbG93OiAwLFxuICogICAvLyBJZiBzcGVjaWZpZWQgdGhlbiB0aGUgdmFsdWUgcmFuZ2UgZGV0ZXJtaW5lZCBmcm9tIG1pbmltdW0gdG8gbWF4aW11bSAob3IgbG93IGFuZCBoaWdoKSB3aWxsIGJlIGRpdmlkZWQgYnkgdGhpcyBudW1iZXIgYW5kIHRpY2tzIHdpbGwgYmUgZ2VuZXJhdGVkIGF0IHRob3NlIGRpdmlzaW9uIHBvaW50cy4gVGhlIGRlZmF1bHQgZGl2aXNvciBpcyAxLlxuICogICBkaXZpc29yOiA0LFxuICogICAvLyBJZiB0aWNrcyBpcyBleHBsaWNpdGx5IHNldCwgdGhlbiB0aGUgYXhpcyB3aWxsIG5vdCBjb21wdXRlIHRoZSB0aWNrcyB3aXRoIHRoZSBkaXZpc29yLCBidXQgZGlyZWN0bHkgdXNlIHRoZSBkYXRhIGluIHRpY2tzIHRvIGRldGVybWluZSBhdCB3aGF0IHBvaW50cyBvbiB0aGUgYXhpcyBhIHRpY2sgbmVlZCB0byBiZSBnZW5lcmF0ZWQuXG4gKiAgIHRpY2tzOiBbMSwgMTAsIDIwLCAzMF1cbiAqIH07XG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlIENoYXJ0aXN0LkZpeGVkU2NhbGVBeGlzXG4gKi9cbi8qIGdsb2JhbCBDaGFydGlzdCAqL1xuKGZ1bmN0aW9uIChnbG9iYWxSb290LCBDaGFydGlzdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHdpbmRvdyA9IGdsb2JhbFJvb3Qud2luZG93O1xuICB2YXIgZG9jdW1lbnQgPSBnbG9iYWxSb290LmRvY3VtZW50O1xuXG4gIGZ1bmN0aW9uIEZpeGVkU2NhbGVBeGlzKGF4aXNVbml0LCBkYXRhLCBjaGFydFJlY3QsIG9wdGlvbnMpIHtcbiAgICB2YXIgaGlnaExvdyA9IG9wdGlvbnMuaGlnaExvdyB8fCBDaGFydGlzdC5nZXRIaWdoTG93KGRhdGEsIG9wdGlvbnMsIGF4aXNVbml0LnBvcyk7XG4gICAgdGhpcy5kaXZpc29yID0gb3B0aW9ucy5kaXZpc29yIHx8IDE7XG4gICAgdGhpcy50aWNrcyA9IG9wdGlvbnMudGlja3MgfHwgQ2hhcnRpc3QudGltZXModGhpcy5kaXZpc29yKS5tYXAoZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICByZXR1cm4gaGlnaExvdy5sb3cgKyAoaGlnaExvdy5oaWdoIC0gaGlnaExvdy5sb3cpIC8gdGhpcy5kaXZpc29yICogaW5kZXg7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnRpY2tzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pO1xuICAgIHRoaXMucmFuZ2UgPSB7XG4gICAgICBtaW46IGhpZ2hMb3cubG93LFxuICAgICAgbWF4OiBoaWdoTG93LmhpZ2hcbiAgICB9O1xuXG4gICAgQ2hhcnRpc3QuRml4ZWRTY2FsZUF4aXMuc3VwZXIuY29uc3RydWN0b3IuY2FsbCh0aGlzLFxuICAgICAgYXhpc1VuaXQsXG4gICAgICBjaGFydFJlY3QsXG4gICAgICB0aGlzLnRpY2tzLFxuICAgICAgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnN0ZXBMZW5ndGggPSB0aGlzLmF4aXNMZW5ndGggLyB0aGlzLmRpdmlzb3I7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9qZWN0VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5heGlzTGVuZ3RoICogKCtDaGFydGlzdC5nZXRNdWx0aVZhbHVlKHZhbHVlLCB0aGlzLnVuaXRzLnBvcykgLSB0aGlzLnJhbmdlLm1pbikgLyAodGhpcy5yYW5nZS5tYXggLSB0aGlzLnJhbmdlLm1pbik7XG4gIH1cblxuICBDaGFydGlzdC5GaXhlZFNjYWxlQXhpcyA9IENoYXJ0aXN0LkF4aXMuZXh0ZW5kKHtcbiAgICBjb25zdHJ1Y3RvcjogRml4ZWRTY2FsZUF4aXMsXG4gICAgcHJvamVjdFZhbHVlOiBwcm9qZWN0VmFsdWVcbiAgfSk7XG5cbn0odGhpcyB8fCBnbG9iYWwsIENoYXJ0aXN0KSk7XG47LyoqXG4gKiBUaGUgc3RlcCBheGlzIGZvciBzdGVwIGJhc2VkIGNoYXJ0cyBsaWtlIGJhciBjaGFydCBvciBzdGVwIGJhc2VkIGxpbmUgY2hhcnRzLiBJdCB1c2VzIGEgZml4ZWQgYW1vdW50IG9mIHRpY2tzIHRoYXQgd2lsbCBiZSBlcXVhbGx5IGRpc3RyaWJ1dGVkIGFjcm9zcyB0aGUgd2hvbGUgYXhpcyBsZW5ndGguIFRoZSBwcm9qZWN0aW9uIGlzIGRvbmUgdXNpbmcgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHZhbHVlIHJhdGhlciB0aGFuIHRoZSB2YWx1ZSBpdHNlbGYgYW5kIHRoZXJlZm9yZSBpdCdzIG9ubHkgdXNlZnVsIGZvciBkaXN0cmlidXRpb24gcHVycG9zZS5cbiAqICoqT3B0aW9ucyoqXG4gKiBUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIHVzZWQgYnkgdGhpcyBheGlzIGluIGFkZGl0aW9uIHRvIHRoZSBkZWZhdWx0IGF4aXMgb3B0aW9ucyBvdXRsaW5lZCBpbiB0aGUgYXhpcyBjb25maWd1cmF0aW9uIG9mIHRoZSBjaGFydCBkZWZhdWx0IHNldHRpbmdzLlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG9wdGlvbnMgPSB7XG4gKiAgIC8vIFRpY2tzIHRvIGJlIHVzZWQgdG8gZGlzdHJpYnV0ZSBhY3Jvc3MgdGhlIGF4aXMgbGVuZ3RoLiBBcyB0aGlzIGF4aXMgdHlwZSByZWxpZXMgb24gdGhlIGluZGV4IG9mIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgdmFsdWUsIGFyYml0cmFyeSBkYXRhIHRoYXQgY2FuIGJlIGNvbnZlcnRlZCB0byBhIHN0cmluZyBjYW4gYmUgdXNlZCBhcyB0aWNrcy5cbiAqICAgdGlja3M6IFsnT25lJywgJ1R3bycsICdUaHJlZSddLFxuICogICAvLyBJZiBzZXQgdG8gdHJ1ZSB0aGUgZnVsbCB3aWR0aCB3aWxsIGJlIHVzZWQgdG8gZGlzdHJpYnV0ZSB0aGUgdmFsdWVzIHdoZXJlIHRoZSBsYXN0IHZhbHVlIHdpbGwgYmUgYXQgdGhlIG1heGltdW0gb2YgdGhlIGF4aXMgbGVuZ3RoLiBJZiBmYWxzZSB0aGUgc3BhY2VzIGJldHdlZW4gdGhlIHRpY2tzIHdpbGwgYmUgZXZlbmx5IGRpc3RyaWJ1dGVkIGluc3RlYWQuXG4gKiAgIHN0cmV0Y2g6IHRydWVcbiAqIH07XG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlIENoYXJ0aXN0LlN0ZXBBeGlzXG4gKi9cbi8qIGdsb2JhbCBDaGFydGlzdCAqL1xuKGZ1bmN0aW9uIChnbG9iYWxSb290LCBDaGFydGlzdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHdpbmRvdyA9IGdsb2JhbFJvb3Qud2luZG93O1xuICB2YXIgZG9jdW1lbnQgPSBnbG9iYWxSb290LmRvY3VtZW50O1xuXG4gIGZ1bmN0aW9uIFN0ZXBBeGlzKGF4aXNVbml0LCBkYXRhLCBjaGFydFJlY3QsIG9wdGlvbnMpIHtcbiAgICBDaGFydGlzdC5TdGVwQXhpcy5zdXBlci5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsXG4gICAgICBheGlzVW5pdCxcbiAgICAgIGNoYXJ0UmVjdCxcbiAgICAgIG9wdGlvbnMudGlja3MsXG4gICAgICBvcHRpb25zKTtcblxuICAgIHZhciBjYWxjID0gTWF0aC5tYXgoMSwgb3B0aW9ucy50aWNrcy5sZW5ndGggLSAob3B0aW9ucy5zdHJldGNoID8gMSA6IDApKTtcbiAgICB0aGlzLnN0ZXBMZW5ndGggPSB0aGlzLmF4aXNMZW5ndGggLyBjYWxjO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvamVjdFZhbHVlKHZhbHVlLCBpbmRleCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBMZW5ndGggKiBpbmRleDtcbiAgfVxuXG4gIENoYXJ0aXN0LlN0ZXBBeGlzID0gQ2hhcnRpc3QuQXhpcy5leHRlbmQoe1xuICAgIGNvbnN0cnVjdG9yOiBTdGVwQXhpcyxcbiAgICBwcm9qZWN0VmFsdWU6IHByb2plY3RWYWx1ZVxuICB9KTtcblxufSh0aGlzIHx8IGdsb2JhbCwgQ2hhcnRpc3QpKTtcbjsvKipcbiAqIFRoZSBDaGFydGlzdCBsaW5lIGNoYXJ0IGNhbiBiZSB1c2VkIHRvIGRyYXcgTGluZSBvciBTY2F0dGVyIGNoYXJ0cy4gSWYgdXNlZCBpbiB0aGUgYnJvd3NlciB5b3UgY2FuIGFjY2VzcyB0aGUgZ2xvYmFsIGBDaGFydGlzdGAgbmFtZXNwYWNlIHdoZXJlIHlvdSBmaW5kIHRoZSBgTGluZWAgZnVuY3Rpb24gYXMgYSBtYWluIGVudHJ5IHBvaW50LlxuICpcbiAqIEZvciBleGFtcGxlcyBvbiBob3cgdG8gdXNlIHRoZSBsaW5lIGNoYXJ0IHBsZWFzZSBjaGVjayB0aGUgZXhhbXBsZXMgb2YgdGhlIGBDaGFydGlzdC5MaW5lYCBtZXRob2QuXG4gKlxuICogQG1vZHVsZSBDaGFydGlzdC5MaW5lXG4gKi9cbi8qIGdsb2JhbCBDaGFydGlzdCAqL1xuKGZ1bmN0aW9uKGdsb2JhbFJvb3QsIENoYXJ0aXN0KXtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB3aW5kb3cgPSBnbG9iYWxSb290LndpbmRvdztcbiAgdmFyIGRvY3VtZW50ID0gZ2xvYmFsUm9vdC5kb2N1bWVudDtcblxuICAvKipcbiAgICogRGVmYXVsdCBvcHRpb25zIGluIGxpbmUgY2hhcnRzLiBFeHBhbmQgdGhlIGNvZGUgdmlldyB0byBzZWUgYSBkZXRhaWxlZCBsaXN0IG9mIG9wdGlvbnMgd2l0aCBjb21tZW50cy5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkxpbmVcbiAgICovXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAvLyBPcHRpb25zIGZvciBYLUF4aXNcbiAgICBheGlzWDoge1xuICAgICAgLy8gVGhlIG9mZnNldCBvZiB0aGUgbGFiZWxzIHRvIHRoZSBjaGFydCBhcmVhXG4gICAgICBvZmZzZXQ6IDMwLFxuICAgICAgLy8gUG9zaXRpb24gd2hlcmUgbGFiZWxzIGFyZSBwbGFjZWQuIENhbiBiZSBzZXQgdG8gYHN0YXJ0YCBvciBgZW5kYCB3aGVyZSBgc3RhcnRgIGlzIGVxdWl2YWxlbnQgdG8gbGVmdCBvciB0b3Agb24gdmVydGljYWwgYXhpcyBhbmQgYGVuZGAgaXMgZXF1aXZhbGVudCB0byByaWdodCBvciBib3R0b20gb24gaG9yaXpvbnRhbCBheGlzLlxuICAgICAgcG9zaXRpb246ICdlbmQnLFxuICAgICAgLy8gQWxsb3dzIHlvdSB0byBjb3JyZWN0IGxhYmVsIHBvc2l0aW9uaW5nIG9uIHRoaXMgYXhpcyBieSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSB4IGFuZCB5IG9mZnNldC5cbiAgICAgIGxhYmVsT2Zmc2V0OiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICAvLyBJZiBsYWJlbHMgc2hvdWxkIGJlIHNob3duIG9yIG5vdFxuICAgICAgc2hvd0xhYmVsOiB0cnVlLFxuICAgICAgLy8gSWYgdGhlIGF4aXMgZ3JpZCBzaG91bGQgYmUgZHJhd24gb3Igbm90XG4gICAgICBzaG93R3JpZDogdHJ1ZSxcbiAgICAgIC8vIEludGVycG9sYXRpb24gZnVuY3Rpb24gdGhhdCBhbGxvd3MgeW91IHRvIGludGVyY2VwdCB0aGUgdmFsdWUgZnJvbSB0aGUgYXhpcyBsYWJlbFxuICAgICAgbGFiZWxJbnRlcnBvbGF0aW9uRm5jOiBDaGFydGlzdC5ub29wLFxuICAgICAgLy8gU2V0IHRoZSBheGlzIHR5cGUgdG8gYmUgdXNlZCB0byBwcm9qZWN0IHZhbHVlcyBvbiB0aGlzIGF4aXMuIElmIG5vdCBkZWZpbmVkLCBDaGFydGlzdC5TdGVwQXhpcyB3aWxsIGJlIHVzZWQgZm9yIHRoZSBYLUF4aXMsIHdoZXJlIHRoZSB0aWNrcyBvcHRpb24gd2lsbCBiZSBzZXQgdG8gdGhlIGxhYmVscyBpbiB0aGUgZGF0YSBhbmQgdGhlIHN0cmV0Y2ggb3B0aW9uIHdpbGwgYmUgc2V0IHRvIHRoZSBnbG9iYWwgZnVsbFdpZHRoIG9wdGlvbi4gVGhpcyB0eXBlIGNhbiBiZSBjaGFuZ2VkIHRvIGFueSBheGlzIGNvbnN0cnVjdG9yIGF2YWlsYWJsZSAoZS5nLiBDaGFydGlzdC5GaXhlZFNjYWxlQXhpcyksIHdoZXJlIGFsbCBheGlzIG9wdGlvbnMgc2hvdWxkIGJlIHByZXNlbnQgaGVyZS5cbiAgICAgIHR5cGU6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgLy8gT3B0aW9ucyBmb3IgWS1BeGlzXG4gICAgYXhpc1k6IHtcbiAgICAgIC8vIFRoZSBvZmZzZXQgb2YgdGhlIGxhYmVscyB0byB0aGUgY2hhcnQgYXJlYVxuICAgICAgb2Zmc2V0OiA0MCxcbiAgICAgIC8vIFBvc2l0aW9uIHdoZXJlIGxhYmVscyBhcmUgcGxhY2VkLiBDYW4gYmUgc2V0IHRvIGBzdGFydGAgb3IgYGVuZGAgd2hlcmUgYHN0YXJ0YCBpcyBlcXVpdmFsZW50IHRvIGxlZnQgb3IgdG9wIG9uIHZlcnRpY2FsIGF4aXMgYW5kIGBlbmRgIGlzIGVxdWl2YWxlbnQgdG8gcmlnaHQgb3IgYm90dG9tIG9uIGhvcml6b250YWwgYXhpcy5cbiAgICAgIHBvc2l0aW9uOiAnc3RhcnQnLFxuICAgICAgLy8gQWxsb3dzIHlvdSB0byBjb3JyZWN0IGxhYmVsIHBvc2l0aW9uaW5nIG9uIHRoaXMgYXhpcyBieSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSB4IGFuZCB5IG9mZnNldC5cbiAgICAgIGxhYmVsT2Zmc2V0OiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICAvLyBJZiBsYWJlbHMgc2hvdWxkIGJlIHNob3duIG9yIG5vdFxuICAgICAgc2hvd0xhYmVsOiB0cnVlLFxuICAgICAgLy8gSWYgdGhlIGF4aXMgZ3JpZCBzaG91bGQgYmUgZHJhd24gb3Igbm90XG4gICAgICBzaG93R3JpZDogdHJ1ZSxcbiAgICAgIC8vIEludGVycG9sYXRpb24gZnVuY3Rpb24gdGhhdCBhbGxvd3MgeW91IHRvIGludGVyY2VwdCB0aGUgdmFsdWUgZnJvbSB0aGUgYXhpcyBsYWJlbFxuICAgICAgbGFiZWxJbnRlcnBvbGF0aW9uRm5jOiBDaGFydGlzdC5ub29wLFxuICAgICAgLy8gU2V0IHRoZSBheGlzIHR5cGUgdG8gYmUgdXNlZCB0byBwcm9qZWN0IHZhbHVlcyBvbiB0aGlzIGF4aXMuIElmIG5vdCBkZWZpbmVkLCBDaGFydGlzdC5BdXRvU2NhbGVBeGlzIHdpbGwgYmUgdXNlZCBmb3IgdGhlIFktQXhpcywgd2hlcmUgdGhlIGhpZ2ggYW5kIGxvdyBvcHRpb25zIHdpbGwgYmUgc2V0IHRvIHRoZSBnbG9iYWwgaGlnaCBhbmQgbG93IG9wdGlvbnMuIFRoaXMgdHlwZSBjYW4gYmUgY2hhbmdlZCB0byBhbnkgYXhpcyBjb25zdHJ1Y3RvciBhdmFpbGFibGUgKGUuZy4gQ2hhcnRpc3QuRml4ZWRTY2FsZUF4aXMpLCB3aGVyZSBhbGwgYXhpcyBvcHRpb25zIHNob3VsZCBiZSBwcmVzZW50IGhlcmUuXG4gICAgICB0eXBlOiB1bmRlZmluZWQsXG4gICAgICAvLyBUaGlzIHZhbHVlIHNwZWNpZmllcyB0aGUgbWluaW11bSBoZWlnaHQgaW4gcGl4ZWwgb2YgdGhlIHNjYWxlIHN0ZXBzXG4gICAgICBzY2FsZU1pblNwYWNlOiAyMCxcbiAgICAgIC8vIFVzZSBvbmx5IGludGVnZXIgdmFsdWVzICh3aG9sZSBudW1iZXJzKSBmb3IgdGhlIHNjYWxlIHN0ZXBzXG4gICAgICBvbmx5SW50ZWdlcjogZmFsc2VcbiAgICB9LFxuICAgIC8vIFNwZWNpZnkgYSBmaXhlZCB3aWR0aCBmb3IgdGhlIGNoYXJ0IGFzIGEgc3RyaW5nIChpLmUuICcxMDBweCcgb3IgJzUwJScpXG4gICAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgICAvLyBTcGVjaWZ5IGEgZml4ZWQgaGVpZ2h0IGZvciB0aGUgY2hhcnQgYXMgYSBzdHJpbmcgKGkuZS4gJzEwMHB4JyBvciAnNTAlJylcbiAgICBoZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICAvLyBJZiB0aGUgbGluZSBzaG91bGQgYmUgZHJhd24gb3Igbm90XG4gICAgc2hvd0xpbmU6IHRydWUsXG4gICAgLy8gSWYgZG90cyBzaG91bGQgYmUgZHJhd24gb3Igbm90XG4gICAgc2hvd1BvaW50OiB0cnVlLFxuICAgIC8vIElmIHRoZSBsaW5lIGNoYXJ0IHNob3VsZCBkcmF3IGFuIGFyZWFcbiAgICBzaG93QXJlYTogZmFsc2UsXG4gICAgLy8gVGhlIGJhc2UgZm9yIHRoZSBhcmVhIGNoYXJ0IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNsb3NlIHRoZSBhcmVhIHNoYXBlIChpcyBub3JtYWxseSAwKVxuICAgIGFyZWFCYXNlOiAwLFxuICAgIC8vIFNwZWNpZnkgaWYgdGhlIGxpbmVzIHNob3VsZCBiZSBzbW9vdGhlZC4gVGhpcyB2YWx1ZSBjYW4gYmUgdHJ1ZSBvciBmYWxzZSB3aGVyZSB0cnVlIHdpbGwgcmVzdWx0IGluIHNtb290aGluZyB1c2luZyB0aGUgZGVmYXVsdCBzbW9vdGhpbmcgaW50ZXJwb2xhdGlvbiBmdW5jdGlvbiBDaGFydGlzdC5JbnRlcnBvbGF0aW9uLmNhcmRpbmFsIGFuZCBmYWxzZSByZXN1bHRzIGluIENoYXJ0aXN0LkludGVycG9sYXRpb24ubm9uZS4gWW91IGNhbiBhbHNvIGNob29zZSBvdGhlciBzbW9vdGhpbmcgLyBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9ucyBhdmFpbGFibGUgaW4gdGhlIENoYXJ0aXN0LkludGVycG9sYXRpb24gbW9kdWxlLCBvciB3cml0ZSB5b3VyIG93biBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uLiBDaGVjayB0aGUgZXhhbXBsZXMgZm9yIGEgYnJpZWYgZGVzY3JpcHRpb24uXG4gICAgbGluZVNtb290aDogdHJ1ZSxcbiAgICAvLyBJZiB0aGUgbGluZSBjaGFydCBzaG91bGQgYWRkIGEgYmFja2dyb3VuZCBmaWxsIHRvIHRoZSAuY3QtZ3JpZHMgZ3JvdXAuXG4gICAgc2hvd0dyaWRCYWNrZ3JvdW5kOiBmYWxzZSxcbiAgICAvLyBPdmVycmlkaW5nIHRoZSBuYXR1cmFsIGxvdyBvZiB0aGUgY2hhcnQgYWxsb3dzIHlvdSB0byB6b29tIGluIG9yIGxpbWl0IHRoZSBjaGFydHMgbG93ZXN0IGRpc3BsYXllZCB2YWx1ZVxuICAgIGxvdzogdW5kZWZpbmVkLFxuICAgIC8vIE92ZXJyaWRpbmcgdGhlIG5hdHVyYWwgaGlnaCBvZiB0aGUgY2hhcnQgYWxsb3dzIHlvdSB0byB6b29tIGluIG9yIGxpbWl0IHRoZSBjaGFydHMgaGlnaGVzdCBkaXNwbGF5ZWQgdmFsdWVcbiAgICBoaWdoOiB1bmRlZmluZWQsXG4gICAgLy8gUGFkZGluZyBvZiB0aGUgY2hhcnQgZHJhd2luZyBhcmVhIHRvIHRoZSBjb250YWluZXIgZWxlbWVudCBhbmQgbGFiZWxzIGFzIGEgbnVtYmVyIG9yIHBhZGRpbmcgb2JqZWN0IHt0b3A6IDUsIHJpZ2h0OiA1LCBib3R0b206IDUsIGxlZnQ6IDV9XG4gICAgY2hhcnRQYWRkaW5nOiB7XG4gICAgICB0b3A6IDE1LFxuICAgICAgcmlnaHQ6IDE1LFxuICAgICAgYm90dG9tOiA1LFxuICAgICAgbGVmdDogMTBcbiAgICB9LFxuICAgIC8vIFdoZW4gc2V0IHRvIHRydWUsIHRoZSBsYXN0IGdyaWQgbGluZSBvbiB0aGUgeC1heGlzIGlzIG5vdCBkcmF3biBhbmQgdGhlIGNoYXJ0IGVsZW1lbnRzIHdpbGwgZXhwYW5kIHRvIHRoZSBmdWxsIGF2YWlsYWJsZSB3aWR0aCBvZiB0aGUgY2hhcnQuIEZvciB0aGUgbGFzdCBsYWJlbCB0byBiZSBkcmF3biBjb3JyZWN0bHkgeW91IG1pZ2h0IG5lZWQgdG8gYWRkIGNoYXJ0IHBhZGRpbmcgb3Igb2Zmc2V0IHRoZSBsYXN0IGxhYmVsIHdpdGggYSBkcmF3IGV2ZW50IGhhbmRsZXIuXG4gICAgZnVsbFdpZHRoOiBmYWxzZSxcbiAgICAvLyBJZiB0cnVlIHRoZSB3aG9sZSBkYXRhIGlzIHJldmVyc2VkIGluY2x1ZGluZyBsYWJlbHMsIHRoZSBzZXJpZXMgb3JkZXIgYXMgd2VsbCBhcyB0aGUgd2hvbGUgc2VyaWVzIGRhdGEgYXJyYXlzLlxuICAgIHJldmVyc2VEYXRhOiBmYWxzZSxcbiAgICAvLyBPdmVycmlkZSB0aGUgY2xhc3MgbmFtZXMgdGhhdCBnZXQgdXNlZCB0byBnZW5lcmF0ZSB0aGUgU1ZHIHN0cnVjdHVyZSBvZiB0aGUgY2hhcnRcbiAgICBjbGFzc05hbWVzOiB7XG4gICAgICBjaGFydDogJ2N0LWNoYXJ0LWxpbmUnLFxuICAgICAgbGFiZWw6ICdjdC1sYWJlbCcsXG4gICAgICBsYWJlbEdyb3VwOiAnY3QtbGFiZWxzJyxcbiAgICAgIHNlcmllczogJ2N0LXNlcmllcycsXG4gICAgICBsaW5lOiAnY3QtbGluZScsXG4gICAgICBwb2ludDogJ2N0LXBvaW50JyxcbiAgICAgIGFyZWE6ICdjdC1hcmVhJyxcbiAgICAgIGdyaWQ6ICdjdC1ncmlkJyxcbiAgICAgIGdyaWRHcm91cDogJ2N0LWdyaWRzJyxcbiAgICAgIGdyaWRCYWNrZ3JvdW5kOiAnY3QtZ3JpZC1iYWNrZ3JvdW5kJyxcbiAgICAgIHZlcnRpY2FsOiAnY3QtdmVydGljYWwnLFxuICAgICAgaG9yaXpvbnRhbDogJ2N0LWhvcml6b250YWwnLFxuICAgICAgc3RhcnQ6ICdjdC1zdGFydCcsXG4gICAgICBlbmQ6ICdjdC1lbmQnXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNoYXJ0XG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDaGFydChvcHRpb25zKSB7XG4gICAgdmFyIGRhdGEgPSBDaGFydGlzdC5ub3JtYWxpemVEYXRhKHRoaXMuZGF0YSwgb3B0aW9ucy5yZXZlcnNlRGF0YSwgdHJ1ZSk7XG5cbiAgICAvLyBDcmVhdGUgbmV3IHN2ZyBvYmplY3RcbiAgICB0aGlzLnN2ZyA9IENoYXJ0aXN0LmNyZWF0ZVN2Zyh0aGlzLmNvbnRhaW5lciwgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQsIG9wdGlvbnMuY2xhc3NOYW1lcy5jaGFydCk7XG4gICAgLy8gQ3JlYXRlIGdyb3VwcyBmb3IgbGFiZWxzLCBncmlkIGFuZCBzZXJpZXNcbiAgICB2YXIgZ3JpZEdyb3VwID0gdGhpcy5zdmcuZWxlbSgnZycpLmFkZENsYXNzKG9wdGlvbnMuY2xhc3NOYW1lcy5ncmlkR3JvdXApO1xuICAgIHZhciBzZXJpZXNHcm91cCA9IHRoaXMuc3ZnLmVsZW0oJ2cnKTtcbiAgICB2YXIgbGFiZWxHcm91cCA9IHRoaXMuc3ZnLmVsZW0oJ2cnKS5hZGRDbGFzcyhvcHRpb25zLmNsYXNzTmFtZXMubGFiZWxHcm91cCk7XG5cbiAgICB2YXIgY2hhcnRSZWN0ID0gQ2hhcnRpc3QuY3JlYXRlQ2hhcnRSZWN0KHRoaXMuc3ZnLCBvcHRpb25zLCBkZWZhdWx0T3B0aW9ucy5wYWRkaW5nKTtcbiAgICB2YXIgYXhpc1gsIGF4aXNZO1xuXG4gICAgaWYob3B0aW9ucy5heGlzWC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGF4aXNYID0gbmV3IENoYXJ0aXN0LlN0ZXBBeGlzKENoYXJ0aXN0LkF4aXMudW5pdHMueCwgZGF0YS5ub3JtYWxpemVkLnNlcmllcywgY2hhcnRSZWN0LCBDaGFydGlzdC5leHRlbmQoe30sIG9wdGlvbnMuYXhpc1gsIHtcbiAgICAgICAgdGlja3M6IGRhdGEubm9ybWFsaXplZC5sYWJlbHMsXG4gICAgICAgIHN0cmV0Y2g6IG9wdGlvbnMuZnVsbFdpZHRoXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXNYID0gb3B0aW9ucy5heGlzWC50eXBlLmNhbGwoQ2hhcnRpc3QsIENoYXJ0aXN0LkF4aXMudW5pdHMueCwgZGF0YS5ub3JtYWxpemVkLnNlcmllcywgY2hhcnRSZWN0LCBvcHRpb25zLmF4aXNYKTtcbiAgICB9XG5cbiAgICBpZihvcHRpb25zLmF4aXNZLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXhpc1kgPSBuZXcgQ2hhcnRpc3QuQXV0b1NjYWxlQXhpcyhDaGFydGlzdC5BeGlzLnVuaXRzLnksIGRhdGEubm9ybWFsaXplZC5zZXJpZXMsIGNoYXJ0UmVjdCwgQ2hhcnRpc3QuZXh0ZW5kKHt9LCBvcHRpb25zLmF4aXNZLCB7XG4gICAgICAgIGhpZ2g6IENoYXJ0aXN0LmlzTnVtZXJpYyhvcHRpb25zLmhpZ2gpID8gb3B0aW9ucy5oaWdoIDogb3B0aW9ucy5heGlzWS5oaWdoLFxuICAgICAgICBsb3c6IENoYXJ0aXN0LmlzTnVtZXJpYyhvcHRpb25zLmxvdykgPyBvcHRpb25zLmxvdyA6IG9wdGlvbnMuYXhpc1kubG93XG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXNZID0gb3B0aW9ucy5heGlzWS50eXBlLmNhbGwoQ2hhcnRpc3QsIENoYXJ0aXN0LkF4aXMudW5pdHMueSwgZGF0YS5ub3JtYWxpemVkLnNlcmllcywgY2hhcnRSZWN0LCBvcHRpb25zLmF4aXNZKTtcbiAgICB9XG5cbiAgICBheGlzWC5jcmVhdGVHcmlkQW5kTGFiZWxzKGdyaWRHcm91cCwgbGFiZWxHcm91cCwgdGhpcy5zdXBwb3J0c0ZvcmVpZ25PYmplY3QsIG9wdGlvbnMsIHRoaXMuZXZlbnRFbWl0dGVyKTtcbiAgICBheGlzWS5jcmVhdGVHcmlkQW5kTGFiZWxzKGdyaWRHcm91cCwgbGFiZWxHcm91cCwgdGhpcy5zdXBwb3J0c0ZvcmVpZ25PYmplY3QsIG9wdGlvbnMsIHRoaXMuZXZlbnRFbWl0dGVyKTtcblxuICAgIGlmIChvcHRpb25zLnNob3dHcmlkQmFja2dyb3VuZCkge1xuICAgICAgQ2hhcnRpc3QuY3JlYXRlR3JpZEJhY2tncm91bmQoZ3JpZEdyb3VwLCBjaGFydFJlY3QsIG9wdGlvbnMuY2xhc3NOYW1lcy5ncmlkQmFja2dyb3VuZCwgdGhpcy5ldmVudEVtaXR0ZXIpO1xuICAgIH1cblxuICAgIC8vIERyYXcgdGhlIHNlcmllc1xuICAgIGRhdGEucmF3LnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcywgc2VyaWVzSW5kZXgpIHtcbiAgICAgIHZhciBzZXJpZXNFbGVtZW50ID0gc2VyaWVzR3JvdXAuZWxlbSgnZycpO1xuXG4gICAgICAvLyBXcml0ZSBhdHRyaWJ1dGVzIHRvIHNlcmllcyBncm91cCBlbGVtZW50LiBJZiBzZXJpZXMgbmFtZSBvciBtZXRhIGlzIHVuZGVmaW5lZCB0aGUgYXR0cmlidXRlcyB3aWxsIG5vdCBiZSB3cml0dGVuXG4gICAgICBzZXJpZXNFbGVtZW50LmF0dHIoe1xuICAgICAgICAnY3Q6c2VyaWVzLW5hbWUnOiBzZXJpZXMubmFtZSxcbiAgICAgICAgJ2N0Om1ldGEnOiBDaGFydGlzdC5zZXJpYWxpemUoc2VyaWVzLm1ldGEpXG4gICAgICB9KTtcblxuICAgICAgLy8gVXNlIHNlcmllcyBjbGFzcyBmcm9tIHNlcmllcyBkYXRhIG9yIGlmIG5vdCBzZXQgZ2VuZXJhdGUgb25lXG4gICAgICBzZXJpZXNFbGVtZW50LmFkZENsYXNzKFtcbiAgICAgICAgb3B0aW9ucy5jbGFzc05hbWVzLnNlcmllcyxcbiAgICAgICAgKHNlcmllcy5jbGFzc05hbWUgfHwgb3B0aW9ucy5jbGFzc05hbWVzLnNlcmllcyArICctJyArIENoYXJ0aXN0LmFscGhhTnVtZXJhdGUoc2VyaWVzSW5kZXgpKVxuICAgICAgXS5qb2luKCcgJykpO1xuXG4gICAgICB2YXIgcGF0aENvb3JkaW5hdGVzID0gW10sXG4gICAgICAgIHBhdGhEYXRhID0gW107XG5cbiAgICAgIGRhdGEubm9ybWFsaXplZC5zZXJpZXNbc2VyaWVzSW5kZXhdLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIHZhbHVlSW5kZXgpIHtcbiAgICAgICAgdmFyIHAgPSB7XG4gICAgICAgICAgeDogY2hhcnRSZWN0LngxICsgYXhpc1gucHJvamVjdFZhbHVlKHZhbHVlLCB2YWx1ZUluZGV4LCBkYXRhLm5vcm1hbGl6ZWQuc2VyaWVzW3Nlcmllc0luZGV4XSksXG4gICAgICAgICAgeTogY2hhcnRSZWN0LnkxIC0gYXhpc1kucHJvamVjdFZhbHVlKHZhbHVlLCB2YWx1ZUluZGV4LCBkYXRhLm5vcm1hbGl6ZWQuc2VyaWVzW3Nlcmllc0luZGV4XSlcbiAgICAgICAgfTtcbiAgICAgICAgcGF0aENvb3JkaW5hdGVzLnB1c2gocC54LCBwLnkpO1xuICAgICAgICBwYXRoRGF0YS5wdXNoKHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgdmFsdWVJbmRleDogdmFsdWVJbmRleCxcbiAgICAgICAgICBtZXRhOiBDaGFydGlzdC5nZXRNZXRhRGF0YShzZXJpZXMsIHZhbHVlSW5kZXgpXG4gICAgICAgIH0pO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgdmFyIHNlcmllc09wdGlvbnMgPSB7XG4gICAgICAgIGxpbmVTbW9vdGg6IENoYXJ0aXN0LmdldFNlcmllc09wdGlvbihzZXJpZXMsIG9wdGlvbnMsICdsaW5lU21vb3RoJyksXG4gICAgICAgIHNob3dQb2ludDogQ2hhcnRpc3QuZ2V0U2VyaWVzT3B0aW9uKHNlcmllcywgb3B0aW9ucywgJ3Nob3dQb2ludCcpLFxuICAgICAgICBzaG93TGluZTogQ2hhcnRpc3QuZ2V0U2VyaWVzT3B0aW9uKHNlcmllcywgb3B0aW9ucywgJ3Nob3dMaW5lJyksXG4gICAgICAgIHNob3dBcmVhOiBDaGFydGlzdC5nZXRTZXJpZXNPcHRpb24oc2VyaWVzLCBvcHRpb25zLCAnc2hvd0FyZWEnKSxcbiAgICAgICAgYXJlYUJhc2U6IENoYXJ0aXN0LmdldFNlcmllc09wdGlvbihzZXJpZXMsIG9wdGlvbnMsICdhcmVhQmFzZScpXG4gICAgICB9O1xuXG4gICAgICB2YXIgc21vb3RoaW5nID0gdHlwZW9mIHNlcmllc09wdGlvbnMubGluZVNtb290aCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHNlcmllc09wdGlvbnMubGluZVNtb290aCA6IChzZXJpZXNPcHRpb25zLmxpbmVTbW9vdGggPyBDaGFydGlzdC5JbnRlcnBvbGF0aW9uLm1vbm90b25lQ3ViaWMoKSA6IENoYXJ0aXN0LkludGVycG9sYXRpb24ubm9uZSgpKTtcbiAgICAgIC8vIEludGVycG9sYXRpbmcgcGF0aCB3aGVyZSBwYXRoRGF0YSB3aWxsIGJlIHVzZWQgdG8gYW5ub3RhdGUgZWFjaCBwYXRoIGVsZW1lbnQgc28gd2UgY2FuIHRyYWNlIGJhY2sgdGhlIG9yaWdpbmFsXG4gICAgICAvLyBpbmRleCwgdmFsdWUgYW5kIG1ldGEgZGF0YVxuICAgICAgdmFyIHBhdGggPSBzbW9vdGhpbmcocGF0aENvb3JkaW5hdGVzLCBwYXRoRGF0YSk7XG5cbiAgICAgIC8vIElmIHdlIHNob3VsZCBzaG93IHBvaW50cyB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVtIG5vdyB0byBhdm9pZCBzZWNvbmRhcnkgbG9vcFxuICAgICAgLy8gUG9pbnRzIGFyZSBkcmF3biBmcm9tIHRoZSBwYXRoRWxlbWVudHMgcmV0dXJuZWQgYnkgdGhlIGludGVycG9sYXRpb24gZnVuY3Rpb25cbiAgICAgIC8vIFNtYWxsIG9mZnNldCBmb3IgRmlyZWZveCB0byByZW5kZXIgc3F1YXJlcyBjb3JyZWN0bHlcbiAgICAgIGlmIChzZXJpZXNPcHRpb25zLnNob3dQb2ludCkge1xuXG4gICAgICAgIHBhdGgucGF0aEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24ocGF0aEVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgcG9pbnQgPSBzZXJpZXNFbGVtZW50LmVsZW0oJ2xpbmUnLCB7XG4gICAgICAgICAgICB4MTogcGF0aEVsZW1lbnQueCxcbiAgICAgICAgICAgIHkxOiBwYXRoRWxlbWVudC55LFxuICAgICAgICAgICAgeDI6IHBhdGhFbGVtZW50LnggKyAwLjAxLFxuICAgICAgICAgICAgeTI6IHBhdGhFbGVtZW50LnlcbiAgICAgICAgICB9LCBvcHRpb25zLmNsYXNzTmFtZXMucG9pbnQpLmF0dHIoe1xuICAgICAgICAgICAgJ2N0OnZhbHVlJzogW3BhdGhFbGVtZW50LmRhdGEudmFsdWUueCwgcGF0aEVsZW1lbnQuZGF0YS52YWx1ZS55XS5maWx0ZXIoQ2hhcnRpc3QuaXNOdW1lcmljKS5qb2luKCcsJyksXG4gICAgICAgICAgICAnY3Q6bWV0YSc6IENoYXJ0aXN0LnNlcmlhbGl6ZShwYXRoRWxlbWVudC5kYXRhLm1ldGEpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdkcmF3Jywge1xuICAgICAgICAgICAgdHlwZTogJ3BvaW50JyxcbiAgICAgICAgICAgIHZhbHVlOiBwYXRoRWxlbWVudC5kYXRhLnZhbHVlLFxuICAgICAgICAgICAgaW5kZXg6IHBhdGhFbGVtZW50LmRhdGEudmFsdWVJbmRleCxcbiAgICAgICAgICAgIG1ldGE6IHBhdGhFbGVtZW50LmRhdGEubWV0YSxcbiAgICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxuICAgICAgICAgICAgYXhpc1g6IGF4aXNYLFxuICAgICAgICAgICAgYXhpc1k6IGF4aXNZLFxuICAgICAgICAgICAgZ3JvdXA6IHNlcmllc0VsZW1lbnQsXG4gICAgICAgICAgICBlbGVtZW50OiBwb2ludCxcbiAgICAgICAgICAgIHg6IHBhdGhFbGVtZW50LngsXG4gICAgICAgICAgICB5OiBwYXRoRWxlbWVudC55XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIGlmKHNlcmllc09wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBzZXJpZXNFbGVtZW50LmVsZW0oJ3BhdGgnLCB7XG4gICAgICAgICAgZDogcGF0aC5zdHJpbmdpZnkoKVxuICAgICAgICB9LCBvcHRpb25zLmNsYXNzTmFtZXMubGluZSwgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnZHJhdycsIHtcbiAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgdmFsdWVzOiBkYXRhLm5vcm1hbGl6ZWQuc2VyaWVzW3Nlcmllc0luZGV4XSxcbiAgICAgICAgICBwYXRoOiBwYXRoLmNsb25lKCksXG4gICAgICAgICAgY2hhcnRSZWN0OiBjaGFydFJlY3QsXG4gICAgICAgICAgaW5kZXg6IHNlcmllc0luZGV4LFxuICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNJbmRleCxcbiAgICAgICAgICBzZXJpZXNNZXRhOiBzZXJpZXMubWV0YSxcbiAgICAgICAgICBheGlzWDogYXhpc1gsXG4gICAgICAgICAgYXhpc1k6IGF4aXNZLFxuICAgICAgICAgIGdyb3VwOiBzZXJpZXNFbGVtZW50LFxuICAgICAgICAgIGVsZW1lbnQ6IGxpbmVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFyZWEgY3VycmVudGx5IG9ubHkgd29ya3Mgd2l0aCBheGVzIHRoYXQgc3VwcG9ydCBhIHJhbmdlIVxuICAgICAgaWYoc2VyaWVzT3B0aW9ucy5zaG93QXJlYSAmJiBheGlzWS5yYW5nZSkge1xuICAgICAgICAvLyBJZiBhcmVhQmFzZSBpcyBvdXRzaWRlIHRoZSBjaGFydCBhcmVhICg8IG1pbiBvciA+IG1heCkgd2UgbmVlZCB0byBzZXQgaXQgcmVzcGVjdGl2ZWx5IHNvIHRoYXRcbiAgICAgICAgLy8gdGhlIGFyZWEgaXMgbm90IGRyYXduIG91dHNpZGUgdGhlIGNoYXJ0IGFyZWEuXG4gICAgICAgIHZhciBhcmVhQmFzZSA9IE1hdGgubWF4KE1hdGgubWluKHNlcmllc09wdGlvbnMuYXJlYUJhc2UsIGF4aXNZLnJhbmdlLm1heCksIGF4aXNZLnJhbmdlLm1pbik7XG5cbiAgICAgICAgLy8gV2UgcHJvamVjdCB0aGUgYXJlYUJhc2UgdmFsdWUgaW50byBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICAgICAgdmFyIGFyZWFCYXNlUHJvamVjdGVkID0gY2hhcnRSZWN0LnkxIC0gYXhpc1kucHJvamVjdFZhbHVlKGFyZWFCYXNlKTtcblxuICAgICAgICAvLyBJbiBvcmRlciB0byBmb3JtIHRoZSBhcmVhIHdlJ2xsIGZpcnN0IHNwbGl0IHRoZSBwYXRoIGJ5IG1vdmUgY29tbWFuZHMgc28gd2UgY2FuIGNodW5rIGl0IHVwIGludG8gc2VnbWVudHNcbiAgICAgICAgcGF0aC5zcGxpdEJ5Q29tbWFuZCgnTScpLmZpbHRlcihmdW5jdGlvbiBvbmx5U29saWRTZWdtZW50cyhwYXRoU2VnbWVudCkge1xuICAgICAgICAgIC8vIFdlIGZpbHRlciBvbmx5IFwic29saWRcIiBzZWdtZW50cyB0aGF0IGNvbnRhaW4gbW9yZSB0aGFuIG9uZSBwb2ludC4gT3RoZXJ3aXNlIHRoZXJlJ3Mgbm8gbmVlZCBmb3IgYW4gYXJlYVxuICAgICAgICAgIHJldHVybiBwYXRoU2VnbWVudC5wYXRoRWxlbWVudHMubGVuZ3RoID4gMTtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uIGNvbnZlcnRUb0FyZWEoc29saWRQYXRoU2VnbWVudHMpIHtcbiAgICAgICAgICAvLyBSZWNlaXZpbmcgdGhlIGZpbHRlcmVkIHNvbGlkIHBhdGggc2VnbWVudHMgd2UgY2FuIG5vdyBjb252ZXJ0IHRob3NlIHNlZ21lbnRzIGludG8gZmlsbCBhcmVhc1xuICAgICAgICAgIHZhciBmaXJzdEVsZW1lbnQgPSBzb2xpZFBhdGhTZWdtZW50cy5wYXRoRWxlbWVudHNbMF07XG4gICAgICAgICAgdmFyIGxhc3RFbGVtZW50ID0gc29saWRQYXRoU2VnbWVudHMucGF0aEVsZW1lbnRzW3NvbGlkUGF0aFNlZ21lbnRzLnBhdGhFbGVtZW50cy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIC8vIENsb25pbmcgdGhlIHNvbGlkIHBhdGggc2VnbWVudCB3aXRoIGNsb3Npbmcgb3B0aW9uIGFuZCByZW1vdmluZyB0aGUgZmlyc3QgbW92ZSBjb21tYW5kIGZyb20gdGhlIGNsb25lXG4gICAgICAgICAgLy8gV2UgdGhlbiBpbnNlcnQgYSBuZXcgbW92ZSB0aGF0IHNob3VsZCBzdGFydCBhdCB0aGUgYXJlYSBiYXNlIGFuZCBkcmF3IGEgc3RyYWlnaHQgbGluZSB1cCBvciBkb3duXG4gICAgICAgICAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgcGF0aCB3ZSBhZGQgYW4gYWRkaXRpb25hbCBzdHJhaWdodCBsaW5lIHRvIHRoZSBwcm9qZWN0ZWQgYXJlYSBiYXNlIHZhbHVlXG4gICAgICAgICAgLy8gQXMgdGhlIGNsb3Npbmcgb3B0aW9uIGlzIHNldCBvdXIgcGF0aCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2xvc2VkXG4gICAgICAgICAgcmV0dXJuIHNvbGlkUGF0aFNlZ21lbnRzLmNsb25lKHRydWUpXG4gICAgICAgICAgICAucG9zaXRpb24oMClcbiAgICAgICAgICAgIC5yZW1vdmUoMSlcbiAgICAgICAgICAgIC5tb3ZlKGZpcnN0RWxlbWVudC54LCBhcmVhQmFzZVByb2plY3RlZClcbiAgICAgICAgICAgIC5saW5lKGZpcnN0RWxlbWVudC54LCBmaXJzdEVsZW1lbnQueSlcbiAgICAgICAgICAgIC5wb3NpdGlvbihzb2xpZFBhdGhTZWdtZW50cy5wYXRoRWxlbWVudHMubGVuZ3RoICsgMSlcbiAgICAgICAgICAgIC5saW5lKGxhc3RFbGVtZW50LngsIGFyZWFCYXNlUHJvamVjdGVkKTtcblxuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIGNyZWF0ZUFyZWEoYXJlYVBhdGgpIHtcbiAgICAgICAgICAvLyBGb3IgZWFjaCBvZiBvdXIgbmV3bHkgY3JlYXRlZCBhcmVhIHBhdGhzLCB3ZSdsbCBub3cgY3JlYXRlIHBhdGggZWxlbWVudHMgYnkgc3RyaW5naWZ5aW5nIG91ciBwYXRoIG9iamVjdHNcbiAgICAgICAgICAvLyBhbmQgYWRkaW5nIHRoZSBjcmVhdGVkIERPTSBlbGVtZW50cyB0byB0aGUgY29ycmVjdCBzZXJpZXMgZ3JvdXBcbiAgICAgICAgICB2YXIgYXJlYSA9IHNlcmllc0VsZW1lbnQuZWxlbSgncGF0aCcsIHtcbiAgICAgICAgICAgIGQ6IGFyZWFQYXRoLnN0cmluZ2lmeSgpXG4gICAgICAgICAgfSwgb3B0aW9ucy5jbGFzc05hbWVzLmFyZWEsIHRydWUpO1xuXG4gICAgICAgICAgLy8gRW1pdCBhbiBldmVudCBmb3IgZWFjaCBhcmVhIHRoYXQgd2FzIGRyYXduXG4gICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnZHJhdycsIHtcbiAgICAgICAgICAgIHR5cGU6ICdhcmVhJyxcbiAgICAgICAgICAgIHZhbHVlczogZGF0YS5ub3JtYWxpemVkLnNlcmllc1tzZXJpZXNJbmRleF0sXG4gICAgICAgICAgICBwYXRoOiBhcmVhUGF0aC5jbG9uZSgpLFxuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICBheGlzWDogYXhpc1gsXG4gICAgICAgICAgICBheGlzWTogYXhpc1ksXG4gICAgICAgICAgICBjaGFydFJlY3Q6IGNoYXJ0UmVjdCxcbiAgICAgICAgICAgIGluZGV4OiBzZXJpZXNJbmRleCxcbiAgICAgICAgICAgIGdyb3VwOiBzZXJpZXNFbGVtZW50LFxuICAgICAgICAgICAgZWxlbWVudDogYXJlYVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdjcmVhdGVkJywge1xuICAgICAgYm91bmRzOiBheGlzWS5ib3VuZHMsXG4gICAgICBjaGFydFJlY3Q6IGNoYXJ0UmVjdCxcbiAgICAgIGF4aXNYOiBheGlzWCxcbiAgICAgIGF4aXNZOiBheGlzWSxcbiAgICAgIHN2ZzogdGhpcy5zdmcsXG4gICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBsaW5lIGNoYXJ0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuTGluZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOb2RlfSBxdWVyeSBBIHNlbGVjdG9yIHF1ZXJ5IHN0cmluZyBvciBkaXJlY3RseSBhIERPTSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIG9iamVjdCB0aGF0IG5lZWRzIHRvIGNvbnNpc3Qgb2YgYSBsYWJlbHMgYW5kIGEgc2VyaWVzIGFycmF5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0IHdpdGggb3B0aW9ucyB0aGF0IG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9wdGlvbnMuIENoZWNrIHRoZSBleGFtcGxlcyBmb3IgYSBkZXRhaWxlZCBsaXN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzcG9uc2l2ZU9wdGlvbnNdIFNwZWNpZnkgYW4gYXJyYXkgb2YgcmVzcG9uc2l2ZSBvcHRpb24gYXJyYXlzIHdoaWNoIGFyZSBhIG1lZGlhIHF1ZXJ5IGFuZCBvcHRpb25zIG9iamVjdCBwYWlyID0+IFtbbWVkaWFRdWVyeVN0cmluZywgb3B0aW9uc09iamVjdF0sW21vcmUuLi5dXVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aGljaCBleHBvc2VzIHRoZSBBUEkgZm9yIHRoZSBjcmVhdGVkIGNoYXJ0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIENyZWF0ZSBhIHNpbXBsZSBsaW5lIGNoYXJ0XG4gICAqIHZhciBkYXRhID0ge1xuICAgKiAgIC8vIEEgbGFiZWxzIGFycmF5IHRoYXQgY2FuIGNvbnRhaW4gYW55IHNvcnQgb2YgdmFsdWVzXG4gICAqICAgbGFiZWxzOiBbJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknXSxcbiAgICogICAvLyBPdXIgc2VyaWVzIGFycmF5IHRoYXQgY29udGFpbnMgc2VyaWVzIG9iamVjdHMgb3IgaW4gdGhpcyBjYXNlIHNlcmllcyBkYXRhIGFycmF5c1xuICAgKiAgIHNlcmllczogW1xuICAgKiAgICAgWzUsIDIsIDQsIDIsIDBdXG4gICAqICAgXVxuICAgKiB9O1xuICAgKlxuICAgKiAvLyBBcyBvcHRpb25zIHdlIGN1cnJlbnRseSBvbmx5IHNldCBhIHN0YXRpYyBzaXplIG9mIDMwMHgyMDAgcHhcbiAgICogdmFyIG9wdGlvbnMgPSB7XG4gICAqICAgd2lkdGg6ICczMDBweCcsXG4gICAqICAgaGVpZ2h0OiAnMjAwcHgnXG4gICAqIH07XG4gICAqXG4gICAqIC8vIEluIHRoZSBnbG9iYWwgbmFtZSBzcGFjZSBDaGFydGlzdCB3ZSBjYWxsIHRoZSBMaW5lIGZ1bmN0aW9uIHRvIGluaXRpYWxpemUgYSBsaW5lIGNoYXJ0LiBBcyBhIGZpcnN0IHBhcmFtZXRlciB3ZSBwYXNzIGluIGEgc2VsZWN0b3Igd2hlcmUgd2Ugd291bGQgbGlrZSB0byBnZXQgb3VyIGNoYXJ0IGNyZWF0ZWQuIFNlY29uZCBwYXJhbWV0ZXIgaXMgdGhlIGFjdHVhbCBkYXRhIG9iamVjdCBhbmQgYXMgYSB0aGlyZCBwYXJhbWV0ZXIgd2UgcGFzcyBpbiBvdXIgb3B0aW9uc1xuICAgKiBuZXcgQ2hhcnRpc3QuTGluZSgnLmN0LWNoYXJ0JywgZGF0YSwgb3B0aW9ucyk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFVzZSBzcGVjaWZpYyBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uIHdpdGggY29uZmlndXJhdGlvbiBmcm9tIHRoZSBDaGFydGlzdC5JbnRlcnBvbGF0aW9uIG1vZHVsZVxuICAgKlxuICAgKiB2YXIgY2hhcnQgPSBuZXcgQ2hhcnRpc3QuTGluZSgnLmN0LWNoYXJ0Jywge1xuICAgKiAgIGxhYmVsczogWzEsIDIsIDMsIDQsIDVdLFxuICAgKiAgIHNlcmllczogW1xuICAgKiAgICAgWzEsIDEsIDgsIDEsIDddXG4gICAqICAgXVxuICAgKiB9LCB7XG4gICAqICAgbGluZVNtb290aDogQ2hhcnRpc3QuSW50ZXJwb2xhdGlvbi5jYXJkaW5hbCh7XG4gICAqICAgICB0ZW5zaW9uOiAwLjJcbiAgICogICB9KVxuICAgKiB9KTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gQ3JlYXRlIGEgbGluZSBjaGFydCB3aXRoIHJlc3BvbnNpdmUgb3B0aW9uc1xuICAgKlxuICAgKiB2YXIgZGF0YSA9IHtcbiAgICogICAvLyBBIGxhYmVscyBhcnJheSB0aGF0IGNhbiBjb250YWluIGFueSBzb3J0IG9mIHZhbHVlc1xuICAgKiAgIGxhYmVsczogWydNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5J10sXG4gICAqICAgLy8gT3VyIHNlcmllcyBhcnJheSB0aGF0IGNvbnRhaW5zIHNlcmllcyBvYmplY3RzIG9yIGluIHRoaXMgY2FzZSBzZXJpZXMgZGF0YSBhcnJheXNcbiAgICogICBzZXJpZXM6IFtcbiAgICogICAgIFs1LCAyLCA0LCAyLCAwXVxuICAgKiAgIF1cbiAgICogfTtcbiAgICpcbiAgICogLy8gSW4gYWRkaXRpb24gdG8gdGhlIHJlZ3VsYXIgb3B0aW9ucyB3ZSBzcGVjaWZ5IHJlc3BvbnNpdmUgb3B0aW9uIG92ZXJyaWRlcyB0aGF0IHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgY29uZmlndXRhdGlvbiBiYXNlZCBvbiB0aGUgbWF0Y2hpbmcgbWVkaWEgcXVlcmllcy5cbiAgICogdmFyIHJlc3BvbnNpdmVPcHRpb25zID0gW1xuICAgKiAgIFsnc2NyZWVuIGFuZCAobWluLXdpZHRoOiA2NDFweCkgYW5kIChtYXgtd2lkdGg6IDEwMjRweCknLCB7XG4gICAqICAgICBzaG93UG9pbnQ6IGZhbHNlLFxuICAgKiAgICAgYXhpc1g6IHtcbiAgICogICAgICAgbGFiZWxJbnRlcnBvbGF0aW9uRm5jOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgKiAgICAgICAgIC8vIFdpbGwgcmV0dXJuIE1vbiwgVHVlLCBXZWQgZXRjLiBvbiBtZWRpdW0gc2NyZWVuc1xuICAgKiAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgwLCAzKTtcbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKiAgIH1dLFxuICAgKiAgIFsnc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA2NDBweCknLCB7XG4gICAqICAgICBzaG93TGluZTogZmFsc2UsXG4gICAqICAgICBheGlzWDoge1xuICAgKiAgICAgICBsYWJlbEludGVycG9sYXRpb25GbmM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAqICAgICAgICAgLy8gV2lsbCByZXR1cm4gTSwgVCwgVyBldGMuIG9uIHNtYWxsIHNjcmVlbnNcbiAgICogICAgICAgICByZXR1cm4gdmFsdWVbMF07XG4gICAqICAgICAgIH1cbiAgICogICAgIH1cbiAgICogICB9XVxuICAgKiBdO1xuICAgKlxuICAgKiBuZXcgQ2hhcnRpc3QuTGluZSgnLmN0LWNoYXJ0JywgZGF0YSwgbnVsbCwgcmVzcG9uc2l2ZU9wdGlvbnMpO1xuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gTGluZShxdWVyeSwgZGF0YSwgb3B0aW9ucywgcmVzcG9uc2l2ZU9wdGlvbnMpIHtcbiAgICBDaGFydGlzdC5MaW5lLnN1cGVyLmNvbnN0cnVjdG9yLmNhbGwodGhpcyxcbiAgICAgIHF1ZXJ5LFxuICAgICAgZGF0YSxcbiAgICAgIGRlZmF1bHRPcHRpb25zLFxuICAgICAgQ2hhcnRpc3QuZXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyksXG4gICAgICByZXNwb25zaXZlT3B0aW9ucyk7XG4gIH1cblxuICAvLyBDcmVhdGluZyBsaW5lIGNoYXJ0IHR5cGUgaW4gQ2hhcnRpc3QgbmFtZXNwYWNlXG4gIENoYXJ0aXN0LkxpbmUgPSBDaGFydGlzdC5CYXNlLmV4dGVuZCh7XG4gICAgY29uc3RydWN0b3I6IExpbmUsXG4gICAgY3JlYXRlQ2hhcnQ6IGNyZWF0ZUNoYXJ0XG4gIH0pO1xuXG59KHRoaXMgfHwgZ2xvYmFsLCBDaGFydGlzdCkpO1xuOy8qKlxuICogVGhlIGJhciBjaGFydCBtb2R1bGUgb2YgQ2hhcnRpc3QgdGhhdCBjYW4gYmUgdXNlZCB0byBkcmF3IHVuaXBvbGFyIG9yIGJpcG9sYXIgYmFyIGFuZCBncm91cGVkIGJhciBjaGFydHMuXG4gKlxuICogQG1vZHVsZSBDaGFydGlzdC5CYXJcbiAqL1xuLyogZ2xvYmFsIENoYXJ0aXN0ICovXG4oZnVuY3Rpb24oZ2xvYmFsUm9vdCwgQ2hhcnRpc3Qpe1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHdpbmRvdyA9IGdsb2JhbFJvb3Qud2luZG93O1xuICB2YXIgZG9jdW1lbnQgPSBnbG9iYWxSb290LmRvY3VtZW50O1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IG9wdGlvbnMgaW4gYmFyIGNoYXJ0cy4gRXhwYW5kIHRoZSBjb2RlIHZpZXcgdG8gc2VlIGEgZGV0YWlsZWQgbGlzdCBvZiBvcHRpb25zIHdpdGggY29tbWVudHMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5CYXJcbiAgICovXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAvLyBPcHRpb25zIGZvciBYLUF4aXNcbiAgICBheGlzWDoge1xuICAgICAgLy8gVGhlIG9mZnNldCBvZiB0aGUgY2hhcnQgZHJhd2luZyBhcmVhIHRvIHRoZSBib3JkZXIgb2YgdGhlIGNvbnRhaW5lclxuICAgICAgb2Zmc2V0OiAzMCxcbiAgICAgIC8vIFBvc2l0aW9uIHdoZXJlIGxhYmVscyBhcmUgcGxhY2VkLiBDYW4gYmUgc2V0IHRvIGBzdGFydGAgb3IgYGVuZGAgd2hlcmUgYHN0YXJ0YCBpcyBlcXVpdmFsZW50IHRvIGxlZnQgb3IgdG9wIG9uIHZlcnRpY2FsIGF4aXMgYW5kIGBlbmRgIGlzIGVxdWl2YWxlbnQgdG8gcmlnaHQgb3IgYm90dG9tIG9uIGhvcml6b250YWwgYXhpcy5cbiAgICAgIHBvc2l0aW9uOiAnZW5kJyxcbiAgICAgIC8vIEFsbG93cyB5b3UgdG8gY29ycmVjdCBsYWJlbCBwb3NpdGlvbmluZyBvbiB0aGlzIGF4aXMgYnkgcG9zaXRpdmUgb3IgbmVnYXRpdmUgeCBhbmQgeSBvZmZzZXQuXG4gICAgICBsYWJlbE9mZnNldDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LFxuICAgICAgLy8gSWYgbGFiZWxzIHNob3VsZCBiZSBzaG93biBvciBub3RcbiAgICAgIHNob3dMYWJlbDogdHJ1ZSxcbiAgICAgIC8vIElmIHRoZSBheGlzIGdyaWQgc2hvdWxkIGJlIGRyYXduIG9yIG5vdFxuICAgICAgc2hvd0dyaWQ6IHRydWUsXG4gICAgICAvLyBJbnRlcnBvbGF0aW9uIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHlvdSB0byBpbnRlcmNlcHQgdGhlIHZhbHVlIGZyb20gdGhlIGF4aXMgbGFiZWxcbiAgICAgIGxhYmVsSW50ZXJwb2xhdGlvbkZuYzogQ2hhcnRpc3Qubm9vcCxcbiAgICAgIC8vIFRoaXMgdmFsdWUgc3BlY2lmaWVzIHRoZSBtaW5pbXVtIHdpZHRoIGluIHBpeGVsIG9mIHRoZSBzY2FsZSBzdGVwc1xuICAgICAgc2NhbGVNaW5TcGFjZTogMzAsXG4gICAgICAvLyBVc2Ugb25seSBpbnRlZ2VyIHZhbHVlcyAod2hvbGUgbnVtYmVycykgZm9yIHRoZSBzY2FsZSBzdGVwc1xuICAgICAgb25seUludGVnZXI6IGZhbHNlXG4gICAgfSxcbiAgICAvLyBPcHRpb25zIGZvciBZLUF4aXNcbiAgICBheGlzWToge1xuICAgICAgLy8gVGhlIG9mZnNldCBvZiB0aGUgY2hhcnQgZHJhd2luZyBhcmVhIHRvIHRoZSBib3JkZXIgb2YgdGhlIGNvbnRhaW5lclxuICAgICAgb2Zmc2V0OiA0MCxcbiAgICAgIC8vIFBvc2l0aW9uIHdoZXJlIGxhYmVscyBhcmUgcGxhY2VkLiBDYW4gYmUgc2V0IHRvIGBzdGFydGAgb3IgYGVuZGAgd2hlcmUgYHN0YXJ0YCBpcyBlcXVpdmFsZW50IHRvIGxlZnQgb3IgdG9wIG9uIHZlcnRpY2FsIGF4aXMgYW5kIGBlbmRgIGlzIGVxdWl2YWxlbnQgdG8gcmlnaHQgb3IgYm90dG9tIG9uIGhvcml6b250YWwgYXhpcy5cbiAgICAgIHBvc2l0aW9uOiAnc3RhcnQnLFxuICAgICAgLy8gQWxsb3dzIHlvdSB0byBjb3JyZWN0IGxhYmVsIHBvc2l0aW9uaW5nIG9uIHRoaXMgYXhpcyBieSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSB4IGFuZCB5IG9mZnNldC5cbiAgICAgIGxhYmVsT2Zmc2V0OiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICAvLyBJZiBsYWJlbHMgc2hvdWxkIGJlIHNob3duIG9yIG5vdFxuICAgICAgc2hvd0xhYmVsOiB0cnVlLFxuICAgICAgLy8gSWYgdGhlIGF4aXMgZ3JpZCBzaG91bGQgYmUgZHJhd24gb3Igbm90XG4gICAgICBzaG93R3JpZDogdHJ1ZSxcbiAgICAgIC8vIEludGVycG9sYXRpb24gZnVuY3Rpb24gdGhhdCBhbGxvd3MgeW91IHRvIGludGVyY2VwdCB0aGUgdmFsdWUgZnJvbSB0aGUgYXhpcyBsYWJlbFxuICAgICAgbGFiZWxJbnRlcnBvbGF0aW9uRm5jOiBDaGFydGlzdC5ub29wLFxuICAgICAgLy8gVGhpcyB2YWx1ZSBzcGVjaWZpZXMgdGhlIG1pbmltdW0gaGVpZ2h0IGluIHBpeGVsIG9mIHRoZSBzY2FsZSBzdGVwc1xuICAgICAgc2NhbGVNaW5TcGFjZTogMjAsXG4gICAgICAvLyBVc2Ugb25seSBpbnRlZ2VyIHZhbHVlcyAod2hvbGUgbnVtYmVycykgZm9yIHRoZSBzY2FsZSBzdGVwc1xuICAgICAgb25seUludGVnZXI6IGZhbHNlXG4gICAgfSxcbiAgICAvLyBTcGVjaWZ5IGEgZml4ZWQgd2lkdGggZm9yIHRoZSBjaGFydCBhcyBhIHN0cmluZyAoaS5lLiAnMTAwcHgnIG9yICc1MCUnKVxuICAgIHdpZHRoOiB1bmRlZmluZWQsXG4gICAgLy8gU3BlY2lmeSBhIGZpeGVkIGhlaWdodCBmb3IgdGhlIGNoYXJ0IGFzIGEgc3RyaW5nIChpLmUuICcxMDBweCcgb3IgJzUwJScpXG4gICAgaGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgLy8gT3ZlcnJpZGluZyB0aGUgbmF0dXJhbCBoaWdoIG9mIHRoZSBjaGFydCBhbGxvd3MgeW91IHRvIHpvb20gaW4gb3IgbGltaXQgdGhlIGNoYXJ0cyBoaWdoZXN0IGRpc3BsYXllZCB2YWx1ZVxuICAgIGhpZ2g6IHVuZGVmaW5lZCxcbiAgICAvLyBPdmVycmlkaW5nIHRoZSBuYXR1cmFsIGxvdyBvZiB0aGUgY2hhcnQgYWxsb3dzIHlvdSB0byB6b29tIGluIG9yIGxpbWl0IHRoZSBjaGFydHMgbG93ZXN0IGRpc3BsYXllZCB2YWx1ZVxuICAgIGxvdzogdW5kZWZpbmVkLFxuICAgIC8vIFVubGVzcyBsb3cvaGlnaCBhcmUgZXhwbGljaXRseSBzZXQsIGJhciBjaGFydCB3aWxsIGJlIGNlbnRlcmVkIGF0IHplcm8gYnkgZGVmYXVsdC4gU2V0IHJlZmVyZW5jZVZhbHVlIHRvIG51bGwgdG8gYXV0byBzY2FsZS5cbiAgICByZWZlcmVuY2VWYWx1ZTogMCxcbiAgICAvLyBQYWRkaW5nIG9mIHRoZSBjaGFydCBkcmF3aW5nIGFyZWEgdG8gdGhlIGNvbnRhaW5lciBlbGVtZW50IGFuZCBsYWJlbHMgYXMgYSBudW1iZXIgb3IgcGFkZGluZyBvYmplY3Qge3RvcDogNSwgcmlnaHQ6IDUsIGJvdHRvbTogNSwgbGVmdDogNX1cbiAgICBjaGFydFBhZGRpbmc6IHtcbiAgICAgIHRvcDogMTUsXG4gICAgICByaWdodDogMTUsXG4gICAgICBib3R0b206IDUsXG4gICAgICBsZWZ0OiAxMFxuICAgIH0sXG4gICAgLy8gU3BlY2lmeSB0aGUgZGlzdGFuY2UgaW4gcGl4ZWwgb2YgYmFycyBpbiBhIGdyb3VwXG4gICAgc2VyaWVzQmFyRGlzdGFuY2U6IDE1LFxuICAgIC8vIElmIHNldCB0byB0cnVlIHRoaXMgcHJvcGVydHkgd2lsbCBjYXVzZSB0aGUgc2VyaWVzIGJhcnMgdG8gYmUgc3RhY2tlZC4gQ2hlY2sgdGhlIGBzdGFja01vZGVgIG9wdGlvbiBmb3IgZnVydGhlciBzdGFja2luZyBvcHRpb25zLlxuICAgIHN0YWNrQmFyczogZmFsc2UsXG4gICAgLy8gSWYgc2V0IHRvICdvdmVybGFwJyB0aGlzIHByb3BlcnR5IHdpbGwgZm9yY2UgdGhlIHN0YWNrZWQgYmFycyB0byBkcmF3IGZyb20gdGhlIHplcm8gbGluZS5cbiAgICAvLyBJZiBzZXQgdG8gJ2FjY3VtdWxhdGUnIHRoaXMgcHJvcGVydHkgd2lsbCBmb3JtIGEgdG90YWwgZm9yIGVhY2ggc2VyaWVzIHBvaW50LiBUaGlzIHdpbGwgYWxzbyBpbmZsdWVuY2UgdGhlIHktYXhpcyBhbmQgdGhlIG92ZXJhbGwgYm91bmRzIG9mIHRoZSBjaGFydC4gSW4gc3RhY2tlZCBtb2RlIHRoZSBzZXJpZXNCYXJEaXN0YW5jZSBwcm9wZXJ0eSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICAgIHN0YWNrTW9kZTogJ2FjY3VtdWxhdGUnLFxuICAgIC8vIEludmVydHMgdGhlIGF4ZXMgb2YgdGhlIGJhciBjaGFydCBpbiBvcmRlciB0byBkcmF3IGEgaG9yaXpvbnRhbCBiYXIgY2hhcnQuIEJlIGF3YXJlIHRoYXQgeW91IGFsc28gbmVlZCB0byBpbnZlcnQgeW91ciBheGlzIHNldHRpbmdzIGFzIHRoZSBZIEF4aXMgd2lsbCBub3cgZGlzcGxheSB0aGUgbGFiZWxzIGFuZCB0aGUgWCBBeGlzIHRoZSB2YWx1ZXMuXG4gICAgaG9yaXpvbnRhbEJhcnM6IGZhbHNlLFxuICAgIC8vIElmIHNldCB0byB0cnVlIHRoZW4gZWFjaCBiYXIgd2lsbCByZXByZXNlbnQgYSBzZXJpZXMgYW5kIHRoZSBkYXRhIGFycmF5IGlzIGV4cGVjdGVkIHRvIGJlIGEgb25lIGRpbWVuc2lvbmFsIGFycmF5IG9mIGRhdGEgdmFsdWVzIHJhdGhlciB0aGFuIGEgc2VyaWVzIGFycmF5IG9mIHNlcmllcy4gVGhpcyBpcyB1c2VmdWwgaWYgdGhlIGJhciBjaGFydCBzaG91bGQgcmVwcmVzZW50IGEgcHJvZmlsZSByYXRoZXIgdGhhbiBzb21lIGRhdGEgb3ZlciB0aW1lLlxuICAgIGRpc3RyaWJ1dGVTZXJpZXM6IGZhbHNlLFxuICAgIC8vIElmIHRydWUgdGhlIHdob2xlIGRhdGEgaXMgcmV2ZXJzZWQgaW5jbHVkaW5nIGxhYmVscywgdGhlIHNlcmllcyBvcmRlciBhcyB3ZWxsIGFzIHRoZSB3aG9sZSBzZXJpZXMgZGF0YSBhcnJheXMuXG4gICAgcmV2ZXJzZURhdGE6IGZhbHNlLFxuICAgIC8vIElmIHRoZSBiYXIgY2hhcnQgc2hvdWxkIGFkZCBhIGJhY2tncm91bmQgZmlsbCB0byB0aGUgLmN0LWdyaWRzIGdyb3VwLlxuICAgIHNob3dHcmlkQmFja2dyb3VuZDogZmFsc2UsXG4gICAgLy8gT3ZlcnJpZGUgdGhlIGNsYXNzIG5hbWVzIHRoYXQgZ2V0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIFNWRyBzdHJ1Y3R1cmUgb2YgdGhlIGNoYXJ0XG4gICAgY2xhc3NOYW1lczoge1xuICAgICAgY2hhcnQ6ICdjdC1jaGFydC1iYXInLFxuICAgICAgaG9yaXpvbnRhbEJhcnM6ICdjdC1ob3Jpem9udGFsLWJhcnMnLFxuICAgICAgbGFiZWw6ICdjdC1sYWJlbCcsXG4gICAgICBsYWJlbEdyb3VwOiAnY3QtbGFiZWxzJyxcbiAgICAgIHNlcmllczogJ2N0LXNlcmllcycsXG4gICAgICBiYXI6ICdjdC1iYXInLFxuICAgICAgZ3JpZDogJ2N0LWdyaWQnLFxuICAgICAgZ3JpZEdyb3VwOiAnY3QtZ3JpZHMnLFxuICAgICAgZ3JpZEJhY2tncm91bmQ6ICdjdC1ncmlkLWJhY2tncm91bmQnLFxuICAgICAgdmVydGljYWw6ICdjdC12ZXJ0aWNhbCcsXG4gICAgICBob3Jpem9udGFsOiAnY3QtaG9yaXpvbnRhbCcsXG4gICAgICBzdGFydDogJ2N0LXN0YXJ0JyxcbiAgICAgIGVuZDogJ2N0LWVuZCdcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY2hhcnRcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYXJ0KG9wdGlvbnMpIHtcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgaGlnaExvdztcblxuICAgIGlmKG9wdGlvbnMuZGlzdHJpYnV0ZVNlcmllcykge1xuICAgICAgZGF0YSA9IENoYXJ0aXN0Lm5vcm1hbGl6ZURhdGEodGhpcy5kYXRhLCBvcHRpb25zLnJldmVyc2VEYXRhLCBvcHRpb25zLmhvcml6b250YWxCYXJzID8gJ3gnIDogJ3knKTtcbiAgICAgIGRhdGEubm9ybWFsaXplZC5zZXJpZXMgPSBkYXRhLm5vcm1hbGl6ZWQuc2VyaWVzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gQ2hhcnRpc3Qubm9ybWFsaXplRGF0YSh0aGlzLmRhdGEsIG9wdGlvbnMucmV2ZXJzZURhdGEsIG9wdGlvbnMuaG9yaXpvbnRhbEJhcnMgPyAneCcgOiAneScpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZXcgc3ZnIGVsZW1lbnRcbiAgICB0aGlzLnN2ZyA9IENoYXJ0aXN0LmNyZWF0ZVN2ZyhcbiAgICAgIHRoaXMuY29udGFpbmVyLFxuICAgICAgb3B0aW9ucy53aWR0aCxcbiAgICAgIG9wdGlvbnMuaGVpZ2h0LFxuICAgICAgb3B0aW9ucy5jbGFzc05hbWVzLmNoYXJ0ICsgKG9wdGlvbnMuaG9yaXpvbnRhbEJhcnMgPyAnICcgKyBvcHRpb25zLmNsYXNzTmFtZXMuaG9yaXpvbnRhbEJhcnMgOiAnJylcbiAgICApO1xuXG4gICAgLy8gRHJhd2luZyBncm91cHMgaW4gY29ycmVjdCBvcmRlclxuICAgIHZhciBncmlkR3JvdXAgPSB0aGlzLnN2Zy5lbGVtKCdnJykuYWRkQ2xhc3Mob3B0aW9ucy5jbGFzc05hbWVzLmdyaWRHcm91cCk7XG4gICAgdmFyIHNlcmllc0dyb3VwID0gdGhpcy5zdmcuZWxlbSgnZycpO1xuICAgIHZhciBsYWJlbEdyb3VwID0gdGhpcy5zdmcuZWxlbSgnZycpLmFkZENsYXNzKG9wdGlvbnMuY2xhc3NOYW1lcy5sYWJlbEdyb3VwKTtcblxuICAgIGlmKG9wdGlvbnMuc3RhY2tCYXJzICYmIGRhdGEubm9ybWFsaXplZC5zZXJpZXMubGVuZ3RoICE9PSAwKSB7XG5cbiAgICAgIC8vIElmIHN0YWNrZWQgYmFycyB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgaGlnaCBsb3cgZnJvbSBzdGFja2VkIHZhbHVlcyBmcm9tIGVhY2ggc2VyaWVzXG4gICAgICB2YXIgc2VyaWFsU3VtcyA9IENoYXJ0aXN0LnNlcmlhbE1hcChkYXRhLm5vcm1hbGl6ZWQuc2VyaWVzLCBmdW5jdGlvbiBzZXJpYWxTdW1zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pLnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHByZXYueCArIChjdXJyICYmIGN1cnIueCkgfHwgMCxcbiAgICAgICAgICAgIHk6IHByZXYueSArIChjdXJyICYmIGN1cnIueSkgfHwgMFxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHt4OiAwLCB5OiAwfSk7XG4gICAgICB9KTtcblxuICAgICAgaGlnaExvdyA9IENoYXJ0aXN0LmdldEhpZ2hMb3coW3NlcmlhbFN1bXNdLCBvcHRpb25zLCBvcHRpb25zLmhvcml6b250YWxCYXJzID8gJ3gnIDogJ3knKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGhpZ2hMb3cgPSBDaGFydGlzdC5nZXRIaWdoTG93KGRhdGEubm9ybWFsaXplZC5zZXJpZXMsIG9wdGlvbnMsIG9wdGlvbnMuaG9yaXpvbnRhbEJhcnMgPyAneCcgOiAneScpO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlcyBvZiBoaWdoIC8gbG93IGZyb20gc2V0dGluZ3NcbiAgICBoaWdoTG93LmhpZ2ggPSArb3B0aW9ucy5oaWdoIHx8IChvcHRpb25zLmhpZ2ggPT09IDAgPyAwIDogaGlnaExvdy5oaWdoKTtcbiAgICBoaWdoTG93LmxvdyA9ICtvcHRpb25zLmxvdyB8fCAob3B0aW9ucy5sb3cgPT09IDAgPyAwIDogaGlnaExvdy5sb3cpO1xuXG4gICAgdmFyIGNoYXJ0UmVjdCA9IENoYXJ0aXN0LmNyZWF0ZUNoYXJ0UmVjdCh0aGlzLnN2Zywgb3B0aW9ucywgZGVmYXVsdE9wdGlvbnMucGFkZGluZyk7XG5cbiAgICB2YXIgdmFsdWVBeGlzLFxuICAgICAgbGFiZWxBeGlzVGlja3MsXG4gICAgICBsYWJlbEF4aXMsXG4gICAgICBheGlzWCxcbiAgICAgIGF4aXNZO1xuXG4gICAgLy8gV2UgbmVlZCB0byBzZXQgc3RlcCBjb3VudCBiYXNlZCBvbiBzb21lIG9wdGlvbnMgY29tYmluYXRpb25zXG4gICAgaWYob3B0aW9ucy5kaXN0cmlidXRlU2VyaWVzICYmIG9wdGlvbnMuc3RhY2tCYXJzKSB7XG4gICAgICAvLyBJZiBkaXN0cmlidXRlZCBzZXJpZXMgYXJlIGVuYWJsZWQgYW5kIGJhcnMgbmVlZCB0byBiZSBzdGFja2VkLCB3ZSdsbCBvbmx5IGhhdmUgb25lIGJhciBhbmQgdGhlcmVmb3JlIHNob3VsZFxuICAgICAgLy8gdXNlIG9ubHkgdGhlIGZpcnN0IGxhYmVsIGZvciB0aGUgc3RlcCBheGlzXG4gICAgICBsYWJlbEF4aXNUaWNrcyA9IGRhdGEubm9ybWFsaXplZC5sYWJlbHMuc2xpY2UoMCwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGRpc3RyaWJ1dGVkIHNlcmllcyBhcmUgZW5hYmxlZCBidXQgc3RhY2tlZCBiYXJzIGFyZW4ndCwgd2Ugc2hvdWxkIHVzZSB0aGUgc2VyaWVzIGxhYmVsc1xuICAgICAgLy8gSWYgd2UgYXJlIGRyYXdpbmcgYSByZWd1bGFyIGJhciBjaGFydCB3aXRoIHR3byBkaW1lbnNpb25hbCBzZXJpZXMgZGF0YSwgd2UganVzdCB1c2UgdGhlIGxhYmVscyBhcnJheVxuICAgICAgLy8gYXMgdGhlIGJhcnMgYXJlIG5vcm1hbGl6ZWRcbiAgICAgIGxhYmVsQXhpc1RpY2tzID0gZGF0YS5ub3JtYWxpemVkLmxhYmVscztcbiAgICB9XG5cbiAgICAvLyBTZXQgbGFiZWxBeGlzIGFuZCB2YWx1ZUF4aXMgYmFzZWQgb24gdGhlIGhvcml6b250YWxCYXJzIHNldHRpbmcuIFRoaXMgc2V0dGluZyB3aWxsIGZsaXAgdGhlIGF4ZXMgaWYgbmVjZXNzYXJ5LlxuICAgIGlmKG9wdGlvbnMuaG9yaXpvbnRhbEJhcnMpIHtcbiAgICAgIGlmKG9wdGlvbnMuYXhpc1gudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlQXhpcyA9IGF4aXNYID0gbmV3IENoYXJ0aXN0LkF1dG9TY2FsZUF4aXMoQ2hhcnRpc3QuQXhpcy51bml0cy54LCBkYXRhLm5vcm1hbGl6ZWQuc2VyaWVzLCBjaGFydFJlY3QsIENoYXJ0aXN0LmV4dGVuZCh7fSwgb3B0aW9ucy5heGlzWCwge1xuICAgICAgICAgIGhpZ2hMb3c6IGhpZ2hMb3csXG4gICAgICAgICAgcmVmZXJlbmNlVmFsdWU6IDBcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVBeGlzID0gYXhpc1ggPSBvcHRpb25zLmF4aXNYLnR5cGUuY2FsbChDaGFydGlzdCwgQ2hhcnRpc3QuQXhpcy51bml0cy54LCBkYXRhLm5vcm1hbGl6ZWQuc2VyaWVzLCBjaGFydFJlY3QsIENoYXJ0aXN0LmV4dGVuZCh7fSwgb3B0aW9ucy5heGlzWCwge1xuICAgICAgICAgIGhpZ2hMb3c6IGhpZ2hMb3csXG4gICAgICAgICAgcmVmZXJlbmNlVmFsdWU6IDBcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBpZihvcHRpb25zLmF4aXNZLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsYWJlbEF4aXMgPSBheGlzWSA9IG5ldyBDaGFydGlzdC5TdGVwQXhpcyhDaGFydGlzdC5BeGlzLnVuaXRzLnksIGRhdGEubm9ybWFsaXplZC5zZXJpZXMsIGNoYXJ0UmVjdCwge1xuICAgICAgICAgIHRpY2tzOiBsYWJlbEF4aXNUaWNrc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmVsQXhpcyA9IGF4aXNZID0gb3B0aW9ucy5heGlzWS50eXBlLmNhbGwoQ2hhcnRpc3QsIENoYXJ0aXN0LkF4aXMudW5pdHMueSwgZGF0YS5ub3JtYWxpemVkLnNlcmllcywgY2hhcnRSZWN0LCBvcHRpb25zLmF4aXNZKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYob3B0aW9ucy5heGlzWC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGFiZWxBeGlzID0gYXhpc1ggPSBuZXcgQ2hhcnRpc3QuU3RlcEF4aXMoQ2hhcnRpc3QuQXhpcy51bml0cy54LCBkYXRhLm5vcm1hbGl6ZWQuc2VyaWVzLCBjaGFydFJlY3QsIHtcbiAgICAgICAgICB0aWNrczogbGFiZWxBeGlzVGlja3NcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbEF4aXMgPSBheGlzWCA9IG9wdGlvbnMuYXhpc1gudHlwZS5jYWxsKENoYXJ0aXN0LCBDaGFydGlzdC5BeGlzLnVuaXRzLngsIGRhdGEubm9ybWFsaXplZC5zZXJpZXMsIGNoYXJ0UmVjdCwgb3B0aW9ucy5heGlzWCk7XG4gICAgICB9XG5cbiAgICAgIGlmKG9wdGlvbnMuYXhpc1kudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlQXhpcyA9IGF4aXNZID0gbmV3IENoYXJ0aXN0LkF1dG9TY2FsZUF4aXMoQ2hhcnRpc3QuQXhpcy51bml0cy55LCBkYXRhLm5vcm1hbGl6ZWQuc2VyaWVzLCBjaGFydFJlY3QsIENoYXJ0aXN0LmV4dGVuZCh7fSwgb3B0aW9ucy5heGlzWSwge1xuICAgICAgICAgIGhpZ2hMb3c6IGhpZ2hMb3csXG4gICAgICAgICAgcmVmZXJlbmNlVmFsdWU6IDBcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVBeGlzID0gYXhpc1kgPSBvcHRpb25zLmF4aXNZLnR5cGUuY2FsbChDaGFydGlzdCwgQ2hhcnRpc3QuQXhpcy51bml0cy55LCBkYXRhLm5vcm1hbGl6ZWQuc2VyaWVzLCBjaGFydFJlY3QsIENoYXJ0aXN0LmV4dGVuZCh7fSwgb3B0aW9ucy5heGlzWSwge1xuICAgICAgICAgIGhpZ2hMb3c6IGhpZ2hMb3csXG4gICAgICAgICAgcmVmZXJlbmNlVmFsdWU6IDBcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb2plY3RlZCAwIHBvaW50XG4gICAgdmFyIHplcm9Qb2ludCA9IG9wdGlvbnMuaG9yaXpvbnRhbEJhcnMgPyAoY2hhcnRSZWN0LngxICsgdmFsdWVBeGlzLnByb2plY3RWYWx1ZSgwKSkgOiAoY2hhcnRSZWN0LnkxIC0gdmFsdWVBeGlzLnByb2plY3RWYWx1ZSgwKSk7XG4gICAgLy8gVXNlZCB0byB0cmFjayB0aGUgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHN0YWNrZWQgYmFyc1xuICAgIHZhciBzdGFja2VkQmFyVmFsdWVzID0gW107XG5cbiAgICBsYWJlbEF4aXMuY3JlYXRlR3JpZEFuZExhYmVscyhncmlkR3JvdXAsIGxhYmVsR3JvdXAsIHRoaXMuc3VwcG9ydHNGb3JlaWduT2JqZWN0LCBvcHRpb25zLCB0aGlzLmV2ZW50RW1pdHRlcik7XG4gICAgdmFsdWVBeGlzLmNyZWF0ZUdyaWRBbmRMYWJlbHMoZ3JpZEdyb3VwLCBsYWJlbEdyb3VwLCB0aGlzLnN1cHBvcnRzRm9yZWlnbk9iamVjdCwgb3B0aW9ucywgdGhpcy5ldmVudEVtaXR0ZXIpO1xuXG4gICAgaWYgKG9wdGlvbnMuc2hvd0dyaWRCYWNrZ3JvdW5kKSB7XG4gICAgICBDaGFydGlzdC5jcmVhdGVHcmlkQmFja2dyb3VuZChncmlkR3JvdXAsIGNoYXJ0UmVjdCwgb3B0aW9ucy5jbGFzc05hbWVzLmdyaWRCYWNrZ3JvdW5kLCB0aGlzLmV2ZW50RW1pdHRlcik7XG4gICAgfVxuXG4gICAgLy8gRHJhdyB0aGUgc2VyaWVzXG4gICAgZGF0YS5yYXcuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLCBzZXJpZXNJbmRleCkge1xuICAgICAgLy8gQ2FsY3VsYXRpbmcgYmktcG9sYXIgdmFsdWUgb2YgaW5kZXggZm9yIHNlcmllc09mZnNldC4gRm9yIGkgPSAwLi40IGJpUG9sIHdpbGwgYmUgLTEuNSwgLTAuNSwgMC41LCAxLjUgZXRjLlxuICAgICAgdmFyIGJpUG9sID0gc2VyaWVzSW5kZXggLSAoZGF0YS5yYXcuc2VyaWVzLmxlbmd0aCAtIDEpIC8gMjtcbiAgICAgIC8vIEhhbGYgb2YgdGhlIHBlcmlvZCB3aWR0aCBiZXR3ZWVuIHZlcnRpY2FsIGdyaWQgbGluZXMgdXNlZCB0byBwb3NpdGlvbiBiYXJzXG4gICAgICB2YXIgcGVyaW9kSGFsZkxlbmd0aDtcbiAgICAgIC8vIEN1cnJlbnQgc2VyaWVzIFNWRyBlbGVtZW50XG4gICAgICB2YXIgc2VyaWVzRWxlbWVudDtcblxuICAgICAgLy8gV2UgbmVlZCB0byBzZXQgcGVyaW9kSGFsZkxlbmd0aCBiYXNlZCBvbiBzb21lIG9wdGlvbnMgY29tYmluYXRpb25zXG4gICAgICBpZihvcHRpb25zLmRpc3RyaWJ1dGVTZXJpZXMgJiYgIW9wdGlvbnMuc3RhY2tCYXJzKSB7XG4gICAgICAgIC8vIElmIGRpc3RyaWJ1dGVkIHNlcmllcyBhcmUgZW5hYmxlZCBidXQgc3RhY2tlZCBiYXJzIGFyZW4ndCwgd2UgbmVlZCB0byB1c2UgdGhlIGxlbmd0aCBvZiB0aGUgbm9ybWFpemVkRGF0YSBhcnJheVxuICAgICAgICAvLyB3aGljaCBpcyB0aGUgc2VyaWVzIGNvdW50IGFuZCBkaXZpZGUgYnkgMlxuICAgICAgICBwZXJpb2RIYWxmTGVuZ3RoID0gbGFiZWxBeGlzLmF4aXNMZW5ndGggLyBkYXRhLm5vcm1hbGl6ZWQuc2VyaWVzLmxlbmd0aCAvIDI7XG4gICAgICB9IGVsc2UgaWYob3B0aW9ucy5kaXN0cmlidXRlU2VyaWVzICYmIG9wdGlvbnMuc3RhY2tCYXJzKSB7XG4gICAgICAgIC8vIElmIGRpc3RyaWJ1dGVkIHNlcmllcyBhbmQgc3RhY2tlZCBiYXJzIGFyZSBlbmFibGVkIHdlJ2xsIG9ubHkgZ2V0IG9uZSBiYXIgc28gd2Ugc2hvdWxkIGp1c3QgZGl2aWRlIHRoZSBheGlzXG4gICAgICAgIC8vIGxlbmd0aCBieSAyXG4gICAgICAgIHBlcmlvZEhhbGZMZW5ndGggPSBsYWJlbEF4aXMuYXhpc0xlbmd0aCAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbiByZWd1bGFyIGJhciBjaGFydHMgd2Ugc2hvdWxkIGp1c3QgdXNlIHRoZSBzZXJpZXMgbGVuZ3RoXG4gICAgICAgIHBlcmlvZEhhbGZMZW5ndGggPSBsYWJlbEF4aXMuYXhpc0xlbmd0aCAvIGRhdGEubm9ybWFsaXplZC5zZXJpZXNbc2VyaWVzSW5kZXhdLmxlbmd0aCAvIDI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZGluZyB0aGUgc2VyaWVzIGdyb3VwIHRvIHRoZSBzZXJpZXMgZWxlbWVudFxuICAgICAgc2VyaWVzRWxlbWVudCA9IHNlcmllc0dyb3VwLmVsZW0oJ2cnKTtcblxuICAgICAgLy8gV3JpdGUgYXR0cmlidXRlcyB0byBzZXJpZXMgZ3JvdXAgZWxlbWVudC4gSWYgc2VyaWVzIG5hbWUgb3IgbWV0YSBpcyB1bmRlZmluZWQgdGhlIGF0dHJpYnV0ZXMgd2lsbCBub3QgYmUgd3JpdHRlblxuICAgICAgc2VyaWVzRWxlbWVudC5hdHRyKHtcbiAgICAgICAgJ2N0OnNlcmllcy1uYW1lJzogc2VyaWVzLm5hbWUsXG4gICAgICAgICdjdDptZXRhJzogQ2hhcnRpc3Quc2VyaWFsaXplKHNlcmllcy5tZXRhKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFVzZSBzZXJpZXMgY2xhc3MgZnJvbSBzZXJpZXMgZGF0YSBvciBpZiBub3Qgc2V0IGdlbmVyYXRlIG9uZVxuICAgICAgc2VyaWVzRWxlbWVudC5hZGRDbGFzcyhbXG4gICAgICAgIG9wdGlvbnMuY2xhc3NOYW1lcy5zZXJpZXMsXG4gICAgICAgIChzZXJpZXMuY2xhc3NOYW1lIHx8IG9wdGlvbnMuY2xhc3NOYW1lcy5zZXJpZXMgKyAnLScgKyBDaGFydGlzdC5hbHBoYU51bWVyYXRlKHNlcmllc0luZGV4KSlcbiAgICAgIF0uam9pbignICcpKTtcblxuICAgICAgZGF0YS5ub3JtYWxpemVkLnNlcmllc1tzZXJpZXNJbmRleF0uZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgdmFsdWVJbmRleCkge1xuICAgICAgICB2YXIgcHJvamVjdGVkLFxuICAgICAgICAgIGJhcixcbiAgICAgICAgICBwcmV2aW91c1N0YWNrLFxuICAgICAgICAgIGxhYmVsQXhpc1ZhbHVlSW5kZXg7XG5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBzZXQgbGFiZWxBeGlzVmFsdWVJbmRleCBiYXNlZCBvbiBzb21lIG9wdGlvbnMgY29tYmluYXRpb25zXG4gICAgICAgIGlmKG9wdGlvbnMuZGlzdHJpYnV0ZVNlcmllcyAmJiAhb3B0aW9ucy5zdGFja0JhcnMpIHtcbiAgICAgICAgICAvLyBJZiBkaXN0cmlidXRlZCBzZXJpZXMgYXJlIGVuYWJsZWQgYnV0IHN0YWNrZWQgYmFycyBhcmVuJ3QsIHdlIGNhbiB1c2UgdGhlIHNlcmllc0luZGV4IGZvciBsYXRlciBwcm9qZWN0aW9uXG4gICAgICAgICAgLy8gb24gdGhlIHN0ZXAgYXhpcyBmb3IgbGFiZWwgcG9zaXRpb25pbmdcbiAgICAgICAgICBsYWJlbEF4aXNWYWx1ZUluZGV4ID0gc2VyaWVzSW5kZXg7XG4gICAgICAgIH0gZWxzZSBpZihvcHRpb25zLmRpc3RyaWJ1dGVTZXJpZXMgJiYgb3B0aW9ucy5zdGFja0JhcnMpIHtcbiAgICAgICAgICAvLyBJZiBkaXN0cmlidXRlZCBzZXJpZXMgYW5kIHN0YWNrZWQgYmFycyBhcmUgZW5hYmxlZCwgd2Ugd2lsbCBvbmx5IGdldCBvbmUgYmFyIGFuZCB0aGVyZWZvcmUgYWx3YXlzIHVzZVxuICAgICAgICAgIC8vIDAgZm9yIHByb2plY3Rpb24gb24gdGhlIGxhYmVsIHN0ZXAgYXhpc1xuICAgICAgICAgIGxhYmVsQXhpc1ZhbHVlSW5kZXggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE9uIHJlZ3VsYXIgYmFyIGNoYXJ0cyB3ZSBqdXN0IHVzZSB0aGUgdmFsdWUgaW5kZXggdG8gcHJvamVjdCBvbiB0aGUgbGFiZWwgc3RlcCBheGlzXG4gICAgICAgICAgbGFiZWxBeGlzVmFsdWVJbmRleCA9IHZhbHVlSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBuZWVkIHRvIHRyYW5zZm9ybSBjb29yZGluYXRlcyBkaWZmZXJlbnRseSBiYXNlZCBvbiB0aGUgY2hhcnQgbGF5b3V0XG4gICAgICAgIGlmKG9wdGlvbnMuaG9yaXpvbnRhbEJhcnMpIHtcbiAgICAgICAgICBwcm9qZWN0ZWQgPSB7XG4gICAgICAgICAgICB4OiBjaGFydFJlY3QueDEgKyB2YWx1ZUF4aXMucHJvamVjdFZhbHVlKHZhbHVlICYmIHZhbHVlLnggPyB2YWx1ZS54IDogMCwgdmFsdWVJbmRleCwgZGF0YS5ub3JtYWxpemVkLnNlcmllc1tzZXJpZXNJbmRleF0pLFxuICAgICAgICAgICAgeTogY2hhcnRSZWN0LnkxIC0gbGFiZWxBeGlzLnByb2plY3RWYWx1ZSh2YWx1ZSAmJiB2YWx1ZS55ID8gdmFsdWUueSA6IDAsIGxhYmVsQXhpc1ZhbHVlSW5kZXgsIGRhdGEubm9ybWFsaXplZC5zZXJpZXNbc2VyaWVzSW5kZXhdKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvamVjdGVkID0ge1xuICAgICAgICAgICAgeDogY2hhcnRSZWN0LngxICsgbGFiZWxBeGlzLnByb2plY3RWYWx1ZSh2YWx1ZSAmJiB2YWx1ZS54ID8gdmFsdWUueCA6IDAsIGxhYmVsQXhpc1ZhbHVlSW5kZXgsIGRhdGEubm9ybWFsaXplZC5zZXJpZXNbc2VyaWVzSW5kZXhdKSxcbiAgICAgICAgICAgIHk6IGNoYXJ0UmVjdC55MSAtIHZhbHVlQXhpcy5wcm9qZWN0VmFsdWUodmFsdWUgJiYgdmFsdWUueSA/IHZhbHVlLnkgOiAwLCB2YWx1ZUluZGV4LCBkYXRhLm5vcm1hbGl6ZWQuc2VyaWVzW3Nlcmllc0luZGV4XSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgbGFiZWwgYXhpcyBpcyBhIHN0ZXAgYmFzZWQgYXhpcyB3ZSB3aWxsIG9mZnNldCB0aGUgYmFyIGludG8gdGhlIG1pZGRsZSBvZiBiZXR3ZWVuIHR3byBzdGVwcyB1c2luZ1xuICAgICAgICAvLyB0aGUgcGVyaW9kSGFsZkxlbmd0aCB2YWx1ZS4gQWxzbyB3ZSBkbyBhcnJhbmdlIHRoZSBkaWZmZXJlbnQgc2VyaWVzIHNvIHRoYXQgdGhleSBhbGlnbiB1cCB0byBlYWNoIG90aGVyIHVzaW5nXG4gICAgICAgIC8vIHRoZSBzZXJpZXNCYXJEaXN0YW5jZS4gSWYgd2UgZG9uJ3QgaGF2ZSBhIHN0ZXAgYXhpcywgdGhlIGJhciBwb3NpdGlvbnMgY2FuIGJlIGNob3NlbiBmcmVlbHkgc28gd2Ugc2hvdWxkIG5vdFxuICAgICAgICAvLyBhZGQgYW55IGF1dG9tYXRlZCBwb3NpdGlvbmluZy5cbiAgICAgICAgaWYobGFiZWxBeGlzIGluc3RhbmNlb2YgQ2hhcnRpc3QuU3RlcEF4aXMpIHtcbiAgICAgICAgICAvLyBPZmZzZXQgdG8gY2VudGVyIGJhciBiZXR3ZWVuIGdyaWQgbGluZXMsIGJ1dCBvbmx5IGlmIHRoZSBzdGVwIGF4aXMgaXMgbm90IHN0cmV0Y2hlZFxuICAgICAgICAgIGlmKCFsYWJlbEF4aXMub3B0aW9ucy5zdHJldGNoKSB7XG4gICAgICAgICAgICBwcm9qZWN0ZWRbbGFiZWxBeGlzLnVuaXRzLnBvc10gKz0gcGVyaW9kSGFsZkxlbmd0aCAqIChvcHRpb25zLmhvcml6b250YWxCYXJzID8gLTEgOiAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVXNpbmcgYmktcG9sYXIgb2Zmc2V0IGZvciBtdWx0aXBsZSBzZXJpZXMgaWYgbm8gc3RhY2tlZCBiYXJzIG9yIHNlcmllcyBkaXN0cmlidXRpb24gaXMgdXNlZFxuICAgICAgICAgIHByb2plY3RlZFtsYWJlbEF4aXMudW5pdHMucG9zXSArPSAob3B0aW9ucy5zdGFja0JhcnMgfHwgb3B0aW9ucy5kaXN0cmlidXRlU2VyaWVzKSA/IDAgOiBiaVBvbCAqIG9wdGlvbnMuc2VyaWVzQmFyRGlzdGFuY2UgKiAob3B0aW9ucy5ob3Jpem9udGFsQmFycyA/IC0xIDogMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnRlciB2YWx1ZSBpbiBzdGFja2VkIGJhciB2YWx1ZXMgdXNlZCB0byByZW1lbWJlciBwcmV2aW91cyBzY3JlZW4gdmFsdWUgZm9yIHN0YWNraW5nIHVwIGJhcnNcbiAgICAgICAgcHJldmlvdXNTdGFjayA9IHN0YWNrZWRCYXJWYWx1ZXNbdmFsdWVJbmRleF0gfHwgemVyb1BvaW50O1xuICAgICAgICBzdGFja2VkQmFyVmFsdWVzW3ZhbHVlSW5kZXhdID0gcHJldmlvdXNTdGFjayAtICh6ZXJvUG9pbnQgLSBwcm9qZWN0ZWRbbGFiZWxBeGlzLmNvdW50ZXJVbml0cy5wb3NdKTtcblxuICAgICAgICAvLyBTa2lwIGlmIHZhbHVlIGlzIHVuZGVmaW5lZFxuICAgICAgICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IHt9O1xuICAgICAgICBwb3NpdGlvbnNbbGFiZWxBeGlzLnVuaXRzLnBvcyArICcxJ10gPSBwcm9qZWN0ZWRbbGFiZWxBeGlzLnVuaXRzLnBvc107XG4gICAgICAgIHBvc2l0aW9uc1tsYWJlbEF4aXMudW5pdHMucG9zICsgJzInXSA9IHByb2plY3RlZFtsYWJlbEF4aXMudW5pdHMucG9zXTtcblxuICAgICAgICBpZihvcHRpb25zLnN0YWNrQmFycyAmJiAob3B0aW9ucy5zdGFja01vZGUgPT09ICdhY2N1bXVsYXRlJyB8fCAhb3B0aW9ucy5zdGFja01vZGUpKSB7XG4gICAgICAgICAgLy8gU3RhY2sgbW9kZTogYWNjdW11bGF0ZSAoZGVmYXVsdClcbiAgICAgICAgICAvLyBJZiBiYXJzIGFyZSBzdGFja2VkIHdlIHVzZSB0aGUgc3RhY2tlZEJhclZhbHVlcyByZWZlcmVuY2UgYW5kIG90aGVyd2lzZSBiYXNlIGFsbCBiYXJzIG9mZiB0aGUgemVybyBsaW5lXG4gICAgICAgICAgLy8gV2Ugd2FudCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgc28gdGhlIGV4cGVjdGVkIGZhbGxiYWNrIHdpdGhvdXQgdGhlICdzdGFja01vZGUnIG9wdGlvblxuICAgICAgICAgIC8vIHRvIGJlIHRoZSBvcmlnaW5hbCBiZWhhdmlvdXIgKGFjY3VtdWxhdGUpXG4gICAgICAgICAgcG9zaXRpb25zW2xhYmVsQXhpcy5jb3VudGVyVW5pdHMucG9zICsgJzEnXSA9IHByZXZpb3VzU3RhY2s7XG4gICAgICAgICAgcG9zaXRpb25zW2xhYmVsQXhpcy5jb3VudGVyVW5pdHMucG9zICsgJzInXSA9IHN0YWNrZWRCYXJWYWx1ZXNbdmFsdWVJbmRleF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRHJhdyBmcm9tIHRoZSB6ZXJvIGxpbmUgbm9ybWFsbHlcbiAgICAgICAgICAvLyBUaGlzIGlzIGFsc28gdGhlIHNhbWUgY29kZSBmb3IgU3RhY2sgbW9kZTogb3ZlcmxhcFxuICAgICAgICAgIHBvc2l0aW9uc1tsYWJlbEF4aXMuY291bnRlclVuaXRzLnBvcyArICcxJ10gPSB6ZXJvUG9pbnQ7XG4gICAgICAgICAgcG9zaXRpb25zW2xhYmVsQXhpcy5jb3VudGVyVW5pdHMucG9zICsgJzInXSA9IHByb2plY3RlZFtsYWJlbEF4aXMuY291bnRlclVuaXRzLnBvc107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMaW1pdCB4IGFuZCB5IHNvIHRoYXQgdGhleSBhcmUgd2l0aGluIHRoZSBjaGFydCByZWN0XG4gICAgICAgIHBvc2l0aW9ucy54MSA9IE1hdGgubWluKE1hdGgubWF4KHBvc2l0aW9ucy54MSwgY2hhcnRSZWN0LngxKSwgY2hhcnRSZWN0LngyKTtcbiAgICAgICAgcG9zaXRpb25zLngyID0gTWF0aC5taW4oTWF0aC5tYXgocG9zaXRpb25zLngyLCBjaGFydFJlY3QueDEpLCBjaGFydFJlY3QueDIpO1xuICAgICAgICBwb3NpdGlvbnMueTEgPSBNYXRoLm1pbihNYXRoLm1heChwb3NpdGlvbnMueTEsIGNoYXJ0UmVjdC55MiksIGNoYXJ0UmVjdC55MSk7XG4gICAgICAgIHBvc2l0aW9ucy55MiA9IE1hdGgubWluKE1hdGgubWF4KHBvc2l0aW9ucy55MiwgY2hhcnRSZWN0LnkyKSwgY2hhcnRSZWN0LnkxKTtcblxuICAgICAgICB2YXIgbWV0YURhdGEgPSBDaGFydGlzdC5nZXRNZXRhRGF0YShzZXJpZXMsIHZhbHVlSW5kZXgpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBiYXIgZWxlbWVudFxuICAgICAgICBiYXIgPSBzZXJpZXNFbGVtZW50LmVsZW0oJ2xpbmUnLCBwb3NpdGlvbnMsIG9wdGlvbnMuY2xhc3NOYW1lcy5iYXIpLmF0dHIoe1xuICAgICAgICAgICdjdDp2YWx1ZSc6IFt2YWx1ZS54LCB2YWx1ZS55XS5maWx0ZXIoQ2hhcnRpc3QuaXNOdW1lcmljKS5qb2luKCcsJyksXG4gICAgICAgICAgJ2N0Om1ldGEnOiBDaGFydGlzdC5zZXJpYWxpemUobWV0YURhdGEpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2RyYXcnLCBDaGFydGlzdC5leHRlbmQoe1xuICAgICAgICAgIHR5cGU6ICdiYXInLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBpbmRleDogdmFsdWVJbmRleCxcbiAgICAgICAgICBtZXRhOiBtZXRhRGF0YSxcbiAgICAgICAgICBzZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXgsXG4gICAgICAgICAgYXhpc1g6IGF4aXNYLFxuICAgICAgICAgIGF4aXNZOiBheGlzWSxcbiAgICAgICAgICBjaGFydFJlY3Q6IGNoYXJ0UmVjdCxcbiAgICAgICAgICBncm91cDogc2VyaWVzRWxlbWVudCxcbiAgICAgICAgICBlbGVtZW50OiBiYXJcbiAgICAgICAgfSwgcG9zaXRpb25zKSk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdjcmVhdGVkJywge1xuICAgICAgYm91bmRzOiB2YWx1ZUF4aXMuYm91bmRzLFxuICAgICAgY2hhcnRSZWN0OiBjaGFydFJlY3QsXG4gICAgICBheGlzWDogYXhpc1gsXG4gICAgICBheGlzWTogYXhpc1ksXG4gICAgICBzdmc6IHRoaXMuc3ZnLFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgYmFyIGNoYXJ0IGFuZCByZXR1cm5zIEFQSSBvYmplY3QgdGhhdCB5b3UgY2FuIHVzZSBmb3IgbGF0ZXIgY2hhbmdlcy5cbiAgICpcbiAgICogQG1lbWJlcm9mIENoYXJ0aXN0LkJhclxuICAgKiBAcGFyYW0ge1N0cmluZ3xOb2RlfSBxdWVyeSBBIHNlbGVjdG9yIHF1ZXJ5IHN0cmluZyBvciBkaXJlY3RseSBhIERPTSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIG9iamVjdCB0aGF0IG5lZWRzIHRvIGNvbnNpc3Qgb2YgYSBsYWJlbHMgYW5kIGEgc2VyaWVzIGFycmF5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0IHdpdGggb3B0aW9ucyB0aGF0IG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9wdGlvbnMuIENoZWNrIHRoZSBleGFtcGxlcyBmb3IgYSBkZXRhaWxlZCBsaXN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzcG9uc2l2ZU9wdGlvbnNdIFNwZWNpZnkgYW4gYXJyYXkgb2YgcmVzcG9uc2l2ZSBvcHRpb24gYXJyYXlzIHdoaWNoIGFyZSBhIG1lZGlhIHF1ZXJ5IGFuZCBvcHRpb25zIG9iamVjdCBwYWlyID0+IFtbbWVkaWFRdWVyeVN0cmluZywgb3B0aW9uc09iamVjdF0sW21vcmUuLi5dXVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aGljaCBleHBvc2VzIHRoZSBBUEkgZm9yIHRoZSBjcmVhdGVkIGNoYXJ0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIENyZWF0ZSBhIHNpbXBsZSBiYXIgY2hhcnRcbiAgICogdmFyIGRhdGEgPSB7XG4gICAqICAgbGFiZWxzOiBbJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknXSxcbiAgICogICBzZXJpZXM6IFtcbiAgICogICAgIFs1LCAyLCA0LCAyLCAwXVxuICAgKiAgIF1cbiAgICogfTtcbiAgICpcbiAgICogLy8gSW4gdGhlIGdsb2JhbCBuYW1lIHNwYWNlIENoYXJ0aXN0IHdlIGNhbGwgdGhlIEJhciBmdW5jdGlvbiB0byBpbml0aWFsaXplIGEgYmFyIGNoYXJ0LiBBcyBhIGZpcnN0IHBhcmFtZXRlciB3ZSBwYXNzIGluIGEgc2VsZWN0b3Igd2hlcmUgd2Ugd291bGQgbGlrZSB0byBnZXQgb3VyIGNoYXJ0IGNyZWF0ZWQgYW5kIGFzIGEgc2Vjb25kIHBhcmFtZXRlciB3ZSBwYXNzIG91ciBkYXRhIG9iamVjdC5cbiAgICogbmV3IENoYXJ0aXN0LkJhcignLmN0LWNoYXJ0JywgZGF0YSk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFRoaXMgZXhhbXBsZSBjcmVhdGVzIGEgYmlwb2xhciBncm91cGVkIGJhciBjaGFydCB3aGVyZSB0aGUgYm91bmRhcmllcyBhcmUgbGltaXR0ZWQgdG8gLTEwIGFuZCAxMFxuICAgKiBuZXcgQ2hhcnRpc3QuQmFyKCcuY3QtY2hhcnQnLCB7XG4gICAqICAgbGFiZWxzOiBbMSwgMiwgMywgNCwgNSwgNiwgN10sXG4gICAqICAgc2VyaWVzOiBbXG4gICAqICAgICBbMSwgMywgMiwgLTUsIC0zLCAxLCAtNl0sXG4gICAqICAgICBbLTUsIC0yLCAtNCwgLTEsIDIsIC0zLCAxXVxuICAgKiAgIF1cbiAgICogfSwge1xuICAgKiAgIHNlcmllc0JhckRpc3RhbmNlOiAxMixcbiAgICogICBsb3c6IC0xMCxcbiAgICogICBoaWdoOiAxMFxuICAgKiB9KTtcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIEJhcihxdWVyeSwgZGF0YSwgb3B0aW9ucywgcmVzcG9uc2l2ZU9wdGlvbnMpIHtcbiAgICBDaGFydGlzdC5CYXIuc3VwZXIuY29uc3RydWN0b3IuY2FsbCh0aGlzLFxuICAgICAgcXVlcnksXG4gICAgICBkYXRhLFxuICAgICAgZGVmYXVsdE9wdGlvbnMsXG4gICAgICBDaGFydGlzdC5leHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKSxcbiAgICAgIHJlc3BvbnNpdmVPcHRpb25zKTtcbiAgfVxuXG4gIC8vIENyZWF0aW5nIGJhciBjaGFydCB0eXBlIGluIENoYXJ0aXN0IG5hbWVzcGFjZVxuICBDaGFydGlzdC5CYXIgPSBDaGFydGlzdC5CYXNlLmV4dGVuZCh7XG4gICAgY29uc3RydWN0b3I6IEJhcixcbiAgICBjcmVhdGVDaGFydDogY3JlYXRlQ2hhcnRcbiAgfSk7XG5cbn0odGhpcyB8fCBnbG9iYWwsIENoYXJ0aXN0KSk7XG47LyoqXG4gKiBUaGUgcGllIGNoYXJ0IG1vZHVsZSBvZiBDaGFydGlzdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGRyYXcgcGllLCBkb251dCBvciBnYXVnZSBjaGFydHNcbiAqXG4gKiBAbW9kdWxlIENoYXJ0aXN0LlBpZVxuICovXG4vKiBnbG9iYWwgQ2hhcnRpc3QgKi9cbihmdW5jdGlvbihnbG9iYWxSb290LCBDaGFydGlzdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHdpbmRvdyA9IGdsb2JhbFJvb3Qud2luZG93O1xuICB2YXIgZG9jdW1lbnQgPSBnbG9iYWxSb290LmRvY3VtZW50O1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IG9wdGlvbnMgaW4gbGluZSBjaGFydHMuIEV4cGFuZCB0aGUgY29kZSB2aWV3IHRvIHNlZSBhIGRldGFpbGVkIGxpc3Qgb2Ygb3B0aW9ucyB3aXRoIGNvbW1lbnRzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2hhcnRpc3QuUGllXG4gICAqL1xuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgLy8gU3BlY2lmeSBhIGZpeGVkIHdpZHRoIGZvciB0aGUgY2hhcnQgYXMgYSBzdHJpbmcgKGkuZS4gJzEwMHB4JyBvciAnNTAlJylcbiAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgIC8vIFNwZWNpZnkgYSBmaXhlZCBoZWlnaHQgZm9yIHRoZSBjaGFydCBhcyBhIHN0cmluZyAoaS5lLiAnMTAwcHgnIG9yICc1MCUnKVxuICAgIGhlaWdodDogdW5kZWZpbmVkLFxuICAgIC8vIFBhZGRpbmcgb2YgdGhlIGNoYXJ0IGRyYXdpbmcgYXJlYSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnQgYW5kIGxhYmVscyBhcyBhIG51bWJlciBvciBwYWRkaW5nIG9iamVjdCB7dG9wOiA1LCByaWdodDogNSwgYm90dG9tOiA1LCBsZWZ0OiA1fVxuICAgIGNoYXJ0UGFkZGluZzogNSxcbiAgICAvLyBPdmVycmlkZSB0aGUgY2xhc3MgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgU1ZHIHN0cnVjdHVyZSBvZiB0aGUgY2hhcnRcbiAgICBjbGFzc05hbWVzOiB7XG4gICAgICBjaGFydFBpZTogJ2N0LWNoYXJ0LXBpZScsXG4gICAgICBjaGFydERvbnV0OiAnY3QtY2hhcnQtZG9udXQnLFxuICAgICAgc2VyaWVzOiAnY3Qtc2VyaWVzJyxcbiAgICAgIHNsaWNlUGllOiAnY3Qtc2xpY2UtcGllJyxcbiAgICAgIHNsaWNlRG9udXQ6ICdjdC1zbGljZS1kb251dCcsXG4gICAgICBzbGljZURvbnV0U29saWQ6ICdjdC1zbGljZS1kb251dC1zb2xpZCcsXG4gICAgICBsYWJlbDogJ2N0LWxhYmVsJ1xuICAgIH0sXG4gICAgLy8gVGhlIHN0YXJ0IGFuZ2xlIG9mIHRoZSBwaWUgY2hhcnQgaW4gZGVncmVlcyB3aGVyZSAwIHBvaW50cyBub3J0aC4gQSBoaWdoZXIgdmFsdWUgb2Zmc2V0cyB0aGUgc3RhcnQgYW5nbGUgY2xvY2t3aXNlLlxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgLy8gQW4gb3B0aW9uYWwgdG90YWwgeW91IGNhbiBzcGVjaWZ5LiBCeSBzcGVjaWZ5aW5nIGEgdG90YWwgdmFsdWUsIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiB0aGUgc2VyaWVzIG11c3QgYmUgdGhpcyB0b3RhbCBpbiBvcmRlciB0byBkcmF3IGEgZnVsbCBwaWUuIFlvdSBjYW4gdXNlIHRoaXMgcGFyYW1ldGVyIHRvIGRyYXcgb25seSBwYXJ0cyBvZiBhIHBpZSBvciBnYXVnZSBjaGFydHMuXG4gICAgdG90YWw6IHVuZGVmaW5lZCxcbiAgICAvLyBJZiBzcGVjaWZpZWQgdGhlIGRvbnV0IENTUyBjbGFzc2VzIHdpbGwgYmUgdXNlZCBhbmQgc3Ryb2tlcyB3aWxsIGJlIGRyYXduIGluc3RlYWQgb2YgcGllIHNsaWNlcy5cbiAgICBkb251dDogZmFsc2UsXG4gICAgLy8gSWYgc3BlY2lmaWVkIHRoZSBkb251dCBzZWdtZW50cyB3aWxsIGJlIGRyYXduIGFzIHNoYXBlcyBpbnN0ZWFkIG9mIHN0cm9rZXMuXG4gICAgZG9udXRTb2xpZDogZmFsc2UsXG4gICAgLy8gU3BlY2lmeSB0aGUgZG9udXQgc3Ryb2tlIHdpZHRoLCBjdXJyZW50bHkgZG9uZSBpbiBqYXZhc2NyaXB0IGZvciBjb252ZW5pZW5jZS4gTWF5IG1vdmUgdG8gQ1NTIHN0eWxlcyBpbiB0aGUgZnV0dXJlLlxuICAgIC8vIFRoaXMgb3B0aW9uIGNhbiBiZSBzZXQgYXMgbnVtYmVyIG9yIHN0cmluZyB0byBzcGVjaWZ5IGEgcmVsYXRpdmUgd2lkdGggKGkuZS4gMTAwIG9yICczMCUnKS5cbiAgICBkb251dFdpZHRoOiA2MCxcbiAgICAvLyBJZiBhIGxhYmVsIHNob3VsZCBiZSBzaG93biBvciBub3RcbiAgICBzaG93TGFiZWw6IHRydWUsXG4gICAgLy8gTGFiZWwgcG9zaXRpb24gb2Zmc2V0IGZyb20gdGhlIHN0YW5kYXJkIHBvc2l0aW9uIHdoaWNoIGlzIGhhbGYgZGlzdGFuY2Ugb2YgdGhlIHJhZGl1cy4gVGhpcyB2YWx1ZSBjYW4gYmUgZWl0aGVyIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBQb3NpdGl2ZSB2YWx1ZXMgd2lsbCBwb3NpdGlvbiB0aGUgbGFiZWwgYXdheSBmcm9tIHRoZSBjZW50ZXIuXG4gICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgLy8gVGhpcyBvcHRpb24gY2FuIGJlIHNldCB0byAnaW5zaWRlJywgJ291dHNpZGUnIG9yICdjZW50ZXInLiBQb3NpdGlvbmVkIHdpdGggJ2luc2lkZScgdGhlIGxhYmVscyB3aWxsIGJlIHBsYWNlZCBvbiBoYWxmIHRoZSBkaXN0YW5jZSBvZiB0aGUgcmFkaXVzIHRvIHRoZSBib3JkZXIgb2YgdGhlIFBpZSBieSByZXNwZWN0aW5nIHRoZSAnbGFiZWxPZmZzZXQnLiBUaGUgJ291dHNpZGUnIG9wdGlvbiB3aWxsIHBsYWNlIHRoZSBsYWJlbHMgYXQgdGhlIGJvcmRlciBvZiB0aGUgcGllIGFuZCAnY2VudGVyJyB3aWxsIHBsYWNlIHRoZSBsYWJlbHMgaW4gdGhlIGFic29sdXRlIGNlbnRlciBwb2ludCBvZiB0aGUgY2hhcnQuIFRoZSAnY2VudGVyJyBvcHRpb24gb25seSBtYWtlcyBzZW5zZSBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSAnbGFiZWxPZmZzZXQnIG9wdGlvbi5cbiAgICBsYWJlbFBvc2l0aW9uOiAnaW5zaWRlJyxcbiAgICAvLyBBbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uIGZvciB0aGUgbGFiZWwgdmFsdWVcbiAgICBsYWJlbEludGVycG9sYXRpb25GbmM6IENoYXJ0aXN0Lm5vb3AsXG4gICAgLy8gTGFiZWwgZGlyZWN0aW9uIGNhbiBiZSAnbmV1dHJhbCcsICdleHBsb2RlJyBvciAnaW1wbG9kZScuIFRoZSBsYWJlbHMgYW5jaG9yIHdpbGwgYmUgcG9zaXRpb25lZCBiYXNlZCBvbiB0aG9zZSBzZXR0aW5ncyBhcyB3ZWxsIGFzIHRoZSBmYWN0IGlmIHRoZSBsYWJlbHMgYXJlIG9uIHRoZSByaWdodCBvciBsZWZ0IHNpZGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2hhcnQuIFVzdWFsbHkgZXhwbG9kZSBpcyB1c2VmdWwgd2hlbiBsYWJlbHMgYXJlIHBvc2l0aW9uZWQgZmFyIGF3YXkgZnJvbSB0aGUgY2VudGVyLlxuICAgIGxhYmVsRGlyZWN0aW9uOiAnbmV1dHJhbCcsXG4gICAgLy8gSWYgdHJ1ZSB0aGUgd2hvbGUgZGF0YSBpcyByZXZlcnNlZCBpbmNsdWRpbmcgbGFiZWxzLCB0aGUgc2VyaWVzIG9yZGVyIGFzIHdlbGwgYXMgdGhlIHdob2xlIHNlcmllcyBkYXRhIGFycmF5cy5cbiAgICByZXZlcnNlRGF0YTogZmFsc2UsXG4gICAgLy8gSWYgdHJ1ZSBlbXB0eSB2YWx1ZXMgd2lsbCBiZSBpZ25vcmVkIHRvIGF2b2lkIGRyYXdpbmcgdW5uY2Vzc2FyeSBzbGljZXMgYW5kIGxhYmVsc1xuICAgIGlnbm9yZUVtcHR5VmFsdWVzOiBmYWxzZVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIFNWRyBhbmNob3IgcG9zaXRpb24gYmFzZWQgb24gZGlyZWN0aW9uIGFuZCBjZW50ZXIgcGFyYW1ldGVyXG4gICAqXG4gICAqIEBwYXJhbSBjZW50ZXJcbiAgICogQHBhcmFtIGxhYmVsXG4gICAqIEBwYXJhbSBkaXJlY3Rpb25cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gZGV0ZXJtaW5lQW5jaG9yUG9zaXRpb24oY2VudGVyLCBsYWJlbCwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIHRvVGhlUmlnaHQgPSBsYWJlbC54ID4gY2VudGVyLng7XG5cbiAgICBpZih0b1RoZVJpZ2h0ICYmIGRpcmVjdGlvbiA9PT0gJ2V4cGxvZGUnIHx8XG4gICAgICAhdG9UaGVSaWdodCAmJiBkaXJlY3Rpb24gPT09ICdpbXBsb2RlJykge1xuICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfSBlbHNlIGlmKHRvVGhlUmlnaHQgJiYgZGlyZWN0aW9uID09PSAnaW1wbG9kZScgfHxcbiAgICAgICF0b1RoZVJpZ2h0ICYmIGRpcmVjdGlvbiA9PT0gJ2V4cGxvZGUnKSB7XG4gICAgICByZXR1cm4gJ2VuZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnbWlkZGxlJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgcGllIGNoYXJ0XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDaGFydChvcHRpb25zKSB7XG4gICAgdmFyIGRhdGEgPSBDaGFydGlzdC5ub3JtYWxpemVEYXRhKHRoaXMuZGF0YSk7XG4gICAgdmFyIHNlcmllc0dyb3VwcyA9IFtdLFxuICAgICAgbGFiZWxzR3JvdXAsXG4gICAgICBjaGFydFJlY3QsXG4gICAgICByYWRpdXMsXG4gICAgICBsYWJlbFJhZGl1cyxcbiAgICAgIHRvdGFsRGF0YVN1bSxcbiAgICAgIHN0YXJ0QW5nbGUgPSBvcHRpb25zLnN0YXJ0QW5nbGU7XG5cbiAgICAvLyBDcmVhdGUgU1ZHLmpzIGRyYXdcbiAgICB0aGlzLnN2ZyA9IENoYXJ0aXN0LmNyZWF0ZVN2Zyh0aGlzLmNvbnRhaW5lciwgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQsb3B0aW9ucy5kb251dCA/IG9wdGlvbnMuY2xhc3NOYW1lcy5jaGFydERvbnV0IDogb3B0aW9ucy5jbGFzc05hbWVzLmNoYXJ0UGllKTtcbiAgICAvLyBDYWxjdWxhdGUgY2hhcnRpbmcgcmVjdFxuICAgIGNoYXJ0UmVjdCA9IENoYXJ0aXN0LmNyZWF0ZUNoYXJ0UmVjdCh0aGlzLnN2Zywgb3B0aW9ucywgZGVmYXVsdE9wdGlvbnMucGFkZGluZyk7XG4gICAgLy8gR2V0IGJpZ2dlc3QgY2lyY2xlIHJhZGl1cyBwb3NzaWJsZSB3aXRoaW4gY2hhcnRSZWN0XG4gICAgcmFkaXVzID0gTWF0aC5taW4oY2hhcnRSZWN0LndpZHRoKCkgLyAyLCBjaGFydFJlY3QuaGVpZ2h0KCkgLyAyKTtcbiAgICAvLyBDYWxjdWxhdGUgdG90YWwgb2YgYWxsIHNlcmllcyB0byBnZXQgcmVmZXJlbmNlIHZhbHVlIG9yIHVzZSB0b3RhbCByZWZlcmVuY2UgZnJvbSBvcHRpb25hbCBvcHRpb25zXG4gICAgdG90YWxEYXRhU3VtID0gb3B0aW9ucy50b3RhbCB8fCBkYXRhLm5vcm1hbGl6ZWQuc2VyaWVzLnJlZHVjZShmdW5jdGlvbihwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpIHtcbiAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlICsgY3VycmVudFZhbHVlO1xuICAgIH0sIDApO1xuXG4gICAgdmFyIGRvbnV0V2lkdGggPSBDaGFydGlzdC5xdWFudGl0eShvcHRpb25zLmRvbnV0V2lkdGgpO1xuICAgIGlmIChkb251dFdpZHRoLnVuaXQgPT09ICclJykge1xuICAgICAgZG9udXRXaWR0aC52YWx1ZSAqPSByYWRpdXMgLyAxMDA7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyBpcyBhIGRvbnV0IGNoYXJ0IHdlIG5lZWQgdG8gYWRqdXN0IG91ciByYWRpdXMgdG8gZW5hYmxlIHN0cm9rZXMgdG8gYmUgZHJhd24gaW5zaWRlXG4gICAgLy8gVW5mb3J0dW5hdGVseSB0aGlzIGlzIG5vdCBwb3NzaWJsZSB3aXRoIHRoZSBjdXJyZW50IFNWRyBTcGVjXG4gICAgLy8gU2VlIHRoaXMgcHJvcG9zYWwgZm9yIG1vcmUgZGV0YWlsczogaHR0cDovL2xpc3RzLnczLm9yZy9BcmNoaXZlcy9QdWJsaWMvd3d3LXN2Zy8yMDAzT2N0LzAwMDAuaHRtbFxuICAgIHJhZGl1cyAtPSBvcHRpb25zLmRvbnV0ICYmICFvcHRpb25zLmRvbnV0U29saWQgPyBkb251dFdpZHRoLnZhbHVlIC8gMiAgOiAwO1xuXG4gICAgLy8gSWYgbGFiZWxQb3NpdGlvbiBpcyBzZXQgdG8gYG91dHNpZGVgIG9yIGEgZG9udXQgY2hhcnQgaXMgZHJhd24gdGhlbiB0aGUgbGFiZWwgcG9zaXRpb24gaXMgYXQgdGhlIHJhZGl1cyxcbiAgICAvLyBpZiByZWd1bGFyIHBpZSBjaGFydCBpdCdzIGhhbGYgb2YgdGhlIHJhZGl1c1xuICAgIGlmKG9wdGlvbnMubGFiZWxQb3NpdGlvbiA9PT0gJ291dHNpZGUnIHx8IG9wdGlvbnMuZG9udXQgJiYgIW9wdGlvbnMuZG9udXRTb2xpZCkge1xuICAgICAgbGFiZWxSYWRpdXMgPSByYWRpdXM7XG4gICAgfSBlbHNlIGlmKG9wdGlvbnMubGFiZWxQb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIC8vIElmIGxhYmVsUG9zaXRpb24gaXMgY2VudGVyIHdlIHN0YXJ0IHdpdGggMCBhbmQgd2lsbCBsYXRlciB3YWl0IGZvciB0aGUgbGFiZWxPZmZzZXRcbiAgICAgIGxhYmVsUmFkaXVzID0gMDtcbiAgICB9IGVsc2UgaWYob3B0aW9ucy5kb251dFNvbGlkKSB7XG4gICAgICBsYWJlbFJhZGl1cyA9IHJhZGl1cyAtIGRvbnV0V2lkdGgudmFsdWUgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IG9wdGlvbiBpcyAnaW5zaWRlJyB3aGVyZSB3ZSB1c2UgaGFsZiB0aGUgcmFkaXVzIHNvIHRoZSBsYWJlbCB3aWxsIGJlIHBsYWNlZCBpbiB0aGUgY2VudGVyIG9mIHRoZSBwaWVcbiAgICAgIC8vIHNsaWNlXG4gICAgICBsYWJlbFJhZGl1cyA9IHJhZGl1cyAvIDI7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgb2Zmc2V0IHRvIHRoZSBsYWJlbFJhZGl1cyB3aGVyZSBhIG5lZ2F0aXZlIG9mZnNldCBtZWFucyBjbG9zZWQgdG8gdGhlIGNlbnRlciBvZiB0aGUgY2hhcnRcbiAgICBsYWJlbFJhZGl1cyArPSBvcHRpb25zLmxhYmVsT2Zmc2V0O1xuXG4gICAgLy8gQ2FsY3VsYXRlIGVuZCBhbmdsZSBiYXNlZCBvbiB0b3RhbCBzdW0gYW5kIGN1cnJlbnQgZGF0YSB2YWx1ZSBhbmQgb2Zmc2V0IHdpdGggcGFkZGluZ1xuICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICB4OiBjaGFydFJlY3QueDEgKyBjaGFydFJlY3Qud2lkdGgoKSAvIDIsXG4gICAgICB5OiBjaGFydFJlY3QueTIgKyBjaGFydFJlY3QuaGVpZ2h0KCkgLyAyXG4gICAgfTtcblxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIG9ubHkgb25lIG5vbi16ZXJvIHZhbHVlIGluIHRoZSBzZXJpZXMgYXJyYXkuXG4gICAgdmFyIGhhc1NpbmdsZVZhbEluU2VyaWVzID0gZGF0YS5yYXcuc2VyaWVzLmZpbHRlcihmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB2YWwuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgPyB2YWwudmFsdWUgIT09IDAgOiB2YWwgIT09IDA7XG4gICAgfSkubGVuZ3RoID09PSAxO1xuXG4gICAgLy8gQ3JlYXRpbmcgdGhlIHNlcmllcyBncm91cHNcbiAgICBkYXRhLnJhdy5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsIGluZGV4KSB7XG4gICAgICBzZXJpZXNHcm91cHNbaW5kZXhdID0gdGhpcy5zdmcuZWxlbSgnZycsIG51bGwsIG51bGwpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgLy9pZiB3ZSBuZWVkIHRvIHNob3cgbGFiZWxzIHdlIGNyZWF0ZSB0aGUgbGFiZWwgZ3JvdXAgbm93XG4gICAgaWYob3B0aW9ucy5zaG93TGFiZWwpIHtcbiAgICAgIGxhYmVsc0dyb3VwID0gdGhpcy5zdmcuZWxlbSgnZycsIG51bGwsIG51bGwpO1xuICAgIH1cblxuICAgIC8vIERyYXcgdGhlIHNlcmllc1xuICAgIC8vIGluaXRpYWxpemUgc2VyaWVzIGdyb3Vwc1xuICAgIGRhdGEucmF3LnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcywgaW5kZXgpIHtcbiAgICAgIC8vIElmIGN1cnJlbnQgdmFsdWUgaXMgemVybyBhbmQgd2UgYXJlIGlnbm9yaW5nIGVtcHR5IHZhbHVlcyB0aGVuIHNraXAgdG8gbmV4dCB2YWx1ZVxuICAgICAgaWYgKGRhdGEubm9ybWFsaXplZC5zZXJpZXNbaW5kZXhdID09PSAwICYmIG9wdGlvbnMuaWdub3JlRW1wdHlWYWx1ZXMpIHJldHVybjtcblxuICAgICAgLy8gSWYgdGhlIHNlcmllcyBpcyBhbiBvYmplY3QgYW5kIGNvbnRhaW5zIGEgbmFtZSBvciBtZXRhIGRhdGEgd2UgYWRkIGEgY3VzdG9tIGF0dHJpYnV0ZVxuICAgICAgc2VyaWVzR3JvdXBzW2luZGV4XS5hdHRyKHtcbiAgICAgICAgJ2N0OnNlcmllcy1uYW1lJzogc2VyaWVzLm5hbWVcbiAgICAgIH0pO1xuXG4gICAgICAvLyBVc2Ugc2VyaWVzIGNsYXNzIGZyb20gc2VyaWVzIGRhdGEgb3IgaWYgbm90IHNldCBnZW5lcmF0ZSBvbmVcbiAgICAgIHNlcmllc0dyb3Vwc1tpbmRleF0uYWRkQ2xhc3MoW1xuICAgICAgICBvcHRpb25zLmNsYXNzTmFtZXMuc2VyaWVzLFxuICAgICAgICAoc2VyaWVzLmNsYXNzTmFtZSB8fCBvcHRpb25zLmNsYXNzTmFtZXMuc2VyaWVzICsgJy0nICsgQ2hhcnRpc3QuYWxwaGFOdW1lcmF0ZShpbmRleCkpXG4gICAgICBdLmpvaW4oJyAnKSk7XG5cbiAgICAgIC8vIElmIHRoZSB3aG9sZSBkYXRhc2V0IGlzIDAgZW5kQW5nbGUgc2hvdWxkIGJlIHplcm8uIENhbid0IGRpdmlkZSBieSAwLlxuICAgICAgdmFyIGVuZEFuZ2xlID0gKHRvdGFsRGF0YVN1bSA+IDAgPyBzdGFydEFuZ2xlICsgZGF0YS5ub3JtYWxpemVkLnNlcmllc1tpbmRleF0gLyB0b3RhbERhdGFTdW0gKiAzNjAgOiAwKTtcblxuICAgICAgLy8gVXNlIHNsaWdodCBvZmZzZXQgc28gdGhlcmUgYXJlIG5vIHRyYW5zcGFyZW50IGhhaXJsaW5lIGlzc3Vlc1xuICAgICAgdmFyIG92ZXJsYXBwaWdTdGFydEFuZ2xlID0gTWF0aC5tYXgoMCwgc3RhcnRBbmdsZSAtIChpbmRleCA9PT0gMCB8fCBoYXNTaW5nbGVWYWxJblNlcmllcyA/IDAgOiAwLjIpKTtcblxuICAgICAgLy8gSWYgd2UgbmVlZCB0byBkcmF3IHRoZSBhcmMgZm9yIGFsbCAzNjAgZGVncmVlcyB3ZSBuZWVkIHRvIGFkZCBhIGhhY2sgd2hlcmUgd2UgY2xvc2UgdGhlIGNpcmNsZVxuICAgICAgLy8gd2l0aCBaIGFuZCB1c2UgMzU5Ljk5IGRlZ3JlZXNcbiAgICAgIGlmKGVuZEFuZ2xlIC0gb3ZlcmxhcHBpZ1N0YXJ0QW5nbGUgPj0gMzU5Ljk5KSB7XG4gICAgICAgIGVuZEFuZ2xlID0gb3ZlcmxhcHBpZ1N0YXJ0QW5nbGUgKyAzNTkuOTk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydCA9IENoYXJ0aXN0LnBvbGFyVG9DYXJ0ZXNpYW4oY2VudGVyLngsIGNlbnRlci55LCByYWRpdXMsIG92ZXJsYXBwaWdTdGFydEFuZ2xlKSxcbiAgICAgICAgZW5kID0gQ2hhcnRpc3QucG9sYXJUb0NhcnRlc2lhbihjZW50ZXIueCwgY2VudGVyLnksIHJhZGl1cywgZW5kQW5nbGUpO1xuXG4gICAgICB2YXIgaW5uZXJTdGFydCxcbiAgICAgICAgaW5uZXJFbmQsXG4gICAgICAgIGRvbnV0U29saWRSYWRpdXM7XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYXRoIGVsZW1lbnQgZm9yIHRoZSBwaWUgY2hhcnQuIElmIHRoaXMgaXNuJ3QgYSBkb251dCBjaGFydCB3ZSBzaG91bGQgY2xvc2UgdGhlIHBhdGggZm9yIGEgY29ycmVjdCBzdHJva2VcbiAgICAgIHZhciBwYXRoID0gbmV3IENoYXJ0aXN0LlN2Zy5QYXRoKCFvcHRpb25zLmRvbnV0IHx8IG9wdGlvbnMuZG9udXRTb2xpZClcbiAgICAgICAgLm1vdmUoZW5kLngsIGVuZC55KVxuICAgICAgICAuYXJjKHJhZGl1cywgcmFkaXVzLCAwLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPiAxODAsIDAsIHN0YXJ0LngsIHN0YXJ0LnkpO1xuXG4gICAgICAvLyBJZiByZWd1bGFyIHBpZSBjaGFydCAobm8gZG9udXQpIHdlIGFkZCBhIGxpbmUgdG8gdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIGZvciBjb21wbGV0aW5nIHRoZSBwaWVcbiAgICAgIGlmKCFvcHRpb25zLmRvbnV0KSB7XG4gICAgICAgIHBhdGgubGluZShjZW50ZXIueCwgY2VudGVyLnkpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmRvbnV0U29saWQpIHtcbiAgICAgICAgZG9udXRTb2xpZFJhZGl1cyA9IHJhZGl1cyAtIGRvbnV0V2lkdGgudmFsdWU7XG4gICAgICAgIGlubmVyU3RhcnQgPSBDaGFydGlzdC5wb2xhclRvQ2FydGVzaWFuKGNlbnRlci54LCBjZW50ZXIueSwgZG9udXRTb2xpZFJhZGl1cywgc3RhcnRBbmdsZSAtIChpbmRleCA9PT0gMCB8fCBoYXNTaW5nbGVWYWxJblNlcmllcyA/IDAgOiAwLjIpKTtcbiAgICAgICAgaW5uZXJFbmQgPSBDaGFydGlzdC5wb2xhclRvQ2FydGVzaWFuKGNlbnRlci54LCBjZW50ZXIueSwgZG9udXRTb2xpZFJhZGl1cywgZW5kQW5nbGUpO1xuICAgICAgICBwYXRoLmxpbmUoaW5uZXJTdGFydC54LCBpbm5lclN0YXJ0LnkpO1xuICAgICAgICBwYXRoLmFyYyhkb251dFNvbGlkUmFkaXVzLCBkb251dFNvbGlkUmFkaXVzLCAwLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgID4gMTgwLCAxLCBpbm5lckVuZC54LCBpbm5lckVuZC55KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIHRoZSBTVkcgcGF0aFxuICAgICAgLy8gSWYgdGhpcyBpcyBhIGRvbnV0IGNoYXJ0IHdlIGFkZCB0aGUgZG9udXQgY2xhc3MsIG90aGVyd2lzZSBqdXN0IGEgcmVndWxhciBzbGljZVxuICAgICAgdmFyIHBhdGhDbGFzc05hbWUgPSBvcHRpb25zLmNsYXNzTmFtZXMuc2xpY2VQaWU7XG4gICAgICBpZiAob3B0aW9ucy5kb251dCkge1xuICAgICAgICBwYXRoQ2xhc3NOYW1lID0gb3B0aW9ucy5jbGFzc05hbWVzLnNsaWNlRG9udXQ7XG4gICAgICAgIGlmIChvcHRpb25zLmRvbnV0U29saWQpIHtcbiAgICAgICAgICBwYXRoQ2xhc3NOYW1lID0gb3B0aW9ucy5jbGFzc05hbWVzLnNsaWNlRG9udXRTb2xpZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHBhdGhFbGVtZW50ID0gc2VyaWVzR3JvdXBzW2luZGV4XS5lbGVtKCdwYXRoJywge1xuICAgICAgICBkOiBwYXRoLnN0cmluZ2lmeSgpXG4gICAgICB9LCBwYXRoQ2xhc3NOYW1lKTtcblxuICAgICAgLy8gQWRkaW5nIHRoZSBwaWUgc2VyaWVzIHZhbHVlIHRvIHRoZSBwYXRoXG4gICAgICBwYXRoRWxlbWVudC5hdHRyKHtcbiAgICAgICAgJ2N0OnZhbHVlJzogZGF0YS5ub3JtYWxpemVkLnNlcmllc1tpbmRleF0sXG4gICAgICAgICdjdDptZXRhJzogQ2hhcnRpc3Quc2VyaWFsaXplKHNlcmllcy5tZXRhKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBkb251dCwgd2UgYWRkIHRoZSBzdHJva2Utd2lkdGggYXMgc3R5bGUgYXR0cmlidXRlXG4gICAgICBpZihvcHRpb25zLmRvbnV0ICYmICFvcHRpb25zLmRvbnV0U29saWQpIHtcbiAgICAgICAgcGF0aEVsZW1lbnQuX25vZGUuc3R5bGUuc3Ryb2tlV2lkdGggPSBkb251dFdpZHRoLnZhbHVlICsgJ3B4JztcbiAgICAgIH1cblxuICAgICAgLy8gRmlyZSBvZmYgZHJhdyBldmVudFxuICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnZHJhdycsIHtcbiAgICAgICAgdHlwZTogJ3NsaWNlJyxcbiAgICAgICAgdmFsdWU6IGRhdGEubm9ybWFsaXplZC5zZXJpZXNbaW5kZXhdLFxuICAgICAgICB0b3RhbERhdGFTdW06IHRvdGFsRGF0YVN1bSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBtZXRhOiBzZXJpZXMubWV0YSxcbiAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgIGdyb3VwOiBzZXJpZXNHcm91cHNbaW5kZXhdLFxuICAgICAgICBlbGVtZW50OiBwYXRoRWxlbWVudCxcbiAgICAgICAgcGF0aDogcGF0aC5jbG9uZSgpLFxuICAgICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIElmIHdlIG5lZWQgdG8gc2hvdyBsYWJlbHMgd2UgbmVlZCB0byBhZGQgdGhlIGxhYmVsIGZvciB0aGlzIHNsaWNlIG5vd1xuICAgICAgaWYob3B0aW9ucy5zaG93TGFiZWwpIHtcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb247XG4gICAgICAgIGlmKGRhdGEucmF3LnNlcmllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG9ubHkgMSBzZXJpZXMsIHdlIGNhbiBwb3NpdGlvbiB0aGUgbGFiZWwgaW4gdGhlIGNlbnRlciBvZiB0aGUgcGllXG4gICAgICAgICAgbGFiZWxQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IGNlbnRlci54LFxuICAgICAgICAgICAgeTogY2VudGVyLnlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFBvc2l0aW9uIGF0IHRoZSBsYWJlbFJhZGl1cyBkaXN0YW5jZSBmcm9tIGNlbnRlciBhbmQgYmV0d2VlbiBzdGFydCBhbmQgZW5kIGFuZ2xlXG4gICAgICAgICAgbGFiZWxQb3NpdGlvbiA9IENoYXJ0aXN0LnBvbGFyVG9DYXJ0ZXNpYW4oXG4gICAgICAgICAgICBjZW50ZXIueCxcbiAgICAgICAgICAgIGNlbnRlci55LFxuICAgICAgICAgICAgbGFiZWxSYWRpdXMsXG4gICAgICAgICAgICBzdGFydEFuZ2xlICsgKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyAyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByYXdWYWx1ZTtcbiAgICAgICAgaWYoZGF0YS5ub3JtYWxpemVkLmxhYmVscyAmJiAhQ2hhcnRpc3QuaXNGYWxzZXlCdXRaZXJvKGRhdGEubm9ybWFsaXplZC5sYWJlbHNbaW5kZXhdKSkge1xuICAgICAgICAgIHJhd1ZhbHVlID0gZGF0YS5ub3JtYWxpemVkLmxhYmVsc1tpbmRleF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmF3VmFsdWUgPSBkYXRhLm5vcm1hbGl6ZWQuc2VyaWVzW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnRlcnBvbGF0ZWRWYWx1ZSA9IG9wdGlvbnMubGFiZWxJbnRlcnBvbGF0aW9uRm5jKHJhd1ZhbHVlLCBpbmRleCk7XG5cbiAgICAgICAgaWYoaW50ZXJwb2xhdGVkVmFsdWUgfHwgaW50ZXJwb2xhdGVkVmFsdWUgPT09IDApIHtcbiAgICAgICAgICB2YXIgbGFiZWxFbGVtZW50ID0gbGFiZWxzR3JvdXAuZWxlbSgndGV4dCcsIHtcbiAgICAgICAgICAgIGR4OiBsYWJlbFBvc2l0aW9uLngsXG4gICAgICAgICAgICBkeTogbGFiZWxQb3NpdGlvbi55LFxuICAgICAgICAgICAgJ3RleHQtYW5jaG9yJzogZGV0ZXJtaW5lQW5jaG9yUG9zaXRpb24oY2VudGVyLCBsYWJlbFBvc2l0aW9uLCBvcHRpb25zLmxhYmVsRGlyZWN0aW9uKVxuICAgICAgICAgIH0sIG9wdGlvbnMuY2xhc3NOYW1lcy5sYWJlbCkudGV4dCgnJyArIGludGVycG9sYXRlZFZhbHVlKTtcblxuICAgICAgICAgIC8vIEZpcmUgb2ZmIGRyYXcgZXZlbnRcbiAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdkcmF3Jywge1xuICAgICAgICAgICAgdHlwZTogJ2xhYmVsJyxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIGdyb3VwOiBsYWJlbHNHcm91cCxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGxhYmVsRWxlbWVudCxcbiAgICAgICAgICAgIHRleHQ6ICcnICsgaW50ZXJwb2xhdGVkVmFsdWUsXG4gICAgICAgICAgICB4OiBsYWJlbFBvc2l0aW9uLngsXG4gICAgICAgICAgICB5OiBsYWJlbFBvc2l0aW9uLnlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTZXQgbmV4dCBzdGFydEFuZ2xlIHRvIGN1cnJlbnQgZW5kQW5nbGUuXG4gICAgICAvLyAoZXhjZXB0IGZvciBsYXN0IHNsaWNlKVxuICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdjcmVhdGVkJywge1xuICAgICAgY2hhcnRSZWN0OiBjaGFydFJlY3QsXG4gICAgICBzdmc6IHRoaXMuc3ZnLFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgcGllIGNoYXJ0IGFuZCByZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZHJhdyB0aGUgY2hhcnQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDaGFydGlzdC5QaWVcbiAgICogQHBhcmFtIHtTdHJpbmd8Tm9kZX0gcXVlcnkgQSBzZWxlY3RvciBxdWVyeSBzdHJpbmcgb3IgZGlyZWN0bHkgYSBET00gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3QgaW4gdGhlIHBpZSBjaGFydCBuZWVkcyB0byBoYXZlIGEgc2VyaWVzIHByb3BlcnR5IHdpdGggYSBvbmUgZGltZW5zaW9uYWwgZGF0YSBhcnJheS4gVGhlIHZhbHVlcyB3aWxsIGJlIG5vcm1hbGl6ZWQgYWdhaW5zdCBlYWNoIG90aGVyIGFuZCBkb24ndCBuZWNlc3NhcmlseSBuZWVkIHRvIGJlIGluIHBlcmNlbnRhZ2UuIFRoZSBzZXJpZXMgcHJvcGVydHkgY2FuIGFsc28gYmUgYW4gYXJyYXkgb2YgdmFsdWUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYSB2YWx1ZSBwcm9wZXJ0eSBhbmQgYSBjbGFzc05hbWUgcHJvcGVydHkgdG8gb3ZlcnJpZGUgdGhlIENTUyBjbGFzcyBuYW1lIGZvciB0aGUgc2VyaWVzIGdyb3VwLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdCB3aXRoIG9wdGlvbnMgdGhhdCBvdmVycmlkZSB0aGUgZGVmYXVsdCBvcHRpb25zLiBDaGVjayB0aGUgZXhhbXBsZXMgZm9yIGEgZGV0YWlsZWQgbGlzdC5cbiAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3BvbnNpdmVPcHRpb25zXSBTcGVjaWZ5IGFuIGFycmF5IG9mIHJlc3BvbnNpdmUgb3B0aW9uIGFycmF5cyB3aGljaCBhcmUgYSBtZWRpYSBxdWVyeSBhbmQgb3B0aW9ucyBvYmplY3QgcGFpciA9PiBbW21lZGlhUXVlcnlTdHJpbmcsIG9wdGlvbnNPYmplY3RdLFttb3JlLi4uXV1cbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHZlcnNpb24gYW5kIGFuIHVwZGF0ZSBtZXRob2QgdG8gbWFudWFsbHkgcmVkcmF3IHRoZSBjaGFydFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBTaW1wbGUgcGllIGNoYXJ0IGV4YW1wbGUgd2l0aCBmb3VyIHNlcmllc1xuICAgKiBuZXcgQ2hhcnRpc3QuUGllKCcuY3QtY2hhcnQnLCB7XG4gICAqICAgc2VyaWVzOiBbMTAsIDIsIDQsIDNdXG4gICAqIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBEcmF3aW5nIGEgZG9udXQgY2hhcnRcbiAgICogbmV3IENoYXJ0aXN0LlBpZSgnLmN0LWNoYXJ0Jywge1xuICAgKiAgIHNlcmllczogWzEwLCAyLCA0LCAzXVxuICAgKiB9LCB7XG4gICAqICAgZG9udXQ6IHRydWVcbiAgICogfSk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFVzaW5nIGRvbnV0LCBzdGFydEFuZ2xlIGFuZCB0b3RhbCB0byBkcmF3IGEgZ2F1Z2UgY2hhcnRcbiAgICogbmV3IENoYXJ0aXN0LlBpZSgnLmN0LWNoYXJ0Jywge1xuICAgKiAgIHNlcmllczogWzIwLCAxMCwgMzAsIDQwXVxuICAgKiB9LCB7XG4gICAqICAgZG9udXQ6IHRydWUsXG4gICAqICAgZG9udXRXaWR0aDogMjAsXG4gICAqICAgc3RhcnRBbmdsZTogMjcwLFxuICAgKiAgIHRvdGFsOiAyMDBcbiAgICogfSk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIERyYXdpbmcgYSBwaWUgY2hhcnQgd2l0aCBwYWRkaW5nIGFuZCBsYWJlbHMgdGhhdCBhcmUgb3V0c2lkZSB0aGUgcGllXG4gICAqIG5ldyBDaGFydGlzdC5QaWUoJy5jdC1jaGFydCcsIHtcbiAgICogICBzZXJpZXM6IFsyMCwgMTAsIDMwLCA0MF1cbiAgICogfSwge1xuICAgKiAgIGNoYXJ0UGFkZGluZzogMzAsXG4gICAqICAgbGFiZWxPZmZzZXQ6IDUwLFxuICAgKiAgIGxhYmVsRGlyZWN0aW9uOiAnZXhwbG9kZSdcbiAgICogfSk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIE92ZXJyaWRpbmcgdGhlIGNsYXNzIG5hbWVzIGZvciBpbmRpdmlkdWFsIHNlcmllcyBhcyB3ZWxsIGFzIGEgbmFtZSBhbmQgbWV0YSBkYXRhLlxuICAgKiAvLyBUaGUgbmFtZSB3aWxsIGJlIHdyaXR0ZW4gYXMgY3Q6c2VyaWVzLW5hbWUgYXR0cmlidXRlIGFuZCB0aGUgbWV0YSBkYXRhIHdpbGwgYmUgc2VyaWFsaXplZCBhbmQgd3JpdHRlblxuICAgKiAvLyB0byBhIGN0Om1ldGEgYXR0cmlidXRlLlxuICAgKiBuZXcgQ2hhcnRpc3QuUGllKCcuY3QtY2hhcnQnLCB7XG4gICAqICAgc2VyaWVzOiBbe1xuICAgKiAgICAgdmFsdWU6IDIwLFxuICAgKiAgICAgbmFtZTogJ1NlcmllcyAxJyxcbiAgICogICAgIGNsYXNzTmFtZTogJ215LWN1c3RvbS1jbGFzcy1vbmUnLFxuICAgKiAgICAgbWV0YTogJ01ldGEgT25lJ1xuICAgKiAgIH0sIHtcbiAgICogICAgIHZhbHVlOiAxMCxcbiAgICogICAgIG5hbWU6ICdTZXJpZXMgMicsXG4gICAqICAgICBjbGFzc05hbWU6ICdteS1jdXN0b20tY2xhc3MtdHdvJyxcbiAgICogICAgIG1ldGE6ICdNZXRhIFR3bydcbiAgICogICB9LCB7XG4gICAqICAgICB2YWx1ZTogNzAsXG4gICAqICAgICBuYW1lOiAnU2VyaWVzIDMnLFxuICAgKiAgICAgY2xhc3NOYW1lOiAnbXktY3VzdG9tLWNsYXNzLXRocmVlJyxcbiAgICogICAgIG1ldGE6ICdNZXRhIFRocmVlJ1xuICAgKiAgIH1dXG4gICAqIH0pO1xuICAgKi9cbiAgZnVuY3Rpb24gUGllKHF1ZXJ5LCBkYXRhLCBvcHRpb25zLCByZXNwb25zaXZlT3B0aW9ucykge1xuICAgIENoYXJ0aXN0LlBpZS5zdXBlci5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsXG4gICAgICBxdWVyeSxcbiAgICAgIGRhdGEsXG4gICAgICBkZWZhdWx0T3B0aW9ucyxcbiAgICAgIENoYXJ0aXN0LmV4dGVuZCh7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpLFxuICAgICAgcmVzcG9uc2l2ZU9wdGlvbnMpO1xuICB9XG5cbiAgLy8gQ3JlYXRpbmcgcGllIGNoYXJ0IHR5cGUgaW4gQ2hhcnRpc3QgbmFtZXNwYWNlXG4gIENoYXJ0aXN0LlBpZSA9IENoYXJ0aXN0LkJhc2UuZXh0ZW5kKHtcbiAgICBjb25zdHJ1Y3RvcjogUGllLFxuICAgIGNyZWF0ZUNoYXJ0OiBjcmVhdGVDaGFydCxcbiAgICBkZXRlcm1pbmVBbmNob3JQb3NpdGlvbjogZGV0ZXJtaW5lQW5jaG9yUG9zaXRpb25cbiAgfSk7XG5cbn0odGhpcyB8fCBnbG9iYWwsIENoYXJ0aXN0KSk7XG5cbnJldHVybiBDaGFydGlzdDtcblxufSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZycpO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3InKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbi8vIGBBcnJheS5mcm9tYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIG1hcGZuID0gYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChPKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvciwgbmV4dCwgdmFsdWU7XG4gIGlmIChtYXBwaW5nKSBtYXBmbiA9IGJpbmQobWFwZm4sIGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAvLyBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBpdGVyYWJsZSBvciBpdCdzIGFuIGFycmF5IHdpdGggdGhlIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2UgYSBzaW1wbGUgY2FzZVxuICBpZiAoaXRlcmF0b3JNZXRob2QgIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlcmF0b3JNZXRob2QpKSkge1xuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoTywgaXRlcmF0b3JNZXRob2QpO1xuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgIHJlc3VsdCA9IG5ldyBDKCk7XG4gICAgZm9yICg7IShzdGVwID0gbmV4dC5jYWxsKGl0ZXJhdG9yKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIHZhbHVlID0gbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpdGVyYXRvckNsb3NlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlJyk7XG5cbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIEVOVFJJRVMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTtcbiAgfVxufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XG4gICAgfSxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1mcm9tLCBuby10aHJvdy1saXRlcmFsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcbiAgaWYgKCFTS0lQX0NMT1NJTkcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgSVRFUkFUSU9OX1NVUFBPUlQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgb2JqZWN0W0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiBJVEVSQVRJT05fU1VQUE9SVCA9IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4ZWMob2JqZWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG59O1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHVzaW5nSXRlcmF0b3IpIHtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBnZXRJdGVyYXRvck1ldGhvZChpdCkgOiB1c2luZ0l0ZXJhdG9yO1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yTWV0aG9kICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XG4gIH0gcmV0dXJuIGFuT2JqZWN0KGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXQpKTtcbn07XG4iLCJ2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGtpbmQsIHZhbHVlKSB7XG4gIHZhciBpbm5lclJlc3VsdCwgaW5uZXJFcnJvcjtcbiAgYW5PYmplY3QoaXRlcmF0b3IpO1xuICB0cnkge1xuICAgIGlubmVyUmVzdWx0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChpbm5lclJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlubmVyUmVzdWx0ID0gaW5uZXJSZXN1bHQuY2FsbChpdGVyYXRvcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW5uZXJFcnJvciA9IHRydWU7XG4gICAgaW5uZXJSZXN1bHQgPSBlcnJvcjtcbiAgfVxuICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gIGlmIChpbm5lckVycm9yKSB0aHJvdyBpbm5lclJlc3VsdDtcbiAgYW5PYmplY3QoaW5uZXJSZXN1bHQpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuIiwiLy8gYE1hdGguc2lnbmAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hdGguc2lnblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW1hdGgtc2lnbiAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRmaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLmZpbmQ7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMnKTtcblxudmFyIEZJTkQgPSAnZmluZCc7XG52YXIgU0tJUFNfSE9MRVMgPSB0cnVlO1xuXG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEZJTkQgaW4gW10pIEFycmF5KDEpW0ZJTkRdKGZ1bmN0aW9uICgpIHsgU0tJUFNfSE9MRVMgPSBmYWxzZTsgfSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBTS0lQU19IT0xFUyB9LCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcyhGSU5EKTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZyb20gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktZnJvbScpO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24nKTtcblxudmFyIElOQ09SUkVDVF9JVEVSQVRJT04gPSAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktZnJvbSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICBBcnJheS5mcm9tKGl0ZXJhYmxlKTtcbn0pO1xuXG4vLyBgQXJyYXkuZnJvbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cbiQoeyB0YXJnZXQ6ICdBcnJheScsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIGZyb206IGZyb21cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKTtcblxudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdzbGljZScpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xudmFyIG5hdGl2ZVNsaWNlID0gW10uc2xpY2U7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc2xpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc2xpY2Vcbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIH0sIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW5ndGgpO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gICAgLy8gaW5saW5lIGBBcnJheVNwZWNpZXNDcmVhdGVgIGZvciB1c2FnZSBuYXRpdmUgYEFycmF5I3NsaWNlYCB3aGVyZSBpdCdzIHBvc3NpYmxlXG4gICAgdmFyIENvbnN0cnVjdG9yLCByZXN1bHQsIG47XG4gICAgaWYgKGlzQXJyYXkoTykpIHtcbiAgICAgIENvbnN0cnVjdG9yID0gTy5jb25zdHJ1Y3RvcjtcbiAgICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIENvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgKENvbnN0cnVjdG9yID09PSBBcnJheSB8fCBpc0FycmF5KENvbnN0cnVjdG9yLnByb3RvdHlwZSkpKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcltTUEVDSUVTXTtcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBudWxsKSBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHwgQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlU2xpY2UuY2FsbChPLCBrLCBmaW4pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQgPSBuZXcgKENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgPyBBcnJheSA6IENvbnN0cnVjdG9yKShtYXgoZmluIC0gaywgMCkpO1xuICAgIGZvciAobiA9IDA7IGsgPCBmaW47IGsrKywgbisrKSBpZiAoayBpbiBPKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIG4sIE9ba10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0Jyk7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnc3BsaWNlJyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxRkZGRkZGRkZGRkZGRjtcbnZhciBNQVhJTVVNX0FMTE9XRURfTEVOR1RIX0VYQ0VFREVEID0gJ01heGltdW0gYWxsb3dlZCBsZW5ndGggZXhjZWVkZWQnO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnNwbGljZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zcGxpY2Vcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCB9LCB7XG4gIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCAvKiAsIC4uLml0ZW1zICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBhY3R1YWxTdGFydCA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuKTtcbiAgICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaW5zZXJ0Q291bnQsIGFjdHVhbERlbGV0ZUNvdW50LCBBLCBrLCBmcm9tLCB0bztcbiAgICBpZiAoYXJndW1lbnRzTGVuZ3RoID09PSAwKSB7XG4gICAgICBpbnNlcnRDb3VudCA9IGFjdHVhbERlbGV0ZUNvdW50ID0gMDtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c0xlbmd0aCA9PT0gMSkge1xuICAgICAgaW5zZXJ0Q291bnQgPSAwO1xuICAgICAgYWN0dWFsRGVsZXRlQ291bnQgPSBsZW4gLSBhY3R1YWxTdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zZXJ0Q291bnQgPSBhcmd1bWVudHNMZW5ndGggLSAyO1xuICAgICAgYWN0dWFsRGVsZXRlQ291bnQgPSBtaW4obWF4KHRvSW50ZWdlcihkZWxldGVDb3VudCksIDApLCBsZW4gLSBhY3R1YWxTdGFydCk7XG4gICAgfVxuICAgIGlmIChsZW4gKyBpbnNlcnRDb3VudCAtIGFjdHVhbERlbGV0ZUNvdW50ID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9MRU5HVEhfRVhDRUVERUQpO1xuICAgIH1cbiAgICBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIGFjdHVhbERlbGV0ZUNvdW50KTtcbiAgICBmb3IgKGsgPSAwOyBrIDwgYWN0dWFsRGVsZXRlQ291bnQ7IGsrKykge1xuICAgICAgZnJvbSA9IGFjdHVhbFN0YXJ0ICsgaztcbiAgICAgIGlmIChmcm9tIGluIE8pIGNyZWF0ZVByb3BlcnR5KEEsIGssIE9bZnJvbV0pO1xuICAgIH1cbiAgICBBLmxlbmd0aCA9IGFjdHVhbERlbGV0ZUNvdW50O1xuICAgIGlmIChpbnNlcnRDb3VudCA8IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICBmb3IgKGsgPSBhY3R1YWxTdGFydDsgayA8IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50OyBrKyspIHtcbiAgICAgICAgZnJvbSA9IGsgKyBhY3R1YWxEZWxldGVDb3VudDtcbiAgICAgICAgdG8gPSBrICsgaW5zZXJ0Q291bnQ7XG4gICAgICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICAgICAgZWxzZSBkZWxldGUgT1t0b107XG4gICAgICB9XG4gICAgICBmb3IgKGsgPSBsZW47IGsgPiBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGluc2VydENvdW50OyBrLS0pIGRlbGV0ZSBPW2sgLSAxXTtcbiAgICB9IGVsc2UgaWYgKGluc2VydENvdW50ID4gYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgIGZvciAoayA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50OyBrID4gYWN0dWFsU3RhcnQ7IGstLSkge1xuICAgICAgICBmcm9tID0gayArIGFjdHVhbERlbGV0ZUNvdW50IC0gMTtcbiAgICAgICAgdG8gPSBrICsgaW5zZXJ0Q291bnQgLSAxO1xuICAgICAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07XG4gICAgICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGsgPSAwOyBrIDwgaW5zZXJ0Q291bnQ7IGsrKykge1xuICAgICAgT1trICsgYWN0dWFsU3RhcnRdID0gYXJndW1lbnRzW2sgKyAyXTtcbiAgICB9XG4gICAgTy5sZW5ndGggPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGluc2VydENvdW50O1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHNpZ24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbWF0aC1zaWduJyk7XG5cbi8vIGBNYXRoLnNpZ25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnNpZ25cbiQoeyB0YXJnZXQ6ICdNYXRoJywgc3RhdDogdHJ1ZSB9LCB7XG4gIHNpZ246IHNpZ25cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcblxudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcigxKTsgfSk7XG52YXIgRk9SQ0VEID0gIURFU0NSSVBUT1JTIHx8IEZBSUxTX09OX1BSSU1JVElWRVM7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VELCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0luZGV4ZWRPYmplY3QoaXQpLCBrZXkpO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vd24ta2V5cycpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgICB2YXIga2V5cyA9IG93bktleXMoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGtleSwgZGVzY3JpcHRvcjtcbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpbmRleCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBrZXkgPSBrZXlzW2luZGV4KytdKTtcbiAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG5cbiAgVnVlLmNoYXJ0aXN0ID0gcmVxdWlyZSgnY2hhcnRpc3QnKTtcbiAgVnVlLnByb3RvdHlwZS4kY2hhcnRpc3QgPSByZXF1aXJlKCdjaGFydGlzdCcpO1xuXG4gIFZ1ZS5jb21wb25lbnQoJ0NoYXJ0aXN0Jywge1xuICAgIHByb3BzOiB7XG4gICAgICByYXRpbzoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICdjdC1zcXVhcmUnXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXJpZXM6IFtdLFxuICAgICAgICAgICAgbGFiZWxzOiBbXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHlwZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcih2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdmFsID09PSAnUGllJyB8fCB2YWwgPT09ICdMaW5lJyB8fCB2YWwgPT09ICdCYXInO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXZlbnRIYW5kbGVyczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZU9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG5vRGF0YToge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnJyxcbiAgICAgICAgICAgIGNsYXNzOiAnY3Qtbm9kYXRhJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFydDogbnVsbCxcbiAgICAgICAgbWVzc2FnZTogJydcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHdhdGNoOiB7XG4gICAgICByYXRpbzogJ3JlZHJhdycsXG4gICAgICBvcHRpb25zOiB7IGhhbmRsZXI6ICdyZWRyYXcnLCBkZWVwOiB0cnVlIH0sXG4gICAgICByZXNwb25zaXZlT3B0aW9uczogeyBoYW5kbGVyOiAncmVkcmF3JywgZGVlcDogdHJ1ZSB9LFxuICAgICAgZGF0YTogeyBoYW5kbGVyOiAncmVkcmF3JywgZGVlcDogdHJ1ZSB9LFxuICAgICAgdHlwZTogJ2RyYXcnLFxuICAgICAgZXZlbnRIYW5kbGVyczogJ3Jlc2V0RXZlbnRIYW5kbGVycycsXG4gICAgICBoYXNOb0RhdGE6IHtcbiAgICAgICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHZhbCkge1xuICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Tm9EYXRhKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLmRyYXcoKTtcbiAgICB9LFxuXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGhhc05vRGF0YTogZnVuY3Rpb24gaGFzTm9EYXRhKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGF0YSB8fCAhdGhpcy5kYXRhLnNlcmllcyB8fCB0aGlzLmRhdGEuc2VyaWVzLmxlbmd0aCA8IDEgfHwgdGhpcy50eXBlICE9PSAnUGllJyAmJiAhdGhpcy5vcHRpb25zLmRpc3RyaWJ1dGVTZXJpZXMgJiYgdGhpcy5kYXRhLnNlcmllcy5ldmVyeShmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VyaWVzKSkge1xuICAgICAgICAgICAgcmV0dXJuICFzZXJpZXMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gIXNlcmllcy5kYXRhLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgbm9EYXRhT3B0aW9uczogZnVuY3Rpb24gbm9EYXRhT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2VOb0RhdGEgfHwgdGhpcy5ub0RhdGEubWVzc2FnZSxcbiAgICAgICAgICBjbGFzczogb3B0aW9ucy5jbGFzc05vRGF0YSB8fCB0aGlzLm5vRGF0YS5jbGFzc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnJztcbiAgICAgIH0sXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KCkge1xuICAgICAgICB0aGlzLmNoYXJ0ID0gdGhpcy5oYXNOb0RhdGEgPyBudWxsIDogbmV3IHRoaXMuJGNoYXJ0aXN0W3RoaXMudHlwZV0odGhpcy4kcmVmcy5jaGFydCwgdGhpcy5kYXRhLCB0aGlzLm9wdGlvbnMsIHRoaXMucmVzcG9uc2l2ZU9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNldEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgIH0sXG4gICAgICByZWRyYXc6IGZ1bmN0aW9uIHJlZHJhdygpIHtcbiAgICAgICAgdGhpcy5jaGFydCA/IHRoaXMuY2hhcnQudXBkYXRlKHRoaXMuZGF0YSwgdGhpcy5vcHRpb25zKSA6IHRoaXMuZHJhdygpO1xuICAgICAgfSxcbiAgICAgIHJlc2V0RXZlbnRIYW5kbGVyczogZnVuY3Rpb24gcmVzZXRFdmVudEhhbmRsZXJzKGV2ZW50SGFuZGxlcnMsIG9sZEV2ZW50SGFuZGxlcikge1xuICAgICAgICBpZiAoIXRoaXMuY2hhcnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gb2xkRXZlbnRIYW5kbGVyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgdGhpcy5jaGFydC5vZmYoaXRlbS5ldmVudCwgaXRlbS5mbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBldmVudEhhbmRsZXJzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX2l0ZW0gPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICAgIHRoaXMuY2hhcnQub24oX2l0ZW0uZXZlbnQsIF9pdGVtLmZuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldEV2ZW50SGFuZGxlcnM6IGZ1bmN0aW9uIHNldEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYXJ0ICYmIHRoaXMuZXZlbnRIYW5kbGVycykge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IHRoaXMuZXZlbnRIYW5kbGVyc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgICAgICB0aGlzLmNoYXJ0Lm9uKGl0ZW0uZXZlbnQsIGl0ZW0uZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXROb0RhdGE6IGZ1bmN0aW9uIHNldE5vRGF0YSgpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5ub0RhdGFPcHRpb25zLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLm1lc3NhZ2UgfHwgdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcblxuICAgICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgICAgcmVmOiAnY2hhcnQnLFxuICAgICAgICAnY2xhc3MnOiBbdGhpcy5yYXRpbywgX2RlZmluZVByb3BlcnR5KHt9LCB0aGlzLm5vRGF0YU9wdGlvbnMuY2xhc3MsIHRoaXMuaGFzTm9EYXRhKV1cbiAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gIH0pO1xufTtcbiIsImZ1bmN0aW9uIHZhbGlkYXRlKGJpbmRpbmcpIHtcbiAgaWYgKHR5cGVvZiBiaW5kaW5nLnZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS53YXJuKCdbVnVlLWNsaWNrLW91dHNpZGU6XSBwcm92aWRlZCBleHByZXNzaW9uJywgYmluZGluZy5leHByZXNzaW9uLCAnaXMgbm90IGEgZnVuY3Rpb24uJylcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzUG9wdXAocG9wdXBJdGVtLCBlbGVtZW50cykge1xuICBpZiAoIXBvcHVwSXRlbSB8fCAhZWxlbWVudHMpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChwb3B1cEl0ZW0uY29udGFpbnMoZWxlbWVudHNbaV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudHNbaV0uY29udGFpbnMocG9wdXBJdGVtKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBpc1NlcnZlcih2Tm9kZSkge1xuICByZXR1cm4gdHlwZW9mIHZOb2RlLmNvbXBvbmVudEluc3RhbmNlICE9PSAndW5kZWZpbmVkJyAmJiB2Tm9kZS5jb21wb25lbnRJbnN0YW5jZS4kaXNTZXJ2ZXJcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBiaW5kOiBmdW5jdGlvbiAoZWwsIGJpbmRpbmcsIHZOb2RlKSB7XG4gICAgaWYgKCF2YWxpZGF0ZShiaW5kaW5nKSkgcmV0dXJuXG5cbiAgICAvLyBEZWZpbmUgSGFuZGxlciBhbmQgY2FjaGUgaXQgb24gdGhlIGVsZW1lbnRcbiAgICBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcbiAgICAgIGlmICghdk5vZGUuY29udGV4dCkgcmV0dXJuXG5cbiAgICAgIC8vIHNvbWUgY29tcG9uZW50cyBtYXkgaGF2ZSByZWxhdGVkIHBvcHVwIGl0ZW0sIG9uIHdoaWNoIHdlIHNoYWxsIHByZXZlbnQgdGhlIGNsaWNrIG91dHNpZGUgZXZlbnQgaGFuZGxlci5cbiAgICAgIHZhciBlbGVtZW50cyA9IGUucGF0aCB8fCAoZS5jb21wb3NlZFBhdGggJiYgZS5jb21wb3NlZFBhdGgoKSlcbiAgICAgIGVsZW1lbnRzICYmIGVsZW1lbnRzLmxlbmd0aCA+IDAgJiYgZWxlbWVudHMudW5zaGlmdChlLnRhcmdldClcblxuICAgICAgaWYgKGVsLmNvbnRhaW5zKGUudGFyZ2V0KSB8fCBpc1BvcHVwKHZOb2RlLmNvbnRleHQucG9wdXBJdGVtLCBlbGVtZW50cykpIHJldHVyblxuXG4gICAgICBlbC5fX3Z1ZUNsaWNrT3V0c2lkZV9fLmNhbGxiYWNrKGUpXG4gICAgfVxuXG4gICAgLy8gYWRkIEV2ZW50IExpc3RlbmVyc1xuICAgIGVsLl9fdnVlQ2xpY2tPdXRzaWRlX18gPSB7XG4gICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgY2FsbGJhY2s6IGJpbmRpbmcudmFsdWVcbiAgICB9XG4gICAgY29uc3QgY2xpY2tIYW5kbGVyID0gJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RvdWNoc3RhcnQnIDogJ2NsaWNrJztcbiAgICAhaXNTZXJ2ZXIodk5vZGUpICYmIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoY2xpY2tIYW5kbGVyLCBoYW5kbGVyKVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKGVsLCBiaW5kaW5nKSB7XG4gICAgaWYgKHZhbGlkYXRlKGJpbmRpbmcpKSBlbC5fX3Z1ZUNsaWNrT3V0c2lkZV9fLmNhbGxiYWNrID0gYmluZGluZy52YWx1ZVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gKGVsLCBiaW5kaW5nLCB2Tm9kZSkge1xuICAgIC8vIFJlbW92ZSBFdmVudCBMaXN0ZW5lcnNcbiAgICBjb25zdCBjbGlja0hhbmRsZXIgPSAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndG91Y2hzdGFydCcgOiAnY2xpY2snO1xuICAgICFpc1NlcnZlcih2Tm9kZSkgJiYgZWwuX192dWVDbGlja091dHNpZGVfXyAmJiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGNsaWNrSGFuZGxlciwgZWwuX192dWVDbGlja091dHNpZGVfXy5oYW5kbGVyKVxuICAgIGRlbGV0ZSBlbC5fX3Z1ZUNsaWNrT3V0c2lkZV9fXG4gIH1cbn1cbiIsIihmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLGUpOlwib2JqZWN0XCI9PT10eXBlb2YgZXhwb3J0cz9leHBvcnRzW1widnVlLWVsbGlwc2UtcHJvZ3Jlc3NcIl09ZSgpOnRbXCJ2dWUtZWxsaXBzZS1wcm9ncmVzc1wiXT1lKCl9KShcInVuZGVmaW5lZFwiIT09dHlwZW9mIHNlbGY/c2VsZjp0aGlzLChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgZT17fTtmdW5jdGlvbiByKG4pe2lmKGVbbl0pcmV0dXJuIGVbbl0uZXhwb3J0czt2YXIgaT1lW25dPXtpOm4sbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gdFtuXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxyKSxpLmw9ITAsaS5leHBvcnRzfXJldHVybiByLm09dCxyLmM9ZSxyLmQ9ZnVuY3Rpb24odCxlLG4pe3Iubyh0LGUpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHtlbnVtZXJhYmxlOiEwLGdldDpufSl9LHIucj1mdW5jdGlvbih0KXtcInVuZGVmaW5lZFwiIT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sci50PWZ1bmN0aW9uKHQsZSl7aWYoMSZlJiYodD1yKHQpKSw4JmUpcmV0dXJuIHQ7aWYoNCZlJiZcIm9iamVjdFwiPT09dHlwZW9mIHQmJnQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgbj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHIucihuKSxPYmplY3QuZGVmaW5lUHJvcGVydHkobixcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSksMiZlJiZcInN0cmluZ1wiIT10eXBlb2YgdClmb3IodmFyIGkgaW4gdClyLmQobixpLGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfS5iaW5kKG51bGwsaSkpO3JldHVybiBufSxyLm49ZnVuY3Rpb24odCl7dmFyIGU9dCYmdC5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHRbXCJkZWZhdWx0XCJdfTpmdW5jdGlvbigpe3JldHVybiB0fTtyZXR1cm4gci5kKGUsXCJhXCIsZSksZX0sci5vPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpfSxyLnA9XCJcIixyKHIucz1cImZiMTVcIil9KHtcIjAwZWVcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcImI2MjJcIiksaT1uKFwidG9TdHJpbmdUYWdcIiksbz17fTtvW2ldPVwielwiLHQuZXhwb3J0cz1cIltvYmplY3Qgel1cIj09PVN0cmluZyhvKX0sXCIwMWYzXCI6ZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoXCI2ZDQwXCIpLGk9ci5uKG4pO2kuYX0sXCIwMmQ0XCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCIyNGZiXCIpO2U9bighMSksZS5wdXNoKFt0LmksXCJALXdlYmtpdC1rZXlmcmFtZXMgZXAtZG90LS1pbml0X19sb29wezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSh2YXIoLS1lcC1kb3Qtc3RhcnQpKTt0cmFuc2Zvcm06cm90YXRlKHZhcigtLWVwLWRvdC1zdGFydCkpfTMzJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUodmFyKC0tZXAtZG90LTM2MCkpO3RyYW5zZm9ybTpyb3RhdGUodmFyKC0tZXAtZG90LTM2MCkpfTY2JXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUodmFyKC0tZXAtZG90LTM2MCkpO3RyYW5zZm9ybTpyb3RhdGUodmFyKC0tZXAtZG90LTM2MCkpfXRvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSh2YXIoLS1lcC1kb3QtbG9vcC1lbmQpKTt0cmFuc2Zvcm06cm90YXRlKHZhcigtLWVwLWRvdC1sb29wLWVuZCkpfX1Aa2V5ZnJhbWVzIGVwLWRvdC0taW5pdF9fbG9vcHswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUodmFyKC0tZXAtZG90LXN0YXJ0KSk7dHJhbnNmb3JtOnJvdGF0ZSh2YXIoLS1lcC1kb3Qtc3RhcnQpKX0zMyV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKHZhcigtLWVwLWRvdC0zNjApKTt0cmFuc2Zvcm06cm90YXRlKHZhcigtLWVwLWRvdC0zNjApKX02NiV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKHZhcigtLWVwLWRvdC0zNjApKTt0cmFuc2Zvcm06cm90YXRlKHZhcigtLWVwLWRvdC0zNjApKX10b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUodmFyKC0tZXAtZG90LWxvb3AtZW5kKSk7dHJhbnNmb3JtOnJvdGF0ZSh2YXIoLS1lcC1kb3QtbG9vcC1lbmQpKX19QC13ZWJraXQta2V5ZnJhbWVzIGVwLWRvdC0taW5pdF9fcmV2ZXJzZXswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUodmFyKC0tZXAtZG90LTM2MCkpO3RyYW5zZm9ybTpyb3RhdGUodmFyKC0tZXAtZG90LTM2MCkpfTUwJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUodmFyKC0tZXAtZG90LTM2MCkpO3RyYW5zZm9ybTpyb3RhdGUodmFyKC0tZXAtZG90LTM2MCkpfXRvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSh2YXIoLS1lcC1kb3QtZW5kKSk7dHJhbnNmb3JtOnJvdGF0ZSh2YXIoLS1lcC1kb3QtZW5kKSl9fUBrZXlmcmFtZXMgZXAtZG90LS1pbml0X19yZXZlcnNlezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSh2YXIoLS1lcC1kb3QtMzYwKSk7dHJhbnNmb3JtOnJvdGF0ZSh2YXIoLS1lcC1kb3QtMzYwKSl9NTAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSh2YXIoLS1lcC1kb3QtMzYwKSk7dHJhbnNmb3JtOnJvdGF0ZSh2YXIoLS1lcC1kb3QtMzYwKSl9dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKHZhcigtLWVwLWRvdC1lbmQpKTt0cmFuc2Zvcm06cm90YXRlKHZhcigtLWVwLWRvdC1lbmQpKX19QC13ZWJraXQta2V5ZnJhbWVzIGVwLWRvdC0taW5pdF9fYm91bmNlezAle29wYWNpdHk6MH05MCV7b3BhY2l0eTowfXRve29wYWNpdHk6MX19QGtleWZyYW1lcyBlcC1kb3QtLWluaXRfX2JvdW5jZXswJXtvcGFjaXR5OjB9OTAle29wYWNpdHk6MH10b3tvcGFjaXR5OjF9fUAtd2Via2l0LWtleWZyYW1lcyBlcC1kb3QtLWluaXRfX2Rpc2FibGVkezAle29wYWNpdHk6MH05MCV7b3BhY2l0eTowfXRve29wYWNpdHk6MX19QGtleWZyYW1lcyBlcC1kb3QtLWluaXRfX2Rpc2FibGVkezAle29wYWNpdHk6MH05MCV7b3BhY2l0eTowfXRve29wYWNpdHk6MX19LmVwLWNpcmNsZS0tcHJvZ3Jlc3N7LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW4tb3V0O2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbi1vdXR9LmVwLWNpcmNsZS0tcHJvZ3Jlc3MuYW5pbWF0aW9uX19kZWZhdWx0ey13ZWJraXQtYW5pbWF0aW9uLW5hbWU6ZXAtcHJvZ3Jlc3MtLWluaXRfX2RlZmF1bHQ7YW5pbWF0aW9uLW5hbWU6ZXAtcHJvZ3Jlc3MtLWluaXRfX2RlZmF1bHR9LmVwLWNpcmNsZS0tcHJvZ3Jlc3MuYW5pbWF0aW9uX19yc3std2Via2l0LWFuaW1hdGlvbi1uYW1lOmVwLXByb2dyZXNzLS1pbml0X19yczthbmltYXRpb24tbmFtZTplcC1wcm9ncmVzcy0taW5pdF9fcnN9LmVwLWNpcmNsZS0tcHJvZ3Jlc3MuYW5pbWF0aW9uX19ib3VuY2V7LXdlYmtpdC1hbmltYXRpb24tbmFtZTplcC1wcm9ncmVzcy0taW5pdF9fYm91bmNlO2FuaW1hdGlvbi1uYW1lOmVwLXByb2dyZXNzLS1pbml0X19ib3VuY2V9LmVwLWNpcmNsZS0tcHJvZ3Jlc3MuYW5pbWF0aW9uX19yZXZlcnNley13ZWJraXQtYW5pbWF0aW9uLW5hbWU6ZXAtcHJvZ3Jlc3MtLWluaXRfX3JldmVyc2U7YW5pbWF0aW9uLW5hbWU6ZXAtcHJvZ3Jlc3MtLWluaXRfX3JldmVyc2V9LmVwLWNpcmNsZS0tcHJvZ3Jlc3MuYW5pbWF0aW9uX19sb29wey13ZWJraXQtYW5pbWF0aW9uLW5hbWU6ZXAtcHJvZ3Jlc3MtLWluaXRfX2xvb3A7YW5pbWF0aW9uLW5hbWU6ZXAtcHJvZ3Jlc3MtLWluaXRfX2xvb3B9LmVwLWNpcmNsZS0tbG9hZGluZy5hbmltYXRpb25fX2xvYWRpbmd7LXdlYmtpdC1hbmltYXRpb24tbmFtZTplcC1wcm9ncmVzcy0tbG9hZGluZyxlcC1wcm9ncmVzcy0tbG9hZGluZ19fcm90YXRpb247YW5pbWF0aW9uLW5hbWU6ZXAtcHJvZ3Jlc3MtLWxvYWRpbmcsZXAtcHJvZ3Jlc3MtLWxvYWRpbmdfX3JvdGF0aW9uOy13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDppbmZpbml0ZSFpbXBvcnRhbnQ7YW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDppbmZpbml0ZSFpbXBvcnRhbnQ7LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246MnMsMXMhaW1wb3J0YW50O2FuaW1hdGlvbi1kdXJhdGlvbjoycywxcyFpbXBvcnRhbnQ7LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW4tb3V0LGxpbmVhcjthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW4tb3V0LGxpbmVhcn0uZXAtaGFsZi1jaXJjbGUtLWxvYWRpbmcuYW5pbWF0aW9uX19sb2FkaW5ney13ZWJraXQtYW5pbWF0aW9uLW5hbWU6ZXAtaGFsZi1wcm9ncmVzcy0tbG9hZGluZzthbmltYXRpb24tbmFtZTplcC1oYWxmLXByb2dyZXNzLS1sb2FkaW5nOy13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDppbmZpbml0ZSFpbXBvcnRhbnQ7YW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDppbmZpbml0ZSFpbXBvcnRhbnQ7LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246MnMhaW1wb3J0YW50O2FuaW1hdGlvbi1kdXJhdGlvbjoycyFpbXBvcnRhbnQ7LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW4tb3V0O2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbi1vdXR9LmVwLWNpcmNsZS0tZW1wdHkuZXAtY2lyY2xlLS1ub2RhdGEsLmVwLWhhbGYtY2lyY2xlLS1lbXB0eS5lcC1jaXJjbGUtLW5vZGF0YXtvcGFjaXR5Oi41fS5lcC1jaXJjbGUtLXByb2dyZXNzX19kb3QtY29udGFpbmVyey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLWluLW91dDthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW4tb3V0fS5lcC1jaXJjbGUtLXByb2dyZXNzX19kb3QtY29udGFpbmVyLmFuaW1hdGlvbl9fcnN7LXdlYmtpdC1hbmltYXRpb24tbmFtZTplcC1kb3QtLWluaXRfX3JzO2FuaW1hdGlvbi1uYW1lOmVwLWRvdC0taW5pdF9fcnN9LmVwLWNpcmNsZS0tcHJvZ3Jlc3NfX2RvdC1jb250YWluZXIuYW5pbWF0aW9uX19ib3VuY2V7LXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOmZvcndhcmRzO2FuaW1hdGlvbi1maWxsLW1vZGU6Zm9yd2FyZHM7LXdlYmtpdC1hbmltYXRpb24tbmFtZTplcC1kb3QtLWluaXRfX2Rpc2FibGVkO2FuaW1hdGlvbi1uYW1lOmVwLWRvdC0taW5pdF9fZGlzYWJsZWR9LmVwLWNpcmNsZS0tcHJvZ3Jlc3NfX2RvdC1jb250YWluZXIuYW5pbWF0aW9uX19yZXZlcnNley13ZWJraXQtYW5pbWF0aW9uLW5hbWU6ZXAtZG90LS1pbml0X19yZXZlcnNlO2FuaW1hdGlvbi1uYW1lOmVwLWRvdC0taW5pdF9fcmV2ZXJzZX0uZXAtY2lyY2xlLS1wcm9ncmVzc19fZG90LWNvbnRhaW5lci5hbmltYXRpb25fX2xvb3B7LXdlYmtpdC1hbmltYXRpb24tbmFtZTplcC1kb3QtLWluaXRfX2xvb3A7YW5pbWF0aW9uLW5hbWU6ZXAtZG90LS1pbml0X19sb29wfS5lcC1jaXJjbGUtLXByb2dyZXNzX19kb3QtY29udGFpbmVyLmVwLWhhbGYtY2lyY2xlLXByb2dyZXNzX19kb3QuYW5pbWF0aW9uX19ib3VuY2UsLmVwLWNpcmNsZS0tcHJvZ3Jlc3NfX2RvdC1jb250YWluZXIuZXAtaGFsZi1jaXJjbGUtcHJvZ3Jlc3NfX2RvdC5hbmltYXRpb25fX2xvb3B7LXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOmZvcndhcmRzO2FuaW1hdGlvbi1maWxsLW1vZGU6Zm9yd2FyZHM7LXdlYmtpdC1hbmltYXRpb24tbmFtZTplcC1kb3QtLWluaXRfX2Rpc2FibGVkO2FuaW1hdGlvbi1uYW1lOmVwLWRvdC0taW5pdF9fZGlzYWJsZWR9QC13ZWJraXQta2V5ZnJhbWVzIGVwLXByb2dyZXNzLS1pbml0X19kZWZhdWx0ezAle3N0cm9rZS1kYXNob2Zmc2V0OnZhcigtLWVwLWNpcmN1bWZlcmVuY2UpfXRve3N0cm9rZS1kYXNob2Zmc2V0OnZhcigtLWVwLXN0cm9rZS1vZmZzZXQpfX1Aa2V5ZnJhbWVzIGVwLXByb2dyZXNzLS1pbml0X19kZWZhdWx0ezAle3N0cm9rZS1kYXNob2Zmc2V0OnZhcigtLWVwLWNpcmN1bWZlcmVuY2UpfXRve3N0cm9rZS1kYXNob2Zmc2V0OnZhcigtLWVwLXN0cm9rZS1vZmZzZXQpfX1ALXdlYmtpdC1rZXlmcmFtZXMgZXAtcHJvZ3Jlc3MtLWluaXRfX3JzezAle3N0cm9rZS1kYXNob2Zmc2V0OnZhcigtLWVwLWNpcmN1bWZlcmVuY2UpfTUwJXtzdHJva2UtZGFzaG9mZnNldDowfXRve3N0cm9rZS1kYXNob2Zmc2V0OnZhcigtLWVwLXN0cm9rZS1vZmZzZXQpfX1Aa2V5ZnJhbWVzIGVwLXByb2dyZXNzLS1pbml0X19yc3swJXtzdHJva2UtZGFzaG9mZnNldDp2YXIoLS1lcC1jaXJjdW1mZXJlbmNlKX01MCV7c3Ryb2tlLWRhc2hvZmZzZXQ6MH10b3tzdHJva2UtZGFzaG9mZnNldDp2YXIoLS1lcC1zdHJva2Utb2Zmc2V0KX19QC13ZWJraXQta2V5ZnJhbWVzIGVwLXByb2dyZXNzLS1pbml0X19ib3VuY2V7MCV7LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmxpbmVhcjthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmxpbmVhcjtzdHJva2UtZGFzaG9mZnNldDp2YXIoLS1lcC1jaXJjdW1mZXJlbmNlKX0zMyV7c3Ryb2tlLWRhc2hvZmZzZXQ6dmFyKC0tZXAtYm91bmNlLW91dC1zdHJva2Utb2Zmc2V0KX02NiV7c3Ryb2tlLWRhc2hvZmZzZXQ6dmFyKC0tZXAtYm91bmNlLWluLXN0cm9rZS1vZmZzZXQpfXRve3N0cm9rZS1kYXNob2Zmc2V0OnZhcigtLWVwLXN0cm9rZS1vZmZzZXQpfX1Aa2V5ZnJhbWVzIGVwLXByb2dyZXNzLS1pbml0X19ib3VuY2V7MCV7LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmxpbmVhcjthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmxpbmVhcjtzdHJva2UtZGFzaG9mZnNldDp2YXIoLS1lcC1jaXJjdW1mZXJlbmNlKX0zMyV7c3Ryb2tlLWRhc2hvZmZzZXQ6dmFyKC0tZXAtYm91bmNlLW91dC1zdHJva2Utb2Zmc2V0KX02NiV7c3Ryb2tlLWRhc2hvZmZzZXQ6dmFyKC0tZXAtYm91bmNlLWluLXN0cm9rZS1vZmZzZXQpfXRve3N0cm9rZS1kYXNob2Zmc2V0OnZhcigtLWVwLXN0cm9rZS1vZmZzZXQpfX1ALXdlYmtpdC1rZXlmcmFtZXMgZXAtcHJvZ3Jlc3MtLWluaXRfX3JldmVyc2V7MCV7c3Ryb2tlLWRhc2hvZmZzZXQ6dmFyKC0tZXAtY2lyY3VtZmVyZW5jZSl9NTAle3N0cm9rZS1kYXNob2Zmc2V0OnZhcigtLWVwLWRvdWJsZS1jaXJjdW1mZXJlbmNlKX10b3tzdHJva2UtZGFzaG9mZnNldDp2YXIoLS1lcC1yZXZlcnNlLXN0cm9rZS1vZmZzZXQpfX1Aa2V5ZnJhbWVzIGVwLXByb2dyZXNzLS1pbml0X19yZXZlcnNlezAle3N0cm9rZS1kYXNob2Zmc2V0OnZhcigtLWVwLWNpcmN1bWZlcmVuY2UpfTUwJXtzdHJva2UtZGFzaG9mZnNldDp2YXIoLS1lcC1kb3VibGUtY2lyY3VtZmVyZW5jZSl9dG97c3Ryb2tlLWRhc2hvZmZzZXQ6dmFyKC0tZXAtcmV2ZXJzZS1zdHJva2Utb2Zmc2V0KX19QC13ZWJraXQta2V5ZnJhbWVzIGVwLXByb2dyZXNzLS1pbml0X19sb29wezAle3N0cm9rZS1kYXNob2Zmc2V0OnZhcigtLWVwLWNpcmN1bWZlcmVuY2UpfTMzJXtzdHJva2UtZGFzaG9mZnNldDowfTY2JXtzdHJva2UtZGFzaG9mZnNldDp2YXIoLS1lcC1uZWdhdGl2ZS1jaXJjdW1mZXJlbmNlKX10b3tzdHJva2UtZGFzaG9mZnNldDp2YXIoLS1lcC1sb29wLXN0cm9rZS1vZmZzZXQpfX1Aa2V5ZnJhbWVzIGVwLXByb2dyZXNzLS1pbml0X19sb29wezAle3N0cm9rZS1kYXNob2Zmc2V0OnZhcigtLWVwLWNpcmN1bWZlcmVuY2UpfTMzJXtzdHJva2UtZGFzaG9mZnNldDowfTY2JXtzdHJva2UtZGFzaG9mZnNldDp2YXIoLS1lcC1uZWdhdGl2ZS1jaXJjdW1mZXJlbmNlKX10b3tzdHJva2UtZGFzaG9mZnNldDp2YXIoLS1lcC1sb29wLXN0cm9rZS1vZmZzZXQpfX1ALXdlYmtpdC1rZXlmcmFtZXMgZXAtcHJvZ3Jlc3MtLWxvYWRpbmd7MCV7b3BhY2l0eTouNTtzdHJva2UtZGFzaG9mZnNldDp2YXIoLS1lcC1jaXJjdW1mZXJlbmNlKX01MCV7b3BhY2l0eTouODtzdHJva2UtZGFzaG9mZnNldDp2YXIoLS1lcC1sb2FkaW5nLXN0cm9rZS1vZmZzZXQpfXRve29wYWNpdHk6LjU7c3Ryb2tlLWRhc2hvZmZzZXQ6dmFyKC0tZXAtY2lyY3VtZmVyZW5jZSl9fUBrZXlmcmFtZXMgZXAtcHJvZ3Jlc3MtLWxvYWRpbmd7MCV7b3BhY2l0eTouNTtzdHJva2UtZGFzaG9mZnNldDp2YXIoLS1lcC1jaXJjdW1mZXJlbmNlKX01MCV7b3BhY2l0eTouODtzdHJva2UtZGFzaG9mZnNldDp2YXIoLS1lcC1sb2FkaW5nLXN0cm9rZS1vZmZzZXQpfXRve29wYWNpdHk6LjU7c3Ryb2tlLWRhc2hvZmZzZXQ6dmFyKC0tZXAtY2lyY3VtZmVyZW5jZSl9fUAtd2Via2l0LWtleWZyYW1lcyBlcC1oYWxmLXByb2dyZXNzLS1sb2FkaW5nezAle29wYWNpdHk6LjU7c3Ryb2tlLWRhc2hvZmZzZXQ6dmFyKC0tZXAtY2lyY3VtZmVyZW5jZSl9NTAle29wYWNpdHk6Ljg7c3Ryb2tlLWRhc2hvZmZzZXQ6MH10b3tvcGFjaXR5Oi41O3N0cm9rZS1kYXNob2Zmc2V0OnZhcigtLWVwLWNpcmN1bWZlcmVuY2UpfX1Aa2V5ZnJhbWVzIGVwLWhhbGYtcHJvZ3Jlc3MtLWxvYWRpbmd7MCV7b3BhY2l0eTouNTtzdHJva2UtZGFzaG9mZnNldDp2YXIoLS1lcC1jaXJjdW1mZXJlbmNlKX01MCV7b3BhY2l0eTouODtzdHJva2UtZGFzaG9mZnNldDowfXRve29wYWNpdHk6LjU7c3Ryb2tlLWRhc2hvZmZzZXQ6dmFyKC0tZXAtY2lyY3VtZmVyZW5jZSl9fUAtd2Via2l0LWtleWZyYW1lcyBlcC1wcm9ncmVzcy0tbG9hZGluZ19fcm90YXRpb257dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDF0dXJuKTt0cmFuc2Zvcm06cm90YXRlKDF0dXJuKX19QGtleWZyYW1lcyBlcC1wcm9ncmVzcy0tbG9hZGluZ19fcm90YXRpb257dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDF0dXJuKTt0cmFuc2Zvcm06cm90YXRlKDF0dXJuKX19QC13ZWJraXQta2V5ZnJhbWVzIGVwLWRvdC0taW5pdF9fcnN7MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKHZhcigtLWVwLWRvdC1zdGFydCkpO3RyYW5zZm9ybTpyb3RhdGUodmFyKC0tZXAtZG90LXN0YXJ0KSl9NTAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSh2YXIoLS1lcC1kb3QtMzYwKSk7dHJhbnNmb3JtOnJvdGF0ZSh2YXIoLS1lcC1kb3QtMzYwKSl9dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKHZhcigtLWVwLWRvdC1lbmQpKTt0cmFuc2Zvcm06cm90YXRlKHZhcigtLWVwLWRvdC1lbmQpKX19QGtleWZyYW1lcyBlcC1kb3QtLWluaXRfX3JzezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSh2YXIoLS1lcC1kb3Qtc3RhcnQpKTt0cmFuc2Zvcm06cm90YXRlKHZhcigtLWVwLWRvdC1zdGFydCkpfTUwJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUodmFyKC0tZXAtZG90LTM2MCkpO3RyYW5zZm9ybTpyb3RhdGUodmFyKC0tZXAtZG90LTM2MCkpfXRvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSh2YXIoLS1lcC1kb3QtZW5kKSk7dHJhbnNmb3JtOnJvdGF0ZSh2YXIoLS1lcC1kb3QtZW5kKSl9fS5lcC1zdmctY29udGFpbmVye2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtwb3NpdGlvbjphYnNvbHV0ZX0uZXAtc3ZnLWNvbnRhaW5lci5lcC1yZXZlcnNley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlWCgtMSk7dHJhbnNmb3JtOnNjYWxlWCgtMSl9Zy5lcC1jaXJjbGUtLWNvbnRhaW5lcnstd2Via2l0LXRyYW5zaXRpb246aW5oZXJpdDstby10cmFuc2l0aW9uOmluaGVyaXQ7dHJhbnNpdGlvbjppbmhlcml0Oy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjo1MCUgNTAlO3RyYW5zZm9ybS1vcmlnaW46NTAlIDUwJX1cIixcIlwiXSksdC5leHBvcnRzPWV9LFwiMDM2NlwiOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiMWMwYlwiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIpe2lmKG4odCksdm9pZCAwPT09ZSlyZXR1cm4gdDtzd2l0Y2gocil7Y2FzZSAwOnJldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmNhbGwoZSl9O2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24ocil7cmV0dXJuIHQuY2FsbChlLHIpfTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHIsbil7cmV0dXJuIHQuY2FsbChlLHIsbil9O2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24ocixuLGkpe3JldHVybiB0LmNhbGwoZSxyLG4saSl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KGUsYXJndW1lbnRzKX19fSxcIjA1NGZcIjpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cihcImEyMzFcIiksaT1yLm4obik7aS5hfSxcIjA1N2ZcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcImZjNmFcIiksaT1yKFwiMjQxY1wiKS5mLG89e30udG9TdHJpbmcsYT1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzP09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdyk6W10scz1mdW5jdGlvbih0KXt0cnl7cmV0dXJuIGkodCl9Y2F0Y2goZSl7cmV0dXJuIGEuc2xpY2UoKX19O3QuZXhwb3J0cy5mPWZ1bmN0aW9uKHQpe3JldHVybiBhJiZcIltvYmplY3QgV2luZG93XVwiPT1vLmNhbGwodCk/cyh0KTppKG4odCkpfX0sXCIwNmNmXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCI4M2FiXCIpLGk9cihcImQxZTdcIiksbz1yKFwiNWM2Y1wiKSxhPXIoXCJmYzZhXCIpLHM9cihcImMwNGVcIiksYz1yKFwiNTEzNVwiKSx1PXIoXCIwY2ZiXCIpLGY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtlLmY9bj9mOmZ1bmN0aW9uKHQsZSl7aWYodD1hKHQpLGU9cyhlLCEwKSx1KXRyeXtyZXR1cm4gZih0LGUpfWNhdGNoKHIpe31pZihjKHQsZSkpcmV0dXJuIG8oIWkuZi5jYWxsKHQsZSksdFtlXSl9fSxcIjBjZmJcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjgzYWJcIiksaT1yKFwiZDAzOVwiKSxvPXIoXCJjYzEyXCIpO3QuZXhwb3J0cz0hbiYmIWkoKGZ1bmN0aW9uKCl7cmV0dXJuIDchPU9iamVjdC5kZWZpbmVQcm9wZXJ0eShvKFwiZGl2XCIpLFwiYVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hfSkpfSwxMTQ4OmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiYTY5MVwiKSxpPXIoXCIxZDgwXCIpO3QuZXhwb3J0cz1cIlwiLnJlcGVhdHx8ZnVuY3Rpb24odCl7dmFyIGU9U3RyaW5nKGkodGhpcykpLHI9XCJcIixvPW4odCk7aWYobzwwfHxvPT0xLzApdGhyb3cgUmFuZ2VFcnJvcihcIldyb25nIG51bWJlciBvZiByZXBldGl0aW9uc1wiKTtmb3IoO28+MDsobz4+Pj0xKSYmKGUrPWUpKTEmbyYmKHIrPWUpO3JldHVybiByfX0sXCIxMWFlXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCIyNGZiXCIpO2U9bighMSksZS5wdXNoKFt0LmksXCIuZXAtY29udGFpbmVyW2RhdGEtdi01OWQ2YTc4ZF17ZGlzcGxheTppbmxpbmUtYmxvY2s7b3ZlcmZsb3c6aGlkZGVufS5lcC1jb250ZW50W2RhdGEtdi01OWQ2YTc4ZF17bWF4LXdpZHRoOmluaGVyaXQ7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyOy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDoxMDAlO3dpZHRoOjEwMCV9LmVwLWNvbnRlbnRbZGF0YS12LTU5ZDZhNzhkXSwuZXAtbGVnZW5kLS1jb250YWluZXJbZGF0YS12LTU5ZDZhNzhkXXstd2Via2l0LXRyYW5zaXRpb246aW5oZXJpdDstby10cmFuc2l0aW9uOmluaGVyaXQ7dHJhbnNpdGlvbjppbmhlcml0fS5lcC1sZWdlbmQtLWNvbnRhaW5lcltkYXRhLXYtNTlkNmE3OGRde3Bvc2l0aW9uOmFic29sdXRlO3RleHQtYWxpZ246Y2VudGVyfS5lcC1sZWdlbmQtLXZhbHVlW2RhdGEtdi01OWQ2YTc4ZF17LXdlYmtpdC10cmFuc2l0aW9uOi4zczstby10cmFuc2l0aW9uOi4zczt0cmFuc2l0aW9uOi4zczt0ZXh0LWFsaWduOmNlbnRlcjtvcGFjaXR5OjF9LmVwLWhpZGRlbltkYXRhLXYtNTlkNmE3OGRde29wYWNpdHk6MH1zdmcuZXAtc3ZnW2RhdGEtdi01OWQ2YTc4ZF17LXdlYmtpdC10cmFuc2l0aW9uOmluaGVyaXQ7LW8tdHJhbnNpdGlvbjppbmhlcml0O3RyYW5zaXRpb246aW5oZXJpdDstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46NTAlIDUwJTt0cmFuc2Zvcm0tb3JpZ2luOjUwJSA1MCV9XCIsXCJcIl0pLHQuZXhwb3J0cz1lfSwxMjc2OmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiZDc4NFwiKSxpPXIoXCI0NGU3XCIpLG89cihcIjgyNWFcIiksYT1yKFwiMWQ4MFwiKSxzPXIoXCI0ODQwXCIpLGM9cihcIjhhYTVcIiksdT1yKFwiNTBjNFwiKSxmPXIoXCIxNGMzXCIpLGw9cihcIjkyNjNcIikscD1yKFwiZDAzOVwiKSxkPVtdLnB1c2gsaD1NYXRoLm1pbix2PTQyOTQ5NjcyOTUsbT0hcCgoZnVuY3Rpb24oKXtyZXR1cm4hUmVnRXhwKHYsXCJ5XCIpfSkpO24oXCJzcGxpdFwiLDIsKGZ1bmN0aW9uKHQsZSxyKXt2YXIgbjtyZXR1cm4gbj1cImNcIj09XCJhYmJjXCIuc3BsaXQoLyhiKSovKVsxXXx8NCE9XCJ0ZXN0XCIuc3BsaXQoLyg/OikvLC0xKS5sZW5ndGh8fDIhPVwiYWJcIi5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aHx8NCE9XCIuXCIuc3BsaXQoLyguPykoLj8pLykubGVuZ3RofHxcIi5cIi5zcGxpdCgvKCkoKS8pLmxlbmd0aD4xfHxcIlwiLnNwbGl0KC8uPy8pLmxlbmd0aD9mdW5jdGlvbih0LHIpe3ZhciBuPVN0cmluZyhhKHRoaXMpKSxvPXZvaWQgMD09PXI/djpyPj4+MDtpZigwPT09bylyZXR1cm5bXTtpZih2b2lkIDA9PT10KXJldHVybltuXTtpZighaSh0KSlyZXR1cm4gZS5jYWxsKG4sdCxvKTt2YXIgcyxjLHUsZj1bXSxwPSh0Lmlnbm9yZUNhc2U/XCJpXCI6XCJcIikrKHQubXVsdGlsaW5lP1wibVwiOlwiXCIpKyh0LnVuaWNvZGU/XCJ1XCI6XCJcIikrKHQuc3RpY2t5P1wieVwiOlwiXCIpLGg9MCxtPW5ldyBSZWdFeHAodC5zb3VyY2UscCtcImdcIik7d2hpbGUocz1sLmNhbGwobSxuKSl7aWYoYz1tLmxhc3RJbmRleCxjPmgmJihmLnB1c2gobi5zbGljZShoLHMuaW5kZXgpKSxzLmxlbmd0aD4xJiZzLmluZGV4PG4ubGVuZ3RoJiZkLmFwcGx5KGYscy5zbGljZSgxKSksdT1zWzBdLmxlbmd0aCxoPWMsZi5sZW5ndGg+PW8pKWJyZWFrO20ubGFzdEluZGV4PT09cy5pbmRleCYmbS5sYXN0SW5kZXgrK31yZXR1cm4gaD09PW4ubGVuZ3RoPyF1JiZtLnRlc3QoXCJcIil8fGYucHVzaChcIlwiKTpmLnB1c2gobi5zbGljZShoKSksZi5sZW5ndGg+bz9mLnNsaWNlKDAsbyk6Zn06XCIwXCIuc3BsaXQodm9pZCAwLDApLmxlbmd0aD9mdW5jdGlvbih0LHIpe3JldHVybiB2b2lkIDA9PT10JiYwPT09cj9bXTplLmNhbGwodGhpcyx0LHIpfTplLFtmdW5jdGlvbihlLHIpe3ZhciBpPWEodGhpcyksbz12b2lkIDA9PWU/dm9pZCAwOmVbdF07cmV0dXJuIHZvaWQgMCE9PW8/by5jYWxsKGUsaSxyKTpuLmNhbGwoU3RyaW5nKGkpLGUscil9LGZ1bmN0aW9uKHQsaSl7dmFyIGE9cihuLHQsdGhpcyxpLG4hPT1lKTtpZihhLmRvbmUpcmV0dXJuIGEudmFsdWU7dmFyIGw9byh0KSxwPVN0cmluZyh0aGlzKSxkPXMobCxSZWdFeHApLGc9bC51bmljb2RlLHk9KGwuaWdub3JlQ2FzZT9cImlcIjpcIlwiKSsobC5tdWx0aWxpbmU/XCJtXCI6XCJcIikrKGwudW5pY29kZT9cInVcIjpcIlwiKSsobT9cInlcIjpcImdcIiksYj1uZXcgZChtP2w6XCJeKD86XCIrbC5zb3VyY2UrXCIpXCIseSkseD12b2lkIDA9PT1pP3Y6aT4+PjA7aWYoMD09PXgpcmV0dXJuW107aWYoMD09PXAubGVuZ3RoKXJldHVybiBudWxsPT09ZihiLHApP1twXTpbXTt2YXIgaz0wLHc9MCxfPVtdO3doaWxlKHc8cC5sZW5ndGgpe2IubGFzdEluZGV4PW0/dzowO3ZhciBTLEU9ZihiLG0/cDpwLnNsaWNlKHcpKTtpZihudWxsPT09RXx8KFM9aCh1KGIubGFzdEluZGV4KyhtPzA6dykpLHAubGVuZ3RoKSk9PT1rKXc9YyhwLHcsZyk7ZWxzZXtpZihfLnB1c2gocC5zbGljZShrLHcpKSxfLmxlbmd0aD09PXgpcmV0dXJuIF87Zm9yKHZhciBUPTE7VDw9RS5sZW5ndGgtMTtUKyspaWYoXy5wdXNoKEVbVF0pLF8ubGVuZ3RoPT09eClyZXR1cm4gXzt3PWs9U319cmV0dXJuIF8ucHVzaChwLnNsaWNlKGspKSxffV19KSwhbSl9LFwiMTI5ZlwiOmZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPU9iamVjdC5pc3x8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09PWU/MCE9PXR8fDEvdD09PTEvZTp0IT10JiZlIT1lfX0sXCIxM2Q1XCI6ZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoXCIyM2U3XCIpLGk9cihcImQ1OGZcIikubGVmdCxvPXIoXCJhNjQwXCIpLGE9cihcImFlNDBcIikscz1vKFwicmVkdWNlXCIpLGM9YShcInJlZHVjZVwiLHsxOjB9KTtuKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohc3x8IWN9LHtyZWR1Y2U6ZnVuY3Rpb24odCl7cmV0dXJuIGkodGhpcyx0LGFyZ3VtZW50cy5sZW5ndGgsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pfSxcIjE0YzNcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcImM2YjZcIiksaT1yKFwiOTI2M1wiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgcj10LmV4ZWM7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIHIpe3ZhciBvPXIuY2FsbCh0LGUpO2lmKFwib2JqZWN0XCIhPT10eXBlb2Ygbyl0aHJvdyBUeXBlRXJyb3IoXCJSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGxcIik7cmV0dXJuIG99aWYoXCJSZWdFeHBcIiE9PW4odCkpdGhyb3cgVHlwZUVycm9yKFwiUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlclwiKTtyZXR1cm4gaS5jYWxsKHQsZSl9fSxcIjE1OWJcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcImRhODRcIiksaT1yKFwiZmRiY1wiKSxvPXIoXCIxN2MyXCIpLGE9cihcIjkxMTJcIik7Zm9yKHZhciBzIGluIGkpe3ZhciBjPW5bc10sdT1jJiZjLnByb3RvdHlwZTtpZih1JiZ1LmZvckVhY2ghPT1vKXRyeXthKHUsXCJmb3JFYWNoXCIsbyl9Y2F0Y2goZil7dS5mb3JFYWNoPW99fX0sXCIxN2MyXCI6ZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoXCJiNzI3XCIpLmZvckVhY2gsaT1yKFwiYTY0MFwiKSxvPXIoXCJhZTQwXCIpLGE9aShcImZvckVhY2hcIikscz1vKFwiZm9yRWFjaFwiKTt0LmV4cG9ydHM9YSYmcz9bXS5mb3JFYWNoOmZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSxcIjE5YWFcIjpmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscil7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgVHlwZUVycm9yKFwiSW5jb3JyZWN0IFwiKyhyP3IrXCIgXCI6XCJcIikrXCJpbnZvY2F0aW9uXCIpO3JldHVybiB0fX0sXCIxYmU0XCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJkMDY2XCIpO3QuZXhwb3J0cz1uKFwiZG9jdW1lbnRcIixcImRvY3VtZW50RWxlbWVudFwiKX0sXCIxYzBiXCI6ZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKHQpK1wiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO3JldHVybiB0fX0sXCIxYzdlXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJiNjIyXCIpLGk9bihcIml0ZXJhdG9yXCIpLG89ITE7dHJ5e3ZhciBhPTAscz17bmV4dDpmdW5jdGlvbigpe3JldHVybntkb25lOiEhYSsrfX0scmV0dXJuOmZ1bmN0aW9uKCl7bz0hMH19O3NbaV09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sQXJyYXkuZnJvbShzLChmdW5jdGlvbigpe3Rocm93IDJ9KSl9Y2F0Y2goYyl7fXQuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2lmKCFlJiYhbylyZXR1cm4hMTt2YXIgcj0hMTt0cnl7dmFyIG49e307bltpXT1mdW5jdGlvbigpe3JldHVybntuZXh0OmZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6cj0hMH19fX0sdChuKX1jYXRjaChjKXt9cmV0dXJuIHJ9fSxcIjFjZGNcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjM0MmZcIik7dC5leHBvcnRzPS8oaXBob25lfGlwb2R8aXBhZCkuKmFwcGxld2Via2l0L2kudGVzdChuKX0sXCIxZDFhXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCIyNGZiXCIpO2U9bighMSksZS5wdXNoKFt0LmksXCJnLmVwLWhhbGYtY2lyY2xlW2RhdGEtdi01YjM3ZWJjM117LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjUwJSA1MCU7dHJhbnNmb3JtLW9yaWdpbjo1MCUgNTAlfVwiLFwiXCJdKSx0LmV4cG9ydHM9ZX0sXCIxZDgwXCI6ZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYodm9pZCAwPT10KXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiK3QpO3JldHVybiB0fX0sXCIxZGRlXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJkMDM5XCIpLGk9cihcImI2MjJcIiksbz1yKFwiMmQwMFwiKSxhPWkoXCJzcGVjaWVzXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gbz49NTF8fCFuKChmdW5jdGlvbigpe3ZhciBlPVtdLHI9ZS5jb25zdHJ1Y3Rvcj17fTtyZXR1cm4gclthXT1mdW5jdGlvbigpe3JldHVybntmb286MX19LDEhPT1lW3RdKEJvb2xlYW4pLmZvb30pKX19LDIyNjY6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCI4MjVhXCIpLGk9cihcImU5NWFcIiksbz1yKFwiNTBjNFwiKSxhPXIoXCIwMzY2XCIpLHM9cihcIjM1YTFcIiksYz1yKFwiOWJkZFwiKSx1PWZ1bmN0aW9uKHQsZSl7dGhpcy5zdG9wcGVkPXQsdGhpcy5yZXN1bHQ9ZX0sZj10LmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIsZixsKXt2YXIgcCxkLGgsdixtLGcseSxiPWEoZSxyLGY/MjoxKTtpZihsKXA9dDtlbHNle2lmKGQ9cyh0KSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBkKXRocm93IFR5cGVFcnJvcihcIlRhcmdldCBpcyBub3QgaXRlcmFibGVcIik7aWYoaShkKSl7Zm9yKGg9MCx2PW8odC5sZW5ndGgpO3Y+aDtoKyspaWYobT1mP2Iobih5PXRbaF0pWzBdLHlbMV0pOmIodFtoXSksbSYmbSBpbnN0YW5jZW9mIHUpcmV0dXJuIG07cmV0dXJuIG5ldyB1KCExKX1wPWQuY2FsbCh0KX1nPXAubmV4dDt3aGlsZSghKHk9Zy5jYWxsKHApKS5kb25lKWlmKG09YyhwLGIseS52YWx1ZSxmKSxcIm9iamVjdFwiPT10eXBlb2YgbSYmbSYmbSBpbnN0YW5jZW9mIHUpcmV0dXJuIG07cmV0dXJuIG5ldyB1KCExKX07Zi5zdG9wPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgdSghMCx0KX19LFwiMjNjYlwiOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiYTY5MVwiKSxpPU1hdGgubWF4LG89TWF0aC5taW47dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIHI9bih0KTtyZXR1cm4gcjwwP2kocitlLDApOm8ocixlKX19LFwiMjNlN1wiOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiZGE4NFwiKSxpPXIoXCIwNmNmXCIpLmYsbz1yKFwiOTExMlwiKSxhPXIoXCI2ZWViXCIpLHM9cihcImNlNGVcIiksYz1yKFwiZTg5M1wiKSx1PXIoXCI5NGNhXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciByLGYsbCxwLGQsaCx2PXQudGFyZ2V0LG09dC5nbG9iYWwsZz10LnN0YXQ7aWYoZj1tP246Zz9uW3ZdfHxzKHYse30pOihuW3ZdfHx7fSkucHJvdG90eXBlLGYpZm9yKGwgaW4gZSl7aWYoZD1lW2xdLHQubm9UYXJnZXRHZXQ/KGg9aShmLGwpLHA9aCYmaC52YWx1ZSk6cD1mW2xdLHI9dShtP2w6disoZz9cIi5cIjpcIiNcIikrbCx0LmZvcmNlZCksIXImJnZvaWQgMCE9PXApe2lmKHR5cGVvZiBkPT09dHlwZW9mIHApY29udGludWU7YyhkLHApfSh0LnNoYW18fHAmJnAuc2hhbSkmJm8oZCxcInNoYW1cIiwhMCksYShmLGwsZCx0KX19fSxcIjI0MWNcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcImNhODRcIiksaT1yKFwiNzgzOVwiKSxvPWkuY29uY2F0KFwibGVuZ3RoXCIsXCJwcm90b3R5cGVcIik7ZS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzfHxmdW5jdGlvbih0KXtyZXR1cm4gbih0LG8pfX0sMjQ3NDpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cihcImQwN2ZcIiksaT1yLm4obik7aS5hfSxcIjI0ZmJcIjpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbih0LGUpe3ZhciByPXRbMV18fFwiXCIsbj10WzNdO2lmKCFuKXJldHVybiByO2lmKGUmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBidG9hKXt2YXIgbz1pKG4pLGE9bi5zb3VyY2VzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChuLnNvdXJjZVJvb3R8fFwiXCIpLmNvbmNhdCh0LFwiICovXCIpfSkpO3JldHVybltyXS5jb25jYXQoYSkuY29uY2F0KFtvXSkuam9pbihcIlxcblwiKX1yZXR1cm5bcl0uam9pbihcIlxcblwiKX1mdW5jdGlvbiBpKHQpe3ZhciBlPWJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHQpKSkpLHI9XCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoZSk7cmV0dXJuXCIvKiMgXCIuY29uY2F0KHIsXCIgKi9cIil9dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlPVtdO3JldHVybiBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwKChmdW5jdGlvbihlKXt2YXIgcj1uKGUsdCk7cmV0dXJuIGVbMl0/XCJAbWVkaWEgXCIuY29uY2F0KGVbMl0sXCIge1wiKS5jb25jYXQocixcIn1cIik6cn0pKS5qb2luKFwiXCIpfSxlLmk9ZnVuY3Rpb24odCxyLG4pe1wic3RyaW5nXCI9PT10eXBlb2YgdCYmKHQ9W1tudWxsLHQsXCJcIl1dKTt2YXIgaT17fTtpZihuKWZvcih2YXIgbz0wO288dGhpcy5sZW5ndGg7bysrKXt2YXIgYT10aGlzW29dWzBdO251bGwhPWEmJihpW2FdPSEwKX1mb3IodmFyIHM9MDtzPHQubGVuZ3RoO3MrKyl7dmFyIGM9W10uY29uY2F0KHRbc10pO24mJmlbY1swXV18fChyJiYoY1syXT9jWzJdPVwiXCIuY29uY2F0KHIsXCIgYW5kIFwiKS5jb25jYXQoY1syXSk6Y1syXT1yKSxlLnB1c2goYykpfX0sZX19LDI1MzI6ZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoXCIyM2U3XCIpLGk9cihcIjVhMzRcIiksbz1yKFwiMWQ4MFwiKSxhPXIoXCJhYjEzXCIpO24oe3RhcmdldDpcIlN0cmluZ1wiLHByb3RvOiEwLGZvcmNlZDohYShcImluY2x1ZGVzXCIpfSx7aW5jbHVkZXM6ZnVuY3Rpb24odCl7cmV0dXJuISF+U3RyaW5nKG8odGhpcykpLmluZGV4T2YoaSh0KSxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSl9LFwiMjVmMFwiOmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiNmVlYlwiKSxpPXIoXCI4MjVhXCIpLG89cihcImQwMzlcIiksYT1yKFwiYWQ2ZFwiKSxzPVwidG9TdHJpbmdcIixjPVJlZ0V4cC5wcm90b3R5cGUsdT1jW3NdLGY9bygoZnVuY3Rpb24oKXtyZXR1cm5cIi9hL2JcIiE9dS5jYWxsKHtzb3VyY2U6XCJhXCIsZmxhZ3M6XCJiXCJ9KX0pKSxsPXUubmFtZSE9czsoZnx8bCkmJm4oUmVnRXhwLnByb3RvdHlwZSxzLChmdW5jdGlvbigpe3ZhciB0PWkodGhpcyksZT1TdHJpbmcodC5zb3VyY2UpLHI9dC5mbGFncyxuPVN0cmluZyh2b2lkIDA9PT1yJiZ0IGluc3RhbmNlb2YgUmVnRXhwJiYhKFwiZmxhZ3NcImluIGMpP2EuY2FsbCh0KTpyKTtyZXR1cm5cIi9cIitlK1wiL1wiK259KSx7dW5zYWZlOiEwfSl9LDI2MjY6ZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoXCJkMDY2XCIpLGk9cihcIjliZjJcIiksbz1yKFwiYjYyMlwiKSxhPXIoXCI4M2FiXCIpLHM9byhcInNwZWNpZXNcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlPW4odCkscj1pLmY7YSYmZSYmIWVbc10mJnIoZSxzLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9fSl9fSxcIjI3M2FcIjpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cihcImQzMGNcIiksaT1yLm4obik7aS5hfSxcIjI4YWJcIjpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxyPXQuX3NlbGYuX2N8fGU7cmV0dXJuIHIoXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJlcC1jb250YWluZXJcIixzdHlsZTp7d2lkdGg6dC5zaXplK1wicHhcIixoZWlnaHQ6dC5zaXplK1wicHhcIn19LFtyKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiZXAtY29udGVudFwifSxbdC5fbCh0LmNpcmNsZXNEYXRhLChmdW5jdGlvbihlLG4pe3JldHVybiByKFwiY2lyY2xlLWNvbnRhaW5lclwiLHQuX2Ioe2tleTpuLGF0dHJzOnttdWx0aXBsZTp0LmlzTXVsdGlwbGUsaW5kZXg6bixnbG9iYWxUaGlja25lc3M6dC50aGlja25lc3MsZ2xvYmFsR2FwOnQuZ2FwLGdsb2JhbERvdDp0LmRvdH19LFwiY2lyY2xlLWNvbnRhaW5lclwiLGUsITEpKX0pKSxyKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiZXAtbGVnZW5kLS1jb250YWluZXJcIixzdHlsZTp7bWF4V2lkdGg6dC5zaXplK1wicHhcIn19LFt0LmxlZ2VuZCYmIXQuaXNNdWx0aXBsZT9yKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiZXAtbGVnZW5kLS12YWx1ZVwiLGNsYXNzOlt0LmxlZ2VuZENsYXNzLHtcImVwLWhpZGRlblwiOnQuc2hvdWxkSGlkZUxlZ2VuZFZhbHVlfV0sc3R5bGU6e2ZvbnRTaXplOnQuZm9udFNpemUsY29sb3I6dC5mb250Q29sb3J9fSxbcihcImNvdW50ZXJcIix7YXR0cnM6e3ZhbHVlOnQubGVnZW5kVmFsLGFuaW1hdGlvbjp0LmFuaW1hdGlvbixsb2FkaW5nOnQubG9hZGluZ30sc2NvcGVkU2xvdHM6dC5fdShbe2tleTpcImRlZmF1bHRcIixmbjpmdW5jdGlvbihlKXt2YXIgbj1lLmNvdW50ZXJUaWNrO3JldHVyblt0LiRzY29wZWRTbG90cy5kZWZhdWx0P3QuX3QoXCJkZWZhdWx0XCIsbnVsbCx7Y291bnRlclRpY2s6bn0pOnQuX2UoKSx0LmxlZ2VuZEZvcm1hdHRlcj9yKFwic3BhblwiLFt0LmlzSFRNTD9yKFwic3BhblwiLHtkb21Qcm9wczp7aW5uZXJIVE1MOnQuX3ModC5sZWdlbmRGb3JtYXR0ZXIobikpfX0pOnIoXCJzcGFuXCIsW3QuX3YodC5fcyh0LmxlZ2VuZEZvcm1hdHRlcihuKSkpXSldKTp0LiRzY29wZWRTbG90cy5kZWZhdWx0P3QuX2UoKTpyKFwic3BhblwiLFt0Ll92KHQuX3Mobi5jdXJyZW50Rm9ybWF0dGVkVmFsdWUpKV0pXX19XSxudWxsLCEwKX0pLHQuX3QoXCJsZWdlbmQtdmFsdWVcIildLDIpOnQuX2UoKSx0Ll90KFwibGVnZW5kLWNhcHRpb25cIildLDIpXSwyKV0pfSxpPVtdO3IoXCJkODFkXCIpLHIoXCJkM2I3XCIpLHIoXCIyNWYwXCIpLHIoXCI0OThhXCIpLHIoXCJhNGQzXCIpLHIoXCI0ZGU0XCIpLHIoXCI0MTYwXCIpLHIoXCJlNDM5XCIpLHIoXCJkYmI0XCIpLHIoXCJiNjRiXCIpLHIoXCIxNTliXCIpO2Z1bmN0aW9uIG8odCxlLHIpe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6cixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09cix0fWZ1bmN0aW9uIGEodCxlKXt2YXIgcj1PYmplY3Qua2V5cyh0KTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpO2UmJihuPW4uZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGUpLmVudW1lcmFibGV9KSkpLHIucHVzaC5hcHBseShyLG4pfXJldHVybiByfWZ1bmN0aW9uIHModCl7Zm9yKHZhciBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIHI9bnVsbCE9YXJndW1lbnRzW2VdP2FyZ3VtZW50c1tlXTp7fTtlJTI/YShPYmplY3QociksITApLmZvckVhY2goKGZ1bmN0aW9uKGUpe28odCxlLHJbZV0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocikpOmEoT2JqZWN0KHIpKS5mb3JFYWNoKChmdW5jdGlvbihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocixlKSl9KSl9cmV0dXJuIHR9cihcImE5ZTNcIikscihcIjkxMjlcIik7dmFyIGM9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXQmJlwiXCIhPT10JiZudWxsIT09dCYmIU51bWJlci5pc05hTihwYXJzZUZsb2F0KHQpKX0sdT1mdW5jdGlvbih0KXtyZXR1cm4hIWModCkmJnBhcnNlRmxvYXQodCl9O3IoXCJhNjIzXCIpLHIoXCJjYWFkXCIpLHIoXCI0NWZjXCIpLHIoXCJhYzFmXCIpLHIoXCI1MzE5XCIpLHIoXCIxMjc2XCIpLHIoXCIyY2EwXCIpLHIoXCJlMDFhXCIpLHIoXCJkMjhiXCIpLHIoXCJlMjYwXCIpLHIoXCIzY2EzXCIpLHIoXCJkZGIwXCIpO2Z1bmN0aW9uIGYodCl7cmV0dXJuIGY9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0sZih0KX12YXIgbD1mdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpcInRyYW5zcGFyZW50XCI7cmV0dXJue3R5cGU6W1N0cmluZyxPYmplY3RdLHJlcXVpcmVkOiExLGRlZmF1bHQ6dCx2YWxpZGF0b3I6ZnVuY3Rpb24odCl7cmV0dXJuIShcInN0cmluZ1wiIT09dHlwZW9mIHR8fCF0KXx8IShcIm9iamVjdFwiIT09Zih0KXx8IXQuY29sb3JzKSYmdC5jb2xvcnMuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbG9yJiZ0Lm9mZnNldH0pKX19fSxwPXtkYXRhOnt0eXBlOkFycmF5LHJlcXVpcmVkOiExLGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm5bXX19LHByb2dyZXNzOnt0eXBlOk51bWJlcixyZXF1aXJlOiEwLHZhbGlkYXRvcjpmdW5jdGlvbih0KXtyZXR1cm4gdD49LTEwMCYmdDw9MTAwfX0sbGVnZW5kVmFsdWU6e3R5cGU6W051bWJlcixTdHJpbmddLHJlcXVpcmVkOiExLHZhbGlkYXRvcjpmdW5jdGlvbih0KXtyZXR1cm4hTnVtYmVyLmlzTmFOKHBhcnNlRmxvYXQodC50b1N0cmluZygpLnJlcGxhY2UoXCIsXCIsXCIuXCIpKSl9fSxzaXplOnt0eXBlOk51bWJlcixyZXF1aXJlZDohMSxkZWZhdWx0OjIwMCx2YWxpZGF0b3I6ZnVuY3Rpb24odCl7cmV0dXJuIHQ+PTB9fSx0aGlja25lc3M6e3R5cGU6W051bWJlcixTdHJpbmddLHJlcXVpcmVkOiExLGRlZmF1bHQ6XCI1JVwiLHZhbGlkYXRvcjpmdW5jdGlvbih0KXtyZXR1cm4gcGFyc2VGbG9hdCh0KT49MH19LGVtcHR5VGhpY2tuZXNzOnt0eXBlOltOdW1iZXIsU3RyaW5nXSxyZXF1aXJlZDohMSxkZWZhdWx0OlwiNSVcIix2YWxpZGF0b3I6ZnVuY3Rpb24odCl7cmV0dXJuIHBhcnNlRmxvYXQodCk+PTB9fSxsaW5lOnt0eXBlOlN0cmluZyxyZXF1aXJlZDohMSxkZWZhdWx0Olwicm91bmRcIix2YWxpZGF0b3I6ZnVuY3Rpb24odCl7cmV0dXJuW1wicm91bmRcIixcImJ1dHRcIixcInNxdWFyZVwiXS5pbmNsdWRlcyh0KX19LGxpbmVNb2RlOnt0eXBlOlN0cmluZyxyZXF1aXJlZDohMSxkZWZhdWx0Olwibm9ybWFsXCIsdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe3ZhciBlPXQuc3BsaXQoXCIgXCIpLHI9W1wibm9ybWFsXCIsXCJvdXRcIixcIm91dC1vdmVyXCIsXCJpblwiLFwiaW4tb3ZlclwiLFwidG9wXCIsXCJib3R0b21cIl0uaW5jbHVkZXMoZVswXSksbj0hZVsxXXx8IU51bWJlci5pc05hTihwYXJzZUZsb2F0KGVbMV0pKTtyZXR1cm4gciYmbn19LGNvbG9yOmwoXCIjM2Y3OWZmXCIpLGVtcHR5Q29sb3I6bChcIiNlNmU5ZjBcIiksY29sb3JGaWxsOmwoKSxlbXB0eUNvbG9yRmlsbDpsKCksZm9udFNpemU6e3R5cGU6U3RyaW5nLHJlcXVpcmVkOiExfSxmb250Q29sb3I6e3R5cGU6U3RyaW5nLHJlcXVpcmVkOiExfSxhbmltYXRpb246e3R5cGU6U3RyaW5nLHJlcXVpcmVkOiExLGRlZmF1bHQ6XCJkZWZhdWx0IDEwMDAgNDAwXCIsdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe3ZhciBlPXQuc3BsaXQoXCIgXCIpLHI9W1wiZGVmYXVsdFwiLFwicnNcIixcImxvb3BcIixcInJldmVyc2VcIixcImJvdW5jZVwiXS5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gdD09PWVbMF19KSksbj0hZVsxXXx8cGFyc2VGbG9hdChlWzFdKT49MCxpPSFlWzJdfHxwYXJzZUZsb2F0KGVbMl0pPj0wO3JldHVybiByJiZuJiZpfX0sbGVnZW5kOnt0eXBlOkJvb2xlYW4scmVxdWlyZWQ6ITEsZGVmYXVsdDohMH0sbGVnZW5kQ2xhc3M6e3R5cGU6U3RyaW5nLHJlcXVpcmVkOiExfSxhbmdsZTp7dHlwZTpbU3RyaW5nLE51bWJlcl0scmVxdWlyZWQ6ITEsZGVmYXVsdDotOTB9LGxvYWRpbmc6e3R5cGU6Qm9vbGVhbixyZXF1aXJlZDohMSxkZWZhdWx0OiExfSxub0RhdGE6e3R5cGU6Qm9vbGVhbixyZXF1aXJlZDohMSxkZWZhdWx0OiExfSxkYXNoOnt0eXBlOlN0cmluZyxyZXF1aXJlZDohMSxkZWZhdWx0OlwiXCIsdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe2lmKHQuc3RhcnRzV2l0aChcInN0cmljdFwiKSl7dmFyIGU9dC5zcGxpdChcIiBcIik7cmV0dXJuIHBhcnNlRmxvYXQoZVsxXSk+PTAmJnBhcnNlRmxvYXQoZVsyXSk+PTB9cmV0dXJuITB9fSxoYWxmOnt0eXBlOkJvb2xlYW4scmVxdWlyZWQ6ITEsZGVmYXVsdDohMX0sZ2FwOnt0eXBlOk51bWJlcixyZXF1aXJlZDohMSxkZWZhdWx0OjAsdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe3JldHVybiFOdW1iZXIuaXNOYU4ocGFyc2VJbnQodCwxMCkpfX0sZGV0ZXJtaW5hdGU6e3R5cGU6Qm9vbGVhbixyZXF1aXJlZDohMSxkZWZhdWx0OiExfSxkb3Q6e3R5cGU6W1N0cmluZyxOdW1iZXIsT2JqZWN0XSxyZXF1aXJlZDohMSxkZWZhdWx0OjAsdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe3JldHVyblwib2JqZWN0XCI9PT1mKHQpP3ZvaWQgMCE9PXQuc2l6ZSYmIU51bWJlci5pc05hTihwYXJzZUZsb2F0KHQuc2l6ZSkpOiFOdW1iZXIuaXNOYU4ocGFyc2VGbG9hdCh0KSl9fSxyZXZlcnNlOnt0eXBlOkJvb2xlYW4scmVxdWlyZWQ6ITEsZGVmYXVsdDohMX19LGQ9e307Zm9yKHZhciBoIGluIHApZFtoXT17dHlwZTpwW2hdLnR5cGUsZGVmYXVsdDpwW2hdLmRlZmF1bHR9O3ZhciB2PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQscj10Ll9zZWxmLl9jfHxlO3JldHVybiByKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwiZXAtc3ZnLWNvbnRhaW5lclwiLGNsYXNzOntcImVwLXJldmVyc2VcIjp0LnJldmVyc2V9fSxbcihcInN2Z1wiLHtzdGF0aWNDbGFzczpcImVwLXN2Z1wiLGF0dHJzOntoZWlnaHQ6dC5zaXplLHdpZHRoOnQuc2l6ZSx4bWxuczpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJ9fSxbcihcImdcIix7c3RhdGljQ2xhc3M6XCJlcC1jaXJjbGUtLWNvbnRhaW5lclwifSxbcihcImRlZnNcIixbdC5pc0NvbG9yR3JhZGllbnQ/cihcImdyYWRpZW50XCIse2F0dHJzOntjb2xvcjp0LmNvbG9yLHR5cGU6XCJwcm9ncmVzc1wiLGlkOnQuX3VpZH19KTp0Ll9lKCksdC5pc0NvbG9yRmlsbEdyYWRpZW50P3IoXCJncmFkaWVudFwiLHthdHRyczp7Y29sb3I6dC5jb2xvckZpbGwsdHlwZTpcInByb2dyZXNzLWZpbGxcIixpZDp0Ll91aWR9fSk6dC5fZSgpLHQuaXNFbXB0eUNvbG9yR3JhZGllbnQ/cihcImdyYWRpZW50XCIse2F0dHJzOntjb2xvcjp0LmVtcHR5Q29sb3IsdHlwZTpcImVtcHR5XCIsaWQ6dC5fdWlkfX0pOnQuX2UoKSx0LmlzRW1wdHlDb2xvckZpbGxHcmFkaWVudD9yKFwiZ3JhZGllbnRcIix7YXR0cnM6e2NvbG9yOnQuZW1wdHlDb2xvckZpbGwsdHlwZTpcImVtcHR5LWZpbGxcIixpZDp0Ll91aWR9fSk6dC5fZSgpXSwxKSxyKHQuY2lyY2xlVHlwZSx0Ll9iKHt0YWc6XCJjb21wb25lbnRcIixhdHRyczp7aWQ6dC5fdWlkfX0sXCJjb21wb25lbnRcIix0LiRwcm9wcywhMSkpXSwxKV0pLHQuZG90P3IoXCJjaXJjbGUtZG90XCIsdC5fYih7YXR0cnM6e2lkOnQuX3VpZH19LFwiY2lyY2xlLWRvdFwiLHQuJHByb3BzLCExKSk6dC5fZSgpXSwxKX0sbT1bXSxnPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQscj10Ll9zZWxmLl9jfHxlO3JldHVybiByKHQuZ3JhZGllbnRDb21wb25lbnQse3RhZzpcImNvbXBvbmVudFwiLGF0dHJzOntpZDpcImVwLVwiK3QudHlwZStcIi1ncmFkaWVudC1cIit0LmlkLHgxOlwiMCVcIix5MTpcIjEwMCVcIix4MjpcIjAlXCIseTI6XCIwJVwiLFwiYXJlYS1oaWRkZW5cIjpcInRydWVcIn19LHQuX2wodC5jb2xvci5jb2xvcnMsKGZ1bmN0aW9uKGUsbil7cmV0dXJuIHIoXCJzdG9wXCIse2tleTpuLGF0dHJzOntvZmZzZXQ6ZS5vZmZzZXQrXCIlXCIsXCJzdG9wLWNvbG9yXCI6XCJcIitlLmNvbG9yLFwic3RvcC1vcGFjaXR5XCI6XCJcIisodC5pc1ZhbGlkTnVtYmVyKGUub3BhY2l0eSk/ZS5vcGFjaXR5OjEpfX0pfSkpLDEpfSx5PVtdLGI9e25hbWU6XCJHcmFkaWVudFwiLHByb3BzOntjb2xvcjp7dHlwZTpPYmplY3QscmVxdWlyZWQ6ITB9LHR5cGU6e3R5cGU6U3RyaW5nLHJlcXVpcmVkOiEwfSxpZDp7dHlwZTpOdW1iZXIscmVxdWlyZWQ6ITB9fSxtZXRob2RzOntpc1ZhbGlkTnVtYmVyOmZ1bmN0aW9uKHQpe3JldHVybiBjKHQpfX0sY29tcHV0ZWQ6e2dyYWRpZW50Q29tcG9uZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29sb3IucmFkaWFsP1wicmFkaWFsR3JhZGllbnRcIjpcImxpbmVhckdyYWRpZW50XCJ9fX0seD1iO2Z1bmN0aW9uIGsodCxlLHIsbixpLG8sYSxzKXt2YXIgYyx1PVwiZnVuY3Rpb25cIj09PXR5cGVvZiB0P3Qub3B0aW9uczp0O2lmKGUmJih1LnJlbmRlcj1lLHUuc3RhdGljUmVuZGVyRm5zPXIsdS5fY29tcGlsZWQ9ITApLG4mJih1LmZ1bmN0aW9uYWw9ITApLG8mJih1Ll9zY29wZUlkPVwiZGF0YS12LVwiK28pLGE/KGM9ZnVuY3Rpb24odCl7dD10fHx0aGlzLiR2bm9kZSYmdGhpcy4kdm5vZGUuc3NyQ29udGV4dHx8dGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LiR2bm9kZSYmdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQsdHx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9ffHwodD1fX1ZVRV9TU1JfQ09OVEVYVF9fKSxpJiZpLmNhbGwodGhpcyx0KSx0JiZ0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cyYmdC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKGEpfSx1Ll9zc3JSZWdpc3Rlcj1jKTppJiYoYz1zP2Z1bmN0aW9uKCl7aS5jYWxsKHRoaXMsKHUuZnVuY3Rpb25hbD90aGlzLnBhcmVudDp0aGlzKS4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290KX06aSksYylpZih1LmZ1bmN0aW9uYWwpe3UuX2luamVjdFN0eWxlcz1jO3ZhciBmPXUucmVuZGVyO3UucmVuZGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGMuY2FsbChlKSxmKHQsZSl9fWVsc2V7dmFyIGw9dS5iZWZvcmVDcmVhdGU7dS5iZWZvcmVDcmVhdGU9bD9bXS5jb25jYXQobCxjKTpbY119cmV0dXJue2V4cG9ydHM6dCxvcHRpb25zOnV9fXZhciB3PWsoeCxnLHksITEsbnVsbCxudWxsLG51bGwpLF89dy5leHBvcnRzLFM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxyPXQuX3NlbGYuX2N8fGU7cmV0dXJuIHIoXCJnXCIse3N0YXRpY0NsYXNzOlwiZXAtaGFsZi1jaXJjbGVcIixzdHlsZTp7dHJhbnNpdGlvbkR1cmF0aW9uOnQuc3R5bGVzLnRyYW5zaXRpb25EdXJhdGlvbix0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246dC5zdHlsZXMudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uLHRyYW5zZm9ybTpcInJvdGF0ZShcIit0LmNvbXB1dGVkQW5nbGUrXCJkZWcpXCJ9fSxbcihcInBhdGhcIix7c3RhdGljQ2xhc3M6XCJlcC1oYWxmLWNpcmNsZS0tZW1wdHlcIixjbGFzczp7XCJlcC1jaXJjbGUtLW5vZGF0YVwiOiF0LmRhdGFJc0F2YWlsYWJsZX0sc3R5bGU6e3RyYW5zaXRpb25EdXJhdGlvbjp0LmFuaW1hdGlvbkR1cmF0aW9uLHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjp0LnN0eWxlcy50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb259LGF0dHJzOntcInN0cm9rZS13aWR0aFwiOnQuY29tcHV0ZWRFbXB0eVRoaWNrbmVzcyxmaWxsOnQuY29tcHV0ZWRDb2xvckZpbGwsc3Ryb2tlOnQuY29tcHV0ZWRFbXB0eUNvbG9yLGQ6dC5lbXB0eVBhdGgsXCJzdHJva2UtbGluZWNhcFwiOnQubGluZSxcInN0cm9rZS1kYXNoYXJyYXlcIjp0LmVtcHR5RGFzaGFycmF5fX0pLHIoXCJmYWRlLWluLXRyYW5zaXRpb25cIixbdC5pc0xvYWRpbmc/cihcImdcIixbcihcImdcIix7c3R5bGU6e29wYWNpdHk6XCJcIisodC5sb2FkaW5nPzE6LjQ1KX19LFtyKFwicGF0aFwiLHtzdGF0aWNDbGFzczpcImVwLWhhbGYtY2lyY2xlLS1sb2FkaW5nIGFuaW1hdGlvbl9fbG9hZGluZ1wiLHN0eWxlOnt0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246dC5zdHlsZXMudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uLHRyYW5zZm9ybU9yaWdpbjp0LnN0eWxlcy50cmFuc2Zvcm1PcmlnaW4sXCItLWVwLWxvYWRpbmctc3Ryb2tlLW9mZnNldFwiOnQuc3R5bGVzW1wiLS1lcC1sb2FkaW5nLXN0cm9rZS1vZmZzZXRcIl0sXCItLWVwLWNpcmN1bWZlcmVuY2VcIjp0LnN0eWxlc1tcIi0tZXAtY2lyY3VtZmVyZW5jZVwiXSxcIi0tZXAtbmVnYXRpdmUtY2lyY3VtZmVyZW5jZVwiOnQuc3R5bGVzW1wiLS1lcC1uZWdhdGl2ZS1jaXJjdW1mZXJlbmNlXCJdfSxhdHRyczp7XCJzdHJva2Utd2lkdGhcIjp0LmNvbXB1dGVkVGhpY2tuZXNzLGQ6dC5wYXRoLGZpbGw6dC5jb21wdXRlZENvbG9yRmlsbCxzdHJva2U6dC5jb21wdXRlZENvbG9yLFwic3Ryb2tlLWRhc2hhcnJheVwiOnQuY2lyY3VtZmVyZW5jZSxcInN0cm9rZS1saW5lY2FwXCI6dC5saW5lfX0pXSldKTp0Ll9lKCldKSxyKFwicGF0aFwiLHtzdGF0aWNDbGFzczpcImVwLWhhbGYtY2lyY2xlLS1wcm9ncmVzcyBlcC1jaXJjbGUtLXByb2dyZXNzXCIsY2xhc3M6dC5hbmltYXRpb25DbGFzcyxzdHlsZTp0LnN0eWxlcyxhdHRyczp7XCJzdHJva2Utd2lkdGhcIjp0LmNvbXB1dGVkVGhpY2tuZXNzLGQ6dC5wYXRoLGZpbGw6dC5jb21wdXRlZENvbG9yRmlsbCxzdHJva2U6dC5jb21wdXRlZENvbG9yLFwic3Ryb2tlLWRhc2hhcnJheVwiOnQuY2lyY3VtZmVyZW5jZSxcInN0cm9rZS1saW5lY2FwXCI6dC5saW5lfX0pXSwxKX0sRT1bXTtyKFwiOTlhZlwiKSxyKFwiMTNkNVwiKSxyKFwiZTZjZlwiKSxyKFwiMjUzMlwiKSxyKFwiNDc5NVwiKSxyKFwiOTZjZlwiKTtmdW5jdGlvbiBUKHQsZSxyLG4saSxvLGEpe3RyeXt2YXIgcz10W29dKGEpLGM9cy52YWx1ZX1jYXRjaCh1KXtyZXR1cm4gdm9pZCByKHUpfXMuZG9uZT9lKGMpOlByb21pc2UucmVzb2x2ZShjKS50aGVuKG4saSl9ZnVuY3Rpb24gTyh0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10aGlzLHI9YXJndW1lbnRzO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24obixpKXt2YXIgbz10LmFwcGx5KGUscik7ZnVuY3Rpb24gYSh0KXtUKG8sbixpLGEscyxcIm5leHRcIix0KX1mdW5jdGlvbiBzKHQpe1QobyxuLGksYSxzLFwidGhyb3dcIix0KX1hKHZvaWQgMCl9KSl9fXZhciBDPWZ1bmN0aW9uKHQpe3ZhciBlPXQudHJpbSgpLnNwbGl0KFwiIFwiKTtyZXR1cm57bW9kZTplWzBdLG9mZnNldDp1KGVbMV0pfHwwfX0saj1mdW5jdGlvbih0KXt2YXIgZT10LnRyaW0oKS5zcGxpdChcIiBcIik7cmV0dXJue3R5cGU6ZVswXSxkdXJhdGlvbjpjKGVbMV0pP3BhcnNlRmxvYXQoZVsxXSk6MWUzLGRlbGF5OmMoZVsyXSk/cGFyc2VGbG9hdChlWzJdKTo0MDB9fSxBPWZ1bmN0aW9uKHQpe3ZhciBlPXQudHJpbSgpLnNwbGl0KFwiIFwiKSxyPVwic3RyaWN0XCI9PT1lWzBdO3JldHVybiByP3tjb3VudDpwYXJzZUludChlWzFdLDEwKSxzcGFjaW5nOnBhcnNlRmxvYXQoZVsyXSl9OnR9LFA9ZnVuY3Rpb24odCl7dmFyIGU9MCxyPVwid2hpdGVcIixuPXt9O2lmKFwib2JqZWN0XCIhPT1mKHQpKXt2YXIgaT10LnRvU3RyaW5nKCkudHJpbSgpLnNwbGl0KFwiIFwiKTtlPWMoaVswXSk/aVswXTowLHI9aVsxXXx8XCJ3aGl0ZVwifWVsc2UgZT10LnNpemV8fDAsbj10O3JldHVybiBzKHMoe30sbikse30se3NpemU6ZSxjb2xvcjpyfSl9LFI9ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06NDAwO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7cmV0dXJuIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7cmV0dXJuIGUoKX0pLHQpfSkpfSxGPXtuYW1lOlwiQ2lyY2xlTWl4aW5cIixwcm9wczpzKHMoe30sZCkse30se211bHRpcGxlOnt0eXBlOkJvb2xlYW4scmVxdWlyZWQ6ITB9LGlkOnt0eXBlOk51bWJlcixyZXF1aXJlZDohMH0saW5kZXg6e3R5cGU6TnVtYmVyLHJlcXVpcmVkOiEwfSxnbG9iYWxUaGlja25lc3M6e3R5cGU6W051bWJlcixTdHJpbmddLHJlcXVpcmVkOiExLGRlZmF1bHQ6XCI1JVwifSxnbG9iYWxHYXA6e3R5cGU6TnVtYmVyLHJlcXVpcmVkOiExfSxnbG9iYWxEb3Q6e3R5cGU6W051bWJlcixTdHJpbmcsT2JqZWN0XSxyZXF1aXJlZDohMX19KSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue2lzSW5pdGlhbGl6ZWQ6ITF9fSxjb21wdXRlZDp7Y29tcHV0ZWRQcm9ncmVzczpmdW5jdGlvbigpe3JldHVybiBwYXJzZUZsb2F0KHRoaXMucHJvZ3Jlc3N8fDApfSxwcm9ncmVzc09mZnNldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuY2lyY3VtZmVyZW5jZS10aGlzLmNvbXB1dGVkUHJvZ3Jlc3MvMTAwKnRoaXMuY2lyY3VtZmVyZW5jZTtyZXR1cm4gTWF0aC5hYnModGhpcy5jaXJjdW1mZXJlbmNlLXQpPDE/dGhpcy5jaXJjdW1mZXJlbmNlLS41OnR9LHJhZGl1czpmdW5jdGlvbigpe3ZhciB0PXRoaXMucGFyc2VkTGluZU1vZGUub2Zmc2V0O2lmKHRoaXMubXVsdGlwbGUpcmV0dXJuIHRoaXMuYmFzZVJhZGl1cy10aGlzLnByZXZpb3VzQ2lyY2xlc1RoaWNrbmVzcztzd2l0Y2godGhpcy5wYXJzZWRMaW5lTW9kZS5tb2RlKXtjYXNlXCJub3JtYWxcIjpyZXR1cm4gdGhpcy5ub3JtYWxMaW5lTW9kZVJhZGl1cztjYXNlXCJpblwiOnJldHVybiB0aGlzLmVtcHR5UmFkaXVzLSh0aGlzLmNvbXB1dGVkRW1wdHlUaGlja25lc3MvMit0aGlzLmNvbXB1dGVkVGhpY2tuZXNzLzIrdCk7Y2FzZVwib3V0LW92ZXJcIjpyZXR1cm4gdGhpcy5jb21wdXRlZEVtcHR5VGhpY2tuZXNzPD10aGlzLmNvbXB1dGVkVGhpY2tuZXNzP3RoaXMuYmFzZVJhZGl1czp0aGlzLmVtcHR5UmFkaXVzLXRoaXMuY29tcHV0ZWRFbXB0eVRoaWNrbmVzcy8yK3RoaXMuY29tcHV0ZWRUaGlja25lc3MvMjtjYXNlXCJib3R0b21cIjpyZXR1cm4gdGhpcy5lbXB0eVJhZGl1cy10aGlzLmNvbXB1dGVkRW1wdHlUaGlja25lc3MvMjtjYXNlXCJ0b3BcIjpyZXR1cm4gdGhpcy5lbXB0eVJhZGl1cyt0aGlzLmNvbXB1dGVkRW1wdHlUaGlja25lc3MvMjtkZWZhdWx0OnJldHVybiB0aGlzLmJhc2VSYWRpdXN9fSxlbXB0eVJhZGl1czpmdW5jdGlvbigpe3ZhciB0PXRoaXMucGFyc2VkTGluZU1vZGUub2Zmc2V0O2lmKHRoaXMubXVsdGlwbGUpcmV0dXJuIHRoaXMuYmFzZVJhZGl1cy10aGlzLnByZXZpb3VzQ2lyY2xlc1RoaWNrbmVzcztzd2l0Y2godGhpcy5wYXJzZWRMaW5lTW9kZS5tb2RlKXtjYXNlXCJub3JtYWxcIjpyZXR1cm4gdGhpcy5ub3JtYWxMaW5lTW9kZVJhZGl1cztjYXNlXCJpblwiOnZhciBlPXRoaXMuY29tcHV0ZWRUaGlja25lc3MvMit0aGlzLmNvbXB1dGVkRW1wdHlUaGlja25lc3MrdDtyZXR1cm4gdGhpcy5kb3RTaXplLzI+ZT90aGlzLmVtcHR5QmFzZVJhZGl1cy0odGhpcy5kb3RTaXplLzItZSk6dGhpcy5lbXB0eUJhc2VSYWRpdXM7Y2FzZVwiaW4tb3ZlclwiOnJldHVybiB0aGlzLmRvdFRvVGhpY2tuZXNzRGlmZmVyZW5jZT4wP3RoaXMuZW1wdHlCYXNlUmFkaXVzLXRoaXMuZG90VG9UaGlja25lc3NEaWZmZXJlbmNlLzI6dGhpcy5lbXB0eUJhc2VSYWRpdXM7Y2FzZVwib3V0XCI6cmV0dXJuIHRoaXMuYmFzZVJhZGl1cy0odGhpcy5jb21wdXRlZFRoaWNrbmVzcy8yK3RoaXMuY29tcHV0ZWRFbXB0eVRoaWNrbmVzcy8yK3QpO2Nhc2VcIm91dC1vdmVyXCI6cmV0dXJuIHRoaXMuY29tcHV0ZWRFbXB0eVRoaWNrbmVzczw9dGhpcy5jb21wdXRlZFRoaWNrbmVzcz90aGlzLmJhc2VSYWRpdXMtdGhpcy5jb21wdXRlZFRoaWNrbmVzcy8yK3RoaXMuY29tcHV0ZWRFbXB0eVRoaWNrbmVzcy8yOnRoaXMuZW1wdHlCYXNlUmFkaXVzO2Nhc2VcImJvdHRvbVwiOnJldHVybiB0aGlzLmNvbXB1dGVkRW1wdHlUaGlja25lc3M8dGhpcy50aGlja25lc3NXaXRoRG90LzI/dGhpcy5lbXB0eUJhc2VSYWRpdXMtKHRoaXMudGhpY2tuZXNzV2l0aERvdC8yLXRoaXMuY29tcHV0ZWRFbXB0eVRoaWNrbmVzcyk6dGhpcy5lbXB0eUJhc2VSYWRpdXM7Y2FzZVwidG9wXCI6cmV0dXJuIHRoaXMuZW1wdHlCYXNlUmFkaXVzLXRoaXMudGhpY2tuZXNzV2l0aERvdC8yO2RlZmF1bHQ6cmV0dXJuIHRoaXMuZW1wdHlCYXNlUmFkaXVzfX0sYmFzZVJhZGl1czpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemUvMi10aGlzLnRoaWNrbmVzc1dpdGhEb3QvMn0sZW1wdHlCYXNlUmFkaXVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2l6ZS8yLXRoaXMuY29tcHV0ZWRFbXB0eVRoaWNrbmVzcy8yfSxub3JtYWxMaW5lTW9kZVJhZGl1czpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaWNrbmVzc1dpdGhEb3Q8dGhpcy5jb21wdXRlZEVtcHR5VGhpY2tuZXNzP3RoaXMuZW1wdHlCYXNlUmFkaXVzOnRoaXMuYmFzZVJhZGl1c30scGFyc2VkTGluZU1vZGU6ZnVuY3Rpb24oKXtyZXR1cm4gQyh0aGlzLmxpbmVNb2RlKX0scGFyc2VkQW5pbWF0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGoodGhpcy5hbmltYXRpb24pfSxwYXJzZWREYXNoOmZ1bmN0aW9uKCl7cmV0dXJuIEEodGhpcy5kYXNoKX0sZGF0YUlzQXZhaWxhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIGModGhpcy5jb21wdXRlZFByb2dyZXNzKSYmIXRoaXMubm9EYXRhfSxhbmltYXRpb25DbGFzczpmdW5jdGlvbigpe3JldHVybltcImFuaW1hdGlvbl9fXCIuY29uY2F0KCF0aGlzLmxvYWRpbmcmJnRoaXMuZGF0YUlzQXZhaWxhYmxlJiZ0aGlzLmlzSW5pdGlhbGl6ZWQ/dGhpcy5wYXJzZWRBbmltYXRpb24udHlwZTpcIm5vbmVcIildfSxhbmltYXRpb25EdXJhdGlvbjpmdW5jdGlvbigpe3JldHVyblwiXCIuY29uY2F0KHRoaXMucGFyc2VkQW5pbWF0aW9uLmR1cmF0aW9uLFwibXNcIil9LGNvbXB1dGVkQ29sb3I6ZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLmNvbG9yLmNvbG9ycyk/XCJ1cmwoI2VwLXByb2dyZXNzLWdyYWRpZW50LVwiLmNvbmNhdCh0aGlzLmlkLFwiKVwiKTp0aGlzLmNvbG9yfSxjb21wdXRlZEVtcHR5Q29sb3I6ZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLmVtcHR5Q29sb3IuY29sb3JzKT9cInVybCgjZXAtZW1wdHktZ3JhZGllbnQtXCIuY29uY2F0KHRoaXMuaWQsXCIpXCIpOnRoaXMuZW1wdHlDb2xvcn0sY29tcHV0ZWRDb2xvckZpbGw6ZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLmNvbG9yRmlsbC5jb2xvcnMpP1widXJsKCNlcC1wcm9ncmVzcy1maWxsLWdyYWRpZW50LVwiLmNvbmNhdCh0aGlzLmlkLFwiKVwiKTp0aGlzLmNvbG9yRmlsbH0sY29tcHV0ZWRFbXB0eUNvbG9yRmlsbDpmdW5jdGlvbigpe3JldHVybiBBcnJheS5pc0FycmF5KHRoaXMuZW1wdHlDb2xvckZpbGwuY29sb3JzKT9cInVybCgjZXAtZW1wdHktZmlsbC1ncmFkaWVudC1cIi5jb25jYXQodGhpcy5pZCxcIilcIik6dGhpcy5lbXB0eUNvbG9yRmlsbH0sY29tcHV0ZWRUaGlja25lc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jYWxjdWxhdGVUaGlja25lc3ModGhpcy50aGlja25lc3MudG9TdHJpbmcoKSl9LHRoaWNrbmVzc1dpdGhEb3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlZFRoaWNrbmVzczx0aGlzLmRvdFNpemU/dGhpcy5kb3RTaXplOnRoaXMuY29tcHV0ZWRUaGlja25lc3N9LGNvbXB1dGVkR2xvYmFsVGhpY2tuZXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2FsY3VsYXRlVGhpY2tuZXNzKHRoaXMuZ2xvYmFsVGhpY2tuZXNzKX0sY29tcHV0ZWRFbXB0eVRoaWNrbmVzczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNhbGN1bGF0ZVRoaWNrbmVzcyh0aGlzLmVtcHR5VGhpY2tuZXNzKX0sY29tcHV0ZWRBbmdsZTpmdW5jdGlvbigpe3JldHVybiBjKHRoaXMuYW5nbGUpP3RoaXMuYW5nbGU6LTkwfSx0cmFuc2Zvcm1PcmlnaW46ZnVuY3Rpb24oKXtyZXR1cm5cIjUwJSA1MCVcIn0sZW1wdHlEYXNoYXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJzZWREYXNoLmNvdW50JiZ0aGlzLnBhcnNlZERhc2guc3BhY2luZz9cIlwiLmNvbmNhdCgyKk1hdGguUEkqdGhpcy5lbXB0eVJhZGl1cyp0aGlzLmdldERhc2hQZXJjZW50KCksXCIsXFxuICAgICAgICAgICAgICBcIikuY29uY2F0KDIqTWF0aC5QSSp0aGlzLmVtcHR5UmFkaXVzKnRoaXMuZ2V0RGFzaFNwYWNpbmdQZXJjZW50KCkpLnRyaW0oKTp0aGlzLnBhcnNlZERhc2h9LHN0cm9rZURhc2hPZmZzZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhSXNBdmFpbGFibGUmJiF0aGlzLmxvYWRpbmcmJnRoaXMuaXNJbml0aWFsaXplZD90aGlzLnByb2dyZXNzT2Zmc2V0OnRoaXMuY2lyY3VtZmVyZW5jZX0scHJldmlvdXNDaXJjbGVzVGhpY2tuZXNzOmZ1bmN0aW9uKCl7aWYoMD09PXRoaXMuaW5kZXgpcmV0dXJuIDA7Zm9yKHZhciB0PWModGhpcy5nYXApP3RoaXMuZ2FwOnRoaXMuZ2xvYmFsR2FwLGU9W10scj0wO3I8dGhpcy5pbmRleDtyKyspe3ZhciBuPXRoaXMuZGF0YVtyXSxpPW4uZG90P3RoaXMuY2FsY3VsYXRlVGhpY2tuZXNzKFAobi5kb3QpLnNpemUpOnRoaXMuZ2xvYmFsRG90U2l6ZSxvPWMobi50aGlja25lc3MpP3RoaXMuY2FsY3VsYXRlVGhpY2tuZXNzKG4udGhpY2tuZXNzKTp0aGlzLmNvbXB1dGVkR2xvYmFsVGhpY2tuZXNzLGE9YyhuLmdhcCk/bi5nYXA6dGhpcy5nbG9iYWxHYXAscz1NYXRoLm1heChpLG8pO2UucHVzaChyPjA/cythOnMpfXJldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtlfSkpK3R9LHBhcnNlZERvdDpmdW5jdGlvbigpe3JldHVybiBQKHRoaXMuZG90KX0sZG90U2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNhbGN1bGF0ZVRoaWNrbmVzcyh0aGlzLnBhcnNlZERvdC5zaXplKX0sZG90Q29sb3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJzZWREb3QuY29sb3J9LGRvdFRvVGhpY2tuZXNzRGlmZmVyZW5jZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRvdFNpemUtdGhpcy5jb21wdXRlZFRoaWNrbmVzc30sZ2xvYmFsRG90U2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNhbGN1bGF0ZVRoaWNrbmVzcyhQKHRoaXMuZ2xvYmFsRG90KS5zaXplKX0sc3R5bGVzOmZ1bmN0aW9uKCl7cmV0dXJue3RyYW5zaXRpb246XCJcIi5jb25jYXQodGhpcy5hbmltYXRpb25EdXJhdGlvbixcIiwgb3BhY2l0eSAwLjNzXCIpLHN0cm9rZURhc2hvZmZzZXQ6dGhpcy5zdHJva2VEYXNoT2Zmc2V0LHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjpcImVhc2UtaW4tb3V0XCIsdHJhbnNmb3JtT3JpZ2luOnRoaXMudHJhbnNmb3JtT3JpZ2luLG9wYWNpdHk6dGhpcy5sb2FkaW5nfHwhdGhpcy5kYXRhSXNBdmFpbGFibGU/MDoxLFwiLS1lcC1jaXJjdW1mZXJlbmNlXCI6dGhpcy5jaXJjdW1mZXJlbmNlLFwiLS1lcC1uZWdhdGl2ZS1jaXJjdW1mZXJlbmNlXCI6dGhpcy5nZXROZWdhdGl2ZUNpcmN1bWZlcmVuY2UoKSxcIi0tZXAtZG91YmxlLWNpcmN1bWZlcmVuY2VcIjp0aGlzLmdldERvdWJsZUNpcmN1bWZlcmVuY2UoKSxcIi0tZXAtc3Ryb2tlLW9mZnNldFwiOnRoaXMucHJvZ3Jlc3NPZmZzZXQsXCItLWVwLWxvb3Atc3Ryb2tlLW9mZnNldFwiOnRoaXMuZ2V0TG9vcE9mZnNldCgpLFwiLS1lcC1ib3VuY2Utb3V0LXN0cm9rZS1vZmZzZXRcIjp0aGlzLmdldEJvdW5jZU91dE9mZnNldCgpLFwiLS1lcC1ib3VuY2UtaW4tc3Ryb2tlLW9mZnNldFwiOnRoaXMuZ2V0Qm91bmNlSW5PZmZzZXQoKSxcIi0tZXAtcmV2ZXJzZS1zdHJva2Utb2Zmc2V0XCI6dGhpcy5nZXRSZXZlcnNlT2Zmc2V0KCksXCItLWVwLWxvYWRpbmctc3Ryb2tlLW9mZnNldFwiOi4yKnRoaXMuY2lyY3VtZmVyZW5jZSxcImFuaW1hdGlvbi1kdXJhdGlvblwiOnRoaXMuYW5pbWF0aW9uRHVyYXRpb259fSxpc0xvYWRpbmc6ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5kZXRlcm1pbmF0ZXx8dGhpcy5sb2FkaW5nKSYmdGhpcy5kYXRhSXNBdmFpbGFibGV9fSxtZXRob2RzOntjYWxjdWxhdGVUaGlja25lc3M6ZnVuY3Rpb24odCl7dmFyIGU9cGFyc2VGbG9hdCh0KTtzd2l0Y2goITApe2Nhc2UgdC50b1N0cmluZygpLmluY2x1ZGVzKFwiJVwiKTpyZXR1cm4gZSp0aGlzLnNpemUvMTAwO2RlZmF1bHQ6cmV0dXJuIGV9fSxnZXREYXNoU3BhY2luZ1BlcmNlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJzZWREYXNoLnNwYWNpbmcvdGhpcy5wYXJzZWREYXNoLmNvdW50fSxnZXREYXNoUGVyY2VudDpmdW5jdGlvbigpe3JldHVybigxLXRoaXMucGFyc2VkRGFzaC5zcGFjaW5nKS90aGlzLnBhcnNlZERhc2guY291bnR9LGdldE5lZ2F0aXZlQ2lyY3VtZmVyZW5jZTpmdW5jdGlvbigpe3JldHVybi0xKnRoaXMuY2lyY3VtZmVyZW5jZX0sZ2V0RG91YmxlQ2lyY3VtZmVyZW5jZTpmdW5jdGlvbigpe3JldHVybiAyKnRoaXMuY2lyY3VtZmVyZW5jZX0sZ2V0TG9vcE9mZnNldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldE5lZ2F0aXZlQ2lyY3VtZmVyZW5jZSgpLSh0aGlzLmNpcmN1bWZlcmVuY2UtdGhpcy5wcm9ncmVzc09mZnNldCl9LGdldFJldmVyc2VPZmZzZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXREb3VibGVDaXJjdW1mZXJlbmNlKCkrdGhpcy5wcm9ncmVzc09mZnNldH0sZ2V0Qm91bmNlT3V0T2Zmc2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvZ3Jlc3NPZmZzZXQ8MTAwPzA6dGhpcy5wcm9ncmVzc09mZnNldC0xMDB9LGdldEJvdW5jZUluT2Zmc2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2lyY3VtZmVyZW5jZS10aGlzLnByb2dyZXNzT2Zmc2V0PDEwMD90aGlzLnByb2dyZXNzT2Zmc2V0OnRoaXMucHJvZ3Jlc3NPZmZzZXQrMTAwfX0sbW91bnRlZDpmdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIE8ocmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoKGZ1bmN0aW9uIGUoKXtyZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoKGZ1bmN0aW9uKGUpe3doaWxlKDEpc3dpdGNoKGUucHJldj1lLm5leHQpe2Nhc2UgMDppZih0LmxvYWRpbmcpe2UubmV4dD0zO2JyZWFrfXJldHVybiBlLm5leHQ9MyxSKHQucGFyc2VkQW5pbWF0aW9uLmRlbGF5KTtjYXNlIDM6dC5pc0luaXRpYWxpemVkPSEwO2Nhc2UgNDpjYXNlXCJlbmRcIjpyZXR1cm4gZS5zdG9wKCl9fSksZSl9KSkpKCl9fSxJPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQscj10Ll9zZWxmLl9jfHxlO3JldHVybiByKFwidHJhbnNpdGlvblwiLHthdHRyczp7bW9kZTpcIm91dC1pblwiLG5hbWU6XCJmYWRlXCIsYXBwZWFyOlwiXCJ9fSxbdC5fdChcImRlZmF1bHRcIildLDIpfSxOPVtdLEQ9e25hbWU6XCJGYWRlSW5UcmFuc2l0aW9uXCJ9LEw9RCxNPShyKFwiNTNjOFwiKSxrKEwsSSxOLCExLG51bGwsXCI4NzNlZjYzOFwiLG51bGwpKSx6PU0uZXhwb3J0cyxxPXtuYW1lOlwiSGFsZkNpcmNsZVByb2dyZXNzXCIsY29tcG9uZW50czp7RmFkZUluVHJhbnNpdGlvbjp6fSxtaXhpbnM6W0ZdLGNvbXB1dGVkOntjaXJjdW1mZXJlbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIDIqdGhpcy5yYWRpdXMqTWF0aC5QSS8yfSxwYXRoOmZ1bmN0aW9uKCl7cmV0dXJuXCIgTSBcIi5jb25jYXQodGhpcy5wb3NpdGlvbixcIiwgXCIpLmNvbmNhdCh0aGlzLnNpemUvMixcIiBhIFwiKS5jb25jYXQodGhpcy5yYWRpdXMsXCIsXCIpLmNvbmNhdCh0aGlzLnJhZGl1cyxcIiAwIDEsMSBcIikuY29uY2F0KDIqdGhpcy5yYWRpdXMsXCIsMFwiKX0sZW1wdHlQYXRoOmZ1bmN0aW9uKCl7cmV0dXJuXCIgTSBcIi5jb25jYXQodGhpcy5lbXB0eVBvc2l0aW9uLFwiLCBcIikuY29uY2F0KHRoaXMuc2l6ZS8yLFwiIGEgXCIpLmNvbmNhdCh0aGlzLmVtcHR5UmFkaXVzLFwiLFwiKS5jb25jYXQodGhpcy5lbXB0eVJhZGl1cyxcIiAwIDEsMSBcIikuY29uY2F0KDIqdGhpcy5lbXB0eVJhZGl1cyxcIiwwXCIpfSxwb3NpdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemUvMi10aGlzLnJhZGl1c30sZW1wdHlQb3NpdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemUvMi10aGlzLmVtcHR5UmFkaXVzfX19LFY9cSxHPShyKFwiMDU0ZlwiKSxrKFYsUyxFLCExLG51bGwsXCI1YjM3ZWJjM1wiLG51bGwpKSwkPUcuZXhwb3J0cyxCPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXQuJGNyZWF0ZUVsZW1lbnQscj10Ll9zZWxmLl9jfHxlO3JldHVybiByKFwiZ1wiLHtzdGF0aWNDbGFzczpcImVwLWNpcmNsZVwiLHN0eWxlOnt0cmFuc2l0aW9uRHVyYXRpb246dC5zdHlsZXMudHJhbnNpdGlvbkR1cmF0aW9uLHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjp0LnN0eWxlcy50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24sdHJhbnNmb3JtOlwicm90YXRlKFwiK3QuY29tcHV0ZWRBbmdsZStcImRlZylcIn19LFtyKFwiY2lyY2xlXCIse3N0YXRpY0NsYXNzOlwiZXAtY2lyY2xlLS1lbXB0eVwiLGNsYXNzOntcImVwLWNpcmNsZS0tbm9kYXRhXCI6IXQuZGF0YUlzQXZhaWxhYmxlfSxzdHlsZTp7dHJhbnNpdGlvbkR1cmF0aW9uOnQuYW5pbWF0aW9uRHVyYXRpb24sdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOnQuc3R5bGVzLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbn0sYXR0cnM6e3I6dC5lbXB0eVJhZGl1cyxjeDp0LnBvc2l0aW9uLGN5OnQucG9zaXRpb24sc3Ryb2tlOnQuY29tcHV0ZWRFbXB0eUNvbG9yLFwic3Ryb2tlLWRhc2hhcnJheVwiOnQuZW1wdHlEYXNoYXJyYXksZmlsbDp0LmNvbXB1dGVkRW1wdHlDb2xvckZpbGwsXCJzdHJva2Utd2lkdGhcIjp0LmNvbXB1dGVkRW1wdHlUaGlja25lc3N9fSkscihcImZhZGUtaW4tdHJhbnNpdGlvblwiLFt0LmlzTG9hZGluZz9yKFwiZ1wiLFtyKFwiZ1wiLHtzdGF0aWNDbGFzczpcImVwLWNpcmNsZS0tbG9hZGluZ19fY29udGFpbmVyXCIsc3R5bGU6e29wYWNpdHk6XCJcIisodC5sb2FkaW5nPzE6LjQ1KX19LFtyKFwiY2lyY2xlXCIse3N0YXRpY0NsYXNzOlwiZXAtY2lyY2xlLS1sb2FkaW5nIGFuaW1hdGlvbl9fbG9hZGluZ1wiLHN0eWxlOnt0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246dC5zdHlsZXMudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uLHRyYW5zZm9ybU9yaWdpbjp0LnN0eWxlcy50cmFuc2Zvcm1PcmlnaW4sXCItLWVwLWxvYWRpbmctc3Ryb2tlLW9mZnNldFwiOnQuc3R5bGVzW1wiLS1lcC1sb2FkaW5nLXN0cm9rZS1vZmZzZXRcIl0sXCItLWVwLWNpcmN1bWZlcmVuY2VcIjp0LnN0eWxlc1tcIi0tZXAtY2lyY3VtZmVyZW5jZVwiXX0sYXR0cnM6e3I6dC5yYWRpdXMsY3g6dC5wb3NpdGlvbixjeTp0LnBvc2l0aW9uLGZpbGw6XCJ0cmFuc3BhcmVudFwiLHN0cm9rZTp0LmNvbXB1dGVkQ29sb3IsXCJzdHJva2Utd2lkdGhcIjp0LmNvbXB1dGVkVGhpY2tuZXNzLFwic3Ryb2tlLWxpbmVjYXBcIjp0LmxpbmUsXCJzdHJva2UtZGFzaGFycmF5XCI6dC5jaXJjdW1mZXJlbmNlfX0pXSldKTp0Ll9lKCldKSxyKFwiY2lyY2xlXCIse3N0YXRpY0NsYXNzOlwiZXAtY2lyY2xlLS1wcm9ncmVzc1wiLGNsYXNzOnQuYW5pbWF0aW9uQ2xhc3Msc3R5bGU6dC5zdHlsZXMsYXR0cnM6e3I6dC5yYWRpdXMsY3g6dC5wb3NpdGlvbixjeTp0LnBvc2l0aW9uLGZpbGw6dC5jb21wdXRlZENvbG9yRmlsbCxzdHJva2U6dC5jb21wdXRlZENvbG9yLFwic3Ryb2tlLXdpZHRoXCI6dC5jb21wdXRlZFRoaWNrbmVzcyxcInN0cm9rZS1saW5lY2FwXCI6dC5saW5lLFwic3Ryb2tlLWRhc2hhcnJheVwiOnQuY2lyY3VtZmVyZW5jZX19KV0sMSl9LFU9W10sVz17bmFtZTpcIkNpcmNsZVByb2dyZXNzXCIsY29tcG9uZW50czp7RmFkZUluVHJhbnNpdGlvbjp6fSxtaXhpbnM6W0ZdLGNvbXB1dGVkOntwb3NpdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemUvMn0sY2lyY3VtZmVyZW5jZTpmdW5jdGlvbigpe3JldHVybiAyKnRoaXMucmFkaXVzKk1hdGguUEl9fX0sSD1XLFg9KHIoXCIyNzNhXCIpLGsoSCxCLFUsITEsbnVsbCxcIjdkMGEwZmJiXCIsbnVsbCkpLFk9WC5leHBvcnRzLEs9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxyPXQuX3NlbGYuX2N8fGU7cmV0dXJuIHIoXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJlcC1jaXJjbGUtLXByb2dyZXNzX19kb3QtY29udGFpbmVyXCIsY2xhc3M6dC5kb3RDb250YWluZXJDbGFzc2VzLHN0eWxlOnQuZG90Q29udGFpbmVyU3R5bGV9LFtyKFwiZGl2XCIsW3IoXCJzcGFuXCIse3N0YXRpY0NsYXNzOlwiZXAtY2lyY2xlLS1wcm9ncmVzc19fZG90XCIsY2xhc3M6e1wiZXAtaGlkZGVuXCI6dC5pc0hpZGRlbn0sc3R5bGU6dC5kb3RTdHlsZX0pXSldKX0sSj1bXSxRPXtwcm9wczpzKHt9LGQpLG5hbWU6XCJDaXJjbGVEb3RcIixtaXhpbnM6W0ZdLGNvbXB1dGVkOntkb3RDb250YWluZXJTaXplOmZ1bmN0aW9uKCl7cmV0dXJuIDIqdGhpcy5yYWRpdXMrdGhpcy5kb3RTaXplfSxkb3RDb250YWluZXJSb3RhdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzSW5pdGlhbGl6ZWQmJiF0aGlzLmxvYWRpbmcmJnRoaXMuZGF0YUlzQXZhaWxhYmxlP3RoaXMuZG90RW5kOnRoaXMuZG90U3RhcnR9LGRvdENvbnRhaW5lckZ1bGxSb3RhdGlvbkRlZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhbGY/MTgwOjM2MH0sZG90Q29udGFpbmVyU3R5bGU6ZnVuY3Rpb24oKXtyZXR1cm4gcyh7d2lkdGg6XCJcIi5jb25jYXQodGhpcy5kb3RDb250YWluZXJTaXplLFwicHhcIiksaGVpZ2h0OlwiXCIuY29uY2F0KHRoaXMuZG90Q29udGFpbmVyU2l6ZSxcInB4XCIpLHRyYW5zZm9ybTpcInJvdGF0ZShcIi5jb25jYXQodGhpcy5kb3RDb250YWluZXJSb3RhdGlvbixcImRlZylcIiksdHJhbnNpdGlvbkR1cmF0aW9uOnRoaXMubG9hZGluZ3x8IXRoaXMuZGF0YUlzQXZhaWxhYmxlP1wiMHNcIjp0aGlzLmFuaW1hdGlvbkR1cmF0aW9uLHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjpcImVhc2UtaW4tb3V0XCIsXCJhbmltYXRpb24tZHVyYXRpb25cIjp0aGlzLmFuaW1hdGlvbkR1cmF0aW9uLFwiLS1lcC1kb3Qtc3RhcnRcIjpcIlwiLmNvbmNhdCh0aGlzLmRvdFN0YXJ0LFwiZGVnXCIpLFwiLS1lcC1kb3QtZW5kXCI6XCJcIi5jb25jYXQodGhpcy5kb3RFbmQsXCJkZWdcIiksXCItLWVwLWRvdC0zNjBcIjpcIlwiLmNvbmNhdCh0aGlzLmRvdFN0YXJ0K3RoaXMuZG90Q29udGFpbmVyRnVsbFJvdGF0aW9uRGVnLFwiZGVnXCIpfSx0aGlzLmRvdENvbnRhaW5lckFuaW1hdGlvblN0eWxlKX0sZG90Q29udGFpbmVyQ2xhc3NlczpmdW5jdGlvbigpe3JldHVyblt0aGlzLmFuaW1hdGlvbkNsYXNzLCF0aGlzLmhhbGZ8fFwiZXAtaGFsZi1jaXJjbGUtcHJvZ3Jlc3NfX2RvdFwiXX0sZG90Q29udGFpbmVyQW5pbWF0aW9uU3R5bGU6ZnVuY3Rpb24oKXt2YXIgdD17bG9vcDp7b3BhY2l0eTp0aGlzLmhhbGY/MDoxLFwiLS1lcC1kb3QtbG9vcC1lbmRcIjpcIlwiLmNvbmNhdCh0aGlzLmRvdFN0YXJ0K3RoaXMuZG90Q29udGFpbmVyRnVsbFJvdGF0aW9uRGVnK3RoaXMuZG90RW5kLFwiZGVnXCIpfSxib3VuY2U6e29wYWNpdHk6MCxcImFuaW1hdGlvbi1kdXJhdGlvblwiOlwiXCIuY29uY2F0KHRoaXMucGFyc2VkQW5pbWF0aW9uLmR1cmF0aW9uKzUwMCxcIm1zXCIpfX07cmV0dXJuIHRbdGhpcy5wYXJzZWRBbmltYXRpb24udHlwZV19LGRvdFN0eWxlOmZ1bmN0aW9uKCl7cmV0dXJuIHMocyh7Ym9yZGVyUmFkaXVzOlwiXCIuY29uY2F0KHRoaXMuZG90U2l6ZS8yLFwicHhcIiksd2lkdGg6XCJcIi5jb25jYXQodGhpcy5kb3RTaXplLFwicHhcIiksYmFja2dyb3VuZENvbG9yOnRoaXMuZG90Q29sb3J9LHRoaXMuZG90KSx7fSx7dHJhbnNpdGlvbkR1cmF0aW9uOnRoaXMubG9hZGluZ3x8IXRoaXMuZGF0YUlzQXZhaWxhYmxlP1wiMHNcIjp0aGlzLmFuaW1hdGlvbkR1cmF0aW9uLGhlaWdodDpcIlwiLmNvbmNhdCh0aGlzLmRvdFNpemUsXCJweFwiKX0pfSxkb3RTdGFydDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhbGY/dGhpcy5hbmdsZS05MDp0aGlzLmFuZ2xlKzkwfSxkb3RFbmQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNhbGN1bGF0ZVByb2dyZXNzKCk7cmV0dXJuIHRoaXMuZG90U3RhcnQrdCp0aGlzLmRvdENvbnRhaW5lckZ1bGxSb3RhdGlvbkRlZy8xMDB9LGlzSGlkZGVuOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaXNJbml0aWFsaXplZHx8dGhpcy5sb2FkaW5nfHwhdGhpcy5kYXRhSXNBdmFpbGFibGV9fSxtZXRob2RzOntjYWxjdWxhdGVQcm9ncmVzczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhbGYmJnRoaXMuY29tcHV0ZWRQcm9ncmVzczwwP3RoaXMuY29tcHV0ZWRQcm9ncmVzcy0xMDA6dGhpcy5jb21wdXRlZFByb2dyZXNzfX19LFo9USx0dD0ocihcIjI0NzRcIiksayhaLEssSiwhMSxudWxsLFwiMzhjYTE2N2ZcIixudWxsKSksZXQ9dHQuZXhwb3J0cyxydD17bmFtZTpcIkVwQ2lyY2xlQ29udGFpbmVyXCIsY29tcG9uZW50czp7Q2lyY2xlRG90OmV0LENpcmNsZVByb2dyZXNzOlksSGFsZkNpcmNsZVByb2dyZXNzOiQsR3JhZGllbnQ6X30scHJvcHM6cyhzKHt9LGQpLHt9LHtpbmRleDp7dHlwZTpOdW1iZXIscmVxdWlyZWQ6ITB9LG11bHRpcGxlOnt0eXBlOkJvb2xlYW4scmVxdWlyZWQ6ITB9LGdsb2JhbFRoaWNrbmVzczp7dHlwZTpbTnVtYmVyLFN0cmluZ10scmVxdWlyZWQ6ITEsZGVmYXVsdDpcIjUlXCJ9LGdsb2JhbEdhcDp7dHlwZTpOdW1iZXIscmVxdWlyZWQ6ITF9LGdsb2JhbERvdDp7dHlwZTpbTnVtYmVyLFN0cmluZyxPYmplY3RdLHJlcXVpcmVkOiExfX0pLGNvbXB1dGVkOntjaXJjbGVUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFsZj9cImhhbGYtY2lyY2xlLXByb2dyZXNzXCI6XCJjaXJjbGUtcHJvZ3Jlc3NcIn0saXNDb2xvckdyYWRpZW50OmZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5jb2xvci5jb2xvcnMpfSxpc0NvbG9yRmlsbEdyYWRpZW50OmZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5jb2xvckZpbGwuY29sb3JzKX0saXNFbXB0eUNvbG9yR3JhZGllbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLmVtcHR5Q29sb3IuY29sb3JzKX0saXNFbXB0eUNvbG9yRmlsbEdyYWRpZW50OmZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5lbXB0eUNvbG9yRmlsbC5jb2xvcnMpfX19LG50PXJ0LGl0PShyKFwiYzQ5ZVwiKSxrKG50LHYsbSwhMSxudWxsLG51bGwsbnVsbCkpLG90PWl0LmV4cG9ydHMsYXQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dC4kY3JlYXRlRWxlbWVudCxyPXQuX3NlbGYuX2N8fGU7cmV0dXJuIHIoXCJzcGFuXCIse3N0YXRpY0NsYXNzOlwiZXAtbGVnZW5kLS12YWx1ZV9fY291bnRlclwifSxbdC5fdChcImRlZmF1bHRcIixudWxsLHtjb3VudGVyVGljazp0LmNvdW50ZXJQcm9wc30pLHQuJHNjb3BlZFNsb3RzLmRlZmF1bHQ/dC5fZSgpOnIoXCJzcGFuXCIsW3QuX3YodC5fcyh0LmZvcm1hdHRlZFZhbHVlKSldKV0sMil9LHN0PVtdLGN0PShyKFwiYjY4MFwiKSxyKFwiODQxY1wiKSx7bmFtZTpcIkNvdW50ZXJcIixwcm9wczp7dmFsdWU6e3R5cGU6W051bWJlcixTdHJpbmddLHJlcXVpcmVkOiEwfSxhbmltYXRpb246e3R5cGU6U3RyaW5nLHJlcXVpcmVkOiEwfSxsb2FkaW5nOnt0eXBlOkJvb2xlYW4scmVxdWlyZWQ6ITB9fSxkYXRhOmZ1bmN0aW9uKCl7cmV0dXJue3N0YXJ0OjAsc3RhcnRUaW1lOjAsY3VycmVudFZhbHVlOjAscmFmOm51bGwscHJldmlvdXNDb3VudFN0ZXBWYWx1ZTowfX0sd2F0Y2g6e3ZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zdGFydD10aGlzLmN1cnJlbnRWYWx1ZSx0aGlzLnJlc2V0KCksdGhpcy5yYWY9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuY291bnQpfX0sY29tcHV0ZWQ6e2VuZDpmdW5jdGlvbigpe3JldHVybiBwYXJzZUZsb2F0KHRoaXMudmFsdWUudG9TdHJpbmcoKS5yZXBsYWNlKFwiLFwiLFwiLlwiKSl9LGRpZmZlcmVuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5hYnModGhpcy5lbmQtdGhpcy5zdGFydCl9LG9uZVN0ZXBEaWZmZXJlbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmR1cmF0aW9uP3RoaXMuZGlmZmVyZW5jZTp0aGlzLmRpZmZlcmVuY2UvdGhpcy5kdXJhdGlvbn0sZGVsaW1pdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWUudG9TdHJpbmcoKS5zZWFyY2goXCIsXCIpPj0wP1wiLFwiOlwiLlwifSxmb3JtYXR0ZWRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmN1cnJlbnRWYWx1ZS50b0ZpeGVkKHRoaXMuY291bnREZWNpbWFscygpKS5yZXBsYWNlKFwiLlwiLHRoaXMuZGVsaW1pdGVyKX0sZGVsYXk6ZnVuY3Rpb24oKXtyZXR1cm4gaih0aGlzLmFuaW1hdGlvbikuZGVsYXl9LGR1cmF0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGoodGhpcy5hbmltYXRpb24pLmR1cmF0aW9ufSxjb3VudGVyUHJvcHM6ZnVuY3Rpb24oKXtyZXR1cm57Y3VycmVudFZhbHVlOnBhcnNlRmxvYXQodGhpcy5mb3JtYXR0ZWRWYWx1ZSksY3VycmVudEZvcm1hdHRlZFZhbHVlOnRoaXMuZm9ybWF0dGVkVmFsdWUsY3VycmVudFJhd1ZhbHVlOnRoaXMuY3VycmVudFZhbHVlLGR1cmF0aW9uOnRoaXMuZHVyYXRpb24scHJldmlvdXNDb3VudFN0ZXBWYWx1ZTp0aGlzLnByZXZpb3VzQ291bnRTdGVwVmFsdWUsc3RhcnQ6dGhpcy5zdGFydCxlbmQ6dGhpcy5lbmQsZGlmZmVyZW5jZTp0aGlzLmRpZmZlcmVuY2Usb25lU3RlcERpZmZlcmVuY2U6dGhpcy5vbmVTdGVwRGlmZmVyZW5jZSxzdGFydFRpbWU6dGhpcy5zdGFydFRpbWUsZWxhcHNlZDowfX19LG1ldGhvZHM6e2NvdW50RGVjaW1hbHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZSUxPT09MD8wOnRoaXMudmFsdWUudG9TdHJpbmcoKS5zcGxpdCh0aGlzLmRlbGltaXRlcilbMV0ubGVuZ3RofSxjb3VudDpmdW5jdGlvbih0KXt0aGlzLnN0YXJ0VGltZXx8KHRoaXMuc3RhcnRUaW1lPXQpO3ZhciBlPXQtdGhpcy5zdGFydFRpbWU7dGhpcy5lbmQ+PXRoaXMuc3RhcnQ/dGhpcy5jb3VudFVwKGUpOnRoaXMuY291bnREb3duKGUpLGU8dGhpcy5kdXJhdGlvbiYmdGhpcy5kaWZmZXJlbmNlPi4xJiYoY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWYpLHRoaXMucmFmPXJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmNvdW50KSksZT49dGhpcy5kdXJhdGlvbiYmKHRoaXMuY3VycmVudFZhbHVlPXRoaXMuZW5kLHRoaXMucmVzZXQoKSl9LGNvdW50RG93bjpmdW5jdGlvbih0KXt2YXIgZT1NYXRoLm1pbih0aGlzLm9uZVN0ZXBEaWZmZXJlbmNlKih0fHwxKSx0aGlzLmRpZmZlcmVuY2UpO3RoaXMuY3VycmVudFZhbHVlLT1lLXRoaXMucHJldmlvdXNDb3VudFN0ZXBWYWx1ZSx0aGlzLnByZXZpb3VzQ291bnRTdGVwVmFsdWU9ZX0sY291bnRVcDpmdW5jdGlvbih0KXt2YXIgZT1NYXRoLm1pbih0aGlzLm9uZVN0ZXBEaWZmZXJlbmNlKih0fHwxKSx0aGlzLmRpZmZlcmVuY2UpO3RoaXMuY3VycmVudFZhbHVlKz1lLXRoaXMucHJldmlvdXNDb3VudFN0ZXBWYWx1ZSx0aGlzLnByZXZpb3VzQ291bnRTdGVwVmFsdWU9ZX0scmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLnN0YXJ0VGltZT0wLHRoaXMucHJldmlvdXNDb3VudFN0ZXBWYWx1ZT0wLGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmKX19LG1vdW50ZWQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMubG9hZGluZz90aGlzLnJhZj1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5jb3VudCk6c2V0VGltZW91dCgoZnVuY3Rpb24oKXt0LnJhZj1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodC5jb3VudCl9KSx0aGlzLmRlbGF5KX19KSx1dD1jdCxmdD1rKHV0LGF0LHN0LCExLG51bGwsbnVsbCxudWxsKSxsdD1mdC5leHBvcnRzLHB0PXtuYW1lOlwiVnVlRWxsaXBzZVByb2dyZXNzXCIsY29tcG9uZW50czp7Q291bnRlcjpsdCxDaXJjbGVDb250YWluZXI6b3R9LHByb3BzOnMocyh7fSxwKSx7fSx7bGVnZW5kRm9ybWF0dGVyOnt0eXBlOkZ1bmN0aW9uLHJlcXVpcmVkOiExfX0pLGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57Y291bnRlclRpY2s6e319fSxjb21wdXRlZDp7bGVnZW5kVmFsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubG9hZGluZ3x8dGhpcy5ub0RhdGE/MDp0aGlzLmxlZ2VuZFZhbHVlP3RoaXMubGVnZW5kVmFsdWU6dSh0aGlzLnByb2dyZXNzKXx8MH0sc2hvdWxkSGlkZUxlZ2VuZFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaXNEYXRhQXZhaWxhYmxlfHx0aGlzLmxvYWRpbmd9LGlzRGF0YUF2YWlsYWJsZTpmdW5jdGlvbigpe3JldHVybiBjKHRoaXMucHJvZ3Jlc3MpJiYhdGhpcy5ub0RhdGF9LGlzTXVsdGlwbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhLmxlbmd0aD4xfSxpc0hUTUw6ZnVuY3Rpb24oKXtyZXR1cm4vPFthLXovXVtcXHNcXFNdKj4vaS50ZXN0KHRoaXMubGVnZW5kRm9ybWF0dGVyKHtjdXJyZW50VmFsdWU6MH0pLnRvU3RyaW5nKCkudHJpbSgpKX0sY2lyY2xlc0RhdGE6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiB0aGlzLmlzTXVsdGlwbGU/dGhpcy5kYXRhLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHMocyhzKHt9LHQuJHByb3BzKSxlKSx7fSx7ZW1wdHlUaGlja25lc3M6YyhlLnRoaWNrbmVzcyk/ZS50aGlja25lc3M6dC4kcHJvcHMudGhpY2tuZXNzfSl9KSk6W3RoaXMuJHByb3BzXX19fSxkdD1wdCxodD0ocihcIjAxZjNcIiksayhkdCxuLGksITEsbnVsbCxcIjU5ZDZhNzhkXCIsbnVsbCkpO2VbXCJhXCJdPWh0LmV4cG9ydHN9LFwiMmNhMFwiOmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiMjNlN1wiKSxpPXIoXCIwNmNmXCIpLmYsbz1yKFwiNTBjNFwiKSxhPXIoXCI1YTM0XCIpLHM9cihcIjFkODBcIiksYz1yKFwiYWIxM1wiKSx1PXIoXCJjNDMwXCIpLGY9XCJcIi5zdGFydHNXaXRoLGw9TWF0aC5taW4scD1jKFwic3RhcnRzV2l0aFwiKSxkPSF1JiYhcCYmISFmdW5jdGlvbigpe3ZhciB0PWkoU3RyaW5nLnByb3RvdHlwZSxcInN0YXJ0c1dpdGhcIik7cmV0dXJuIHQmJiF0LndyaXRhYmxlfSgpO24oe3RhcmdldDpcIlN0cmluZ1wiLHByb3RvOiEwLGZvcmNlZDohZCYmIXB9LHtzdGFydHNXaXRoOmZ1bmN0aW9uKHQpe3ZhciBlPVN0cmluZyhzKHRoaXMpKTthKHQpO3ZhciByPW8obChhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCxlLmxlbmd0aCkpLG49U3RyaW5nKHQpO3JldHVybiBmP2YuY2FsbChlLG4scik6ZS5zbGljZShyLHIrbi5sZW5ndGgpPT09bn19KX0sXCIyY2Y0XCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuLGksbyxhPXIoXCJkYTg0XCIpLHM9cihcImQwMzlcIiksYz1yKFwiYzZiNlwiKSx1PXIoXCIwMzY2XCIpLGY9cihcIjFiZTRcIiksbD1yKFwiY2MxMlwiKSxwPXIoXCIxY2RjXCIpLGQ9YS5sb2NhdGlvbixoPWEuc2V0SW1tZWRpYXRlLHY9YS5jbGVhckltbWVkaWF0ZSxtPWEucHJvY2VzcyxnPWEuTWVzc2FnZUNoYW5uZWwseT1hLkRpc3BhdGNoLGI9MCx4PXt9LGs9XCJvbnJlYWR5c3RhdGVjaGFuZ2VcIix3PWZ1bmN0aW9uKHQpe2lmKHguaGFzT3duUHJvcGVydHkodCkpe3ZhciBlPXhbdF07ZGVsZXRlIHhbdF0sZSgpfX0sXz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt3KHQpfX0sUz1mdW5jdGlvbih0KXt3KHQuZGF0YSl9LEU9ZnVuY3Rpb24odCl7YS5wb3N0TWVzc2FnZSh0K1wiXCIsZC5wcm90b2NvbCtcIi8vXCIrZC5ob3N0KX07aCYmdnx8KGg9ZnVuY3Rpb24odCl7dmFyIGU9W10scj0xO3doaWxlKGFyZ3VtZW50cy5sZW5ndGg+cillLnB1c2goYXJndW1lbnRzW3IrK10pO3JldHVybiB4WysrYl09ZnVuY3Rpb24oKXsoXCJmdW5jdGlvblwiPT10eXBlb2YgdD90OkZ1bmN0aW9uKHQpKS5hcHBseSh2b2lkIDAsZSl9LG4oYiksYn0sdj1mdW5jdGlvbih0KXtkZWxldGUgeFt0XX0sXCJwcm9jZXNzXCI9PWMobSk/bj1mdW5jdGlvbih0KXttLm5leHRUaWNrKF8odCkpfTp5JiZ5Lm5vdz9uPWZ1bmN0aW9uKHQpe3kubm93KF8odCkpfTpnJiYhcD8oaT1uZXcgZyxvPWkucG9ydDIsaS5wb3J0MS5vbm1lc3NhZ2U9UyxuPXUoby5wb3N0TWVzc2FnZSxvLDEpKTohYS5hZGRFdmVudExpc3RlbmVyfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBwb3N0TWVzc2FnZXx8YS5pbXBvcnRTY3JpcHRzfHxzKEUpfHxcImZpbGU6XCI9PT1kLnByb3RvY29sP249ayBpbiBsKFwic2NyaXB0XCIpP2Z1bmN0aW9uKHQpe2YuYXBwZW5kQ2hpbGQobChcInNjcmlwdFwiKSlba109ZnVuY3Rpb24oKXtmLnJlbW92ZUNoaWxkKHRoaXMpLHcodCl9fTpmdW5jdGlvbih0KXtzZXRUaW1lb3V0KF8odCksMCl9OihuPUUsYS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLFMsITEpKSksdC5leHBvcnRzPXtzZXQ6aCxjbGVhcjp2fX0sXCIyZDAwXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuLGksbz1yKFwiZGE4NFwiKSxhPXIoXCIzNDJmXCIpLHM9by5wcm9jZXNzLGM9cyYmcy52ZXJzaW9ucyx1PWMmJmMudjg7dT8obj11LnNwbGl0KFwiLlwiKSxpPW5bMF0rblsxXSk6YSYmKG49YS5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pLCghbnx8blsxXT49NzQpJiYobj1hLm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKSxuJiYoaT1uWzFdKSkpLHQuZXhwb3J0cz1pJiYraX0sXCIzNDJmXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJkMDY2XCIpO3QuZXhwb3J0cz1uKFwibmF2aWdhdG9yXCIsXCJ1c2VyQWdlbnRcIil8fFwiXCJ9LFwiMzVhMVwiOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiZjVkZlwiKSxpPXIoXCIzZjhjXCIpLG89cihcImI2MjJcIiksYT1vKFwiaXRlcmF0b3JcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKHZvaWQgMCE9dClyZXR1cm4gdFthXXx8dFtcIkBAaXRlcmF0b3JcIl18fGlbbih0KV19fSxcIjM3ZThcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjgzYWJcIiksaT1yKFwiOWJmMlwiKSxvPXIoXCI4MjVhXCIpLGE9cihcImRmNzVcIik7dC5leHBvcnRzPW4/T2JqZWN0LmRlZmluZVByb3BlcnRpZXM6ZnVuY3Rpb24odCxlKXtvKHQpO3ZhciByLG49YShlKSxzPW4ubGVuZ3RoLGM9MDt3aGlsZShzPmMpaS5mKHQscj1uW2MrK10sZVtyXSk7cmV0dXJuIHR9fSxcIjNiYmVcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjg2MWRcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKCFuKHQpJiZudWxsIT09dCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBzZXQgXCIrU3RyaW5nKHQpK1wiIGFzIGEgcHJvdG90eXBlXCIpO3JldHVybiB0fX0sXCIzY2EzXCI6ZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoXCI2NTQ3XCIpLmNoYXJBdCxpPXIoXCI2OWYzXCIpLG89cihcIjdkZDBcIiksYT1cIlN0cmluZyBJdGVyYXRvclwiLHM9aS5zZXQsYz1pLmdldHRlckZvcihhKTtvKFN0cmluZyxcIlN0cmluZ1wiLChmdW5jdGlvbih0KXtzKHRoaXMse3R5cGU6YSxzdHJpbmc6U3RyaW5nKHQpLGluZGV4OjB9KX0pLChmdW5jdGlvbigpe3ZhciB0LGU9Yyh0aGlzKSxyPWUuc3RyaW5nLGk9ZS5pbmRleDtyZXR1cm4gaT49ci5sZW5ndGg/e3ZhbHVlOnZvaWQgMCxkb25lOiEwfToodD1uKHIsaSksZS5pbmRleCs9dC5sZW5ndGgse3ZhbHVlOnQsZG9uZTohMX0pfSkpfSxcIjNmOGNcIjpmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz17fX0sXCI0MDNlXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCI2NDhiXCIpO1wic3RyaW5nXCI9PT10eXBlb2YgbiYmKG49W1t0LmksbixcIlwiXV0pLG4ubG9jYWxzJiYodC5leHBvcnRzPW4ubG9jYWxzKTt2YXIgaT1yKFwiNDk5ZVwiKS5kZWZhdWx0O2koXCIzZDNkODZmZFwiLG4sITAse3NvdXJjZU1hcDohMSxzaGFkb3dNb2RlOiExfSl9LFwiNDA4YVwiOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiYzZiNlwiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHQmJlwiTnVtYmVyXCIhPW4odCkpdGhyb3cgVHlwZUVycm9yKFwiSW5jb3JyZWN0IGludm9jYXRpb25cIik7cmV0dXJuK3R9fSw0MTYwOmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiMjNlN1wiKSxpPXIoXCIxN2MyXCIpO24oe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOltdLmZvckVhY2ghPWl9LHtmb3JFYWNoOml9KX0sXCI0MjhmXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJkYTg0XCIpO3QuZXhwb3J0cz1ufSxcIjQ0YWRcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcImQwMzlcIiksaT1yKFwiYzZiNlwiKSxvPVwiXCIuc3BsaXQ7dC5leHBvcnRzPW4oKGZ1bmN0aW9uKCl7cmV0dXJuIU9iamVjdChcInpcIikucHJvcGVydHlJc0VudW1lcmFibGUoMCl9KSk/ZnVuY3Rpb24odCl7cmV0dXJuXCJTdHJpbmdcIj09aSh0KT9vLmNhbGwodCxcIlwiKTpPYmplY3QodCl9Ok9iamVjdH0sXCI0NGQyXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJiNjIyXCIpLGk9cihcIjdjNzNcIiksbz1yKFwiOWJmMlwiKSxhPW4oXCJ1bnNjb3BhYmxlc1wiKSxzPUFycmF5LnByb3RvdHlwZTt2b2lkIDA9PXNbYV0mJm8uZihzLGEse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTppKG51bGwpfSksdC5leHBvcnRzPWZ1bmN0aW9uKHQpe3NbYV1bdF09ITB9fSxcIjQ0ZGVcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcImRhODRcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIHI9bi5jb25zb2xlO3ImJnIuZXJyb3ImJigxPT09YXJndW1lbnRzLmxlbmd0aD9yLmVycm9yKHQpOnIuZXJyb3IodCxlKSl9fSxcIjQ0ZTdcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjg2MWRcIiksaT1yKFwiYzZiNlwiKSxvPXIoXCJiNjIyXCIpLGE9byhcIm1hdGNoXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gbih0KSYmKHZvaWQgMCE9PShlPXRbYV0pPyEhZTpcIlJlZ0V4cFwiPT1pKHQpKX19LFwiNDVmY1wiOmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiMjNlN1wiKSxpPXIoXCJiNzI3XCIpLnNvbWUsbz1yKFwiYTY0MFwiKSxhPXIoXCJhZTQwXCIpLHM9byhcInNvbWVcIiksYz1hKFwic29tZVwiKTtuKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohc3x8IWN9LHtzb21lOmZ1bmN0aW9uKHQpe3JldHVybiBpKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSl9LDQ3OTU6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCIyM2U3XCIpLGk9cihcImRhODRcIiksbz1yKFwiMzQyZlwiKSxhPVtdLnNsaWNlLHM9L01TSUUgLlxcLi8udGVzdChvKSxjPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLHIpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MixpPW4/YS5jYWxsKGFyZ3VtZW50cywyKTp2b2lkIDA7cmV0dXJuIHQobj9mdW5jdGlvbigpeyhcImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2U6RnVuY3Rpb24oZSkpLmFwcGx5KHRoaXMsaSl9OmUscil9fTtuKHtnbG9iYWw6ITAsYmluZDohMCxmb3JjZWQ6c30se3NldFRpbWVvdXQ6YyhpLnNldFRpbWVvdXQpLHNldEludGVydmFsOmMoaS5zZXRJbnRlcnZhbCl9KX0sNDg0MDpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjgyNWFcIiksaT1yKFwiMWMwYlwiKSxvPXIoXCJiNjIyXCIpLGE9byhcInNwZWNpZXNcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbz1uKHQpLmNvbnN0cnVjdG9yO3JldHVybiB2b2lkIDA9PT1vfHx2b2lkIDA9PShyPW4obylbYV0pP2U6aShyKX19LDQ5MzA6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJkMDM5XCIpO3QuZXhwb3J0cz0hIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMmJiFuKChmdW5jdGlvbigpe3JldHVybiFTdHJpbmcoU3ltYm9sKCkpfSkpfSxcIjQ5OGFcIjpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cihcIjIzZTdcIiksaT1yKFwiNThhOFwiKS50cmltLG89cihcImM4ZDJcIik7bih7dGFyZ2V0OlwiU3RyaW5nXCIscHJvdG86ITAsZm9yY2VkOm8oXCJ0cmltXCIpfSx7dHJpbTpmdW5jdGlvbigpe3JldHVybiBpKHRoaXMpfX0pfSxcIjQ5OWVcIjpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbih0LGUpe2Zvcih2YXIgcj1bXSxuPXt9LGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG89ZVtpXSxhPW9bMF0scz1vWzFdLGM9b1syXSx1PW9bM10sZj17aWQ6dCtcIjpcIitpLGNzczpzLG1lZGlhOmMsc291cmNlTWFwOnV9O25bYV0/blthXS5wYXJ0cy5wdXNoKGYpOnIucHVzaChuW2FdPXtpZDphLHBhcnRzOltmXX0pfXJldHVybiByfXIucihlKSxyLmQoZSxcImRlZmF1bHRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gaH0pKTt2YXIgaT1cInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50O2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgREVCVUcmJkRFQlVHJiYhaSl0aHJvdyBuZXcgRXJyb3IoXCJ2dWUtc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQuIFVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCIpO3ZhciBvPXt9LGE9aSYmKGRvY3VtZW50LmhlYWR8fGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXSkscz1udWxsLGM9MCx1PSExLGY9ZnVuY3Rpb24oKXt9LGw9bnVsbCxwPVwiZGF0YS12dWUtc3NyLWlkXCIsZD1cInVuZGVmaW5lZFwiIT09dHlwZW9mIG5hdmlnYXRvciYmL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtmdW5jdGlvbiBoKHQsZSxyLGkpe3U9cixsPWl8fHt9O3ZhciBhPW4odCxlKTtyZXR1cm4gdihhKSxmdW5jdGlvbihlKXtmb3IodmFyIHI9W10saT0wO2k8YS5sZW5ndGg7aSsrKXt2YXIgcz1hW2ldLGM9b1tzLmlkXTtjLnJlZnMtLSxyLnB1c2goYyl9ZT8oYT1uKHQsZSksdihhKSk6YT1bXTtmb3IoaT0wO2k8ci5sZW5ndGg7aSsrKXtjPXJbaV07aWYoMD09PWMucmVmcyl7Zm9yKHZhciB1PTA7dTxjLnBhcnRzLmxlbmd0aDt1KyspYy5wYXJ0c1t1XSgpO2RlbGV0ZSBvW2MuaWRdfX19fWZ1bmN0aW9uIHYodCl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciByPXRbZV0sbj1vW3IuaWRdO2lmKG4pe24ucmVmcysrO2Zvcih2YXIgaT0wO2k8bi5wYXJ0cy5sZW5ndGg7aSsrKW4ucGFydHNbaV0oci5wYXJ0c1tpXSk7Zm9yKDtpPHIucGFydHMubGVuZ3RoO2krKyluLnBhcnRzLnB1c2goZyhyLnBhcnRzW2ldKSk7bi5wYXJ0cy5sZW5ndGg+ci5wYXJ0cy5sZW5ndGgmJihuLnBhcnRzLmxlbmd0aD1yLnBhcnRzLmxlbmd0aCl9ZWxzZXt2YXIgYT1bXTtmb3IoaT0wO2k8ci5wYXJ0cy5sZW5ndGg7aSsrKWEucHVzaChnKHIucGFydHNbaV0pKTtvW3IuaWRdPXtpZDpyLmlkLHJlZnM6MSxwYXJ0czphfX19fWZ1bmN0aW9uIG0oKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7cmV0dXJuIHQudHlwZT1cInRleHQvY3NzXCIsYS5hcHBlbmRDaGlsZCh0KSx0fWZ1bmN0aW9uIGcodCl7dmFyIGUscixuPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJzdHlsZVtcIitwKyd+PVwiJyt0LmlkKydcIl0nKTtpZihuKXtpZih1KXJldHVybiBmO24ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuKX1pZihkKXt2YXIgaT1jKys7bj1zfHwocz1tKCkpLGU9Yi5iaW5kKG51bGwsbixpLCExKSxyPWIuYmluZChudWxsLG4saSwhMCl9ZWxzZSBuPW0oKSxlPXguYmluZChudWxsLG4pLHI9ZnVuY3Rpb24oKXtuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobil9O3JldHVybiBlKHQpLGZ1bmN0aW9uKG4pe2lmKG4pe2lmKG4uY3NzPT09dC5jc3MmJm4ubWVkaWE9PT10Lm1lZGlhJiZuLnNvdXJjZU1hcD09PXQuc291cmNlTWFwKXJldHVybjtlKHQ9bil9ZWxzZSByKCl9fXZhciB5PWZ1bmN0aW9uKCl7dmFyIHQ9W107cmV0dXJuIGZ1bmN0aW9uKGUscil7cmV0dXJuIHRbZV09cix0LmZpbHRlcihCb29sZWFuKS5qb2luKFwiXFxuXCIpfX0oKTtmdW5jdGlvbiBiKHQsZSxyLG4pe3ZhciBpPXI/XCJcIjpuLmNzcztpZih0LnN0eWxlU2hlZXQpdC5zdHlsZVNoZWV0LmNzc1RleHQ9eShlLGkpO2Vsc2V7dmFyIG89ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoaSksYT10LmNoaWxkTm9kZXM7YVtlXSYmdC5yZW1vdmVDaGlsZChhW2VdKSxhLmxlbmd0aD90Lmluc2VydEJlZm9yZShvLGFbZV0pOnQuYXBwZW5kQ2hpbGQobyl9fWZ1bmN0aW9uIHgodCxlKXt2YXIgcj1lLmNzcyxuPWUubWVkaWEsaT1lLnNvdXJjZU1hcDtpZihuJiZ0LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsbiksbC5zc3JJZCYmdC5zZXRBdHRyaWJ1dGUocCxlLmlkKSxpJiYocis9XCJcXG4vKiMgc291cmNlVVJMPVwiK2kuc291cmNlc1swXStcIiAqL1wiLHIrPVwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIitidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShpKSkpKStcIiAqL1wiKSx0LnN0eWxlU2hlZXQpdC5zdHlsZVNoZWV0LmNzc1RleHQ9cjtlbHNle3doaWxlKHQuZmlyc3RDaGlsZCl0LnJlbW92ZUNoaWxkKHQuZmlyc3RDaGlsZCk7dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyKSl9fX0sXCI0ZDY0XCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJmYzZhXCIpLGk9cihcIjUwYzRcIiksbz1yKFwiMjNjYlwiKSxhPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLHIsYSl7dmFyIHMsYz1uKGUpLHU9aShjLmxlbmd0aCksZj1vKGEsdSk7aWYodCYmciE9cil7d2hpbGUodT5mKWlmKHM9Y1tmKytdLHMhPXMpcmV0dXJuITB9ZWxzZSBmb3IoO3U+ZjtmKyspaWYoKHR8fGYgaW4gYykmJmNbZl09PT1yKXJldHVybiB0fHxmfHwwO3JldHVybiF0JiYtMX19O3QuZXhwb3J0cz17aW5jbHVkZXM6YSghMCksaW5kZXhPZjphKCExKX19LFwiNGRlNFwiOmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiMjNlN1wiKSxpPXIoXCJiNzI3XCIpLmZpbHRlcixvPXIoXCIxZGRlXCIpLGE9cihcImFlNDBcIikscz1vKFwiZmlsdGVyXCIpLGM9YShcImZpbHRlclwiKTtuKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohc3x8IWN9LHtmaWx0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIGkodGhpcyx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19KX0sXCI1MGM0XCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJhNjkxXCIpLGk9TWF0aC5taW47dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB0PjA/aShuKHQpLDkwMDcxOTkyNTQ3NDA5OTEpOjB9fSw1MTM1OmZ1bmN0aW9uKHQsZSl7dmFyIHI9e30uaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIuY2FsbCh0LGUpfX0sNTMxOTpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cihcImQ3ODRcIiksaT1yKFwiODI1YVwiKSxvPXIoXCI3YjBiXCIpLGE9cihcIjUwYzRcIikscz1yKFwiYTY5MVwiKSxjPXIoXCIxZDgwXCIpLHU9cihcIjhhYTVcIiksZj1yKFwiMTRjM1wiKSxsPU1hdGgubWF4LHA9TWF0aC5taW4sZD1NYXRoLmZsb29yLGg9L1xcJChbJCYnYF18XFxkXFxkP3w8W14+XSo+KS9nLHY9L1xcJChbJCYnYF18XFxkXFxkPykvZyxtPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10P3Q6U3RyaW5nKHQpfTtuKFwicmVwbGFjZVwiLDIsKGZ1bmN0aW9uKHQsZSxyLG4pe3ZhciBnPW4uUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUseT1uLlJFUExBQ0VfS0VFUFNfJDAsYj1nP1wiJFwiOlwiJDBcIjtyZXR1cm5bZnVuY3Rpb24ocixuKXt2YXIgaT1jKHRoaXMpLG89dm9pZCAwPT1yP3ZvaWQgMDpyW3RdO3JldHVybiB2b2lkIDAhPT1vP28uY2FsbChyLGksbik6ZS5jYWxsKFN0cmluZyhpKSxyLG4pfSxmdW5jdGlvbih0LG4pe2lmKCFnJiZ5fHxcInN0cmluZ1wiPT09dHlwZW9mIG4mJi0xPT09bi5pbmRleE9mKGIpKXt2YXIgbz1yKGUsdCx0aGlzLG4pO2lmKG8uZG9uZSlyZXR1cm4gby52YWx1ZX12YXIgYz1pKHQpLGQ9U3RyaW5nKHRoaXMpLGg9XCJmdW5jdGlvblwiPT09dHlwZW9mIG47aHx8KG49U3RyaW5nKG4pKTt2YXIgdj1jLmdsb2JhbDtpZih2KXt2YXIgaz1jLnVuaWNvZGU7Yy5sYXN0SW5kZXg9MH12YXIgdz1bXTt3aGlsZSgxKXt2YXIgXz1mKGMsZCk7aWYobnVsbD09PV8pYnJlYWs7aWYody5wdXNoKF8pLCF2KWJyZWFrO3ZhciBTPVN0cmluZyhfWzBdKTtcIlwiPT09UyYmKGMubGFzdEluZGV4PXUoZCxhKGMubGFzdEluZGV4KSxrKSl9Zm9yKHZhciBFPVwiXCIsVD0wLE89MDtPPHcubGVuZ3RoO08rKyl7Xz13W09dO2Zvcih2YXIgQz1TdHJpbmcoX1swXSksaj1sKHAocyhfLmluZGV4KSxkLmxlbmd0aCksMCksQT1bXSxQPTE7UDxfLmxlbmd0aDtQKyspQS5wdXNoKG0oX1tQXSkpO3ZhciBSPV8uZ3JvdXBzO2lmKGgpe3ZhciBGPVtDXS5jb25jYXQoQSxqLGQpO3ZvaWQgMCE9PVImJkYucHVzaChSKTt2YXIgST1TdHJpbmcobi5hcHBseSh2b2lkIDAsRikpfWVsc2UgST14KEMsZCxqLEEsUixuKTtqPj1UJiYoRSs9ZC5zbGljZShULGopK0ksVD1qK0MubGVuZ3RoKX1yZXR1cm4gRStkLnNsaWNlKFQpfV07ZnVuY3Rpb24geCh0LHIsbixpLGEscyl7dmFyIGM9bit0Lmxlbmd0aCx1PWkubGVuZ3RoLGY9djtyZXR1cm4gdm9pZCAwIT09YSYmKGE9byhhKSxmPWgpLGUuY2FsbChzLGYsKGZ1bmN0aW9uKGUsbyl7dmFyIHM7c3dpdGNoKG8uY2hhckF0KDApKXtjYXNlXCIkXCI6cmV0dXJuXCIkXCI7Y2FzZVwiJlwiOnJldHVybiB0O2Nhc2VcImBcIjpyZXR1cm4gci5zbGljZSgwLG4pO2Nhc2VcIidcIjpyZXR1cm4gci5zbGljZShjKTtjYXNlXCI8XCI6cz1hW28uc2xpY2UoMSwtMSldO2JyZWFrO2RlZmF1bHQ6dmFyIGY9K287aWYoMD09PWYpcmV0dXJuIGU7aWYoZj51KXt2YXIgbD1kKGYvMTApO3JldHVybiAwPT09bD9lOmw8PXU/dm9pZCAwPT09aVtsLTFdP28uY2hhckF0KDEpOmlbbC0xXStvLmNoYXJBdCgxKTplfXM9aVtmLTFdfXJldHVybiB2b2lkIDA9PT1zP1wiXCI6c30pKX19KSl9LFwiNTNjOFwiOmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiNDAzZVwiKSxpPXIubihuKTtpLmF9LDU2OTI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJjNDMwXCIpLGk9cihcImM2Y2RcIik7KHQuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybiBpW3RdfHwoaVt0XT12b2lkIDAhPT1lP2U6e30pfSkoXCJ2ZXJzaW9uc1wiLFtdKS5wdXNoKHt2ZXJzaW9uOlwiMy42LjVcIixtb2RlOm4/XCJwdXJlXCI6XCJnbG9iYWxcIixjb3B5cmlnaHQ6XCLCqSAyMDIwIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpXCJ9KX0sXCI1NmVmXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJkMDY2XCIpLGk9cihcIjI0MWNcIiksbz1yKFwiNzQxOFwiKSxhPXIoXCI4MjVhXCIpO3QuZXhwb3J0cz1uKFwiUmVmbGVjdFwiLFwib3duS2V5c1wiKXx8ZnVuY3Rpb24odCl7dmFyIGU9aS5mKGEodCkpLHI9by5mO3JldHVybiByP2UuY29uY2F0KHIodCkpOmV9fSw1ODk5OmZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPVwiXFx0XFxuXFx2XFxmXFxyIMKg4ZqA4oCA4oCB4oCC4oCD4oCE4oCF4oCG4oCH4oCI4oCJ4oCK4oCv4oGf44CAXFx1MjAyOFxcdTIwMjlcXHVmZWZmXCJ9LFwiNThhOFwiOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiMWQ4MFwiKSxpPXIoXCI1ODk5XCIpLG89XCJbXCIraStcIl1cIixhPVJlZ0V4cChcIl5cIitvK28rXCIqXCIpLHM9UmVnRXhwKG8rbytcIiokXCIpLGM9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciByPVN0cmluZyhuKGUpKTtyZXR1cm4gMSZ0JiYocj1yLnJlcGxhY2UoYSxcIlwiKSksMiZ0JiYocj1yLnJlcGxhY2UocyxcIlwiKSkscn19O3QuZXhwb3J0cz17c3RhcnQ6YygxKSxlbmQ6YygyKSx0cmltOmMoMyl9fSxcIjVhMzRcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjQ0ZTdcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKG4odCkpdGhyb3cgVHlwZUVycm9yKFwiVGhlIG1ldGhvZCBkb2Vzbid0IGFjY2VwdCByZWd1bGFyIGV4cHJlc3Npb25zXCIpO3JldHVybiB0fX0sXCI1YzZjXCI6ZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm57ZW51bWVyYWJsZTohKDEmdCksY29uZmlndXJhYmxlOiEoMiZ0KSx3cml0YWJsZTohKDQmdCksdmFsdWU6ZX19fSxcIjY0OGJcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjI0ZmJcIik7ZT1uKCExKSxlLnB1c2goW3QuaSxcIi5mYWRlLWVudGVyLWFjdGl2ZVtkYXRhLXYtODczZWY2MzhdLC5mYWRlLWxlYXZlLWFjdGl2ZVtkYXRhLXYtODczZWY2Mzhdey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4zczstby10cmFuc2l0aW9uOm9wYWNpdHkgLjNzO3RyYW5zaXRpb246b3BhY2l0eSAuM3N9LmZhZGUtZW50ZXJbZGF0YS12LTg3M2VmNjM4XSwuZmFkZS1sZWF2ZS1hY3RpdmVbZGF0YS12LTg3M2VmNjM4XXstd2Via2l0LXRyYW5zaXRpb246LjNzOy1vLXRyYW5zaXRpb246LjNzO3RyYW5zaXRpb246LjNzO29wYWNpdHk6MH1cIixcIlwiXSksdC5leHBvcnRzPWV9LDY1NDc6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJhNjkxXCIpLGk9cihcIjFkODBcIiksbz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxyKXt2YXIgbyxhLHM9U3RyaW5nKGkoZSkpLGM9bihyKSx1PXMubGVuZ3RoO3JldHVybiBjPDB8fGM+PXU/dD9cIlwiOnZvaWQgMDoobz1zLmNoYXJDb2RlQXQoYyksbzw1NTI5Nnx8bz41NjMxOXx8YysxPT09dXx8KGE9cy5jaGFyQ29kZUF0KGMrMSkpPDU2MzIwfHxhPjU3MzQzP3Q/cy5jaGFyQXQoYyk6bzp0P3Muc2xpY2UoYyxjKzIpOmEtNTYzMjArKG8tNTUyOTY8PDEwKSs2NTUzNil9fTt0LmV4cG9ydHM9e2NvZGVBdDpvKCExKSxjaGFyQXQ6byghMCl9fSxcIjY1ZjBcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjg2MWRcIiksaT1yKFwiZThiNVwiKSxvPXIoXCJiNjIyXCIpLGE9byhcInNwZWNpZXNcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIHI7cmV0dXJuIGkodCkmJihyPXQuY29uc3RydWN0b3IsXCJmdW5jdGlvblwiIT10eXBlb2Ygcnx8ciE9PUFycmF5JiYhaShyLnByb3RvdHlwZSk/bihyKSYmKHI9clthXSxudWxsPT09ciYmKHI9dm9pZCAwKSk6cj12b2lkIDApLG5ldyh2b2lkIDA9PT1yP0FycmF5OnIpKDA9PT1lPzA6ZSl9fSxcIjY5ZjNcIjpmdW5jdGlvbih0LGUscil7dmFyIG4saSxvLGE9cihcIjdmOWFcIikscz1yKFwiZGE4NFwiKSxjPXIoXCI4NjFkXCIpLHU9cihcIjkxMTJcIiksZj1yKFwiNTEzNVwiKSxsPXIoXCJmNzcyXCIpLHA9cihcImQwMTJcIiksZD1zLldlYWtNYXAsaD1mdW5jdGlvbih0KXtyZXR1cm4gbyh0KT9pKHQpOm4odCx7fSl9LHY9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciByO2lmKCFjKGUpfHwocj1pKGUpKS50eXBlIT09dCl0aHJvdyBUeXBlRXJyb3IoXCJJbmNvbXBhdGlibGUgcmVjZWl2ZXIsIFwiK3QrXCIgcmVxdWlyZWRcIik7cmV0dXJuIHJ9fTtpZihhKXt2YXIgbT1uZXcgZCxnPW0uZ2V0LHk9bS5oYXMsYj1tLnNldDtuPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGIuY2FsbChtLHQsZSksZX0saT1mdW5jdGlvbih0KXtyZXR1cm4gZy5jYWxsKG0sdCl8fHt9fSxvPWZ1bmN0aW9uKHQpe3JldHVybiB5LmNhbGwobSx0KX19ZWxzZXt2YXIgeD1sKFwic3RhdGVcIik7cFt4XT0hMCxuPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHUodCx4LGUpLGV9LGk9ZnVuY3Rpb24odCl7cmV0dXJuIGYodCx4KT90W3hdOnt9fSxvPWZ1bmN0aW9uKHQpe3JldHVybiBmKHQseCl9fXQuZXhwb3J0cz17c2V0Om4sZ2V0OmksaGFzOm8sZW5mb3JjZTpoLGdldHRlckZvcjp2fX0sXCI2ZDQwXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCIxMWFlXCIpO1wic3RyaW5nXCI9PT10eXBlb2YgbiYmKG49W1t0LmksbixcIlwiXV0pLG4ubG9jYWxzJiYodC5leHBvcnRzPW4ubG9jYWxzKTt2YXIgaT1yKFwiNDk5ZVwiKS5kZWZhdWx0O2koXCI3OGI0OWI2ZVwiLG4sITAse3NvdXJjZU1hcDohMSxzaGFkb3dNb2RlOiExfSl9LFwiNmVlYlwiOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiZGE4NFwiKSxpPXIoXCI5MTEyXCIpLG89cihcIjUxMzVcIiksYT1yKFwiY2U0ZVwiKSxzPXIoXCI4OTI1XCIpLGM9cihcIjY5ZjNcIiksdT1jLmdldCxmPWMuZW5mb3JjZSxsPVN0cmluZyhTdHJpbmcpLnNwbGl0KFwiU3RyaW5nXCIpOyh0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIscyl7dmFyIGM9ISFzJiYhIXMudW5zYWZlLHU9ISFzJiYhIXMuZW51bWVyYWJsZSxwPSEhcyYmISFzLm5vVGFyZ2V0R2V0O1wiZnVuY3Rpb25cIj09dHlwZW9mIHImJihcInN0cmluZ1wiIT10eXBlb2YgZXx8byhyLFwibmFtZVwiKXx8aShyLFwibmFtZVwiLGUpLGYocikuc291cmNlPWwuam9pbihcInN0cmluZ1wiPT10eXBlb2YgZT9lOlwiXCIpKSx0IT09bj8oYz8hcCYmdFtlXSYmKHU9ITApOmRlbGV0ZSB0W2VdLHU/dFtlXT1yOmkodCxlLHIpKTp1P3RbZV09cjphKGUscil9KShGdW5jdGlvbi5wcm90b3R5cGUsXCJ0b1N0cmluZ1wiLChmdW5jdGlvbigpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMmJnUodGhpcykuc291cmNlfHxzKHRoaXMpfSkpfSw3MTU2OmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiODYxZFwiKSxpPXIoXCJkMmJiXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscil7dmFyIG8sYTtyZXR1cm4gaSYmXCJmdW5jdGlvblwiPT10eXBlb2Yobz1lLmNvbnN0cnVjdG9yKSYmbyE9PXImJm4oYT1vLnByb3RvdHlwZSkmJmEhPT1yLnByb3RvdHlwZSYmaSh0LGEpLHR9fSw3NDE4OmZ1bmN0aW9uKHQsZSl7ZS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHN9LFwiNzQ2ZlwiOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiNDI4ZlwiKSxpPXIoXCI1MTM1XCIpLG89cihcImU1MzhcIiksYT1yKFwiOWJmMlwiKS5mO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT1uLlN5bWJvbHx8KG4uU3ltYm9sPXt9KTtpKGUsdCl8fGEoZSx0LHt2YWx1ZTpvLmYodCl9KX19LDc4Mzk6ZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9W1wiY29uc3RydWN0b3JcIixcImhhc093blByb3BlcnR5XCIsXCJpc1Byb3RvdHlwZU9mXCIsXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLFwidG9Mb2NhbGVTdHJpbmdcIixcInRvU3RyaW5nXCIsXCJ2YWx1ZU9mXCJdfSxcIjdiMGJcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjFkODBcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3Qobih0KSl9fSxcIjdjNzNcIjpmdW5jdGlvbih0LGUscil7dmFyIG4saT1yKFwiODI1YVwiKSxvPXIoXCIzN2U4XCIpLGE9cihcIjc4MzlcIikscz1yKFwiZDAxMlwiKSxjPXIoXCIxYmU0XCIpLHU9cihcImNjMTJcIiksZj1yKFwiZjc3MlwiKSxsPVwiPlwiLHA9XCI8XCIsZD1cInByb3RvdHlwZVwiLGg9XCJzY3JpcHRcIix2PWYoXCJJRV9QUk9UT1wiKSxtPWZ1bmN0aW9uKCl7fSxnPWZ1bmN0aW9uKHQpe3JldHVybiBwK2grbCt0K3ArXCIvXCIraCtsfSx5PWZ1bmN0aW9uKHQpe3Qud3JpdGUoZyhcIlwiKSksdC5jbG9zZSgpO3ZhciBlPXQucGFyZW50V2luZG93Lk9iamVjdDtyZXR1cm4gdD1udWxsLGV9LGI9ZnVuY3Rpb24oKXt2YXIgdCxlPXUoXCJpZnJhbWVcIikscj1cImphdmFcIitoK1wiOlwiO3JldHVybiBlLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsYy5hcHBlbmRDaGlsZChlKSxlLnNyYz1TdHJpbmcociksdD1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQsdC5vcGVuKCksdC53cml0ZShnKFwiZG9jdW1lbnQuRj1PYmplY3RcIikpLHQuY2xvc2UoKSx0LkZ9LHg9ZnVuY3Rpb24oKXt0cnl7bj1kb2N1bWVudC5kb21haW4mJm5ldyBBY3RpdmVYT2JqZWN0KFwiaHRtbGZpbGVcIil9Y2F0Y2goZSl7fXg9bj95KG4pOmIoKTt2YXIgdD1hLmxlbmd0aDt3aGlsZSh0LS0pZGVsZXRlIHhbZF1bYVt0XV07cmV0dXJuIHgoKX07c1t2XT0hMCx0LmV4cG9ydHM9T2JqZWN0LmNyZWF0ZXx8ZnVuY3Rpb24odCxlKXt2YXIgcjtyZXR1cm4gbnVsbCE9PXQ/KG1bZF09aSh0KSxyPW5ldyBtLG1bZF09bnVsbCxyW3ZdPXQpOnI9eCgpLHZvaWQgMD09PWU/cjpvKHIsZSl9fSxcIjdkZDBcIjpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cihcIjIzZTdcIiksaT1yKFwiOWVkM1wiKSxvPXIoXCJlMTYzXCIpLGE9cihcImQyYmJcIikscz1yKFwiZDQ0ZVwiKSxjPXIoXCI5MTEyXCIpLHU9cihcIjZlZWJcIiksZj1yKFwiYjYyMlwiKSxsPXIoXCJjNDMwXCIpLHA9cihcIjNmOGNcIiksZD1yKFwiYWU5M1wiKSxoPWQuSXRlcmF0b3JQcm90b3R5cGUsdj1kLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlMsbT1mKFwiaXRlcmF0b3JcIiksZz1cImtleXNcIix5PVwidmFsdWVzXCIsYj1cImVudHJpZXNcIix4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscixmLGQsayx3KXtpKHIsZSxmKTt2YXIgXyxTLEUsVD1mdW5jdGlvbih0KXtpZih0PT09ZCYmUClyZXR1cm4gUDtpZighdiYmdCBpbiBqKXJldHVybiBqW3RdO3N3aXRjaCh0KXtjYXNlIGc6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyByKHRoaXMsdCl9O2Nhc2UgeTpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHIodGhpcyx0KX07Y2FzZSBiOnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgcih0aGlzLHQpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHIodGhpcyl9fSxPPWUrXCIgSXRlcmF0b3JcIixDPSExLGo9dC5wcm90b3R5cGUsQT1qW21dfHxqW1wiQEBpdGVyYXRvclwiXXx8ZCYmaltkXSxQPSF2JiZBfHxUKGQpLFI9XCJBcnJheVwiPT1lJiZqLmVudHJpZXN8fEE7aWYoUiYmKF89byhSLmNhbGwobmV3IHQpKSxoIT09T2JqZWN0LnByb3RvdHlwZSYmXy5uZXh0JiYobHx8byhfKT09PWh8fChhP2EoXyxoKTpcImZ1bmN0aW9uXCIhPXR5cGVvZiBfW21dJiZjKF8sbSx4KSkscyhfLE8sITAsITApLGwmJihwW09dPXgpKSksZD09eSYmQSYmQS5uYW1lIT09eSYmKEM9ITAsUD1mdW5jdGlvbigpe3JldHVybiBBLmNhbGwodGhpcyl9KSxsJiYhd3x8alttXT09PVB8fGMoaixtLFApLHBbZV09UCxkKWlmKFM9e3ZhbHVlczpUKHkpLGtleXM6az9QOlQoZyksZW50cmllczpUKGIpfSx3KWZvcihFIGluIFMpKHZ8fEN8fCEoRSBpbiBqKSkmJnUoaixFLFNbRV0pO2Vsc2Ugbih7dGFyZ2V0OmUscHJvdG86ITAsZm9yY2VkOnZ8fEN9LFMpO3JldHVybiBTfX0sXCI3ZjlhXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJkYTg0XCIpLGk9cihcIjg5MjVcIiksbz1uLldlYWtNYXA7dC5leHBvcnRzPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBvJiYvbmF0aXZlIGNvZGUvLnRlc3QoaShvKSl9LFwiODI1YVwiOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiODYxZFwiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoIW4odCkpdGhyb3cgVHlwZUVycm9yKFN0cmluZyh0KStcIiBpcyBub3QgYW4gb2JqZWN0XCIpO3JldHVybiB0fX0sXCI4M2FiXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJkMDM5XCIpO3QuZXhwb3J0cz0hbigoZnVuY3Rpb24oKXtyZXR1cm4gNyE9T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LDEse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pWzFdfSkpfSw4NDE4OmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiYzA0ZVwiKSxpPXIoXCI5YmYyXCIpLG89cihcIjVjNmNcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxyKXt2YXIgYT1uKGUpO2EgaW4gdD9pLmYodCxhLG8oMCxyKSk6dFthXT1yfX0sXCI4NDFjXCI6ZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoXCJkNzg0XCIpLGk9cihcIjgyNWFcIiksbz1yKFwiMWQ4MFwiKSxhPXIoXCIxMjlmXCIpLHM9cihcIjE0YzNcIik7bihcInNlYXJjaFwiLDEsKGZ1bmN0aW9uKHQsZSxyKXtyZXR1cm5bZnVuY3Rpb24oZSl7dmFyIHI9byh0aGlzKSxuPXZvaWQgMD09ZT92b2lkIDA6ZVt0XTtyZXR1cm4gdm9pZCAwIT09bj9uLmNhbGwoZSxyKTpuZXcgUmVnRXhwKGUpW3RdKFN0cmluZyhyKSl9LGZ1bmN0aW9uKHQpe3ZhciBuPXIoZSx0LHRoaXMpO2lmKG4uZG9uZSlyZXR1cm4gbi52YWx1ZTt2YXIgbz1pKHQpLGM9U3RyaW5nKHRoaXMpLHU9by5sYXN0SW5kZXg7YSh1LDApfHwoby5sYXN0SW5kZXg9MCk7dmFyIGY9cyhvLGMpO3JldHVybiBhKG8ubGFzdEluZGV4LHUpfHwoby5sYXN0SW5kZXg9dSksbnVsbD09PWY/LTE6Zi5pbmRleH1dfSkpfSxcIjg2MWRcIjpmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIHQ/bnVsbCE9PXQ6XCJmdW5jdGlvblwiPT09dHlwZW9mIHR9fSw4ODc1OmZ1bmN0aW9uKHQsZSxyKXt2YXIgbixpLG87KGZ1bmN0aW9uKHIsYSl7aT1bXSxuPWEsbz1cImZ1bmN0aW9uXCI9PT10eXBlb2Ygbj9uLmFwcGx5KGUsaSk6bix2b2lkIDA9PT1vfHwodC5leHBvcnRzPW8pfSkoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBzZWxmJiZzZWxmLChmdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt2YXIgZT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRvY3VtZW50LFwiY3VycmVudFNjcmlwdFwiKTtpZighZSYmXCJjdXJyZW50U2NyaXB0XCJpbiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdClyZXR1cm4gZG9jdW1lbnQuY3VycmVudFNjcmlwdDtpZihlJiZlLmdldCE9PXQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQpcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQ7dHJ5e3Rocm93IG5ldyBFcnJvcn1jYXRjaChkKXt2YXIgcixuLGksbz0vLiphdCBbXihdKlxcKCguKik6KC4rKTooLispXFwpJC9naSxhPS9AKFteQF0qKTooXFxkKyk6KFxcZCspXFxzKiQvZ2kscz1vLmV4ZWMoZC5zdGFjayl8fGEuZXhlYyhkLnN0YWNrKSxjPXMmJnNbMV18fCExLHU9cyYmc1syXXx8ITEsZj1kb2N1bWVudC5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoZG9jdW1lbnQubG9jYXRpb24uaGFzaCxcIlwiKSxsPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO2M9PT1mJiYocj1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MLG49bmV3IFJlZ0V4cChcIig/OlteXFxcXG5dKz9cXFxcbil7MCxcIisodS0yKStcIn1bXjxdKjxzY3JpcHQ+KFtcXFxcZFxcXFxEXSo/KTxcXFxcL3NjcmlwdD5bXFxcXGRcXFxcRF0qXCIsXCJpXCIpLGk9ci5yZXBsYWNlKG4sXCIkMVwiKS50cmltKCkpO2Zvcih2YXIgcD0wO3A8bC5sZW5ndGg7cCsrKXtpZihcImludGVyYWN0aXZlXCI9PT1sW3BdLnJlYWR5U3RhdGUpcmV0dXJuIGxbcF07aWYobFtwXS5zcmM9PT1jKXJldHVybiBsW3BdO2lmKGM9PT1mJiZsW3BdLmlubmVySFRNTCYmbFtwXS5pbm5lckhUTUwudHJpbSgpPT09aSlyZXR1cm4gbFtwXX1yZXR1cm4gbnVsbH19cmV0dXJuIHR9KSl9LDg5MjU6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJjNmNkXCIpLGk9RnVuY3Rpb24udG9TdHJpbmc7XCJmdW5jdGlvblwiIT10eXBlb2Ygbi5pbnNwZWN0U291cmNlJiYobi5pbnNwZWN0U291cmNlPWZ1bmN0aW9uKHQpe3JldHVybiBpLmNhbGwodCl9KSx0LmV4cG9ydHM9bi5pbnNwZWN0U291cmNlfSxcIjhhYTVcIjpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cihcIjY1NDdcIikuY2hhckF0O3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscil7cmV0dXJuIGUrKHI/bih0LGUpLmxlbmd0aDoxKX19LFwiOTBlM1wiOmZ1bmN0aW9uKHQsZSl7dmFyIHI9MCxuPU1hdGgucmFuZG9tKCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVyblwiU3ltYm9sKFwiK1N0cmluZyh2b2lkIDA9PT10P1wiXCI6dCkrXCIpX1wiKygrK3IrbikudG9TdHJpbmcoMzYpfX0sOTExMjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjgzYWJcIiksaT1yKFwiOWJmMlwiKSxvPXIoXCI1YzZjXCIpO3QuZXhwb3J0cz1uP2Z1bmN0aW9uKHQsZSxyKXtyZXR1cm4gaS5mKHQsZSxvKDEscikpfTpmdW5jdGlvbih0LGUscil7cmV0dXJuIHRbZV09cix0fX0sOTEyOTpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjIzZTdcIik7bih7dGFyZ2V0OlwiTnVtYmVyXCIsc3RhdDohMH0se2lzTmFOOmZ1bmN0aW9uKHQpe3JldHVybiB0IT10fX0pfSw5MjYzOmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiYWQ2ZFwiKSxpPXIoXCI5ZjdmXCIpLG89UmVnRXhwLnByb3RvdHlwZS5leGVjLGE9U3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlLHM9byxjPWZ1bmN0aW9uKCl7dmFyIHQ9L2EvLGU9L2IqL2c7cmV0dXJuIG8uY2FsbCh0LFwiYVwiKSxvLmNhbGwoZSxcImFcIiksMCE9PXQubGFzdEluZGV4fHwwIT09ZS5sYXN0SW5kZXh9KCksdT1pLlVOU1VQUE9SVEVEX1l8fGkuQlJPS0VOX0NBUkVULGY9dm9pZCAwIT09LygpPz8vLmV4ZWMoXCJcIilbMV0sbD1jfHxmfHx1O2wmJihzPWZ1bmN0aW9uKHQpe3ZhciBlLHIsaSxzLGw9dGhpcyxwPXUmJmwuc3RpY2t5LGQ9bi5jYWxsKGwpLGg9bC5zb3VyY2Usdj0wLG09dDtyZXR1cm4gcCYmKGQ9ZC5yZXBsYWNlKFwieVwiLFwiXCIpLC0xPT09ZC5pbmRleE9mKFwiZ1wiKSYmKGQrPVwiZ1wiKSxtPVN0cmluZyh0KS5zbGljZShsLmxhc3RJbmRleCksbC5sYXN0SW5kZXg+MCYmKCFsLm11bHRpbGluZXx8bC5tdWx0aWxpbmUmJlwiXFxuXCIhPT10W2wubGFzdEluZGV4LTFdKSYmKGg9XCIoPzogXCIraCtcIilcIixtPVwiIFwiK20sdisrKSxyPW5ldyBSZWdFeHAoXCJeKD86XCIraCtcIilcIixkKSksZiYmKHI9bmV3IFJlZ0V4cChcIl5cIitoK1wiJCg/IVxcXFxzKVwiLGQpKSxjJiYoZT1sLmxhc3RJbmRleCksaT1vLmNhbGwocD9yOmwsbSkscD9pPyhpLmlucHV0PWkuaW5wdXQuc2xpY2UodiksaVswXT1pWzBdLnNsaWNlKHYpLGkuaW5kZXg9bC5sYXN0SW5kZXgsbC5sYXN0SW5kZXgrPWlbMF0ubGVuZ3RoKTpsLmxhc3RJbmRleD0wOmMmJmkmJihsLmxhc3RJbmRleD1sLmdsb2JhbD9pLmluZGV4K2lbMF0ubGVuZ3RoOmUpLGYmJmkmJmkubGVuZ3RoPjEmJmEuY2FsbChpWzBdLHIsKGZ1bmN0aW9uKCl7Zm9yKHM9MTtzPGFyZ3VtZW50cy5sZW5ndGgtMjtzKyspdm9pZCAwPT09YXJndW1lbnRzW3NdJiYoaVtzXT12b2lkIDApfSkpLGl9KSx0LmV4cG9ydHM9c30sXCI5NGNhXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJkMDM5XCIpLGk9LyN8XFwucHJvdG90eXBlXFwuLyxvPWZ1bmN0aW9uKHQsZSl7dmFyIHI9c1thKHQpXTtyZXR1cm4gcj09dXx8ciE9YyYmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGU/bihlKTohIWUpfSxhPW8ubm9ybWFsaXplPWZ1bmN0aW9uKHQpe3JldHVybiBTdHJpbmcodCkucmVwbGFjZShpLFwiLlwiKS50b0xvd2VyQ2FzZSgpfSxzPW8uZGF0YT17fSxjPW8uTkFUSVZFPVwiTlwiLHU9by5QT0xZRklMTD1cIlBcIjt0LmV4cG9ydHM9b30sXCI5NmNmXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPWZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO3ZhciBlLHI9T2JqZWN0LnByb3RvdHlwZSxuPXIuaGFzT3duUHJvcGVydHksaT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sP1N5bWJvbDp7fSxvPWkuaXRlcmF0b3J8fFwiQEBpdGVyYXRvclwiLGE9aS5hc3luY0l0ZXJhdG9yfHxcIkBAYXN5bmNJdGVyYXRvclwiLHM9aS50b1N0cmluZ1RhZ3x8XCJAQHRvU3RyaW5nVGFnXCI7ZnVuY3Rpb24gYyh0LGUscil7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOnIsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KSx0W2VdfXRyeXtjKHt9LFwiXCIpfWNhdGNoKFIpe2M9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0W2VdPXJ9fWZ1bmN0aW9uIHUodCxlLHIsbil7dmFyIGk9ZSYmZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBtP2U6bSxvPU9iamVjdC5jcmVhdGUoaS5wcm90b3R5cGUpLGE9bmV3IGoobnx8W10pO3JldHVybiBvLl9pbnZva2U9RSh0LHIsYSksb31mdW5jdGlvbiBmKHQsZSxyKXt0cnl7cmV0dXJue3R5cGU6XCJub3JtYWxcIixhcmc6dC5jYWxsKGUscil9fWNhdGNoKFIpe3JldHVybnt0eXBlOlwidGhyb3dcIixhcmc6Un19fXQud3JhcD11O3ZhciBsPVwic3VzcGVuZGVkU3RhcnRcIixwPVwic3VzcGVuZGVkWWllbGRcIixkPVwiZXhlY3V0aW5nXCIsaD1cImNvbXBsZXRlZFwiLHY9e307ZnVuY3Rpb24gbSgpe31mdW5jdGlvbiBnKCl7fWZ1bmN0aW9uIHkoKXt9dmFyIGI9e307YltvXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTt2YXIgeD1PYmplY3QuZ2V0UHJvdG90eXBlT2Ysaz14JiZ4KHgoQShbXSkpKTtrJiZrIT09ciYmbi5jYWxsKGssbykmJihiPWspO3ZhciB3PXkucHJvdG90eXBlPW0ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoYik7ZnVuY3Rpb24gXyh0KXtbXCJuZXh0XCIsXCJ0aHJvd1wiLFwicmV0dXJuXCJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe2ModCxlLChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5faW52b2tlKGUsdCl9KSl9KSl9ZnVuY3Rpb24gUyh0LGUpe2Z1bmN0aW9uIHIoaSxvLGEscyl7dmFyIGM9Zih0W2ldLHQsbyk7aWYoXCJ0aHJvd1wiIT09Yy50eXBlKXt2YXIgdT1jLmFyZyxsPXUudmFsdWU7cmV0dXJuIGwmJlwib2JqZWN0XCI9PT10eXBlb2YgbCYmbi5jYWxsKGwsXCJfX2F3YWl0XCIpP2UucmVzb2x2ZShsLl9fYXdhaXQpLnRoZW4oKGZ1bmN0aW9uKHQpe3IoXCJuZXh0XCIsdCxhLHMpfSksKGZ1bmN0aW9uKHQpe3IoXCJ0aHJvd1wiLHQsYSxzKX0pKTplLnJlc29sdmUobCkudGhlbigoZnVuY3Rpb24odCl7dS52YWx1ZT10LGEodSl9KSwoZnVuY3Rpb24odCl7cmV0dXJuIHIoXCJ0aHJvd1wiLHQsYSxzKX0pKX1zKGMuYXJnKX12YXIgaTtmdW5jdGlvbiBvKHQsbil7ZnVuY3Rpb24gbygpe3JldHVybiBuZXcgZSgoZnVuY3Rpb24oZSxpKXtyKHQsbixlLGkpfSkpfXJldHVybiBpPWk/aS50aGVuKG8sbyk6bygpfXRoaXMuX2ludm9rZT1vfWZ1bmN0aW9uIEUodCxlLHIpe3ZhciBuPWw7cmV0dXJuIGZ1bmN0aW9uKGksbyl7aWYobj09PWQpdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtpZihuPT09aCl7aWYoXCJ0aHJvd1wiPT09aSl0aHJvdyBvO3JldHVybiBQKCl9ci5tZXRob2Q9aSxyLmFyZz1vO3doaWxlKDEpe3ZhciBhPXIuZGVsZWdhdGU7aWYoYSl7dmFyIHM9VChhLHIpO2lmKHMpe2lmKHM9PT12KWNvbnRpbnVlO3JldHVybiBzfX1pZihcIm5leHRcIj09PXIubWV0aG9kKXIuc2VudD1yLl9zZW50PXIuYXJnO2Vsc2UgaWYoXCJ0aHJvd1wiPT09ci5tZXRob2Qpe2lmKG49PT1sKXRocm93IG49aCxyLmFyZztyLmRpc3BhdGNoRXhjZXB0aW9uKHIuYXJnKX1lbHNlXCJyZXR1cm5cIj09PXIubWV0aG9kJiZyLmFicnVwdChcInJldHVyblwiLHIuYXJnKTtuPWQ7dmFyIGM9Zih0LGUscik7aWYoXCJub3JtYWxcIj09PWMudHlwZSl7aWYobj1yLmRvbmU/aDpwLGMuYXJnPT09diljb250aW51ZTtyZXR1cm57dmFsdWU6Yy5hcmcsZG9uZTpyLmRvbmV9fVwidGhyb3dcIj09PWMudHlwZSYmKG49aCxyLm1ldGhvZD1cInRocm93XCIsci5hcmc9Yy5hcmcpfX19ZnVuY3Rpb24gVCh0LHIpe3ZhciBuPXQuaXRlcmF0b3Jbci5tZXRob2RdO2lmKG49PT1lKXtpZihyLmRlbGVnYXRlPW51bGwsXCJ0aHJvd1wiPT09ci5tZXRob2Qpe2lmKHQuaXRlcmF0b3JbXCJyZXR1cm5cIl0mJihyLm1ldGhvZD1cInJldHVyblwiLHIuYXJnPWUsVCh0LHIpLFwidGhyb3dcIj09PXIubWV0aG9kKSlyZXR1cm4gdjtyLm1ldGhvZD1cInRocm93XCIsci5hcmc9bmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIil9cmV0dXJuIHZ9dmFyIGk9ZihuLHQuaXRlcmF0b3Isci5hcmcpO2lmKFwidGhyb3dcIj09PWkudHlwZSlyZXR1cm4gci5tZXRob2Q9XCJ0aHJvd1wiLHIuYXJnPWkuYXJnLHIuZGVsZWdhdGU9bnVsbCx2O3ZhciBvPWkuYXJnO3JldHVybiBvP28uZG9uZT8oclt0LnJlc3VsdE5hbWVdPW8udmFsdWUsci5uZXh0PXQubmV4dExvYyxcInJldHVyblwiIT09ci5tZXRob2QmJihyLm1ldGhvZD1cIm5leHRcIixyLmFyZz1lKSxyLmRlbGVnYXRlPW51bGwsdik6bzooci5tZXRob2Q9XCJ0aHJvd1wiLHIuYXJnPW5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSxyLmRlbGVnYXRlPW51bGwsdil9ZnVuY3Rpb24gTyh0KXt2YXIgZT17dHJ5TG9jOnRbMF19OzEgaW4gdCYmKGUuY2F0Y2hMb2M9dFsxXSksMiBpbiB0JiYoZS5maW5hbGx5TG9jPXRbMl0sZS5hZnRlckxvYz10WzNdKSx0aGlzLnRyeUVudHJpZXMucHVzaChlKX1mdW5jdGlvbiBDKHQpe3ZhciBlPXQuY29tcGxldGlvbnx8e307ZS50eXBlPVwibm9ybWFsXCIsZGVsZXRlIGUuYXJnLHQuY29tcGxldGlvbj1lfWZ1bmN0aW9uIGoodCl7dGhpcy50cnlFbnRyaWVzPVt7dHJ5TG9jOlwicm9vdFwifV0sdC5mb3JFYWNoKE8sdGhpcyksdGhpcy5yZXNldCghMCl9ZnVuY3Rpb24gQSh0KXtpZih0KXt2YXIgcj10W29dO2lmKHIpcmV0dXJuIHIuY2FsbCh0KTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgdC5uZXh0KXJldHVybiB0O2lmKCFpc05hTih0Lmxlbmd0aCkpe3ZhciBpPS0xLGE9ZnVuY3Rpb24gcigpe3doaWxlKCsraTx0Lmxlbmd0aClpZihuLmNhbGwodCxpKSlyZXR1cm4gci52YWx1ZT10W2ldLHIuZG9uZT0hMSxyO3JldHVybiByLnZhbHVlPWUsci5kb25lPSEwLHJ9O3JldHVybiBhLm5leHQ9YX19cmV0dXJue25leHQ6UH19ZnVuY3Rpb24gUCgpe3JldHVybnt2YWx1ZTplLGRvbmU6ITB9fXJldHVybiBnLnByb3RvdHlwZT13LmNvbnN0cnVjdG9yPXkseS5jb25zdHJ1Y3Rvcj1nLGcuZGlzcGxheU5hbWU9Yyh5LHMsXCJHZW5lcmF0b3JGdW5jdGlvblwiKSx0LmlzR2VuZXJhdG9yRnVuY3Rpb249ZnVuY3Rpb24odCl7dmFyIGU9XCJmdW5jdGlvblwiPT09dHlwZW9mIHQmJnQuY29uc3RydWN0b3I7cmV0dXJuISFlJiYoZT09PWd8fFwiR2VuZXJhdG9yRnVuY3Rpb25cIj09PShlLmRpc3BsYXlOYW1lfHxlLm5hbWUpKX0sdC5tYXJrPWZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKHQseSk6KHQuX19wcm90b19fPXksYyh0LHMsXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksdC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh3KSx0fSx0LmF3cmFwPWZ1bmN0aW9uKHQpe3JldHVybntfX2F3YWl0OnR9fSxfKFMucHJvdG90eXBlKSxTLnByb3RvdHlwZVthXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSx0LkFzeW5jSXRlcmF0b3I9Uyx0LmFzeW5jPWZ1bmN0aW9uKGUscixuLGksbyl7dm9pZCAwPT09byYmKG89UHJvbWlzZSk7dmFyIGE9bmV3IFModShlLHIsbixpKSxvKTtyZXR1cm4gdC5pc0dlbmVyYXRvckZ1bmN0aW9uKHIpP2E6YS5uZXh0KCkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHQuZG9uZT90LnZhbHVlOmEubmV4dCgpfSkpfSxfKHcpLGModyxzLFwiR2VuZXJhdG9yXCIpLHdbb109ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sdy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiW29iamVjdCBHZW5lcmF0b3JdXCJ9LHQua2V5cz1mdW5jdGlvbih0KXt2YXIgZT1bXTtmb3IodmFyIHIgaW4gdCllLnB1c2gocik7cmV0dXJuIGUucmV2ZXJzZSgpLGZ1bmN0aW9uIHIoKXt3aGlsZShlLmxlbmd0aCl7dmFyIG49ZS5wb3AoKTtpZihuIGluIHQpcmV0dXJuIHIudmFsdWU9bixyLmRvbmU9ITEscn1yZXR1cm4gci5kb25lPSEwLHJ9fSx0LnZhbHVlcz1BLGoucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpqLHJlc2V0OmZ1bmN0aW9uKHQpe2lmKHRoaXMucHJldj0wLHRoaXMubmV4dD0wLHRoaXMuc2VudD10aGlzLl9zZW50PWUsdGhpcy5kb25lPSExLHRoaXMuZGVsZWdhdGU9bnVsbCx0aGlzLm1ldGhvZD1cIm5leHRcIix0aGlzLmFyZz1lLHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKEMpLCF0KWZvcih2YXIgciBpbiB0aGlzKVwidFwiPT09ci5jaGFyQXQoMCkmJm4uY2FsbCh0aGlzLHIpJiYhaXNOYU4oK3Iuc2xpY2UoMSkpJiYodGhpc1tyXT1lKX0sc3RvcDpmdW5jdGlvbigpe3RoaXMuZG9uZT0hMDt2YXIgdD10aGlzLnRyeUVudHJpZXNbMF0sZT10LmNvbXBsZXRpb247aWYoXCJ0aHJvd1wiPT09ZS50eXBlKXRocm93IGUuYXJnO3JldHVybiB0aGlzLnJ2YWx9LGRpc3BhdGNoRXhjZXB0aW9uOmZ1bmN0aW9uKHQpe2lmKHRoaXMuZG9uZSl0aHJvdyB0O3ZhciByPXRoaXM7ZnVuY3Rpb24gaShuLGkpe3JldHVybiBzLnR5cGU9XCJ0aHJvd1wiLHMuYXJnPXQsci5uZXh0PW4saSYmKHIubWV0aG9kPVwibmV4dFwiLHIuYXJnPWUpLCEhaX1mb3IodmFyIG89dGhpcy50cnlFbnRyaWVzLmxlbmd0aC0xO28+PTA7LS1vKXt2YXIgYT10aGlzLnRyeUVudHJpZXNbb10scz1hLmNvbXBsZXRpb247aWYoXCJyb290XCI9PT1hLnRyeUxvYylyZXR1cm4gaShcImVuZFwiKTtpZihhLnRyeUxvYzw9dGhpcy5wcmV2KXt2YXIgYz1uLmNhbGwoYSxcImNhdGNoTG9jXCIpLHU9bi5jYWxsKGEsXCJmaW5hbGx5TG9jXCIpO2lmKGMmJnUpe2lmKHRoaXMucHJldjxhLmNhdGNoTG9jKXJldHVybiBpKGEuY2F0Y2hMb2MsITApO2lmKHRoaXMucHJldjxhLmZpbmFsbHlMb2MpcmV0dXJuIGkoYS5maW5hbGx5TG9jKX1lbHNlIGlmKGMpe2lmKHRoaXMucHJldjxhLmNhdGNoTG9jKXJldHVybiBpKGEuY2F0Y2hMb2MsITApfWVsc2V7aWYoIXUpdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7aWYodGhpcy5wcmV2PGEuZmluYWxseUxvYylyZXR1cm4gaShhLmZpbmFsbHlMb2MpfX19fSxhYnJ1cHQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9dGhpcy50cnlFbnRyaWVzLmxlbmd0aC0xO3I+PTA7LS1yKXt2YXIgaT10aGlzLnRyeUVudHJpZXNbcl07aWYoaS50cnlMb2M8PXRoaXMucHJldiYmbi5jYWxsKGksXCJmaW5hbGx5TG9jXCIpJiZ0aGlzLnByZXY8aS5maW5hbGx5TG9jKXt2YXIgbz1pO2JyZWFrfX1vJiYoXCJicmVha1wiPT09dHx8XCJjb250aW51ZVwiPT09dCkmJm8udHJ5TG9jPD1lJiZlPD1vLmZpbmFsbHlMb2MmJihvPW51bGwpO3ZhciBhPW8/by5jb21wbGV0aW9uOnt9O3JldHVybiBhLnR5cGU9dCxhLmFyZz1lLG8/KHRoaXMubWV0aG9kPVwibmV4dFwiLHRoaXMubmV4dD1vLmZpbmFsbHlMb2Msdik6dGhpcy5jb21wbGV0ZShhKX0sY29tcGxldGU6ZnVuY3Rpb24odCxlKXtpZihcInRocm93XCI9PT10LnR5cGUpdGhyb3cgdC5hcmc7cmV0dXJuXCJicmVha1wiPT09dC50eXBlfHxcImNvbnRpbnVlXCI9PT10LnR5cGU/dGhpcy5uZXh0PXQuYXJnOlwicmV0dXJuXCI9PT10LnR5cGU/KHRoaXMucnZhbD10aGlzLmFyZz10LmFyZyx0aGlzLm1ldGhvZD1cInJldHVyblwiLHRoaXMubmV4dD1cImVuZFwiKTpcIm5vcm1hbFwiPT09dC50eXBlJiZlJiYodGhpcy5uZXh0PWUpLHZ9LGZpbmlzaDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy50cnlFbnRyaWVzLmxlbmd0aC0xO2U+PTA7LS1lKXt2YXIgcj10aGlzLnRyeUVudHJpZXNbZV07aWYoci5maW5hbGx5TG9jPT09dClyZXR1cm4gdGhpcy5jb21wbGV0ZShyLmNvbXBsZXRpb24sci5hZnRlckxvYyksQyhyKSx2fX0sY2F0Y2g6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtlPj0wOy0tZSl7dmFyIHI9dGhpcy50cnlFbnRyaWVzW2VdO2lmKHIudHJ5TG9jPT09dCl7dmFyIG49ci5jb21wbGV0aW9uO2lmKFwidGhyb3dcIj09PW4udHlwZSl7dmFyIGk9bi5hcmc7QyhyKX1yZXR1cm4gaX19dGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpfSxkZWxlZ2F0ZVlpZWxkOmZ1bmN0aW9uKHQscixuKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZT17aXRlcmF0b3I6QSh0KSxyZXN1bHROYW1lOnIsbmV4dExvYzpufSxcIm5leHRcIj09PXRoaXMubWV0aG9kJiYodGhpcy5hcmc9ZSksdn19LHR9KHQuZXhwb3J0cyk7dHJ5e3JlZ2VuZXJhdG9yUnVudGltZT1ufWNhdGNoKGkpe0Z1bmN0aW9uKFwiclwiLFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShuKX19LFwiOTlhZlwiOmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiMjNlN1wiKSxpPXIoXCJkMDM5XCIpLG89cihcImU4YjVcIiksYT1yKFwiODYxZFwiKSxzPXIoXCI3YjBiXCIpLGM9cihcIjUwYzRcIiksdT1yKFwiODQxOFwiKSxmPXIoXCI2NWYwXCIpLGw9cihcIjFkZGVcIikscD1yKFwiYjYyMlwiKSxkPXIoXCIyZDAwXCIpLGg9cChcImlzQ29uY2F0U3ByZWFkYWJsZVwiKSx2PTkwMDcxOTkyNTQ3NDA5OTEsbT1cIk1heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZFwiLGc9ZD49NTF8fCFpKChmdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiB0W2hdPSExLHQuY29uY2F0KClbMF0hPT10fSkpLHk9bChcImNvbmNhdFwiKSxiPWZ1bmN0aW9uKHQpe2lmKCFhKHQpKXJldHVybiExO3ZhciBlPXRbaF07cmV0dXJuIHZvaWQgMCE9PWU/ISFlOm8odCl9LHg9IWd8fCF5O24oe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOnh9LHtjb25jYXQ6ZnVuY3Rpb24odCl7dmFyIGUscixuLGksbyxhPXModGhpcyksbD1mKGEsMCkscD0wO2ZvcihlPS0xLG49YXJndW1lbnRzLmxlbmd0aDtlPG47ZSsrKWlmKG89LTE9PT1lP2E6YXJndW1lbnRzW2VdLGIobykpe2lmKGk9YyhvLmxlbmd0aCkscCtpPnYpdGhyb3cgVHlwZUVycm9yKG0pO2ZvcihyPTA7cjxpO3IrKyxwKyspciBpbiBvJiZ1KGwscCxvW3JdKX1lbHNle2lmKHA+PXYpdGhyb3cgVHlwZUVycm9yKG0pO3UobCxwKyssbyl9cmV0dXJuIGwubGVuZ3RoPXAsbH19KX0sXCI5YmRkXCI6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCI4MjVhXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscixpKXt0cnl7cmV0dXJuIGk/ZShuKHIpWzBdLHJbMV0pOmUocil9Y2F0Y2goYSl7dmFyIG89dFtcInJldHVyblwiXTt0aHJvdyB2b2lkIDAhPT1vJiZuKG8uY2FsbCh0KSksYX19fSxcIjliZjJcIjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjgzYWJcIiksaT1yKFwiMGNmYlwiKSxvPXIoXCI4MjVhXCIpLGE9cihcImMwNGVcIikscz1PYmplY3QuZGVmaW5lUHJvcGVydHk7ZS5mPW4/czpmdW5jdGlvbih0LGUscil7aWYobyh0KSxlPWEoZSwhMCksbyhyKSxpKXRyeXtyZXR1cm4gcyh0LGUscil9Y2F0Y2gobil7fWlmKFwiZ2V0XCJpbiByfHxcInNldFwiaW4gcil0aHJvdyBUeXBlRXJyb3IoXCJBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm5cInZhbHVlXCJpbiByJiYodFtlXT1yLnZhbHVlKSx0fX0sXCI5ZWQzXCI6ZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoXCJhZTkzXCIpLkl0ZXJhdG9yUHJvdG90eXBlLGk9cihcIjdjNzNcIiksbz1yKFwiNWM2Y1wiKSxhPXIoXCJkNDRlXCIpLHM9cihcIjNmOGNcIiksYz1mdW5jdGlvbigpe3JldHVybiB0aGlzfTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIpe3ZhciB1PWUrXCIgSXRlcmF0b3JcIjtyZXR1cm4gdC5wcm90b3R5cGU9aShuLHtuZXh0Om8oMSxyKX0pLGEodCx1LCExLCEwKSxzW3VdPWMsdH19LFwiOWY3ZlwiOmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiZDAzOVwiKTtmdW5jdGlvbiBpKHQsZSl7cmV0dXJuIFJlZ0V4cCh0LGUpfWUuVU5TVVBQT1JURURfWT1uKChmdW5jdGlvbigpe3ZhciB0PWkoXCJhXCIsXCJ5XCIpO3JldHVybiB0Lmxhc3RJbmRleD0yLG51bGwhPXQuZXhlYyhcImFiY2RcIil9KSksZS5CUk9LRU5fQ0FSRVQ9bigoZnVuY3Rpb24oKXt2YXIgdD1pKFwiXnJcIixcImd5XCIpO3JldHVybiB0Lmxhc3RJbmRleD0yLG51bGwhPXQuZXhlYyhcInN0clwiKX0pKX0sYTIzMTpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjFkMWFcIik7XCJzdHJpbmdcIj09PXR5cGVvZiBuJiYobj1bW3QuaSxuLFwiXCJdXSksbi5sb2NhbHMmJih0LmV4cG9ydHM9bi5sb2NhbHMpO3ZhciBpPXIoXCI0OTllXCIpLmRlZmF1bHQ7aShcIjFlZjk1ZjEzXCIsbiwhMCx7c291cmNlTWFwOiExLHNoYWRvd01vZGU6ITF9KX0sYTRkMzpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cihcIjIzZTdcIiksaT1yKFwiZGE4NFwiKSxvPXIoXCJkMDY2XCIpLGE9cihcImM0MzBcIikscz1yKFwiODNhYlwiKSxjPXIoXCI0OTMwXCIpLHU9cihcImZkYmZcIiksZj1yKFwiZDAzOVwiKSxsPXIoXCI1MTM1XCIpLHA9cihcImU4YjVcIiksZD1yKFwiODYxZFwiKSxoPXIoXCI4MjVhXCIpLHY9cihcIjdiMGJcIiksbT1yKFwiZmM2YVwiKSxnPXIoXCJjMDRlXCIpLHk9cihcIjVjNmNcIiksYj1yKFwiN2M3M1wiKSx4PXIoXCJkZjc1XCIpLGs9cihcIjI0MWNcIiksdz1yKFwiMDU3ZlwiKSxfPXIoXCI3NDE4XCIpLFM9cihcIjA2Y2ZcIiksRT1yKFwiOWJmMlwiKSxUPXIoXCJkMWU3XCIpLE89cihcIjkxMTJcIiksQz1yKFwiNmVlYlwiKSxqPXIoXCI1NjkyXCIpLEE9cihcImY3NzJcIiksUD1yKFwiZDAxMlwiKSxSPXIoXCI5MGUzXCIpLEY9cihcImI2MjJcIiksST1yKFwiZTUzOFwiKSxOPXIoXCI3NDZmXCIpLEQ9cihcImQ0NGVcIiksTD1yKFwiNjlmM1wiKSxNPXIoXCJiNzI3XCIpLmZvckVhY2gsej1BKFwiaGlkZGVuXCIpLHE9XCJTeW1ib2xcIixWPVwicHJvdG90eXBlXCIsRz1GKFwidG9QcmltaXRpdmVcIiksJD1MLnNldCxCPUwuZ2V0dGVyRm9yKHEpLFU9T2JqZWN0W1ZdLFc9aS5TeW1ib2wsSD1vKFwiSlNPTlwiLFwic3RyaW5naWZ5XCIpLFg9Uy5mLFk9RS5mLEs9dy5mLEo9VC5mLFE9aihcInN5bWJvbHNcIiksWj1qKFwib3Atc3ltYm9sc1wiKSx0dD1qKFwic3RyaW5nLXRvLXN5bWJvbC1yZWdpc3RyeVwiKSxldD1qKFwic3ltYm9sLXRvLXN0cmluZy1yZWdpc3RyeVwiKSxydD1qKFwid2tzXCIpLG50PWkuUU9iamVjdCxpdD0hbnR8fCFudFtWXXx8IW50W1ZdLmZpbmRDaGlsZCxvdD1zJiZmKChmdW5jdGlvbigpe3JldHVybiA3IT1iKFkoe30sXCJhXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBZKHRoaXMsXCJhXCIse3ZhbHVlOjd9KS5hfX0pKS5hfSkpP2Z1bmN0aW9uKHQsZSxyKXt2YXIgbj1YKFUsZSk7biYmZGVsZXRlIFVbZV0sWSh0LGUsciksbiYmdCE9PVUmJlkoVSxlLG4pfTpZLGF0PWZ1bmN0aW9uKHQsZSl7dmFyIHI9UVt0XT1iKFdbVl0pO3JldHVybiAkKHIse3R5cGU6cSx0YWc6dCxkZXNjcmlwdGlvbjplfSksc3x8KHIuZGVzY3JpcHRpb249ZSkscn0sc3Q9dT9mdW5jdGlvbih0KXtyZXR1cm5cInN5bWJvbFwiPT10eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdCh0KWluc3RhbmNlb2YgV30sY3Q9ZnVuY3Rpb24odCxlLHIpe3Q9PT1VJiZjdChaLGUsciksaCh0KTt2YXIgbj1nKGUsITApO3JldHVybiBoKHIpLGwoUSxuKT8oci5lbnVtZXJhYmxlPyhsKHQseikmJnRbel1bbl0mJih0W3pdW25dPSExKSxyPWIocix7ZW51bWVyYWJsZTp5KDAsITEpfSkpOihsKHQseil8fFkodCx6LHkoMSx7fSkpLHRbel1bbl09ITApLG90KHQsbixyKSk6WSh0LG4scil9LHV0PWZ1bmN0aW9uKHQsZSl7aCh0KTt2YXIgcj1tKGUpLG49eChyKS5jb25jYXQoaHQocikpO3JldHVybiBNKG4sKGZ1bmN0aW9uKGUpe3MmJiFsdC5jYWxsKHIsZSl8fGN0KHQsZSxyW2VdKX0pKSx0fSxmdD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lP2IodCk6dXQoYih0KSxlKX0sbHQ9ZnVuY3Rpb24odCl7dmFyIGU9Zyh0LCEwKSxyPUouY2FsbCh0aGlzLGUpO3JldHVybiEodGhpcz09PVUmJmwoUSxlKSYmIWwoWixlKSkmJighKHJ8fCFsKHRoaXMsZSl8fCFsKFEsZSl8fGwodGhpcyx6KSYmdGhpc1t6XVtlXSl8fHIpfSxwdD1mdW5jdGlvbih0LGUpe3ZhciByPW0odCksbj1nKGUsITApO2lmKHIhPT1VfHwhbChRLG4pfHxsKFosbikpe3ZhciBpPVgocixuKTtyZXR1cm4haXx8IWwoUSxuKXx8bChyLHopJiZyW3pdW25dfHwoaS5lbnVtZXJhYmxlPSEwKSxpfX0sZHQ9ZnVuY3Rpb24odCl7dmFyIGU9SyhtKHQpKSxyPVtdO3JldHVybiBNKGUsKGZ1bmN0aW9uKHQpe2woUSx0KXx8bChQLHQpfHxyLnB1c2godCl9KSkscn0saHQ9ZnVuY3Rpb24odCl7dmFyIGU9dD09PVUscj1LKGU/WjptKHQpKSxuPVtdO3JldHVybiBNKHIsKGZ1bmN0aW9uKHQpeyFsKFEsdCl8fGUmJiFsKFUsdCl8fG4ucHVzaChRW3RdKX0pKSxufTtpZihjfHwoVz1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiBXKXRocm93IFR5cGVFcnJvcihcIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvclwiKTt2YXIgdD1hcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/U3RyaW5nKGFyZ3VtZW50c1swXSk6dm9pZCAwLGU9Uih0KSxyPWZ1bmN0aW9uKHQpe3RoaXM9PT1VJiZyLmNhbGwoWix0KSxsKHRoaXMseikmJmwodGhpc1t6XSxlKSYmKHRoaXNbel1bZV09ITEpLG90KHRoaXMsZSx5KDEsdCkpfTtyZXR1cm4gcyYmaXQmJm90KFUsZSx7Y29uZmlndXJhYmxlOiEwLHNldDpyfSksYXQoZSx0KX0sQyhXW1ZdLFwidG9TdHJpbmdcIiwoZnVuY3Rpb24oKXtyZXR1cm4gQih0aGlzKS50YWd9KSksQyhXLFwid2l0aG91dFNldHRlclwiLChmdW5jdGlvbih0KXtyZXR1cm4gYXQoUih0KSx0KX0pKSxULmY9bHQsRS5mPWN0LFMuZj1wdCxrLmY9dy5mPWR0LF8uZj1odCxJLmY9ZnVuY3Rpb24odCl7cmV0dXJuIGF0KEYodCksdCl9LHMmJihZKFdbVl0sXCJkZXNjcmlwdGlvblwiLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEIodGhpcykuZGVzY3JpcHRpb259fSksYXx8QyhVLFwicHJvcGVydHlJc0VudW1lcmFibGVcIixsdCx7dW5zYWZlOiEwfSkpKSxuKHtnbG9iYWw6ITAsd3JhcDohMCxmb3JjZWQ6IWMsc2hhbTohY30se1N5bWJvbDpXfSksTSh4KHJ0KSwoZnVuY3Rpb24odCl7Tih0KX0pKSxuKHt0YXJnZXQ6cSxzdGF0OiEwLGZvcmNlZDohY30se2ZvcjpmdW5jdGlvbih0KXt2YXIgZT1TdHJpbmcodCk7aWYobCh0dCxlKSlyZXR1cm4gdHRbZV07dmFyIHI9VyhlKTtyZXR1cm4gdHRbZV09cixldFtyXT1lLHJ9LGtleUZvcjpmdW5jdGlvbih0KXtpZighc3QodCkpdGhyb3cgVHlwZUVycm9yKHQrXCIgaXMgbm90IGEgc3ltYm9sXCIpO2lmKGwoZXQsdCkpcmV0dXJuIGV0W3RdfSx1c2VTZXR0ZXI6ZnVuY3Rpb24oKXtpdD0hMH0sdXNlU2ltcGxlOmZ1bmN0aW9uKCl7aXQ9ITF9fSksbih7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxmb3JjZWQ6IWMsc2hhbTohc30se2NyZWF0ZTpmdCxkZWZpbmVQcm9wZXJ0eTpjdCxkZWZpbmVQcm9wZXJ0aWVzOnV0LGdldE93blByb3BlcnR5RGVzY3JpcHRvcjpwdH0pLG4oe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOiFjfSx7Z2V0T3duUHJvcGVydHlOYW1lczpkdCxnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6aHR9KSxuKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDpmKChmdW5jdGlvbigpe18uZigxKX0pKX0se2dldE93blByb3BlcnR5U3ltYm9sczpmdW5jdGlvbih0KXtyZXR1cm4gXy5mKHYodCkpfX0pLEgpe3ZhciB2dD0hY3x8ZigoZnVuY3Rpb24oKXt2YXIgdD1XKCk7cmV0dXJuXCJbbnVsbF1cIiE9SChbdF0pfHxcInt9XCIhPUgoe2E6dH0pfHxcInt9XCIhPUgoT2JqZWN0KHQpKX0pKTtuKHt0YXJnZXQ6XCJKU09OXCIsc3RhdDohMCxmb3JjZWQ6dnR9LHtzdHJpbmdpZnk6ZnVuY3Rpb24odCxlLHIpe3ZhciBuLGk9W3RdLG89MTt3aGlsZShhcmd1bWVudHMubGVuZ3RoPm8paS5wdXNoKGFyZ3VtZW50c1tvKytdKTtpZihuPWUsKGQoZSl8fHZvaWQgMCE9PXQpJiYhc3QodCkpcmV0dXJuIHAoZSl8fChlPWZ1bmN0aW9uKHQsZSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgbiYmKGU9bi5jYWxsKHRoaXMsdCxlKSksIXN0KGUpKXJldHVybiBlfSksaVsxXT1lLEguYXBwbHkobnVsbCxpKX19KX1XW1ZdW0ddfHxPKFdbVl0sRyxXW1ZdLnZhbHVlT2YpLEQoVyxxKSxQW3pdPSEwfSxhNjIzOmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiMjNlN1wiKSxpPXIoXCJiNzI3XCIpLmV2ZXJ5LG89cihcImE2NDBcIiksYT1yKFwiYWU0MFwiKSxzPW8oXCJldmVyeVwiKSxjPWEoXCJldmVyeVwiKTtuKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohc3x8IWN9LHtldmVyeTpmdW5jdGlvbih0KXtyZXR1cm4gaSh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pfSxhNjQwOmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiZDAzOVwiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgcj1bXVt0XTtyZXR1cm4hIXImJm4oKGZ1bmN0aW9uKCl7ci5jYWxsKG51bGwsZXx8ZnVuY3Rpb24oKXt0aHJvdyAxfSwxKX0pKX19LGE2OTE6ZnVuY3Rpb24odCxlKXt2YXIgcj1NYXRoLmNlaWwsbj1NYXRoLmZsb29yO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gaXNOYU4odD0rdCk/MDoodD4wP246cikodCl9fSxhOTFhOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiMjRmYlwiKTtlPW4oITEpLGUucHVzaChbdC5pLFwiLmVwLWNpcmNsZS0tcHJvZ3Jlc3NfX2RvdC1jb250YWluZXJbZGF0YS12LTM4Y2ExNjdmXXtwb3NpdGlvbjphYnNvbHV0ZTstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46Y2VudGVyIGNlbnRlcjt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlciBjZW50ZXJ9LmVwLWNpcmNsZS0tcHJvZ3Jlc3NfX2RvdC1jb250YWluZXIuaGlkZGVuW2RhdGEtdi0zOGNhMTY3Zl17LXdlYmtpdC10cmFuc2l0aW9uLWR1cmF0aW9uOjBzOy1vLXRyYW5zaXRpb24tZHVyYXRpb246MHM7dHJhbnNpdGlvbi1kdXJhdGlvbjowc30uZXAtY2lyY2xlLS1wcm9ncmVzc19fZG90LWNvbnRhaW5lcj5kaXZbZGF0YS12LTM4Y2ExNjdmXXtwb3NpdGlvbjpyZWxhdGl2ZX0uZXAtY2lyY2xlLS1wcm9ncmVzc19fZG90W2RhdGEtdi0zOGNhMTY3Zl17LXdlYmtpdC10cmFuc2l0aW9uLWR1cmF0aW9uOi4yczstby10cmFuc2l0aW9uLWR1cmF0aW9uOi4yczt0cmFuc2l0aW9uLWR1cmF0aW9uOi4yczstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luOmF1dG87cmlnaHQ6MDtsZWZ0OjB9LmVwLWNpcmNsZS0tcHJvZ3Jlc3NfX2RvdC5lcC1oaWRkZW5bZGF0YS12LTM4Y2ExNjdmXXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSgwKTt0cmFuc2Zvcm06c2NhbGUoMCl9XCIsXCJcIl0pLHQuZXhwb3J0cz1lfSxhOWUzOmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiODNhYlwiKSxpPXIoXCJkYTg0XCIpLG89cihcIjk0Y2FcIiksYT1yKFwiNmVlYlwiKSxzPXIoXCI1MTM1XCIpLGM9cihcImM2YjZcIiksdT1yKFwiNzE1NlwiKSxmPXIoXCJjMDRlXCIpLGw9cihcImQwMzlcIikscD1yKFwiN2M3M1wiKSxkPXIoXCIyNDFjXCIpLmYsaD1yKFwiMDZjZlwiKS5mLHY9cihcIjliZjJcIikuZixtPXIoXCI1OGE4XCIpLnRyaW0sZz1cIk51bWJlclwiLHk9aVtnXSxiPXkucHJvdG90eXBlLHg9YyhwKGIpKT09ZyxrPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbixpLG8sYSxzLGMsdT1mKHQsITEpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB1JiZ1Lmxlbmd0aD4yKWlmKHU9bSh1KSxlPXUuY2hhckNvZGVBdCgwKSw0Mz09PWV8fDQ1PT09ZSl7aWYocj11LmNoYXJDb2RlQXQoMiksODg9PT1yfHwxMjA9PT1yKXJldHVybiBOYU59ZWxzZSBpZig0OD09PWUpe3N3aXRjaCh1LmNoYXJDb2RlQXQoMSkpe2Nhc2UgNjY6Y2FzZSA5ODpuPTIsaT00OTticmVhaztjYXNlIDc5OmNhc2UgMTExOm49OCxpPTU1O2JyZWFrO2RlZmF1bHQ6cmV0dXJuK3V9Zm9yKG89dS5zbGljZSgyKSxhPW8ubGVuZ3RoLHM9MDtzPGE7cysrKWlmKGM9by5jaGFyQ29kZUF0KHMpLGM8NDh8fGM+aSlyZXR1cm4gTmFOO3JldHVybiBwYXJzZUludChvLG4pfXJldHVybit1fTtpZihvKGcsIXkoXCIgMG8xXCIpfHwheShcIjBiMVwiKXx8eShcIisweDFcIikpKXtmb3IodmFyIHcsXz1mdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPDE/MDp0LHI9dGhpcztyZXR1cm4gciBpbnN0YW5jZW9mIF8mJih4P2woKGZ1bmN0aW9uKCl7Yi52YWx1ZU9mLmNhbGwocil9KSk6YyhyKSE9Zyk/dShuZXcgeShrKGUpKSxyLF8pOmsoZSl9LFM9bj9kKHkpOlwiTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLE1JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXJcIi5zcGxpdChcIixcIiksRT0wO1MubGVuZ3RoPkU7RSsrKXMoeSx3PVNbRV0pJiYhcyhfLHcpJiZ2KF8sdyxoKHksdykpO18ucHJvdG90eXBlPWIsYi5jb25zdHJ1Y3Rvcj1fLGEoaSxnLF8pfX0sYWIxMzpmdW5jdGlvbih0LGUscil7dmFyIG49cihcImI2MjJcIiksaT1uKFwibWF0Y2hcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlPS8uLzt0cnl7XCIvLi9cIlt0XShlKX1jYXRjaChyKXt0cnl7cmV0dXJuIGVbaV09ITEsXCIvLi9cIlt0XShlKX1jYXRjaChuKXt9fXJldHVybiExfX0sYWMxZjpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cihcIjIzZTdcIiksaT1yKFwiOTI2M1wiKTtuKHt0YXJnZXQ6XCJSZWdFeHBcIixwcm90bzohMCxmb3JjZWQ6Ly4vLmV4ZWMhPT1pfSx7ZXhlYzppfSl9LGFkNmQ6ZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoXCI4MjVhXCIpO3QuZXhwb3J0cz1mdW5jdGlvbigpe3ZhciB0PW4odGhpcyksZT1cIlwiO3JldHVybiB0Lmdsb2JhbCYmKGUrPVwiZ1wiKSx0Lmlnbm9yZUNhc2UmJihlKz1cImlcIiksdC5tdWx0aWxpbmUmJihlKz1cIm1cIiksdC5kb3RBbGwmJihlKz1cInNcIiksdC51bmljb2RlJiYoZSs9XCJ1XCIpLHQuc3RpY2t5JiYoZSs9XCJ5XCIpLGV9fSxhZTQwOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiODNhYlwiKSxpPXIoXCJkMDM5XCIpLG89cihcIjUxMzVcIiksYT1PYmplY3QuZGVmaW5lUHJvcGVydHkscz17fSxjPWZ1bmN0aW9uKHQpe3Rocm93IHR9O3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2lmKG8ocyx0KSlyZXR1cm4gc1t0XTtlfHwoZT17fSk7dmFyIHI9W11bdF0sdT0hIW8oZSxcIkFDQ0VTU09SU1wiKSYmZS5BQ0NFU1NPUlMsZj1vKGUsMCk/ZVswXTpjLGw9byhlLDEpP2VbMV06dm9pZCAwO3JldHVybiBzW3RdPSEhciYmIWkoKGZ1bmN0aW9uKCl7aWYodSYmIW4pcmV0dXJuITA7dmFyIHQ9e2xlbmd0aDotMX07dT9hKHQsMSx7ZW51bWVyYWJsZTohMCxnZXQ6Y30pOnRbMV09MSxyLmNhbGwodCxmLGwpfSkpfX0sYWU5MzpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG4saSxvLGE9cihcImUxNjNcIikscz1yKFwiOTExMlwiKSxjPXIoXCI1MTM1XCIpLHU9cihcImI2MjJcIiksZj1yKFwiYzQzMFwiKSxsPXUoXCJpdGVyYXRvclwiKSxwPSExLGQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307W10ua2V5cyYmKG89W10ua2V5cygpLFwibmV4dFwiaW4gbz8oaT1hKGEobykpLGkhPT1PYmplY3QucHJvdG90eXBlJiYobj1pKSk6cD0hMCksdm9pZCAwPT1uJiYobj17fSksZnx8YyhuLGwpfHxzKG4sbCxkKSx0LmV4cG9ydHM9e0l0ZXJhdG9yUHJvdG90eXBlOm4sQlVHR1lfU0FGQVJJX0lURVJBVE9SUzpwfX0sYjA0MTpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cihcIjAwZWVcIiksaT1yKFwiZjVkZlwiKTt0LmV4cG9ydHM9bj97fS50b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiW29iamVjdCBcIitpKHRoaXMpK1wiXVwifX0sYjU3NTpmdW5jdGlvbih0LGUscil7dmFyIG4saSxvLGEscyxjLHUsZixsPXIoXCJkYTg0XCIpLHA9cihcIjA2Y2ZcIikuZixkPXIoXCJjNmI2XCIpLGg9cihcIjJjZjRcIikuc2V0LHY9cihcIjFjZGNcIiksbT1sLk11dGF0aW9uT2JzZXJ2ZXJ8fGwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcixnPWwucHJvY2Vzcyx5PWwuUHJvbWlzZSxiPVwicHJvY2Vzc1wiPT1kKGcpLHg9cChsLFwicXVldWVNaWNyb3Rhc2tcIiksaz14JiZ4LnZhbHVlO2t8fChuPWZ1bmN0aW9uKCl7dmFyIHQsZTtiJiYodD1nLmRvbWFpbikmJnQuZXhpdCgpO3doaWxlKGkpe2U9aS5mbixpPWkubmV4dDt0cnl7ZSgpfWNhdGNoKHIpe3Rocm93IGk/YSgpOm89dm9pZCAwLHJ9fW89dm9pZCAwLHQmJnQuZW50ZXIoKX0sYj9hPWZ1bmN0aW9uKCl7Zy5uZXh0VGljayhuKX06bSYmIXY/KHM9ITAsYz1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKSxuZXcgbShuKS5vYnNlcnZlKGMse2NoYXJhY3RlckRhdGE6ITB9KSxhPWZ1bmN0aW9uKCl7Yy5kYXRhPXM9IXN9KTp5JiZ5LnJlc29sdmU/KHU9eS5yZXNvbHZlKHZvaWQgMCksZj11LnRoZW4sYT1mdW5jdGlvbigpe2YuY2FsbCh1LG4pfSk6YT1mdW5jdGlvbigpe2guY2FsbChsLG4pfSksdC5leHBvcnRzPWt8fGZ1bmN0aW9uKHQpe3ZhciBlPXtmbjp0LG5leHQ6dm9pZCAwfTtvJiYoby5uZXh0PWUpLGl8fChpPWUsYSgpKSxvPWV9fSxiNjIyOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiZGE4NFwiKSxpPXIoXCI1NjkyXCIpLG89cihcIjUxMzVcIiksYT1yKFwiOTBlM1wiKSxzPXIoXCI0OTMwXCIpLGM9cihcImZkYmZcIiksdT1pKFwid2tzXCIpLGY9bi5TeW1ib2wsbD1jP2Y6ZiYmZi53aXRob3V0U2V0dGVyfHxhO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gbyh1LHQpfHwocyYmbyhmLHQpP3VbdF09Zlt0XTp1W3RdPWwoXCJTeW1ib2wuXCIrdCkpLHVbdF19fSxiNjRiOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiMjNlN1wiKSxpPXIoXCI3YjBiXCIpLG89cihcImRmNzVcIiksYT1yKFwiZDAzOVwiKSxzPWEoKGZ1bmN0aW9uKCl7bygxKX0pKTtuKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDpzfSx7a2V5czpmdW5jdGlvbih0KXtyZXR1cm4gbyhpKHQpKX19KX0sYjY4MDpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cihcIjIzZTdcIiksaT1yKFwiYTY5MVwiKSxvPXIoXCI0MDhhXCIpLGE9cihcIjExNDhcIikscz1yKFwiZDAzOVwiKSxjPTEuLnRvRml4ZWQsdT1NYXRoLmZsb29yLGY9ZnVuY3Rpb24odCxlLHIpe3JldHVybiAwPT09ZT9yOmUlMj09PTE/Zih0LGUtMSxyKnQpOmYodCp0LGUvMixyKX0sbD1mdW5jdGlvbih0KXt2YXIgZT0wLHI9dDt3aGlsZShyPj00MDk2KWUrPTEyLHIvPTQwOTY7d2hpbGUocj49MillKz0xLHIvPTI7cmV0dXJuIGV9LHA9YyYmKFwiMC4wMDBcIiE9PThlLTUudG9GaXhlZCgzKXx8XCIxXCIhPT0uOS50b0ZpeGVkKDApfHxcIjEuMjVcIiE9PTEuMjU1LnRvRml4ZWQoMil8fFwiMTAwMDAwMDAwMDAwMDAwMDEyOFwiIT09KDB4ZGUwYjZiM2E3NjQwMDgwKS50b0ZpeGVkKDApKXx8IXMoKGZ1bmN0aW9uKCl7Yy5jYWxsKHt9KX0pKTtuKHt0YXJnZXQ6XCJOdW1iZXJcIixwcm90bzohMCxmb3JjZWQ6cH0se3RvRml4ZWQ6ZnVuY3Rpb24odCl7dmFyIGUscixuLHMsYz1vKHRoaXMpLHA9aSh0KSxkPVswLDAsMCwwLDAsMF0saD1cIlwiLHY9XCIwXCIsbT1mdW5jdGlvbih0LGUpe3ZhciByPS0xLG49ZTt3aGlsZSgrK3I8NiluKz10KmRbcl0sZFtyXT1uJTFlNyxuPXUobi8xZTcpfSxnPWZ1bmN0aW9uKHQpe3ZhciBlPTYscj0wO3doaWxlKC0tZT49MClyKz1kW2VdLGRbZV09dShyL3QpLHI9ciV0KjFlN30seT1mdW5jdGlvbigpe3ZhciB0PTYsZT1cIlwiO3doaWxlKC0tdD49MClpZihcIlwiIT09ZXx8MD09PXR8fDAhPT1kW3RdKXt2YXIgcj1TdHJpbmcoZFt0XSk7ZT1cIlwiPT09ZT9yOmUrYS5jYWxsKFwiMFwiLDctci5sZW5ndGgpK3J9cmV0dXJuIGV9O2lmKHA8MHx8cD4yMCl0aHJvdyBSYW5nZUVycm9yKFwiSW5jb3JyZWN0IGZyYWN0aW9uIGRpZ2l0c1wiKTtpZihjIT1jKXJldHVyblwiTmFOXCI7aWYoYzw9LTFlMjF8fGM+PTFlMjEpcmV0dXJuIFN0cmluZyhjKTtpZihjPDAmJihoPVwiLVwiLGM9LWMpLGM+MWUtMjEpaWYoZT1sKGMqZigyLDY5LDEpKS02OSxyPWU8MD9jKmYoMiwtZSwxKTpjL2YoMixlLDEpLHIqPTQ1MDM1OTk2MjczNzA0OTYsZT01Mi1lLGU+MCl7bSgwLHIpLG49cDt3aGlsZShuPj03KW0oMWU3LDApLG4tPTc7bShmKDEwLG4sMSksMCksbj1lLTE7d2hpbGUobj49MjMpZygxPDwyMyksbi09MjM7ZygxPDxuKSxtKDEsMSksZygyKSx2PXkoKX1lbHNlIG0oMCxyKSxtKDE8PC1lLDApLHY9eSgpK2EuY2FsbChcIjBcIixwKTtyZXR1cm4gcD4wPyhzPXYubGVuZ3RoLHY9aCsoczw9cD9cIjAuXCIrYS5jYWxsKFwiMFwiLHAtcykrdjp2LnNsaWNlKDAscy1wKStcIi5cIit2LnNsaWNlKHMtcCkpKTp2PWgrdix2fX0pfSxiNzI3OmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiMDM2NlwiKSxpPXIoXCI0NGFkXCIpLG89cihcIjdiMGJcIiksYT1yKFwiNTBjNFwiKSxzPXIoXCI2NWYwXCIpLGM9W10ucHVzaCx1PWZ1bmN0aW9uKHQpe3ZhciBlPTE9PXQscj0yPT10LHU9Mz09dCxmPTQ9PXQsbD02PT10LHA9NT09dHx8bDtyZXR1cm4gZnVuY3Rpb24oZCxoLHYsbSl7Zm9yKHZhciBnLHksYj1vKGQpLHg9aShiKSxrPW4oaCx2LDMpLHc9YSh4Lmxlbmd0aCksXz0wLFM9bXx8cyxFPWU/UyhkLHcpOnI/UyhkLDApOnZvaWQgMDt3Pl87XysrKWlmKChwfHxfIGluIHgpJiYoZz14W19dLHk9ayhnLF8sYiksdCkpaWYoZSlFW19dPXk7ZWxzZSBpZih5KXN3aXRjaCh0KXtjYXNlIDM6cmV0dXJuITA7Y2FzZSA1OnJldHVybiBnO2Nhc2UgNjpyZXR1cm4gXztjYXNlIDI6Yy5jYWxsKEUsZyl9ZWxzZSBpZihmKXJldHVybiExO3JldHVybiBsPy0xOnV8fGY/ZjpFfX07dC5leHBvcnRzPXtmb3JFYWNoOnUoMCksbWFwOnUoMSksZmlsdGVyOnUoMiksc29tZTp1KDMpLGV2ZXJ5OnUoNCksZmluZDp1KDUpLGZpbmRJbmRleDp1KDYpfX0sYzA0ZTpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjg2MWRcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7aWYoIW4odCkpcmV0dXJuIHQ7dmFyIHIsaTtpZihlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZihyPXQudG9TdHJpbmcpJiYhbihpPXIuY2FsbCh0KSkpcmV0dXJuIGk7aWYoXCJmdW5jdGlvblwiPT10eXBlb2Yocj10LnZhbHVlT2YpJiYhbihpPXIuY2FsbCh0KSkpcmV0dXJuIGk7aWYoIWUmJlwiZnVuY3Rpb25cIj09dHlwZW9mKHI9dC50b1N0cmluZykmJiFuKGk9ci5jYWxsKHQpKSlyZXR1cm4gaTt0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIil9fSxjNDMwOmZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPSExfSxjNDllOmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiZmVjMVwiKSxpPXIubihuKTtpLmF9LGM2YjY6ZnVuY3Rpb24odCxlKXt2YXIgcj17fS50b1N0cmluZzt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHIuY2FsbCh0KS5zbGljZSg4LC0xKX19LGM2Y2Q6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJkYTg0XCIpLGk9cihcImNlNGVcIiksbz1cIl9fY29yZS1qc19zaGFyZWRfX1wiLGE9bltvXXx8aShvLHt9KTt0LmV4cG9ydHM9YX0sYzhiYTpmdW5jdGlvbih0LGUpe3ZhciByO3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKTt0cnl7cj1yfHxuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfWNhdGNoKG4pe1wib2JqZWN0XCI9PT10eXBlb2Ygd2luZG93JiYocj13aW5kb3cpfXQuZXhwb3J0cz1yfSxjOGQyOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiZDAzOVwiKSxpPXIoXCI1ODk5XCIpLG89XCLigIvCheGgjlwiO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gbigoZnVuY3Rpb24oKXtyZXR1cm4hIWlbdF0oKXx8b1t0XSgpIT1vfHxpW3RdLm5hbWUhPT10fSkpfX0sY2E4NDpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjUxMzVcIiksaT1yKFwiZmM2YVwiKSxvPXIoXCI0ZDY0XCIpLmluZGV4T2YsYT1yKFwiZDAxMlwiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgcixzPWkodCksYz0wLHU9W107Zm9yKHIgaW4gcykhbihhLHIpJiZuKHMscikmJnUucHVzaChyKTt3aGlsZShlLmxlbmd0aD5jKW4ocyxyPWVbYysrXSkmJih+byh1LHIpfHx1LnB1c2gocikpO3JldHVybiB1fX0sY2FhZDpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cihcIjIzZTdcIiksaT1yKFwiNGQ2NFwiKS5pbmNsdWRlcyxvPXIoXCI0NGQyXCIpLGE9cihcImFlNDBcIikscz1hKFwiaW5kZXhPZlwiLHtBQ0NFU1NPUlM6ITAsMTowfSk7bih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IXN9LHtpbmNsdWRlczpmdW5jdGlvbih0KXtyZXR1cm4gaSh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pLG8oXCJpbmNsdWRlc1wiKX0sY2MxMjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcImRhODRcIiksaT1yKFwiODYxZFwiKSxvPW4uZG9jdW1lbnQsYT1pKG8pJiZpKG8uY3JlYXRlRWxlbWVudCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBhP28uY3JlYXRlRWxlbWVudCh0KTp7fX19LGNkZjk6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCI4MjVhXCIpLGk9cihcIjg2MWRcIiksbz1yKFwiZjA2OVwiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtpZihuKHQpLGkoZSkmJmUuY29uc3RydWN0b3I9PT10KXJldHVybiBlO3ZhciByPW8uZih0KSxhPXIucmVzb2x2ZTtyZXR1cm4gYShlKSxyLnByb21pc2V9fSxjZTRlOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiZGE4NFwiKSxpPXIoXCI5MTEyXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3RyeXtpKG4sdCxlKX1jYXRjaChyKXtuW3RdPWV9cmV0dXJuIGV9fSxkMDEyOmZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPXt9fSxkMDM5OmZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4hIXQoKX1jYXRjaChlKXtyZXR1cm4hMH19fSxkMDY2OmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiNDI4ZlwiKSxpPXIoXCJkYTg0XCIpLG89ZnVuY3Rpb24odCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdD90OnZvaWQgMH07dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg8Mj9vKG5bdF0pfHxvKGlbdF0pOm5bdF0mJm5bdF1bZV18fGlbdF0mJmlbdF1bZV19fSxkMDdmOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiYTkxYVwiKTtcInN0cmluZ1wiPT09dHlwZW9mIG4mJihuPVtbdC5pLG4sXCJcIl1dKSxuLmxvY2FscyYmKHQuZXhwb3J0cz1uLmxvY2Fscyk7dmFyIGk9cihcIjQ5OWVcIikuZGVmYXVsdDtpKFwiYTJmYWUyY2NcIixuLCEwLHtzb3VyY2VNYXA6ITEsc2hhZG93TW9kZTohMX0pfSxkMWU3OmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Isbz1pJiYhbi5jYWxsKHsxOjJ9LDEpO2UuZj1vP2Z1bmN0aW9uKHQpe3ZhciBlPWkodGhpcyx0KTtyZXR1cm4hIWUmJmUuZW51bWVyYWJsZX06bn0sZDI4YjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjc0NmZcIik7bihcIml0ZXJhdG9yXCIpfSxkMmJiOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiODI1YVwiKSxpPXIoXCIzYmJlXCIpO3QuZXhwb3J0cz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fChcIl9fcHJvdG9fX1wiaW57fT9mdW5jdGlvbigpe3ZhciB0LGU9ITEscj17fTt0cnl7dD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsXCJfX3Byb3RvX19cIikuc2V0LHQuY2FsbChyLFtdKSxlPXIgaW5zdGFuY2VvZiBBcnJheX1jYXRjaChvKXt9cmV0dXJuIGZ1bmN0aW9uKHIsbyl7cmV0dXJuIG4ociksaShvKSxlP3QuY2FsbChyLG8pOnIuX19wcm90b19fPW8scn19KCk6dm9pZCAwKX0sZDMwYzpmdW5jdGlvbih0LGUscil7dmFyIG49cihcImQ1YTRcIik7XCJzdHJpbmdcIj09PXR5cGVvZiBuJiYobj1bW3QuaSxuLFwiXCJdXSksbi5sb2NhbHMmJih0LmV4cG9ydHM9bi5sb2NhbHMpO3ZhciBpPXIoXCI0OTllXCIpLmRlZmF1bHQ7aShcIjNkMGFlYzI5XCIsbiwhMCx7c291cmNlTWFwOiExLHNoYWRvd01vZGU6ITF9KX0sZDNiNzpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjAwZWVcIiksaT1yKFwiNmVlYlwiKSxvPXIoXCJiMDQxXCIpO258fGkoT2JqZWN0LnByb3RvdHlwZSxcInRvU3RyaW5nXCIsbyx7dW5zYWZlOiEwfSl9LGQ0NGU6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCI5YmYyXCIpLmYsaT1yKFwiNTEzNVwiKSxvPXIoXCJiNjIyXCIpLGE9byhcInRvU3RyaW5nVGFnXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscil7dCYmIWkodD1yP3Q6dC5wcm90b3R5cGUsYSkmJm4odCxhLHtjb25maWd1cmFibGU6ITAsdmFsdWU6ZX0pfX0sZDU4ZjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjFjMGJcIiksaT1yKFwiN2IwYlwiKSxvPXIoXCI0NGFkXCIpLGE9cihcIjUwYzRcIikscz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxyLHMsYyl7bihyKTt2YXIgdT1pKGUpLGY9byh1KSxsPWEodS5sZW5ndGgpLHA9dD9sLTE6MCxkPXQ/LTE6MTtpZihzPDIpd2hpbGUoMSl7aWYocCBpbiBmKXtjPWZbcF0scCs9ZDticmVha31pZihwKz1kLHQ/cDwwOmw8PXApdGhyb3cgVHlwZUVycm9yKFwiUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZVwiKX1mb3IoO3Q/cD49MDpsPnA7cCs9ZClwIGluIGYmJihjPXIoYyxmW3BdLHAsdSkpO3JldHVybiBjfX07dC5leHBvcnRzPXtsZWZ0OnMoITEpLHJpZ2h0OnMoITApfX0sZDVhNDpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjI0ZmJcIik7ZT1uKCExKSxlLnB1c2goW3QuaSxcIi5lcC1jaXJjbGVbZGF0YS12LTdkMGEwZmJiXXstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46NTAlIDUwJTt0cmFuc2Zvcm0tb3JpZ2luOjUwJSA1MCV9XCIsXCJcIl0pLHQuZXhwb3J0cz1lfSxkNzg0OmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyKFwiYWMxZlwiKTt2YXIgbj1yKFwiNmVlYlwiKSxpPXIoXCJkMDM5XCIpLG89cihcImI2MjJcIiksYT1yKFwiOTI2M1wiKSxzPXIoXCI5MTEyXCIpLGM9byhcInNwZWNpZXNcIiksdT0haSgoZnVuY3Rpb24oKXt2YXIgdD0vLi87cmV0dXJuIHQuZXhlYz1mdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiB0Lmdyb3Vwcz17YTpcIjdcIn0sdH0sXCI3XCIhPT1cIlwiLnJlcGxhY2UodCxcIiQ8YT5cIil9KSksZj1mdW5jdGlvbigpe3JldHVyblwiJDBcIj09PVwiYVwiLnJlcGxhY2UoLy4vLFwiJDBcIil9KCksbD1vKFwicmVwbGFjZVwiKSxwPWZ1bmN0aW9uKCl7cmV0dXJuISEvLi9bbF0mJlwiXCI9PT0vLi9bbF0oXCJhXCIsXCIkMFwiKX0oKSxkPSFpKChmdW5jdGlvbigpe3ZhciB0PS8oPzopLyxlPXQuZXhlYzt0LmV4ZWM9ZnVuY3Rpb24oKXtyZXR1cm4gZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciByPVwiYWJcIi5zcGxpdCh0KTtyZXR1cm4gMiE9PXIubGVuZ3RofHxcImFcIiE9PXJbMF18fFwiYlwiIT09clsxXX0pKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIsbCl7dmFyIGg9byh0KSx2PSFpKChmdW5jdGlvbigpe3ZhciBlPXt9O3JldHVybiBlW2hdPWZ1bmN0aW9uKCl7cmV0dXJuIDd9LDchPVwiXCJbdF0oZSl9KSksbT12JiYhaSgoZnVuY3Rpb24oKXt2YXIgZT0hMSxyPS9hLztyZXR1cm5cInNwbGl0XCI9PT10JiYocj17fSxyLmNvbnN0cnVjdG9yPXt9LHIuY29uc3RydWN0b3JbY109ZnVuY3Rpb24oKXtyZXR1cm4gcn0sci5mbGFncz1cIlwiLHJbaF09Ly4vW2hdKSxyLmV4ZWM9ZnVuY3Rpb24oKXtyZXR1cm4gZT0hMCxudWxsfSxyW2hdKFwiXCIpLCFlfSkpO2lmKCF2fHwhbXx8XCJyZXBsYWNlXCI9PT10JiYoIXV8fCFmfHxwKXx8XCJzcGxpdFwiPT09dCYmIWQpe3ZhciBnPS8uL1toXSx5PXIoaCxcIlwiW3RdLChmdW5jdGlvbih0LGUscixuLGkpe3JldHVybiBlLmV4ZWM9PT1hP3YmJiFpP3tkb25lOiEwLHZhbHVlOmcuY2FsbChlLHIsbil9Ontkb25lOiEwLHZhbHVlOnQuY2FsbChyLGUsbil9Ontkb25lOiExfX0pLHtSRVBMQUNFX0tFRVBTXyQwOmYsUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkU6cH0pLGI9eVswXSx4PXlbMV07bihTdHJpbmcucHJvdG90eXBlLHQsYiksbihSZWdFeHAucHJvdG90eXBlLGgsMj09ZT9mdW5jdGlvbih0LGUpe3JldHVybiB4LmNhbGwodCx0aGlzLGUpfTpmdW5jdGlvbih0KXtyZXR1cm4geC5jYWxsKHQsdGhpcyl9KX1sJiZzKFJlZ0V4cC5wcm90b3R5cGVbaF0sXCJzaGFtXCIsITApfX0sZDgxZDpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cihcIjIzZTdcIiksaT1yKFwiYjcyN1wiKS5tYXAsbz1yKFwiMWRkZVwiKSxhPXIoXCJhZTQwXCIpLHM9byhcIm1hcFwiKSxjPWEoXCJtYXBcIik7bih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IXN8fCFjfSx7bWFwOmZ1bmN0aW9uKHQpe3JldHVybiBpKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSl9LGRhODQ6ZnVuY3Rpb24odCxlLHIpeyhmdW5jdGlvbihlKXt2YXIgcj1mdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5NYXRoPT1NYXRoJiZ0fTt0LmV4cG9ydHM9cihcIm9iamVjdFwiPT10eXBlb2YgZ2xvYmFsVGhpcyYmZ2xvYmFsVGhpcyl8fHIoXCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyYmd2luZG93KXx8cihcIm9iamVjdFwiPT10eXBlb2Ygc2VsZiYmc2VsZil8fHIoXCJvYmplY3RcIj09dHlwZW9mIGUmJmUpfHxGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCl9KS5jYWxsKHRoaXMscihcImM4YmFcIikpfSxkYmI0OmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiMjNlN1wiKSxpPXIoXCI4M2FiXCIpLG89cihcIjU2ZWZcIiksYT1yKFwiZmM2YVwiKSxzPXIoXCIwNmNmXCIpLGM9cihcIjg0MThcIik7bih7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxzaGFtOiFpfSx7Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczpmdW5jdGlvbih0KXt2YXIgZSxyLG49YSh0KSxpPXMuZix1PW8obiksZj17fSxsPTA7d2hpbGUodS5sZW5ndGg+bClyPWkobixlPXVbbCsrXSksdm9pZCAwIT09ciYmYyhmLGUscik7cmV0dXJuIGZ9fSl9LGRkYjA6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJkYTg0XCIpLGk9cihcImZkYmNcIiksbz1yKFwiZTI2MFwiKSxhPXIoXCI5MTEyXCIpLHM9cihcImI2MjJcIiksYz1zKFwiaXRlcmF0b3JcIiksdT1zKFwidG9TdHJpbmdUYWdcIiksZj1vLnZhbHVlcztmb3IodmFyIGwgaW4gaSl7dmFyIHA9bltsXSxkPXAmJnAucHJvdG90eXBlO2lmKGQpe2lmKGRbY10hPT1mKXRyeXthKGQsYyxmKX1jYXRjaCh2KXtkW2NdPWZ9aWYoZFt1XXx8YShkLHUsbCksaVtsXSlmb3IodmFyIGggaW4gbylpZihkW2hdIT09b1toXSl0cnl7YShkLGgsb1toXSl9Y2F0Y2godil7ZFtoXT1vW2hdfX19fSxkZjc1OmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiY2E4NFwiKSxpPXIoXCI3ODM5XCIpO3QuZXhwb3J0cz1PYmplY3Qua2V5c3x8ZnVuY3Rpb24odCl7cmV0dXJuIG4odCxpKX19LGUwMWE6ZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoXCIyM2U3XCIpLGk9cihcIjgzYWJcIiksbz1yKFwiZGE4NFwiKSxhPXIoXCI1MTM1XCIpLHM9cihcIjg2MWRcIiksYz1yKFwiOWJmMlwiKS5mLHU9cihcImU4OTNcIiksZj1vLlN5bWJvbDtpZihpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBmJiYoIShcImRlc2NyaXB0aW9uXCJpbiBmLnByb3RvdHlwZSl8fHZvaWQgMCE9PWYoKS5kZXNjcmlwdGlvbikpe3ZhciBsPXt9LHA9ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPDF8fHZvaWQgMD09PWFyZ3VtZW50c1swXT92b2lkIDA6U3RyaW5nKGFyZ3VtZW50c1swXSksZT10aGlzIGluc3RhbmNlb2YgcD9uZXcgZih0KTp2b2lkIDA9PT10P2YoKTpmKHQpO3JldHVyblwiXCI9PT10JiYobFtlXT0hMCksZX07dShwLGYpO3ZhciBkPXAucHJvdG90eXBlPWYucHJvdG90eXBlO2QuY29uc3RydWN0b3I9cDt2YXIgaD1kLnRvU3RyaW5nLHY9XCJTeW1ib2wodGVzdClcIj09U3RyaW5nKGYoXCJ0ZXN0XCIpKSxtPS9eU3ltYm9sXFwoKC4qKVxcKVteKV0rJC87YyhkLFwiZGVzY3JpcHRpb25cIix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3ZhciB0PXModGhpcyk/dGhpcy52YWx1ZU9mKCk6dGhpcyxlPWguY2FsbCh0KTtpZihhKGwsdCkpcmV0dXJuXCJcIjt2YXIgcj12P2Uuc2xpY2UoNywtMSk6ZS5yZXBsYWNlKG0sXCIkMVwiKTtyZXR1cm5cIlwiPT09cj92b2lkIDA6cn19KSxuKHtnbG9iYWw6ITAsZm9yY2VkOiEwfSx7U3ltYm9sOnB9KX19LGUxNjM6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCI1MTM1XCIpLGk9cihcIjdiMGJcIiksbz1yKFwiZjc3MlwiKSxhPXIoXCJlMTc3XCIpLHM9byhcIklFX1BST1RPXCIpLGM9T2JqZWN0LnByb3RvdHlwZTt0LmV4cG9ydHM9YT9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9aSh0KSxuKHQscyk/dFtzXTpcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmNvbnN0cnVjdG9yJiZ0IGluc3RhbmNlb2YgdC5jb25zdHJ1Y3Rvcj90LmNvbnN0cnVjdG9yLnByb3RvdHlwZTp0IGluc3RhbmNlb2YgT2JqZWN0P2M6bnVsbH19LGUxNzc6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJkMDM5XCIpO3QuZXhwb3J0cz0hbigoZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1udWxsLE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgdCkhPT10LnByb3RvdHlwZX0pKX0sZTI2MDpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cihcImZjNmFcIiksaT1yKFwiNDRkMlwiKSxvPXIoXCIzZjhjXCIpLGE9cihcIjY5ZjNcIikscz1yKFwiN2RkMFwiKSxjPVwiQXJyYXkgSXRlcmF0b3JcIix1PWEuc2V0LGY9YS5nZXR0ZXJGb3IoYyk7dC5leHBvcnRzPXMoQXJyYXksXCJBcnJheVwiLChmdW5jdGlvbih0LGUpe3UodGhpcyx7dHlwZTpjLHRhcmdldDpuKHQpLGluZGV4OjAsa2luZDplfSl9KSwoZnVuY3Rpb24oKXt2YXIgdD1mKHRoaXMpLGU9dC50YXJnZXQscj10LmtpbmQsbj10LmluZGV4Kys7cmV0dXJuIWV8fG4+PWUubGVuZ3RoPyh0LnRhcmdldD12b2lkIDAse3ZhbHVlOnZvaWQgMCxkb25lOiEwfSk6XCJrZXlzXCI9PXI/e3ZhbHVlOm4sZG9uZTohMX06XCJ2YWx1ZXNcIj09cj97dmFsdWU6ZVtuXSxkb25lOiExfTp7dmFsdWU6W24sZVtuXV0sZG9uZTohMX19KSxcInZhbHVlc1wiKSxvLkFyZ3VtZW50cz1vLkFycmF5LGkoXCJrZXlzXCIpLGkoXCJ2YWx1ZXNcIiksaShcImVudHJpZXNcIil9LGUyY2M6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCI2ZWViXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscil7Zm9yKHZhciBpIGluIGUpbih0LGksZVtpXSxyKTtyZXR1cm4gdH19LGU0Mzk6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCIyM2U3XCIpLGk9cihcImQwMzlcIiksbz1yKFwiZmM2YVwiKSxhPXIoXCIwNmNmXCIpLmYscz1yKFwiODNhYlwiKSxjPWkoKGZ1bmN0aW9uKCl7YSgxKX0pKSx1PSFzfHxjO24oe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOnUsc2hhbTohc30se2dldE93blByb3BlcnR5RGVzY3JpcHRvcjpmdW5jdGlvbih0LGUpe3JldHVybiBhKG8odCksZSl9fSl9LGU1Mzg6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJiNjIyXCIpO2UuZj1ufSxlNjY3OmZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm57ZXJyb3I6ITEsdmFsdWU6dCgpfX1jYXRjaChlKXtyZXR1cm57ZXJyb3I6ITAsdmFsdWU6ZX19fX0sZTZjZjpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG4saSxvLGEscz1yKFwiMjNlN1wiKSxjPXIoXCJjNDMwXCIpLHU9cihcImRhODRcIiksZj1yKFwiZDA2NlwiKSxsPXIoXCJmZWE5XCIpLHA9cihcIjZlZWJcIiksZD1yKFwiZTJjY1wiKSxoPXIoXCJkNDRlXCIpLHY9cihcIjI2MjZcIiksbT1yKFwiODYxZFwiKSxnPXIoXCIxYzBiXCIpLHk9cihcIjE5YWFcIiksYj1yKFwiYzZiNlwiKSx4PXIoXCI4OTI1XCIpLGs9cihcIjIyNjZcIiksdz1yKFwiMWM3ZVwiKSxfPXIoXCI0ODQwXCIpLFM9cihcIjJjZjRcIikuc2V0LEU9cihcImI1NzVcIiksVD1yKFwiY2RmOVwiKSxPPXIoXCI0NGRlXCIpLEM9cihcImYwNjlcIiksaj1yKFwiZTY2N1wiKSxBPXIoXCI2OWYzXCIpLFA9cihcIjk0Y2FcIiksUj1yKFwiYjYyMlwiKSxGPXIoXCIyZDAwXCIpLEk9UihcInNwZWNpZXNcIiksTj1cIlByb21pc2VcIixEPUEuZ2V0LEw9QS5zZXQsTT1BLmdldHRlckZvcihOKSx6PWwscT11LlR5cGVFcnJvcixWPXUuZG9jdW1lbnQsRz11LnByb2Nlc3MsJD1mKFwiZmV0Y2hcIiksQj1DLmYsVT1CLFc9XCJwcm9jZXNzXCI9PWIoRyksSD0hIShWJiZWLmNyZWF0ZUV2ZW50JiZ1LmRpc3BhdGNoRXZlbnQpLFg9XCJ1bmhhbmRsZWRyZWplY3Rpb25cIixZPVwicmVqZWN0aW9uaGFuZGxlZFwiLEs9MCxKPTEsUT0yLFo9MSx0dD0yLGV0PVAoTiwoZnVuY3Rpb24oKXt2YXIgdD14KHopIT09U3RyaW5nKHopO2lmKCF0KXtpZig2Nj09PUYpcmV0dXJuITA7aWYoIVcmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudClyZXR1cm4hMH1pZihjJiYhei5wcm90b3R5cGVbXCJmaW5hbGx5XCJdKXJldHVybiEwO2lmKEY+PTUxJiYvbmF0aXZlIGNvZGUvLnRlc3QoeikpcmV0dXJuITE7dmFyIGU9ei5yZXNvbHZlKDEpLHI9ZnVuY3Rpb24odCl7dCgoZnVuY3Rpb24oKXt9KSwoZnVuY3Rpb24oKXt9KSl9LG49ZS5jb25zdHJ1Y3Rvcj17fTtyZXR1cm4gbltJXT1yLCEoZS50aGVuKChmdW5jdGlvbigpe30pKWluc3RhbmNlb2Ygcil9KSkscnQ9ZXR8fCF3KChmdW5jdGlvbih0KXt6LmFsbCh0KVtcImNhdGNoXCJdKChmdW5jdGlvbigpe30pKX0pKSxudD1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4hKCFtKHQpfHxcImZ1bmN0aW9uXCIhPXR5cGVvZihlPXQudGhlbikpJiZlfSxpdD1mdW5jdGlvbih0LGUscil7aWYoIWUubm90aWZpZWQpe2Uubm90aWZpZWQ9ITA7dmFyIG49ZS5yZWFjdGlvbnM7RSgoZnVuY3Rpb24oKXt2YXIgaT1lLnZhbHVlLG89ZS5zdGF0ZT09SixhPTA7d2hpbGUobi5sZW5ndGg+YSl7dmFyIHMsYyx1LGY9blthKytdLGw9bz9mLm9rOmYuZmFpbCxwPWYucmVzb2x2ZSxkPWYucmVqZWN0LGg9Zi5kb21haW47dHJ5e2w/KG98fChlLnJlamVjdGlvbj09PXR0JiZjdCh0LGUpLGUucmVqZWN0aW9uPVopLCEwPT09bD9zPWk6KGgmJmguZW50ZXIoKSxzPWwoaSksaCYmKGguZXhpdCgpLHU9ITApKSxzPT09Zi5wcm9taXNlP2QocShcIlByb21pc2UtY2hhaW4gY3ljbGVcIikpOihjPW50KHMpKT9jLmNhbGwocyxwLGQpOnAocykpOmQoaSl9Y2F0Y2godil7aCYmIXUmJmguZXhpdCgpLGQodil9fWUucmVhY3Rpb25zPVtdLGUubm90aWZpZWQ9ITEsciYmIWUucmVqZWN0aW9uJiZhdCh0LGUpfSkpfX0sb3Q9ZnVuY3Rpb24odCxlLHIpe3ZhciBuLGk7SD8obj1WLmNyZWF0ZUV2ZW50KFwiRXZlbnRcIiksbi5wcm9taXNlPWUsbi5yZWFzb249cixuLmluaXRFdmVudCh0LCExLCEwKSx1LmRpc3BhdGNoRXZlbnQobikpOm49e3Byb21pc2U6ZSxyZWFzb246cn0sKGk9dVtcIm9uXCIrdF0pP2kobik6dD09PVgmJk8oXCJVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25cIixyKX0sYXQ9ZnVuY3Rpb24odCxlKXtTLmNhbGwodSwoZnVuY3Rpb24oKXt2YXIgcixuPWUudmFsdWUsaT1zdChlKTtpZihpJiYocj1qKChmdW5jdGlvbigpe1c/Ry5lbWl0KFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsbix0KTpvdChYLHQsbil9KSksZS5yZWplY3Rpb249V3x8c3QoZSk/dHQ6WixyLmVycm9yKSl0aHJvdyByLnZhbHVlfSkpfSxzdD1mdW5jdGlvbih0KXtyZXR1cm4gdC5yZWplY3Rpb24hPT1aJiYhdC5wYXJlbnR9LGN0PWZ1bmN0aW9uKHQsZSl7Uy5jYWxsKHUsKGZ1bmN0aW9uKCl7Vz9HLmVtaXQoXCJyZWplY3Rpb25IYW5kbGVkXCIsdCk6b3QoWSx0LGUudmFsdWUpfSkpfSx1dD1mdW5jdGlvbih0LGUscixuKXtyZXR1cm4gZnVuY3Rpb24oaSl7dChlLHIsaSxuKX19LGZ0PWZ1bmN0aW9uKHQsZSxyLG4pe2UuZG9uZXx8KGUuZG9uZT0hMCxuJiYoZT1uKSxlLnZhbHVlPXIsZS5zdGF0ZT1RLGl0KHQsZSwhMCkpfSxsdD1mdW5jdGlvbih0LGUscixuKXtpZighZS5kb25lKXtlLmRvbmU9ITAsbiYmKGU9bik7dHJ5e2lmKHQ9PT1yKXRocm93IHEoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTt2YXIgaT1udChyKTtpP0UoKGZ1bmN0aW9uKCl7dmFyIG49e2RvbmU6ITF9O3RyeXtpLmNhbGwocix1dChsdCx0LG4sZSksdXQoZnQsdCxuLGUpKX1jYXRjaChvKXtmdCh0LG4sbyxlKX19KSk6KGUudmFsdWU9cixlLnN0YXRlPUosaXQodCxlLCExKSl9Y2F0Y2gobyl7ZnQodCx7ZG9uZTohMX0sbyxlKX19fTtldCYmKHo9ZnVuY3Rpb24odCl7eSh0aGlzLHosTiksZyh0KSxuLmNhbGwodGhpcyk7dmFyIGU9RCh0aGlzKTt0cnl7dCh1dChsdCx0aGlzLGUpLHV0KGZ0LHRoaXMsZSkpfWNhdGNoKHIpe2Z0KHRoaXMsZSxyKX19LG49ZnVuY3Rpb24odCl7TCh0aGlzLHt0eXBlOk4sZG9uZTohMSxub3RpZmllZDohMSxwYXJlbnQ6ITEscmVhY3Rpb25zOltdLHJlamVjdGlvbjohMSxzdGF0ZTpLLHZhbHVlOnZvaWQgMH0pfSxuLnByb3RvdHlwZT1kKHoucHJvdG90eXBlLHt0aGVuOmZ1bmN0aW9uKHQsZSl7dmFyIHI9TSh0aGlzKSxuPUIoXyh0aGlzLHopKTtyZXR1cm4gbi5vaz1cImZ1bmN0aW9uXCIhPXR5cGVvZiB0fHx0LG4uZmFpbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlLG4uZG9tYWluPVc/Ry5kb21haW46dm9pZCAwLHIucGFyZW50PSEwLHIucmVhY3Rpb25zLnB1c2gobiksci5zdGF0ZSE9SyYmaXQodGhpcyxyLCExKSxuLnByb21pc2V9LGNhdGNoOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRoZW4odm9pZCAwLHQpfX0pLGk9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgbixlPUQodCk7dGhpcy5wcm9taXNlPXQsdGhpcy5yZXNvbHZlPXV0KGx0LHQsZSksdGhpcy5yZWplY3Q9dXQoZnQsdCxlKX0sQy5mPUI9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT16fHx0PT09bz9uZXcgaSh0KTpVKHQpfSxjfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBsfHwoYT1sLnByb3RvdHlwZS50aGVuLHAobC5wcm90b3R5cGUsXCJ0aGVuXCIsKGZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcztyZXR1cm4gbmV3IHooKGZ1bmN0aW9uKHQsZSl7YS5jYWxsKHIsdCxlKX0pKS50aGVuKHQsZSl9KSx7dW5zYWZlOiEwfSksXCJmdW5jdGlvblwiPT10eXBlb2YgJCYmcyh7Z2xvYmFsOiEwLGVudW1lcmFibGU6ITAsZm9yY2VkOiEwfSx7ZmV0Y2g6ZnVuY3Rpb24odCl7cmV0dXJuIFQoeiwkLmFwcGx5KHUsYXJndW1lbnRzKSl9fSkpKSxzKHtnbG9iYWw6ITAsd3JhcDohMCxmb3JjZWQ6ZXR9LHtQcm9taXNlOnp9KSxoKHosTiwhMSwhMCksdihOKSxvPWYoTikscyh7dGFyZ2V0Ok4sc3RhdDohMCxmb3JjZWQ6ZXR9LHtyZWplY3Q6ZnVuY3Rpb24odCl7dmFyIGU9Qih0aGlzKTtyZXR1cm4gZS5yZWplY3QuY2FsbCh2b2lkIDAsdCksZS5wcm9taXNlfX0pLHMoe3RhcmdldDpOLHN0YXQ6ITAsZm9yY2VkOmN8fGV0fSx7cmVzb2x2ZTpmdW5jdGlvbih0KXtyZXR1cm4gVChjJiZ0aGlzPT09bz96OnRoaXMsdCl9fSkscyh7dGFyZ2V0Ok4sc3RhdDohMCxmb3JjZWQ6cnR9LHthbGw6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPUIoZSksbj1yLnJlc29sdmUsaT1yLnJlamVjdCxvPWooKGZ1bmN0aW9uKCl7dmFyIHI9ZyhlLnJlc29sdmUpLG89W10sYT0wLHM9MTtrKHQsKGZ1bmN0aW9uKHQpe3ZhciBjPWErKyx1PSExO28ucHVzaCh2b2lkIDApLHMrKyxyLmNhbGwoZSx0KS50aGVuKChmdW5jdGlvbih0KXt1fHwodT0hMCxvW2NdPXQsLS1zfHxuKG8pKX0pLGkpfSkpLC0tc3x8bihvKX0pKTtyZXR1cm4gby5lcnJvciYmaShvLnZhbHVlKSxyLnByb21pc2V9LHJhY2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPUIoZSksbj1yLnJlamVjdCxpPWooKGZ1bmN0aW9uKCl7dmFyIGk9ZyhlLnJlc29sdmUpO2sodCwoZnVuY3Rpb24odCl7aS5jYWxsKGUsdCkudGhlbihyLnJlc29sdmUsbil9KSl9KSk7cmV0dXJuIGkuZXJyb3ImJm4oaS52YWx1ZSksci5wcm9taXNlfX0pfSxlODkzOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiNTEzNVwiKSxpPXIoXCI1NmVmXCIpLG89cihcIjA2Y2ZcIiksYT1yKFwiOWJmMlwiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9aShlKSxzPWEuZixjPW8uZix1PTA7dTxyLmxlbmd0aDt1Kyspe3ZhciBmPXJbdV07bih0LGYpfHxzKHQsZixjKGUsZikpfX19LGU4YjU6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoXCJjNmI2XCIpO3QuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbih0KXtyZXR1cm5cIkFycmF5XCI9PW4odCl9fSxlOTVhOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiYjYyMlwiKSxpPXIoXCIzZjhjXCIpLG89bihcIml0ZXJhdG9yXCIpLGE9QXJyYXkucHJvdG90eXBlO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dCYmKGkuQXJyYXk9PT10fHxhW29dPT09dCl9fSxmMDY5OmZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKFwiMWMwYlwiKSxpPWZ1bmN0aW9uKHQpe3ZhciBlLHI7dGhpcy5wcm9taXNlPW5ldyB0KChmdW5jdGlvbih0LG4pe2lmKHZvaWQgMCE9PWV8fHZvaWQgMCE9PXIpdGhyb3cgVHlwZUVycm9yKFwiQmFkIFByb21pc2UgY29uc3RydWN0b3JcIik7ZT10LHI9bn0pKSx0aGlzLnJlc29sdmU9bihlKSx0aGlzLnJlamVjdD1uKHIpfTt0LmV4cG9ydHMuZj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGkodCl9fSxmNWRmOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiMDBlZVwiKSxpPXIoXCJjNmI2XCIpLG89cihcImI2MjJcIiksYT1vKFwidG9TdHJpbmdUYWdcIikscz1cIkFyZ3VtZW50c1wiPT1pKGZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c30oKSksYz1mdW5jdGlvbih0LGUpe3RyeXtyZXR1cm4gdFtlXX1jYXRjaChyKXt9fTt0LmV4cG9ydHM9bj9pOmZ1bmN0aW9uKHQpe3ZhciBlLHIsbjtyZXR1cm4gdm9pZCAwPT09dD9cIlVuZGVmaW5lZFwiOm51bGw9PT10P1wiTnVsbFwiOlwic3RyaW5nXCI9PXR5cGVvZihyPWMoZT1PYmplY3QodCksYSkpP3I6cz9pKGUpOlwiT2JqZWN0XCI9PShuPWkoZSkpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmNhbGxlZT9cIkFyZ3VtZW50c1wiOm59fSxmNzcyOmZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKFwiNTY5MlwiKSxpPXIoXCI5MGUzXCIpLG89bihcImtleXNcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBvW3RdfHwob1t0XT1pKHQpKX19LGZiMTU6ZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO2lmKHIucihlKSxcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdyl7dmFyIG49d2luZG93LmRvY3VtZW50LmN1cnJlbnRTY3JpcHQsaT1yKFwiODg3NVwiKTtuPWkoKSxcImN1cnJlbnRTY3JpcHRcImluIGRvY3VtZW50fHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnQsXCJjdXJyZW50U2NyaXB0XCIse2dldDppfSk7dmFyIG89biYmbi5zcmMubWF0Y2goLyguK1xcLylbXi9dK1xcLmpzKFxcPy4qKT8kLyk7byYmKHIucD1vWzFdKX12YXIgYT1yKFwiZmU4M1wiKTtlW1wiZGVmYXVsdFwiXT1hW1wiYVwiXX0sZmM2YTpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjQ0YWRcIiksaT1yKFwiMWQ4MFwiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4oaSh0KSl9fSxmZGJjOmZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPXtDU1NSdWxlTGlzdDowLENTU1N0eWxlRGVjbGFyYXRpb246MCxDU1NWYWx1ZUxpc3Q6MCxDbGllbnRSZWN0TGlzdDowLERPTVJlY3RMaXN0OjAsRE9NU3RyaW5nTGlzdDowLERPTVRva2VuTGlzdDoxLERhdGFUcmFuc2Zlckl0ZW1MaXN0OjAsRmlsZUxpc3Q6MCxIVE1MQWxsQ29sbGVjdGlvbjowLEhUTUxDb2xsZWN0aW9uOjAsSFRNTEZvcm1FbGVtZW50OjAsSFRNTFNlbGVjdEVsZW1lbnQ6MCxNZWRpYUxpc3Q6MCxNaW1lVHlwZUFycmF5OjAsTmFtZWROb2RlTWFwOjAsTm9kZUxpc3Q6MSxQYWludFJlcXVlc3RMaXN0OjAsUGx1Z2luOjAsUGx1Z2luQXJyYXk6MCxTVkdMZW5ndGhMaXN0OjAsU1ZHTnVtYmVyTGlzdDowLFNWR1BhdGhTZWdMaXN0OjAsU1ZHUG9pbnRMaXN0OjAsU1ZHU3RyaW5nTGlzdDowLFNWR1RyYW5zZm9ybUxpc3Q6MCxTb3VyY2VCdWZmZXJMaXN0OjAsU3R5bGVTaGVldExpc3Q6MCxUZXh0VHJhY2tDdWVMaXN0OjAsVGV4dFRyYWNrTGlzdDowLFRvdWNoTGlzdDowfX0sZmRiZjpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjQ5MzBcIik7dC5leHBvcnRzPW4mJiFTeW1ib2wuc2hhbSYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcn0sZmU4MzpmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7KGZ1bmN0aW9uKHQpe3ZhciBuPXIoXCIyOGFiXCIpLGk9ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOlwidnVlLWVsbGlwc2UtcHJvZ3Jlc3NcIjtyZXR1cm4gdC5jb21wb25lbnQoZSxuW1wiYVwiXSl9LG89bnVsbDtcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdz9vPXdpbmRvdy5WdWU6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB0JiYobz10LlZ1ZSksbyYmby51c2Uoe2luc3RhbGw6aX0pLGVbXCJhXCJdPXtpbnN0YWxsOml9fSkuY2FsbCh0aGlzLHIoXCJjOGJhXCIpKX0sZmVhOTpmdW5jdGlvbih0LGUscil7dmFyIG49cihcImRhODRcIik7dC5leHBvcnRzPW4uUHJvbWlzZX0sZmVjMTpmdW5jdGlvbih0LGUscil7dmFyIG49cihcIjAyZDRcIik7XCJzdHJpbmdcIj09PXR5cGVvZiBuJiYobj1bW3QuaSxuLFwiXCJdXSksbi5sb2NhbHMmJih0LmV4cG9ydHM9bi5sb2NhbHMpO3ZhciBpPXIoXCI0OTllXCIpLmRlZmF1bHQ7aShcImVjMDliNDljXCIsbiwhMCx7c291cmNlTWFwOiExLHNoYWRvd01vZGU6ITF9KX19KX0pKTsiLCJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiZmIxNVwiKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gXCIwMTRiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImU1M2RcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjA3ZTNcIik7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOGU2MFwiKTtcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjYzYjZcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTEzOFwiKTtcbnZhciBNRVRBID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImViZmRcIikuS0VZO1xudmFyICRmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyOTRjXCIpO1xudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkYmRiXCIpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ1ZjJcIik7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjYyYTBcIik7XG52YXIgd2tzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUxNjhcIik7XG52YXIgd2tzRXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNjYjlcIik7XG52YXIgd2tzRGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY3MThcIik7XG52YXIgZW51bUtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDdlZVwiKTtcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkwMDNcIik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTRhZVwiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNzcyXCIpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI0MWVcIik7XG52YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjM2YzNcIik7XG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWJjM1wiKTtcbnZhciBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFlYmRcIik7XG52YXIgX2NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhMTU5XCIpO1xudmFyIGdPUE5FeHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDM5NVwiKTtcbnZhciAkR09QRCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiZjBiXCIpO1xudmFyICRHT1BTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjlhYTlcIik7XG52YXIgJERQID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ5ZjZcIik7XG52YXIgJGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzNhMVwiKTtcbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbicgJiYgISEkR09QUy5mO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgX193ZWJwYWNrX3JlcXVpcmVfXyhcIjZhYmZcIikuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzU1ZFwiKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICAkR09QUy5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIV9fd2VicGFja19yZXF1aXJlX18oXCJiOGUzXCIpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIENocm9tZSAzOCBhbmQgMzkgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIGZhaWxzIG9uIHByaW1pdGl2ZXNcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM0NDNcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gJGZhaWxzKGZ1bmN0aW9uICgpIHsgJEdPUFMuZigxKTsgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogRkFJTFNfT05fUFJJTUlUSVZFUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgICByZXR1cm4gJEdPUFMuZih0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzVlOFwiKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIwMWY5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgTElCUkFSWSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyZDAwXCIpO1xudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWNhMVwiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYWJhXCIpO1xudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzJlOVwiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODRmMlwiKTtcbnZhciAkaXRlckNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0MWEwXCIpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdmMjBcIik7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzhmZFwiKTtcbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYjRjXCIpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYgKCFMSUJSQVJZICYmIHR5cGVvZiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0gIT0gJ2Z1bmN0aW9uJykgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjAzOTVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNmMzXCIpO1xudmFyIGdPUE4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmFiZlwiKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMDdlM1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjBhNDlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5YjQzXCIpO1xudmFyIElPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjI2YVwiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0YmY4XCIpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjlkZWZcIik7XG52YXIgYXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNkMWNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSByZXN1bHRbaW5kZXhdID0gcmVzOyAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXMpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMGJmYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYjdjXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMGQ1OFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjZTEwXCIpO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUxMWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjBmYzlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzYTM4XCIpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxMTY5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJkOTVcIik7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjExNzNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMTFlOVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcElFID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUyYTdcIik7XG52YXIgY3JlYXRlRGVzYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NjMwXCIpO1xudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2ODIxXCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjZhOTlcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY5YThcIik7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzY5YVwiKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllMWVcIikgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjE0OTVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRQID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg2Y2NcIik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2I3Y1wiKTtcbnZhciBnZXRLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjBkNThcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllMWVcIikgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMTY1NFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICRhdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3MWMxXCIpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzBmMVwiKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjE2OTFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMWFmNlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAyMi4xLjIuMiAvIDE1LjQuMy4yIEFycmF5LmlzQXJyYXkoYXJnKVxudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjNiNlwiKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdBcnJheScsIHsgaXNBcnJheTogX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkwMDNcIikgfSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMWJjM1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNzcyXCIpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMWVjOVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjc3MlwiKTtcbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlNTNkXCIpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyMGQ2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVjYTFcIik7XG52YXIgJGZpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGE0OVwiKSg2KTtcbnZhciBLRVkgPSAnZmluZEluZGV4JztcbnZhciBmb3JjZWQgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmIChLRVkgaW4gW10pIEFycmF5KDEpW0tFWV0oZnVuY3Rpb24gKCkgeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXyhcIjljNmNcIikoS0VZKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyMGZkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ5ZjZcIik7XG52YXIgY3JlYXRlRGVzYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhZWJkXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4LCB2YWx1ZSkge1xuICBpZiAoaW5kZXggaW4gb2JqZWN0KSAkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyMzBlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkM2Y0XCIpO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc3MjZcIikuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjI0MWVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjVlYlwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyNGM1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgTElCUkFSWSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiOGUzXCIpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlNTNkXCIpO1xudmFyIGN0eCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkODY0XCIpO1xudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDBjM1wiKTtcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjYzYjZcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjc3MlwiKTtcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzlhYVwiKTtcbnZhciBhbkluc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjExNzNcIik7XG52YXIgZm9yT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYTIyYVwiKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjIwMVwiKTtcbnZhciB0YXNrID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQxNzhcIikuc2V0O1xudmFyIG1pY3JvdGFzayA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhYmEyXCIpKCk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjU2ZVwiKTtcbnZhciBwZXJmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ0MzlcIik7XG52YXIgdXNlckFnZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImJjMTNcIik7XG52YXIgcHJvbWlzZVJlc29sdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2Q3OFwiKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjggfHwgJyc7XG52YXIgJFByb21pc2UgPSBnbG9iYWxbUFJPTUlTRV07XG52YXIgaXNOb2RlID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgZW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgSW50ZXJuYWwsIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlID0gJFByb21pc2UucmVzb2x2ZSgxKTtcbiAgICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTE2OFwiKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgICBleGVjKGVtcHR5LCBlbXB0eSk7XG4gICAgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKVxuICAgICAgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlXG4gICAgICAvLyB2OCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgICAgIC8vIHdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gICAgICAmJiB2OC5pbmRleE9mKCc2LjYnKSAhPT0gMFxuICAgICAgJiYgdXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZS82NicpID09PSAtMTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBtYXkgdGhyb3dcbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhcHJvbWlzZS5faCkgb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciB1bmhhbmRsZWQgPSBpc1VuaGFuZGxlZChwcm9taXNlKTtcbiAgICB2YXIgcmVzdWx0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmICh1bmhhbmRsZWQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbikge1xuICAgICAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHVuaGFuZGxlZCAmJiByZXN1bHQuZSkgdGhyb3cgcmVzdWx0LnY7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHJldHVybiBwcm9taXNlLl9oICE9PSAxICYmIChwcm9taXNlLl9hIHx8IHByb21pc2UuX2MpLmxlbmd0aCA9PT0gMDtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVjOTVcIikoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDVmMlwiKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiNGM5NVwiKShQUk9NSVNFKTtcbldyYXBwZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTg0YVwiKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKTtcbiAgICB2YXIgJCRyZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoTElCUkFSWSAmJiB0aGlzID09PSBXcmFwcGVyID8gJFByb21pc2UgOiB0aGlzLCB4KTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNGVlMVwiKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjUyY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgaW5zdGFsbCAqL1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBSZXNpemVPYnNlcnZlcjsgfSk7XG5mdW5jdGlvbiBnZXRJbnRlcm5ldEV4cGxvcmVyVmVyc2lvbigpIHtcblx0dmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cblx0dmFyIG1zaWUgPSB1YS5pbmRleE9mKCdNU0lFICcpO1xuXHRpZiAobXNpZSA+IDApIHtcblx0XHQvLyBJRSAxMCBvciBvbGRlciA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcblx0XHRyZXR1cm4gcGFyc2VJbnQodWEuc3Vic3RyaW5nKG1zaWUgKyA1LCB1YS5pbmRleE9mKCcuJywgbXNpZSkpLCAxMCk7XG5cdH1cblxuXHR2YXIgdHJpZGVudCA9IHVhLmluZGV4T2YoJ1RyaWRlbnQvJyk7XG5cdGlmICh0cmlkZW50ID4gMCkge1xuXHRcdC8vIElFIDExID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxuXHRcdHZhciBydiA9IHVhLmluZGV4T2YoJ3J2OicpO1xuXHRcdHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcocnYgKyAzLCB1YS5pbmRleE9mKCcuJywgcnYpKSwgMTApO1xuXHR9XG5cblx0dmFyIGVkZ2UgPSB1YS5pbmRleE9mKCdFZGdlLycpO1xuXHRpZiAoZWRnZSA+IDApIHtcblx0XHQvLyBFZGdlIChJRSAxMispID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxuXHRcdHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcoZWRnZSArIDUsIHVhLmluZGV4T2YoJy4nLCBlZGdlKSksIDEwKTtcblx0fVxuXG5cdC8vIG90aGVyIGJyb3dzZXJcblx0cmV0dXJuIC0xO1xufVxuXG52YXIgaXNJRSA9IHZvaWQgMDtcblxuZnVuY3Rpb24gaW5pdENvbXBhdCgpIHtcblx0aWYgKCFpbml0Q29tcGF0LmluaXQpIHtcblx0XHRpbml0Q29tcGF0LmluaXQgPSB0cnVlO1xuXHRcdGlzSUUgPSBnZXRJbnRlcm5ldEV4cGxvcmVyVmVyc2lvbigpICE9PSAtMTtcblx0fVxufVxuXG52YXIgUmVzaXplT2JzZXJ2ZXIgPSB7IHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuXHRcdHZhciBfdm0gPSB0aGlzO3ZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7cmV0dXJuIF9jKCdkaXYnLCB7IHN0YXRpY0NsYXNzOiBcInJlc2l6ZS1vYnNlcnZlclwiLCBhdHRyczogeyBcInRhYmluZGV4XCI6IFwiLTFcIiB9IH0pO1xuXHR9LCBzdGF0aWNSZW5kZXJGbnM6IFtdLCBfc2NvcGVJZDogJ2RhdGEtdi1iMzI5ZWU0YycsXG5cdG5hbWU6ICdyZXNpemUtb2JzZXJ2ZXInLFxuXG5cdG1ldGhvZHM6IHtcblx0XHRjb21wYXJlQW5kTm90aWZ5OiBmdW5jdGlvbiBjb21wYXJlQW5kTm90aWZ5KCkge1xuXHRcdFx0aWYgKHRoaXMuX3cgIT09IHRoaXMuJGVsLm9mZnNldFdpZHRoIHx8IHRoaXMuX2ggIT09IHRoaXMuJGVsLm9mZnNldEhlaWdodCkge1xuXHRcdFx0XHR0aGlzLl93ID0gdGhpcy4kZWwub2Zmc2V0V2lkdGg7XG5cdFx0XHRcdHRoaXMuX2ggPSB0aGlzLiRlbC5vZmZzZXRIZWlnaHQ7XG5cdFx0XHRcdHRoaXMuJGVtaXQoJ25vdGlmeScpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YWRkUmVzaXplSGFuZGxlcnM6IGZ1bmN0aW9uIGFkZFJlc2l6ZUhhbmRsZXJzKCkge1xuXHRcdFx0dGhpcy5fcmVzaXplT2JqZWN0LmNvbnRlbnREb2N1bWVudC5kZWZhdWx0Vmlldy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmNvbXBhcmVBbmROb3RpZnkpO1xuXHRcdFx0dGhpcy5jb21wYXJlQW5kTm90aWZ5KCk7XG5cdFx0fSxcblx0XHRyZW1vdmVSZXNpemVIYW5kbGVyczogZnVuY3Rpb24gcmVtb3ZlUmVzaXplSGFuZGxlcnMoKSB7XG5cdFx0XHRpZiAodGhpcy5fcmVzaXplT2JqZWN0ICYmIHRoaXMuX3Jlc2l6ZU9iamVjdC5vbmxvYWQpIHtcblx0XHRcdFx0aWYgKCFpc0lFICYmIHRoaXMuX3Jlc2l6ZU9iamVjdC5jb250ZW50RG9jdW1lbnQpIHtcblx0XHRcdFx0XHR0aGlzLl9yZXNpemVPYmplY3QuY29udGVudERvY3VtZW50LmRlZmF1bHRWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuY29tcGFyZUFuZE5vdGlmeSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIHRoaXMuX3Jlc2l6ZU9iamVjdC5vbmxvYWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdGluaXRDb21wYXQoKTtcblx0XHR0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0XHRfdGhpcy5fdyA9IF90aGlzLiRlbC5vZmZzZXRXaWR0aDtcblx0XHRcdF90aGlzLl9oID0gX3RoaXMuJGVsLm9mZnNldEhlaWdodDtcblx0XHR9KTtcblx0XHR2YXIgb2JqZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb2JqZWN0Jyk7XG5cdFx0dGhpcy5fcmVzaXplT2JqZWN0ID0gb2JqZWN0O1xuXHRcdG9iamVjdC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblx0XHRvYmplY3Quc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKTtcblx0XHRvYmplY3Qub25sb2FkID0gdGhpcy5hZGRSZXNpemVIYW5kbGVycztcblx0XHRvYmplY3QudHlwZSA9ICd0ZXh0L2h0bWwnO1xuXHRcdGlmIChpc0lFKSB7XG5cdFx0XHR0aGlzLiRlbC5hcHBlbmRDaGlsZChvYmplY3QpO1xuXHRcdH1cblx0XHRvYmplY3QuZGF0YSA9ICdhYm91dDpibGFuayc7XG5cdFx0aWYgKCFpc0lFKSB7XG5cdFx0XHR0aGlzLiRlbC5hcHBlbmRDaGlsZChvYmplY3QpO1xuXHRcdH1cblx0fSxcblx0YmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcblx0XHR0aGlzLnJlbW92ZVJlc2l6ZUhhbmRsZXJzKCk7XG5cdH1cbn07XG5cbi8vIEluc3RhbGwgdGhlIGNvbXBvbmVudHNcbmZ1bmN0aW9uIGluc3RhbGwoVnVlKSB7XG5cdFZ1ZS5jb21wb25lbnQoJ3Jlc2l6ZS1vYnNlcnZlcicsIFJlc2l6ZU9ic2VydmVyKTtcblx0VnVlLmNvbXBvbmVudCgnUmVzaXplT2JzZXJ2ZXInLCBSZXNpemVPYnNlcnZlcik7XG59XG5cbi8vIFBsdWdpblxudmFyIHBsdWdpbiA9IHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZlcnNpb246IFwiMC40LjVcIixcblx0aW5zdGFsbDogaW5zdGFsbFxufTtcblxuLy8gQXV0by1pbnN0YWxsXG52YXIgR2xvYmFsVnVlID0gbnVsbDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHRHbG9iYWxWdWUgPSB3aW5kb3cuVnVlO1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuXHRHbG9iYWxWdWUgPSBnbG9iYWwuVnVlO1xufVxuaWYgKEdsb2JhbFZ1ZSkge1xuXHRHbG9iYWxWdWUudXNlKHBsdWdpbik7XG59XG5cblxuLyogdW51c2VkIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIF91bnVzZWRfd2VicGFja19kZWZhdWx0X2V4cG9ydCA9IChwbHVnaW4pO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXyhcImM4YmFcIikpKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyNWViXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjYyMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjI5NGNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjJhYmFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NzI2XCIpO1xudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzJlOVwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjlhOFwiKTtcbnZhciBTUkMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2E1YVwiKSgnc3JjJyk7XG52YXIgJHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZhNWJcIik7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oXCI4Mzc4XCIpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIGlmICghc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH0gZWxzZSBpZiAoT1trZXldKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMmFlYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYjdjXCIpO1xudmFyIGRQcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxNDk1XCIpO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUxMWVcIik7XG52YXIgSUVfUFJPVE8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjEzYlwiKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjMwZVwiKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgX193ZWJwYWNrX3JlcXVpcmVfXyhcImZhYjJcIikuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjJiNGNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHN0b3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU1MzdcIikoJ3drcycpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYTVhXCIpO1xudmFyIFN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NzI2XCIpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjJkMDBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyZDk1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyZmRiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gMjEuMS4zLjcgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyhzZWFyY2hTdHJpbmcsIHBvc2l0aW9uID0gMClcblxudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWNhMVwiKTtcbnZhciBjb250ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQyYzhcIik7XG52YXIgSU5DTFVERVMgPSAnaW5jbHVkZXMnO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIF9fd2VicGFja19yZXF1aXJlX18oXCI1MTQ3XCIpKElOQ0xVREVTKSwgJ1N0cmluZycsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHJldHVybiAhIX5jb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgSU5DTFVERVMpXG4gICAgICAuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMzAyNFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBhcmdzLCB0aGF0KSB7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMzBmMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIExJQlJBUlkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjhlM1wiKTtcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjYzYjZcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTEzOFwiKTtcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjM1ZThcIik7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ4MWJcIik7XG52YXIgJGl0ZXJDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOGY2MFwiKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NWYyXCIpO1xudmFyIGdldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUzZTJcIik7XG52YXIgSVRFUkFUT1IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTE2OFwiKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzMmU5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NmNjXCIpO1xudmFyIGNyZWF0ZURlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDYzMFwiKTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllMWVcIikgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzMmZjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlNTNkXCIpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMzMxNFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX3JlZl84X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzhfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfaW5kZXhfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfNDZlMTA1ZGVfbGFuZ19zY3NzX3Njb3BlZF90cnVlX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjhmODJcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19taW5pX2Nzc19leHRyYWN0X3BsdWdpbl9kaXN0X2xvYWRlcl9qc19yZWZfOF9vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl84X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfc2Fzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX2luZGV4X3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzQ2ZTEwNWRlX2xhbmdfc2Nzc19zY29wZWRfdHJ1ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX3JlZl84X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzhfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfaW5kZXhfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfNDZlMTA1ZGVfbGFuZ19zY3NzX3Njb3BlZF90cnVlX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIHVudXNlZCBoYXJtb255IHJlZXhwb3J0ICogKi9cbiAvKiB1bnVzZWQgaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgX3VudXNlZF93ZWJwYWNrX2RlZmF1bHRfZXhwb3J0ID0gKF9ub2RlX21vZHVsZXNfbWluaV9jc3NfZXh0cmFjdF9wbHVnaW5fZGlzdF9sb2FkZXJfanNfcmVmXzhfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl84X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfOF9vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl84X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19pbmRleF92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF80NmUxMDVkZV9sYW5nX3Njc3Nfc2NvcGVkX3RydWVfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKTsgXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjMzNWNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmI0Y1wiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzNTVkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjM1ZThcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRQID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ5ZjZcIik7XG52YXIgY3JlYXRlRGVzYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhZWJkXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOGU2MFwiKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjM2YzNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzMzVjXCIpO1xudmFyIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjVlYlwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMzcwMlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ4MWJcIik7XG52YXIgSVRFUkFUT1IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTE2OFwiKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzODQ2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmIChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWUxZVwiKSAmJiAvLi9nLmZsYWdzICE9ICdnJykgX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg2Y2NcIikuZihSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGJmYlwiKVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMzhmZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2OWE4XCIpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjRiZjhcIik7XG52YXIgSUVfUFJPVE8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjEzYlwiKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjNhMzhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiM2MxMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtZmluYWxseVxuXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2M2I2XCIpO1xudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTg0YVwiKTtcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTUzZFwiKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjIwMVwiKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjZDc4XCIpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1Byb21pc2UnLCB7ICdmaW5hbGx5JzogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpO1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBvbkZpbmFsbHkgPT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICB9IDogb25GaW5hbGx5LFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgdGhyb3cgZTsgfSk7XG4gICAgfSA6IG9uRmluYWxseVxuICApO1xufSB9KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0MGMzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjZiNGNcIik7XG52YXIgVEFHID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUxNjhcIikoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0MTc4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjdHggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDg2NFwiKTtcbnZhciBpbnZva2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzAyNFwiKTtcbnZhciBodG1sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjMyZmNcIik7XG52YXIgY2VsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFlYzlcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImU1M2RcIik7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKF9fd2VicGFja19yZXF1aXJlX18oXCI2YjRjXCIpKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNDFhMFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYWViXCIpO1xudmFyIGRlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDYzMFwiKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3ZjIwXCIpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzJlOVwiKShJdGVyYXRvclByb3RvdHlwZSwgX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJiNGNcIikoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQzZmNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtdHJ5XG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2M2I2XCIpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY1NmVcIik7XG52YXIgcGVyZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NDM5XCIpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1Byb21pc2UnLCB7ICd0cnknOiBmdW5jdGlvbiAoY2FsbGJhY2tmbikge1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gcGVyZm9ybShjYWxsYmFja2ZuKTtcbiAgKHJlc3VsdC5lID8gcHJvbWlzZUNhcGFiaWxpdHkucmVqZWN0IDogcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZSkocmVzdWx0LnYpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn0gfSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNDQzOVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZTogZmFsc2UsIHY6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgZTogdHJ1ZSwgdjogZSB9O1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQ1NGZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ2YTdcIik7XG52YXIgJE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1ODRhXCIpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYykge1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNDU2ZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0YmY4XCIpO1xudmFyICRrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjBkNThcIik7XG5cbl9fd2VicGFja19yZXF1aXJlX18oXCI1ZWRhXCIpKCdrZXlzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNDU4OFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0NWYyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkZWYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDlmNlwiKS5mO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwN2UzXCIpO1xudmFyIFRBRyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MTY4XCIpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQ2MzBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0NmE3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjYzYjZcIik7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhX193ZWJwYWNrX3JlcXVpcmVfXyhcIjhlNjBcIiksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnR5OiBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDlmNlwiKS5mIH0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQ3ZWVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImMzYTFcIik7XG52YXIgZ09QUyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5YWE5XCIpO1xudmFyIHBJRSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNTVkXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNDgxYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQ4ODNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxleHBvcnRzLmNvbG9yTmFtZVRvSGV4PWV4cG9ydHMuaXNDb2xvck5hbWU9ZXhwb3J0cy5IZXhUb1JnYmE9ZXhwb3J0cy5TaGFkZUNvbG9yPXZvaWQgMDt2YXIgU2hhZGVDb2xvcj1mdW5jdGlvbihlLGYpe3ZhciBhPXBhcnNlSW50KGUuc3Vic3RyaW5nKDEsMyksMTYpLHI9cGFyc2VJbnQoZS5zdWJzdHJpbmcoMyw1KSwxNiksbz1wYXJzZUludChlLnN1YnN0cmluZyg1LDcpLDE2KTtyZXR1cm4gYT1wYXJzZUludChhKigxMDArZikvMTAwKSxyPXBhcnNlSW50KHIqKDEwMCtmKS8xMDApLG89cGFyc2VJbnQobyooMTAwK2YpLzEwMCksYT1hPDI1NT9hOjI1NSxyPXI8MjU1P3I6MjU1LG89bzwyNTU/bzoyNTUsXCIjXCIrKDE9PT1hLnRvU3RyaW5nKDE2KS5sZW5ndGg/XCIwXCIrYS50b1N0cmluZygxNik6YS50b1N0cmluZygxNikpKygxPT09ci50b1N0cmluZygxNikubGVuZ3RoP1wiMFwiK3IudG9TdHJpbmcoMTYpOnIudG9TdHJpbmcoMTYpKSsoMT09PW8udG9TdHJpbmcoMTYpLmxlbmd0aD9cIjBcIitvLnRvU3RyaW5nKDE2KTpvLnRvU3RyaW5nKDE2KSl9O2V4cG9ydHMuU2hhZGVDb2xvcj1TaGFkZUNvbG9yO3ZhciBIZXhUb1JnYmE9ZnVuY3Rpb24oZSxmKXt2YXIgYTtpZigvXiMoW0EtRmEtZjAtOV17M30pezEsMn0kLy50ZXN0KGUpKXJldHVybiAzPT09KGE9ZS5zdWJzdHJpbmcoMSkuc3BsaXQoXCJcIikpLmxlbmd0aCYmKGE9W2FbMF0sYVswXSxhWzFdLGFbMV0sYVsyXSxhWzJdXSksYT1cIjB4XCIuY29uY2F0KGEuam9pbihcIlwiKSksXCJyZ2JhKFwiLmNvbmNhdChbYT4+MTYmMjU1LGE+PjgmMjU1LDI1NSZhXS5qb2luKFwiLCBcIiksXCIsIFwiKS5jb25jYXQoZixcIilcIik7dGhyb3cgbmV3IEVycm9yKFwiQmFkIEhleFwiKX07ZXhwb3J0cy5IZXhUb1JnYmE9SGV4VG9SZ2JhO3ZhciBpc0NvbG9yTmFtZT1mdW5jdGlvbihlKXtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJpc0NvbG9yTmFtZTogTm8gY29sb3JcIik7cmV0dXJuIWUuaW5jbHVkZXMoXCIjXCIpfTtleHBvcnRzLmlzQ29sb3JOYW1lPWlzQ29sb3JOYW1lO3ZhciBjb2xvck5hbWVUb0hleD1mdW5jdGlvbihlKXtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJjb2xvck5hbWVUb0hleDogTm8gY29sb3JcIik7dmFyIGY9e2FsaWNlYmx1ZTpcIiNmMGY4ZmZcIixhbnRpcXVld2hpdGU6XCIjZmFlYmQ3XCIsYXF1YTpcIiMwMGZmZmZcIixhcXVhbWFyaW5lOlwiIzdmZmZkNFwiLGF6dXJlOlwiI2YwZmZmZlwiLGJlaWdlOlwiI2Y1ZjVkY1wiLGJpc3F1ZTpcIiNmZmU0YzRcIixibGFjazpcIiMwMDAwMDBcIixibGFuY2hlZGFsbW9uZDpcIiNmZmViY2RcIixibHVlOlwiIzAwMDBmZlwiLGJsdWV2aW9sZXQ6XCIjOGEyYmUyXCIsYnJvd246XCIjYTUyYTJhXCIsYnVybHl3b29kOlwiI2RlYjg4N1wiLGNhZGV0Ymx1ZTpcIiM1ZjllYTBcIixjaGFydHJldXNlOlwiIzdmZmYwMFwiLGNob2NvbGF0ZTpcIiNkMjY5MWVcIixjb3JhbDpcIiNmZjdmNTBcIixjb3JuZmxvd2VyYmx1ZTpcIiM2NDk1ZWRcIixjb3Juc2lsazpcIiNmZmY4ZGNcIixjcmltc29uOlwiI2RjMTQzY1wiLGN5YW46XCIjMDBmZmZmXCIsZGFya2JsdWU6XCIjMDAwMDhiXCIsZGFya2N5YW46XCIjMDA4YjhiXCIsZGFya2dvbGRlbnJvZDpcIiNiODg2MGJcIixkYXJrZ3JheTpcIiNhOWE5YTlcIixkYXJrZ3JlZW46XCIjMDA2NDAwXCIsZGFya2toYWtpOlwiI2JkYjc2YlwiLGRhcmttYWdlbnRhOlwiIzhiMDA4YlwiLGRhcmtvbGl2ZWdyZWVuOlwiIzU1NmIyZlwiLGRhcmtvcmFuZ2U6XCIjZmY4YzAwXCIsZGFya29yY2hpZDpcIiM5OTMyY2NcIixkYXJrcmVkOlwiIzhiMDAwMFwiLGRhcmtzYWxtb246XCIjZTk5NjdhXCIsZGFya3NlYWdyZWVuOlwiIzhmYmM4ZlwiLGRhcmtzbGF0ZWJsdWU6XCIjNDgzZDhiXCIsZGFya3NsYXRlZ3JheTpcIiMyZjRmNGZcIixkYXJrdHVycXVvaXNlOlwiIzAwY2VkMVwiLGRhcmt2aW9sZXQ6XCIjOTQwMGQzXCIsZGVlcHBpbms6XCIjZmYxNDkzXCIsZGVlcHNreWJsdWU6XCIjMDBiZmZmXCIsZGltZ3JheTpcIiM2OTY5NjlcIixkb2RnZXJibHVlOlwiIzFlOTBmZlwiLGZpcmVicmljazpcIiNiMjIyMjJcIixmbG9yYWx3aGl0ZTpcIiNmZmZhZjBcIixmb3Jlc3RncmVlbjpcIiMyMjhiMjJcIixmdWNoc2lhOlwiI2ZmMDBmZlwiLGdhaW5zYm9ybzpcIiNkY2RjZGNcIixnaG9zdHdoaXRlOlwiI2Y4ZjhmZlwiLGdvbGQ6XCIjZmZkNzAwXCIsZ29sZGVucm9kOlwiI2RhYTUyMFwiLGdyYXk6XCIjODA4MDgwXCIsZ3JlZW46XCIjMDA4MDAwXCIsZ3JlZW55ZWxsb3c6XCIjYWRmZjJmXCIsaG9uZXlkZXc6XCIjZjBmZmYwXCIsaG90cGluazpcIiNmZjY5YjRcIixcImluZGlhbnJlZCBcIjpcIiNjZDVjNWNcIixpbmRpZ286XCIjNGIwMDgyXCIsaXZvcnk6XCIjZmZmZmYwXCIsa2hha2k6XCIjZjBlNjhjXCIsbGF2ZW5kZXI6XCIjZTZlNmZhXCIsbGF2ZW5kZXJibHVzaDpcIiNmZmYwZjVcIixsYXduZ3JlZW46XCIjN2NmYzAwXCIsbGVtb25jaGlmZm9uOlwiI2ZmZmFjZFwiLGxpZ2h0Ymx1ZTpcIiNhZGQ4ZTZcIixsaWdodGNvcmFsOlwiI2YwODA4MFwiLGxpZ2h0Y3lhbjpcIiNlMGZmZmZcIixsaWdodGdvbGRlbnJvZHllbGxvdzpcIiNmYWZhZDJcIixsaWdodGdyZXk6XCIjZDNkM2QzXCIsbGlnaHRncmVlbjpcIiM5MGVlOTBcIixsaWdodHBpbms6XCIjZmZiNmMxXCIsbGlnaHRzYWxtb246XCIjZmZhMDdhXCIsbGlnaHRzZWFncmVlbjpcIiMyMGIyYWFcIixsaWdodHNreWJsdWU6XCIjODdjZWZhXCIsbGlnaHRzbGF0ZWdyYXk6XCIjNzc4ODk5XCIsbGlnaHRzdGVlbGJsdWU6XCIjYjBjNGRlXCIsbGlnaHR5ZWxsb3c6XCIjZmZmZmUwXCIsbGltZTpcIiMwMGZmMDBcIixsaW1lZ3JlZW46XCIjMzJjZDMyXCIsbGluZW46XCIjZmFmMGU2XCIsbWFnZW50YTpcIiNmZjAwZmZcIixtYXJvb246XCIjODAwMDAwXCIsbWVkaXVtYXF1YW1hcmluZTpcIiM2NmNkYWFcIixtZWRpdW1ibHVlOlwiIzAwMDBjZFwiLG1lZGl1bW9yY2hpZDpcIiNiYTU1ZDNcIixtZWRpdW1wdXJwbGU6XCIjOTM3MGQ4XCIsbWVkaXVtc2VhZ3JlZW46XCIjM2NiMzcxXCIsbWVkaXVtc2xhdGVibHVlOlwiIzdiNjhlZVwiLG1lZGl1bXNwcmluZ2dyZWVuOlwiIzAwZmE5YVwiLG1lZGl1bXR1cnF1b2lzZTpcIiM0OGQxY2NcIixtZWRpdW12aW9sZXRyZWQ6XCIjYzcxNTg1XCIsbWlkbmlnaHRibHVlOlwiIzE5MTk3MFwiLG1pbnRjcmVhbTpcIiNmNWZmZmFcIixtaXN0eXJvc2U6XCIjZmZlNGUxXCIsbW9jY2FzaW46XCIjZmZlNGI1XCIsbmF2YWpvd2hpdGU6XCIjZmZkZWFkXCIsbmF2eTpcIiMwMDAwODBcIixvbGRsYWNlOlwiI2ZkZjVlNlwiLG9saXZlOlwiIzgwODAwMFwiLG9saXZlZHJhYjpcIiM2YjhlMjNcIixvcmFuZ2U6XCIjZmZhNTAwXCIsb3JhbmdlcmVkOlwiI2ZmNDUwMFwiLG9yY2hpZDpcIiNkYTcwZDZcIixwYWxlZ29sZGVucm9kOlwiI2VlZThhYVwiLHBhbGVncmVlbjpcIiM5OGZiOThcIixwYWxldHVycXVvaXNlOlwiI2FmZWVlZVwiLHBhbGV2aW9sZXRyZWQ6XCIjZDg3MDkzXCIscGFwYXlhd2hpcDpcIiNmZmVmZDVcIixwZWFjaHB1ZmY6XCIjZmZkYWI5XCIscGVydTpcIiNjZDg1M2ZcIixwaW5rOlwiI2ZmYzBjYlwiLHBsdW06XCIjZGRhMGRkXCIscG93ZGVyYmx1ZTpcIiNiMGUwZTZcIixwdXJwbGU6XCIjODAwMDgwXCIscmViZWNjYXB1cnBsZTpcIiM2NjMzOTlcIixyZWQ6XCIjZmYwMDAwXCIscm9zeWJyb3duOlwiI2JjOGY4ZlwiLHJveWFsYmx1ZTpcIiM0MTY5ZTFcIixzYWRkbGVicm93bjpcIiM4YjQ1MTNcIixzYWxtb246XCIjZmE4MDcyXCIsc2FuZHlicm93bjpcIiNmNGE0NjBcIixzZWFncmVlbjpcIiMyZThiNTdcIixzZWFzaGVsbDpcIiNmZmY1ZWVcIixzaWVubmE6XCIjYTA1MjJkXCIsc2lsdmVyOlwiI2MwYzBjMFwiLHNreWJsdWU6XCIjODdjZWViXCIsc2xhdGVibHVlOlwiIzZhNWFjZFwiLHNsYXRlZ3JheTpcIiM3MDgwOTBcIixzbm93OlwiI2ZmZmFmYVwiLHNwcmluZ2dyZWVuOlwiIzAwZmY3ZlwiLHN0ZWVsYmx1ZTpcIiM0NjgyYjRcIix0YW46XCIjZDJiNDhjXCIsdGVhbDpcIiMwMDgwODBcIix0aGlzdGxlOlwiI2Q4YmZkOFwiLHRvbWF0bzpcIiNmZjYzNDdcIix0dXJxdW9pc2U6XCIjNDBlMGQwXCIsdmlvbGV0OlwiI2VlODJlZVwiLHdoZWF0OlwiI2Y1ZGViM1wiLHdoaXRlOlwiI2ZmZmZmZlwiLHdoaXRlc21va2U6XCIjZjVmNWY1XCIseWVsbG93OlwiI2ZmZmYwMFwiLHllbGxvd2dyZWVuOlwiIzlhY2QzMlwifTtyZXR1cm4gdm9pZCAwIT09ZltlLnRvTG93ZXJDYXNlKCldJiZmW2UudG9Mb3dlckNhc2UoKV19O2V4cG9ydHMuY29sb3JOYW1lVG9IZXg9Y29sb3JOYW1lVG9IZXg7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjRiZjhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYmUxM1wiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0Yzk1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImU1M2RcIik7XG52YXIgY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1ODRhXCIpO1xudmFyIGRQID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ5ZjZcIik7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOGU2MFwiKTtcbnZhciBTUEVDSUVTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUxNjhcIikoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gdHlwZW9mIGNvcmVbS0VZXSA9PSAnZnVuY3Rpb24nID8gY29yZVtLRVldIDogZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0ZWUxXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MTY4XCIpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNTBlZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1MTQ3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBNQVRDSCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYjRjXCIpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciByZSA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tLRVldKHJlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaCAoZikgeyAvKiBlbXB0eSAqLyB9XG4gIH0gcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjUxNjhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHN0b3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRiZGJcIikoJ3drcycpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2MmEwXCIpO1xudmFyIFN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlNTNkXCIpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjUyYTdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNTNlMlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwN2UzXCIpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI0MWVcIik7XG52YXIgSUVfUFJPVE8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTU1OVwiKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjU0OWJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjdHggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDg2NFwiKTtcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjYzYjZcIik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjQxZVwiKTtcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImIwZGNcIik7XG52YXIgaXNBcnJheUl0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzcwMlwiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiNDQ3XCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIwZmRcIik7XG52YXIgZ2V0SXRlckZuID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdjZDZcIik7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIV9fd2VicGFja19yZXF1aXJlX18oXCI0ZWUxXCIpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjU0YTFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyhcIjZjMWNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTY1NFwiKTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjk1ZDVcIik7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNTUzN1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4Mzc4XCIpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NzI2XCIpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmQwMFwiKSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNTU1OVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRiZGJcIikoJ2tleXMnKTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjJhMFwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1ODRhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjYuMTEnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjViNGVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzZjM1wiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiNDQ3XCIpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwZmM5XCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNWM5NVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNWU4XCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGlmIChzYWZlICYmIHRhcmdldFtrZXldKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO1xuICAgIGVsc2UgaGlkZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9IHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjVjYTFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NzI2XCIpO1xudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODM3OFwiKTtcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjMyZTlcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmFiYVwiKTtcbnZhciBjdHggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWI0M1wiKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNWRiY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDNmNFwiKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4Yjk3XCIpLnNldDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHRhcmdldCwgQykge1xuICB2YXIgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgdmFyIFA7XG4gIGlmIChTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKSB7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjVlZGFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1Y2ExXCIpO1xudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODM3OFwiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3OWU1XCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNjEzYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU1MzdcIikoJ2tleXMnKTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2E1YVwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2MjZhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJkOTVcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNjJhMFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2M2I2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTUzZFwiKTtcbnZhciBjb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU4NGFcIik7XG52YXIgY3R4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ4NjRcIik7XG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNWU4XCIpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwN2UzXCIpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXTtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBrZXksIG93biwgb3V0O1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChvd24gJiYgaGFzKGV4cG9ydHMsIGtleSkpIGNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24gKEMpIHtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7XG4gICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZiAoSVNfUFJPVE8pIHtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZiAodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSkgaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2NTZlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyAyNS40LjEuNSBOZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxudmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3OWFhXCIpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2NzE4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTUzZFwiKTtcbnZhciBjb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU4NGFcIik7XG52YXIgTElCUkFSWSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiOGUzXCIpO1xudmFyIHdrc0V4dCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjY2I5XCIpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ5ZjZcIikuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2NzYyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVjYTFcIik7XG52YXIgJGluY2x1ZGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImMzNjZcIikodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWM2Y1wiKSgnaW5jbHVkZXMnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2N2JiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImY5MjFcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjY4MjFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2MjZhXCIpO1xudmFyIGRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYmUxM1wiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNjk2ZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzIwN1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oXCIxNjU0XCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyhcIjZjMWNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjRjNVwiKTtcbl9fd2VicGFja19yZXF1aXJlX18oXCIzYzExXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQzZmNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1ODRhXCIpLlByb21pc2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNjk5NlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX3JlZl84X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzhfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfaW5kZXhfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfMTljOWExYzdfbGFuZ19zY3NzX3Njb3BlZF90cnVlX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkyY2NcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19taW5pX2Nzc19leHRyYWN0X3BsdWdpbl9kaXN0X2xvYWRlcl9qc19yZWZfOF9vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl84X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfc2Fzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX2luZGV4X3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzE5YzlhMWM3X2xhbmdfc2Nzc19zY29wZWRfdHJ1ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX3JlZl84X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzhfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfaW5kZXhfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfMTljOWExYzdfbGFuZ19zY3NzX3Njb3BlZF90cnVlX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIHVudXNlZCBoYXJtb255IHJlZXhwb3J0ICogKi9cbiAvKiB1bnVzZWQgaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgX3VudXNlZF93ZWJwYWNrX2RlZmF1bHRfZXhwb3J0ID0gKF9ub2RlX21vZHVsZXNfbWluaV9jc3NfZXh0cmFjdF9wbHVnaW5fZGlzdF9sb2FkZXJfanNfcmVmXzhfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl84X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfOF9vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl84X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19pbmRleF92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF8xOWM5YTFjN19sYW5nX3Njc3Nfc2NvcGVkX3RydWVfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKTsgXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjY5YThcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2OWQzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbl9fd2VicGFja19yZXF1aXJlX18oXCI2NzE4XCIpKCdhc3luY0l0ZXJhdG9yJyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNmE5OVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkM2Y0XCIpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNmFiZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTZmM1wiKTtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE2OTFcIikuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjZiNGNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjZiNTRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbl9fd2VicGFja19yZXF1aXJlX18oXCIzODQ2XCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNiN2NcIik7XG52YXIgJGZsYWdzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjBiZmJcIik7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWUxZVwiKTtcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IC8uL1tUT19TVFJJTkddO1xuXG52YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZuKSB7XG4gIF9fd2VicGFja19yZXF1aXJlX18oXCIyYWJhXCIpKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZm4sIHRydWUpO1xufTtcblxuLy8gMjEuMi41LjE0IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcoKVxuaWYgKF9fd2VicGFja19yZXF1aXJlX18oXCI3OWU1XCIpKGZ1bmN0aW9uICgpIHsgcmV0dXJuICR0b1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KSkge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICByZXR1cm4gJy8nLmNvbmNhdChSLnNvdXJjZSwgJy8nLFxuICAgICAgJ2ZsYWdzJyBpbiBSID8gUi5mbGFncyA6ICFERVNDUklQVE9SUyAmJiBSIGluc3RhbmNlb2YgUmVnRXhwID8gJGZsYWdzLmNhbGwoUikgOiB1bmRlZmluZWQpO1xuICB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG59IGVsc2UgaWYgKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORykge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICR0b1N0cmluZy5jYWxsKHRoaXMpO1xuICB9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2YzFjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbl9fd2VicGFja19yZXF1aXJlX18oXCJjMzY3XCIpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlNTNkXCIpO1xudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzVlOFwiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDgxYlwiKTtcbnZhciBUT19TVFJJTkdfVEFHID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUxNjhcIikoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArXG4gICdET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LCcgK1xuICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICtcbiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgK1xuICAnVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QnKS5zcGxpdCgnLCcpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IERPTUl0ZXJhYmxlc1tpXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzFjMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjNhMzhcIik7XG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyNWViXCIpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3NTE0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1Y2ExXCIpO1xudmFyICRmaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjBhNDlcIikoNSk7XG52YXIgS0VZID0gJ2ZpbmQnO1xudmFyIGZvcmNlZCA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbl9fd2VicGFja19yZXF1aXJlX18oXCI5YzZjXCIpKEtFWSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzY1ZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjcxOFwiKSgnb2JzZXJ2YWJsZScpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjc3MjZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjc3NGVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDJkNVwiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzdmMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ1ODhcIik7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjc5NGJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXyhcIjhlNjBcIikgJiYgIV9fd2VicGFja19yZXF1aXJlX18oXCIyOTRjXCIpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWVjOVwiKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzk1YlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2OTZlXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3OWFhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3OWU1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3Y2Q2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQwYzNcIik7XG52YXIgSVRFUkFUT1IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTE2OFwiKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDgxYlwiKTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU4NGFcIikuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3ZTkwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkOWY2XCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImU0YWVcIik7XG52YXIgZ2V0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjM2ExXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4ZTYwXCIpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjdmMjBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRlZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NmNjXCIpLmY7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY5YThcIik7XG52YXIgVEFHID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJiNGNcIikoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiN2Y3ZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZFAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODZjY1wiKS5mO1xudmFyIEZQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBuYW1lUkUgPSAvXlxccypmdW5jdGlvbiAoW14gKF0qKS87XG52YXIgTkFNRSA9ICduYW1lJztcblxuLy8gMTkuMi40LjIgbmFtZVxuTkFNRSBpbiBGUHJvdG8gfHwgX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllMWVcIikgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoJycgKyB0aGlzKS5tYXRjaChuYW1lUkUpWzFdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjgzNzhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNi4xMScgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiODQzNlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4NGYyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiODVmMlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NTRmXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4NWZlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gT2JzZXJ2ZVZpc2liaWxpdHk7IH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGluc3RhbGwgKi9cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT3B0aW9ucyh2YWx1ZSkge1xuICB2YXIgb3B0aW9ucztcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gU2ltcGxlIG9wdGlvbnMgKGNhbGxiYWNrLW9ubHkpXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGNhbGxiYWNrOiB2YWx1ZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gT3B0aW9ucyBvYmplY3RcbiAgICBvcHRpb25zID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrLCBkZWxheSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB0aW1lb3V0O1xuICB2YXIgbGFzdFN0YXRlO1xuICB2YXIgY3VycmVudEFyZ3M7XG5cbiAgdmFyIHRocm90dGxlZCA9IGZ1bmN0aW9uIHRocm90dGxlZChzdGF0ZSkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGN1cnJlbnRBcmdzID0gYXJncztcbiAgICBpZiAodGltZW91dCAmJiBzdGF0ZSA9PT0gbGFzdFN0YXRlKSByZXR1cm47XG4gICAgdmFyIGxlYWRpbmcgPSBvcHRpb25zLmxlYWRpbmc7XG5cbiAgICBpZiAodHlwZW9mIGxlYWRpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxlYWRpbmcgPSBsZWFkaW5nKHN0YXRlLCBsYXN0U3RhdGUpO1xuICAgIH1cblxuICAgIGlmICgoIXRpbWVvdXQgfHwgc3RhdGUgIT09IGxhc3RTdGF0ZSkgJiYgbGVhZGluZykge1xuICAgICAgY2FsbGJhY2suYXBwbHkodm9pZCAwLCBbc3RhdGVdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY3VycmVudEFyZ3MpKSk7XG4gICAgfVxuXG4gICAgbGFzdFN0YXRlID0gc3RhdGU7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgW3N0YXRlXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGN1cnJlbnRBcmdzKSkpO1xuICAgICAgdGltZW91dCA9IDA7XG4gICAgfSwgZGVsYXkpO1xuICB9O1xuXG4gIHRocm90dGxlZC5fY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiB0aHJvdHRsZWQ7XG59XG5mdW5jdGlvbiBkZWVwRXF1YWwodmFsMSwgdmFsMikge1xuICBpZiAodmFsMSA9PT0gdmFsMikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKF90eXBlb2YodmFsMSkgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbDEpIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKHZhbDFba2V5XSwgdmFsMltrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBWaXNpYmlsaXR5U3RhdGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWaXNpYmlsaXR5U3RhdGUoZWwsIG9wdGlvbnMsIHZub2RlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpc2liaWxpdHlTdGF0ZSk7XG5cbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmNyZWF0ZU9ic2VydmVyKG9wdGlvbnMsIHZub2RlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhWaXNpYmlsaXR5U3RhdGUsIFt7XG4gICAga2V5OiBcImNyZWF0ZU9ic2VydmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMsIHZub2RlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5vYnNlcnZlcikge1xuICAgICAgICB0aGlzLmRlc3Ryb3lPYnNlcnZlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5mcm96ZW4pIHJldHVybjtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHByb2Nlc3NPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLmNhbGxiYWNrID0gZnVuY3Rpb24gKHJlc3VsdCwgZW50cnkpIHtcbiAgICAgICAgX3RoaXMub3B0aW9ucy5jYWxsYmFjayhyZXN1bHQsIGVudHJ5KTtcblxuICAgICAgICBpZiAocmVzdWx0ICYmIF90aGlzLm9wdGlvbnMub25jZSkge1xuICAgICAgICAgIF90aGlzLmZyb3plbiA9IHRydWU7XG5cbiAgICAgICAgICBfdGhpcy5kZXN0cm95T2JzZXJ2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgfTsgLy8gVGhyb3R0bGVcblxuXG4gICAgICBpZiAodGhpcy5jYWxsYmFjayAmJiB0aGlzLm9wdGlvbnMudGhyb3R0bGUpIHtcbiAgICAgICAgdmFyIF9yZWYgPSB0aGlzLm9wdGlvbnMudGhyb3R0bGVPcHRpb25zIHx8IHt9LFxuICAgICAgICAgICAgX2xlYWRpbmcgPSBfcmVmLmxlYWRpbmc7XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IHRocm90dGxlKHRoaXMuY2FsbGJhY2ssIHRoaXMub3B0aW9ucy50aHJvdHRsZSwge1xuICAgICAgICAgIGxlYWRpbmc6IGZ1bmN0aW9uIGxlYWRpbmcoc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfbGVhZGluZyA9PT0gJ2JvdGgnIHx8IF9sZWFkaW5nID09PSAndmlzaWJsZScgJiYgc3RhdGUgfHwgX2xlYWRpbmcgPT09ICdoaWRkZW4nICYmICFzdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9sZFJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1swXTtcblxuICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFyIGludGVyc2VjdGluZ0VudHJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5pc0ludGVyc2VjdGluZztcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChpbnRlcnNlY3RpbmdFbnRyeSkge1xuICAgICAgICAgICAgZW50cnkgPSBpbnRlcnNlY3RpbmdFbnRyeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMuY2FsbGJhY2spIHtcbiAgICAgICAgICAvLyBVc2UgaXNJbnRlcnNlY3RpbmcgaWYgcG9zc2libGUgYmVjYXVzZSBicm93c2VycyBjYW4gcmVwb3J0IGlzSW50ZXJzZWN0aW5nIGFzIHRydWUsIGJ1dCBpbnRlcnNlY3Rpb25SYXRpbyBhcyAwLCB3aGVuIHNvbWV0aGluZyB2ZXJ5IHNsb3dseSBlbnRlcnMgdGhlIHZpZXdwb3J0LlxuICAgICAgICAgIHZhciByZXN1bHQgPSBlbnRyeS5pc0ludGVyc2VjdGluZyAmJiBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+PSBfdGhpcy50aHJlc2hvbGQ7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gX3RoaXMub2xkUmVzdWx0KSByZXR1cm47XG4gICAgICAgICAgX3RoaXMub2xkUmVzdWx0ID0gcmVzdWx0O1xuXG4gICAgICAgICAgX3RoaXMuY2FsbGJhY2socmVzdWx0LCBlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnNlY3Rpb24pOyAvLyBXYWl0IGZvciB0aGUgZWxlbWVudCB0byBiZSBpbiBkb2N1bWVudFxuXG4gICAgICB2bm9kZS5jb250ZXh0LiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5vYnNlcnZlcikge1xuICAgICAgICAgIF90aGlzLm9ic2VydmVyLm9ic2VydmUoX3RoaXMuZWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveU9ic2VydmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3lPYnNlcnZlcigpIHtcbiAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgIH0gLy8gQ2FuY2VsIHRocm90dGxlZCBjYWxsXG5cblxuICAgICAgaWYgKHRoaXMuY2FsbGJhY2sgJiYgdGhpcy5jYWxsYmFjay5fY2xlYXIpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjay5fY2xlYXIoKTtcblxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGhyZXNob2xkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmludGVyc2VjdGlvbiAmJiB0aGlzLm9wdGlvbnMuaW50ZXJzZWN0aW9uLnRocmVzaG9sZCB8fCAwO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWaXNpYmlsaXR5U3RhdGU7XG59KCk7XG5cbmZ1bmN0aW9uIGJpbmQoZWwsIF9yZWYyLCB2bm9kZSkge1xuICB2YXIgdmFsdWUgPSBfcmVmMi52YWx1ZTtcbiAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuXG4gIGlmICh0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS53YXJuKCdbdnVlLW9ic2VydmUtdmlzaWJpbGl0eV0gSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgQVBJIGlzIG5vdCBhdmFpbGFibGUgaW4geW91ciBicm93c2VyLiBQbGVhc2UgaW5zdGFsbCB0aGlzIHBvbHlmaWxsOiBodHRwczovL2dpdGh1Yi5jb20vdzNjL0ludGVyc2VjdGlvbk9ic2VydmVyL3RyZWUvbWFzdGVyL3BvbHlmaWxsJyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0YXRlID0gbmV3IFZpc2liaWxpdHlTdGF0ZShlbCwgdmFsdWUsIHZub2RlKTtcbiAgICBlbC5fdnVlX3Zpc2liaWxpdHlTdGF0ZSA9IHN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZShlbCwgX3JlZjMsIHZub2RlKSB7XG4gIHZhciB2YWx1ZSA9IF9yZWYzLnZhbHVlLFxuICAgICAgb2xkVmFsdWUgPSBfcmVmMy5vbGRWYWx1ZTtcbiAgaWYgKGRlZXBFcXVhbCh2YWx1ZSwgb2xkVmFsdWUpKSByZXR1cm47XG4gIHZhciBzdGF0ZSA9IGVsLl92dWVfdmlzaWJpbGl0eVN0YXRlO1xuXG4gIGlmICghdmFsdWUpIHtcbiAgICB1bmJpbmQoZWwpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZSkge1xuICAgIHN0YXRlLmNyZWF0ZU9ic2VydmVyKHZhbHVlLCB2bm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgYmluZChlbCwge1xuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuYmluZChlbCkge1xuICB2YXIgc3RhdGUgPSBlbC5fdnVlX3Zpc2liaWxpdHlTdGF0ZTtcblxuICBpZiAoc3RhdGUpIHtcbiAgICBzdGF0ZS5kZXN0cm95T2JzZXJ2ZXIoKTtcbiAgICBkZWxldGUgZWwuX3Z1ZV92aXNpYmlsaXR5U3RhdGU7XG4gIH1cbn1cblxudmFyIE9ic2VydmVWaXNpYmlsaXR5ID0ge1xuICBiaW5kOiBiaW5kLFxuICB1cGRhdGU6IHVwZGF0ZSxcbiAgdW5iaW5kOiB1bmJpbmRcbn07XG5cbmZ1bmN0aW9uIGluc3RhbGwoVnVlKSB7XG4gIFZ1ZS5kaXJlY3RpdmUoJ29ic2VydmUtdmlzaWJpbGl0eScsIE9ic2VydmVWaXNpYmlsaXR5KTtcbiAgLyogLS0gQWRkIG1vcmUgY29tcG9uZW50cyBoZXJlIC0tICovXG59XG4vKiAtLSBQbHVnaW4gZGVmaW5pdGlvbiAmIEF1dG8taW5zdGFsbCAtLSAqL1xuXG4vKiBZb3Ugc2hvdWxkbid0IGhhdmUgdG8gbW9kaWZ5IHRoZSBjb2RlIGJlbG93ICovXG4vLyBQbHVnaW5cblxudmFyIHBsdWdpbiA9IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZlcnNpb246IFwiMC40LjZcIixcbiAgaW5zdGFsbDogaW5zdGFsbFxufTtcblxudmFyIEdsb2JhbFZ1ZSA9IG51bGw7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBHbG9iYWxWdWUgPSB3aW5kb3cuVnVlO1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICBHbG9iYWxWdWUgPSBnbG9iYWwuVnVlO1xufVxuXG5pZiAoR2xvYmFsVnVlKSB7XG4gIEdsb2JhbFZ1ZS51c2UocGx1Z2luKTtcbn1cblxuLyogdW51c2VkIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIF91bnVzZWRfd2VicGFja19kZWZhdWx0X2V4cG9ydCA9IChwbHVnaW4pO1xuXG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzhiYVwiKSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjg2Y2NcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNiN2NcIik7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzY5YVwiKTtcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2YTk5XCIpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWUxZVwiKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjg4NzVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187Ly8gYWRkYXB0ZWQgZnJvbSB0aGUgZG9jdW1lbnQuY3VycmVudFNjcmlwdCBwb2x5ZmlsbCBieSBBZGFtIE1pbGxlclxuLy8gTUlUIGxpY2Vuc2Vcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FtaWxsZXItZ2gvY3VycmVudFNjcmlwdC1wb2x5ZmlsbFxuXG4vLyBhZGRlZCBzdXBwb3J0IGZvciBGaXJlZm94IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MjA1MDVcblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0cnVlKSB7XG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICB9IGVsc2Uge31cbn0odHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmlwdCAoKSB7XG4gICAgaWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0XG4gICAgfVxuICBcbiAgICAvLyBJRSA4LTEwIHN1cHBvcnQgc2NyaXB0IHJlYWR5U3RhdGVcbiAgICAvLyBJRSAxMSsgJiBGaXJlZm94IHN1cHBvcnQgc3RhY2sgdHJhY2VcbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIEZpbmQgdGhlIHNlY29uZCBtYXRjaCBmb3IgdGhlIFwiYXRcIiBzdHJpbmcgdG8gZ2V0IGZpbGUgc3JjIHVybCBmcm9tIHN0YWNrLlxuICAgICAgdmFyIGllU3RhY2tSZWdFeHAgPSAvLiphdCBbXihdKlxcKCguKik6KC4rKTooLispXFwpJC9pZyxcbiAgICAgICAgZmZTdGFja1JlZ0V4cCA9IC9AKFteQF0qKTooXFxkKyk6KFxcZCspXFxzKiQvaWcsXG4gICAgICAgIHN0YWNrRGV0YWlscyA9IGllU3RhY2tSZWdFeHAuZXhlYyhlcnIuc3RhY2spIHx8IGZmU3RhY2tSZWdFeHAuZXhlYyhlcnIuc3RhY2spLFxuICAgICAgICBzY3JpcHRMb2NhdGlvbiA9IChzdGFja0RldGFpbHMgJiYgc3RhY2tEZXRhaWxzWzFdKSB8fCBmYWxzZSxcbiAgICAgICAgbGluZSA9IChzdGFja0RldGFpbHMgJiYgc3RhY2tEZXRhaWxzWzJdKSB8fCBmYWxzZSxcbiAgICAgICAgY3VycmVudExvY2F0aW9uID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZi5yZXBsYWNlKGRvY3VtZW50LmxvY2F0aW9uLmhhc2gsICcnKSxcbiAgICAgICAgcGFnZVNvdXJjZSxcbiAgICAgICAgaW5saW5lU2NyaXB0U291cmNlUmVnRXhwLFxuICAgICAgICBpbmxpbmVTY3JpcHRTb3VyY2UsXG4gICAgICAgIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7IC8vIExpdmUgTm9kZUxpc3QgY29sbGVjdGlvblxuICBcbiAgICAgIGlmIChzY3JpcHRMb2NhdGlvbiA9PT0gY3VycmVudExvY2F0aW9uKSB7XG4gICAgICAgIHBhZ2VTb3VyY2UgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICBpbmxpbmVTY3JpcHRTb3VyY2VSZWdFeHAgPSBuZXcgUmVnRXhwKCcoPzpbXlxcXFxuXSs/XFxcXG4pezAsJyArIChsaW5lIC0gMikgKyAnfVtePF0qPHNjcmlwdD4oW1xcXFxkXFxcXERdKj8pPFxcXFwvc2NyaXB0PltcXFxcZFxcXFxEXSonLCAnaScpO1xuICAgICAgICBpbmxpbmVTY3JpcHRTb3VyY2UgPSBwYWdlU291cmNlLnJlcGxhY2UoaW5saW5lU2NyaXB0U291cmNlUmVnRXhwLCAnJDEnKS50cmltKCk7XG4gICAgICB9XG4gIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIElmIHJlYWR5IHN0YXRlIGlzIGludGVyYWN0aXZlLCByZXR1cm4gdGhlIHNjcmlwdCB0YWdcbiAgICAgICAgaWYgKHNjcmlwdHNbaV0ucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJykge1xuICAgICAgICAgIHJldHVybiBzY3JpcHRzW2ldO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBJZiBzcmMgbWF0Y2hlcywgcmV0dXJuIHRoZSBzY3JpcHQgdGFnXG4gICAgICAgIGlmIChzY3JpcHRzW2ldLnNyYyA9PT0gc2NyaXB0TG9jYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gc2NyaXB0c1tpXTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gSWYgaW5saW5lIHNvdXJjZSBtYXRjaGVzLCByZXR1cm4gdGhlIHNjcmlwdCB0YWdcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHNjcmlwdExvY2F0aW9uID09PSBjdXJyZW50TG9jYXRpb24gJiZcbiAgICAgICAgICBzY3JpcHRzW2ldLmlubmVySFRNTCAmJlxuICAgICAgICAgIHNjcmlwdHNbaV0uaW5uZXJIVE1MLnRyaW0oKSA9PT0gaW5saW5lU2NyaXB0U291cmNlXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBzY3JpcHRzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgLy8gSWYgbm8gbWF0Y2gsIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGdldEN1cnJlbnRTY3JpcHRcbn0pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4Yjk3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkM2Y0XCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNiN2NcIik7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjliNDNcIikoRnVuY3Rpb24uY2FsbCwgX193ZWJwYWNrX3JlcXVpcmVfXyhcIjExZTlcIikuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoIChlKSB7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYgKGJ1Z2d5KSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOGJiZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ2dWVcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjhlNjBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI5NGNcIikoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjhlNmVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVjYTFcIik7XG52YXIgb3duS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5OTBiXCIpO1xudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2ODIxXCIpO1xudmFyIGdPUEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTFlOVwiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmMWFlXCIpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXREZXNjID0gZ09QRC5mO1xuICAgIHZhciBrZXlzID0gb3duS2V5cyhPKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXksIGRlc2M7XG4gICAgd2hpbGUgKGtleXMubGVuZ3RoID4gaSkge1xuICAgICAgZGVzYyA9IGdldERlc2MoTywga2V5ID0ga2V5c1tpKytdKTtcbiAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOGY2MFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhMTU5XCIpO1xudmFyIGRlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWViZFwiKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NWYyXCIpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzVlOFwiKShJdGVyYXRvclByb3RvdHlwZSwgX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUxNjhcIikoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjhmODJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjkwMDNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmI0Y1wiKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOTA5M1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2UxMFwiKTtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUxMWVcIikuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjkxMzhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzVlOFwiKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5MmNjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5NWQ1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQwYzNcIik7XG52YXIgSVRFUkFUT1IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTE2OFwiKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDgxYlwiKTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU4NGFcIikuaXNJdGVyYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTyA9IE9iamVjdChpdCk7XG4gIHJldHVybiBPW0lURVJBVE9SXSAhPT0gdW5kZWZpbmVkXG4gICAgfHwgJ0BAaXRlcmF0b3InIGluIE9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgfHwgSXRlcmF0b3JzLmhhc093blByb3BlcnR5KGNsYXNzb2YoTykpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5NmNmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gICB0cnVlID8gbW9kdWxlLmV4cG9ydHMgOiB1bmRlZmluZWRcbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5OTBiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBnT1BOID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkwOTNcIik7XG52YXIgZ09QUyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyNjIxXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNiN2NcIik7XG52YXIgUmVmbGVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NzI2XCIpLlJlZmxlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnT1BOLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHJldHVybiBnZXRTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOWFhOVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjliNDNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ4ZThcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOWM2Y1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmI0Y1wiKSgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuaWYgKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkgX193ZWJwYWNrX3JlcXVpcmVfXyhcIjMyZTlcIikoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOWRlZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDU4OFwiKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjllMWVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc5ZTVcIikoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImExNTlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTRhZVwiKTtcbnZhciBkUHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2U5MFwiKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxNjkxXCIpO1xudmFyIElFX1BST1RPID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU1NTlcIikoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFlYzlcIikoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIF9fd2VicGFja19yZXF1aXJlX18oXCIzMmZjXCIpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhMjJhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjdHggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDg2NFwiKTtcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImIwZGNcIik7XG52YXIgaXNBcnJheUl0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzcwMlwiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlNGFlXCIpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI0NDdcIik7XG52YXIgZ2V0SXRlckZuID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdjZDZcIik7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYTc0NVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNDEwXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhYTc3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVjYTFcIik7XG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiZTEzXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc5ZTVcIik7XG52YXIgc3BhY2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZkZWZcIik7XG52YXIgc3BhY2UgPSAnWycgKyBzcGFjZXMgKyAnXSc7XG52YXIgbm9uID0gJ1xcdTIwMGJcXHUwMDg1JztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7XG5cbnZhciBleHBvcnRlciA9IGZ1bmN0aW9uIChLRVksIGV4ZWMsIEFMSUFTKSB7XG4gIHZhciBleHAgPSB7fTtcbiAgdmFyIEZPUkNFID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZiAoQUxJQVMpIGV4cFtBTElBU10gPSBmbjtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59O1xuXG4vLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbiAoc3RyaW5nLCBUWVBFKSB7XG4gIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmIChUWVBFICYgMikgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYWFlM1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyA3LjIuOCBJc1JlZ0V4cChhcmd1bWVudClcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkM2Y0XCIpO1xudmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyZDk1XCIpO1xudmFyIE1BVENIID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJiNGNcIikoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYWJhMlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImU1M2RcIik7XG52YXIgbWFjcm90YXNrID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQxNzhcIikuc2V0O1xudmFyIE9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbnZhciBpc05vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmI0Y1wiKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZiAoaXNOb2RlKSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIFNhZmFyaSAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgfSBlbHNlIGlmIChPYnNlcnZlciAmJiAhKGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci5zdGFuZGFsb25lKSkge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgLy8gUHJvbWlzZS5yZXNvbHZlIHdpdGhvdXQgYW4gYXJndW1lbnQgdGhyb3dzIGFuIGVycm9yIGluIExHIFdlYk9TIDJcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYgKCFoZWFkKSB7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImFjNmFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICRpdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2FkZlwiKTtcbnZhciBnZXRLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjBkNThcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmFiYVwiKTtcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzcyNlwiKTtcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjMyZTlcIik7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg0ZjJcIik7XG52YXIgd2tzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJiNGNcIik7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhZWJkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYjBkY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTRhZVwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiNDQ3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzYTM4XCIpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYjhhY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX3JlZl84X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzhfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfaW5kZXhfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfZTU5YmUzYjRfbGFuZ19zY3NzX3Njb3BlZF90cnVlX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQwNTJcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19taW5pX2Nzc19leHRyYWN0X3BsdWdpbl9kaXN0X2xvYWRlcl9qc19yZWZfOF9vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl84X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfc2Fzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzhfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX2luZGV4X3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkX2U1OWJlM2I0X2xhbmdfc2Nzc19zY29wZWRfdHJ1ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX3JlZl84X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzhfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfOF9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfaW5kZXhfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfZTU5YmUzYjRfbGFuZ19zY3NzX3Njb3BlZF90cnVlX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIHVudXNlZCBoYXJtb255IHJlZXhwb3J0ICogKi9cbiAvKiB1bnVzZWQgaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgX3VudXNlZF93ZWJwYWNrX2RlZmF1bHRfZXhwb3J0ID0gKF9ub2RlX21vZHVsZXNfbWluaV9jc3NfZXh0cmFjdF9wbHVnaW5fZGlzdF9sb2FkZXJfanNfcmVmXzhfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl84X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfOF9vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl84X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19pbmRleF92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF9lNTliZTNiNF9sYW5nX3Njc3Nfc2NvcGVkX3RydWVfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKTsgXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImI4ZTNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImJjMTNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlNTNkXCIpO1xudmFyIG5hdmlnYXRvciA9IGdsb2JhbC5uYXZpZ2F0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYmUxM1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImJmMGJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHBJRSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNTVkXCIpO1xudmFyIGNyZWF0ZURlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWViZFwiKTtcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzZjM1wiKTtcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxYmMzXCIpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwN2UzXCIpO1xudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc5NGJcIik7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4ZTYwXCIpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjMjA3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjMzY2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY4MjFcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWRlZlwiKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzdmMVwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImMzNjdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg0MzZcIik7XG52YXIgc3RlcCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MGVkXCIpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0ODFiXCIpO1xudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNmMzXCIpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzMGYxXCIpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzNhMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlNmYzXCIpO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE2OTFcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImM1ZjZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzcyNlwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjlhOFwiKTtcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmQ5NVwiKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1ZGJjXCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjZhOTlcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzllNVwiKTtcbnZhciBnT1BOID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkwOTNcIikuZjtcbnZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjExZTlcIikuZjtcbnZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NmNjXCIpLmY7XG52YXIgJHRyaW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWE3N1wiKS50cmltO1xudmFyIE5VTUJFUiA9ICdOdW1iZXInO1xudmFyICROdW1iZXIgPSBnbG9iYWxbTlVNQkVSXTtcbnZhciBCYXNlID0gJE51bWJlcjtcbnZhciBwcm90byA9ICROdW1iZXIucHJvdG90eXBlO1xuLy8gT3BlcmEgfjEyIGhhcyBicm9rZW4gT2JqZWN0I3RvU3RyaW5nXG52YXIgQlJPS0VOX0NPRiA9IGNvZihfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmFlYlwiKShwcm90bykpID09IE5VTUJFUjtcbnZhciBUUklNID0gJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGU7XG5cbi8vIDcuMS4zIFRvTnVtYmVyKGFyZ3VtZW50KVxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBpdCA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCBmYWxzZSk7XG4gIGlmICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMikge1xuICAgIGl0ID0gVFJJTSA/IGl0LnRyaW0oKSA6ICR0cmltKGl0LCAzKTtcbiAgICB2YXIgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApO1xuICAgIHZhciB0aGlyZCwgcmFkaXgsIG1heENvZGU7XG4gICAgaWYgKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpIHtcbiAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmICh0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMCkgcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09IDQ4KSB7XG4gICAgICBzd2l0Y2ggKGl0LmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgICAgY2FzZSA2NjogY2FzZSA5ODogcmFkaXggPSAyOyBtYXhDb2RlID0gNDk7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDc5OiBjYXNlIDExMTogcmFkaXggPSA4OyBtYXhDb2RlID0gNTU7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMG9bMC03XSskL2lcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuICtpdDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGRpZ2l0cyA9IGl0LnNsaWNlKDIpLCBpID0gMCwgbCA9IGRpZ2l0cy5sZW5ndGgsIGNvZGU7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSkgcmV0dXJuIE5hTjtcbiAgICAgIH0gcmV0dXJuIHBhcnNlSW50KGRpZ2l0cywgcmFkaXgpO1xuICAgIH1cbiAgfSByZXR1cm4gK2l0O1xufTtcblxuaWYgKCEkTnVtYmVyKCcgMG8xJykgfHwgISROdW1iZXIoJzBiMScpIHx8ICROdW1iZXIoJysweDEnKSkge1xuICAkTnVtYmVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKSB7XG4gICAgdmFyIGl0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogdmFsdWU7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGF0IGluc3RhbmNlb2YgJE51bWJlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NPRiA/IGZhaWxzKGZ1bmN0aW9uICgpIHsgcHJvdG8udmFsdWVPZi5jYWxsKHRoYXQpOyB9KSA6IGNvZih0aGF0KSAhPSBOVU1CRVIpXG4gICAgICAgID8gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UodG9OdW1iZXIoaXQpKSwgdGhhdCwgJE51bWJlcikgOiB0b051bWJlcihpdCk7XG4gIH07XG4gIGZvciAodmFyIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWUxZVwiKSA/IGdPUE4oQmFzZSkgOiAoXG4gICAgLy8gRVMzOlxuICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAvLyBFUzYgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzYgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgK1xuICAgICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJ1xuICApLnNwbGl0KCcsJyksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgaisrKSB7XG4gICAgaWYgKGhhcyhCYXNlLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKCROdW1iZXIsIGtleSkpIHtcbiAgICAgIGRQKCROdW1iZXIsIGtleSwgZ09QRChCYXNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbiAgJE51bWJlci5wcm90b3R5cGUgPSBwcm90bztcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkTnVtYmVyO1xuICBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmFiYVwiKShnbG9iYWwsIE5VTUJFUiwgJE51bWJlcik7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzY5YVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWUxZVwiKSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc5ZTVcIikoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19yZXF1aXJlX18oXCIyMzBlXCIpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjOGJhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjOGJiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU0YTFcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImNhNWFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiY2FkZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWM2Y1wiKTtcbnZhciBzdGVwID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ1M2JcIik7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg0ZjJcIik7XG52YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY4MjFcIik7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjAxZjlcIikoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjYjdjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkM2Y0XCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjY2I5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MTY4XCIpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImNkMWNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlODUzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImNkNzhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImU0YWVcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjc3MlwiKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2NTZlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImNlMTBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2OWE4XCIpO1xudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2ODIxXCIpO1xudmFyIGFycmF5SW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjMzY2XCIpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2MTNiXCIpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkMDUyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkMmM4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGhlbHBlciBmb3IgU3RyaW5nI3tzdGFydHNXaXRoLCBlbmRzV2l0aCwgaW5jbHVkZXN9XG52YXIgaXNSZWdFeHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWFlM1wiKTtcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImJlMTNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSkge1xuICBpZiAoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSkgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQyZDVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE2NTRcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTQ5YlwiKTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU4NGFcIikuQXJyYXkuZnJvbTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkMzkxXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTi5wYXJzZShcIntcXFwiQUNcXFwiOlxcXCI0MDEyM1xcXCIsXFxcIkFEXFxcIjpcXFwiMzEyMzQ1XFxcIixcXFwiQUVcXFwiOlxcXCI1MDEyMzQ1NjdcXFwiLFxcXCJBRlxcXCI6XFxcIjcwMTIzNDU2N1xcXCIsXFxcIkFHXFxcIjpcXFwiMjY4NDY0MTIzNFxcXCIsXFxcIkFJXFxcIjpcXFwiMjY0MjM1MTIzNFxcXCIsXFxcIkFMXFxcIjpcXFwiNjcyMTIzNDU2XFxcIixcXFwiQU1cXFwiOlxcXCI3NzEyMzQ1NlxcXCIsXFxcIkFPXFxcIjpcXFwiOTIzMTIzNDU2XFxcIixcXFwiQVJcXFwiOlxcXCI5MTEyMzQ1Njc4OVxcXCIsXFxcIkFTXFxcIjpcXFwiNjg0NzMzMTIzNFxcXCIsXFxcIkFUXFxcIjpcXFwiNjY0MTIzNDU2XFxcIixcXFwiQVVcXFwiOlxcXCI0MTIzNDU2NzhcXFwiLFxcXCJBV1xcXCI6XFxcIjU2MDEyMzRcXFwiLFxcXCJBWFxcXCI6XFxcIjQxMjM0NTY3OFxcXCIsXFxcIkFaXFxcIjpcXFwiNDAxMjM0NTY3XFxcIixcXFwiQkFcXFwiOlxcXCI2MTEyMzQ1NlxcXCIsXFxcIkJCXFxcIjpcXFwiMjQ2MjUwMTIzNFxcXCIsXFxcIkJEXFxcIjpcXFwiMTgxMjM0NTY3OFxcXCIsXFxcIkJFXFxcIjpcXFwiNDcwMTIzNDU2XFxcIixcXFwiQkZcXFwiOlxcXCI3MDEyMzQ1NlxcXCIsXFxcIkJHXFxcIjpcXFwiNDgxMjM0NTZcXFwiLFxcXCJCSFxcXCI6XFxcIjM2MDAxMjM0XFxcIixcXFwiQklcXFwiOlxcXCI3OTU2MTIzNFxcXCIsXFxcIkJKXFxcIjpcXFwiOTAwMTEyMzRcXFwiLFxcXCJCTFxcXCI6XFxcIjY5MDAwMTIzNFxcXCIsXFxcIkJNXFxcIjpcXFwiNDQxMzcwMTIzNFxcXCIsXFxcIkJOXFxcIjpcXFwiNzEyMzQ1NlxcXCIsXFxcIkJPXFxcIjpcXFwiNzEyMzQ1NjdcXFwiLFxcXCJCUVxcXCI6XFxcIjMxODEyMzRcXFwiLFxcXCJCUlxcXCI6XFxcIjExOTYxMjM0NTY3XFxcIixcXFwiQlNcXFwiOlxcXCIyNDIzNTkxMjM0XFxcIixcXFwiQlRcXFwiOlxcXCIxNzEyMzQ1NlxcXCIsXFxcIkJXXFxcIjpcXFwiNzExMjM0NTZcXFwiLFxcXCJCWVxcXCI6XFxcIjI5NDkxMTkxMVxcXCIsXFxcIkJaXFxcIjpcXFwiNjIyMTIzNFxcXCIsXFxcIkNBXFxcIjpcXFwiNTA2MjM0NTY3OFxcXCIsXFxcIkNDXFxcIjpcXFwiNDEyMzQ1Njc4XFxcIixcXFwiQ0RcXFwiOlxcXCI5OTEyMzQ1NjdcXFwiLFxcXCJDRlxcXCI6XFxcIjcwMDEyMzQ1XFxcIixcXFwiQ0dcXFwiOlxcXCIwNjEyMzQ1NjdcXFwiLFxcXCJDSFxcXCI6XFxcIjc4MTIzNDU2N1xcXCIsXFxcIkNJXFxcIjpcXFwiMDEyMzQ1NjdcXFwiLFxcXCJDS1xcXCI6XFxcIjcxMjM0XFxcIixcXFwiQ0xcXFwiOlxcXCIyMjEyMzQ1NjdcXFwiLFxcXCJDTVxcXCI6XFxcIjY3MTIzNDU2N1xcXCIsXFxcIkNOXFxcIjpcXFwiMTMxMjM0NTY3ODlcXFwiLFxcXCJDT1xcXCI6XFxcIjMyMTEyMzQ1NjdcXFwiLFxcXCJDUlxcXCI6XFxcIjgzMTIzNDU2XFxcIixcXFwiQ1VcXFwiOlxcXCI1MTIzNDU2N1xcXCIsXFxcIkNWXFxcIjpcXFwiOTkxMTIzNFxcXCIsXFxcIkNXXFxcIjpcXFwiOTUxODEyMzRcXFwiLFxcXCJDWFxcXCI6XFxcIjQxMjM0NTY3OFxcXCIsXFxcIkNZXFxcIjpcXFwiOTYxMjM0NTZcXFwiLFxcXCJDWlxcXCI6XFxcIjYwMTEyMzQ1NlxcXCIsXFxcIkRFXFxcIjpcXFwiMTUxMjM0NTY3ODlcXFwiLFxcXCJESlxcXCI6XFxcIjc3ODMxMDAxXFxcIixcXFwiREtcXFwiOlxcXCIzMjEyMzQ1NlxcXCIsXFxcIkRNXFxcIjpcXFwiNzY3MjI1MTIzNFxcXCIsXFxcIkRPXFxcIjpcXFwiODA5MjM0NTY3OFxcXCIsXFxcIkRaXFxcIjpcXFwiNTUxMjM0NTY3XFxcIixcXFwiRUNcXFwiOlxcXCI5OTEyMzQ1NjdcXFwiLFxcXCJFRVxcXCI6XFxcIjUxMjM0NTY3XFxcIixcXFwiRUdcXFwiOlxcXCIxMDAxMjM0NTY3XFxcIixcXFwiRUhcXFwiOlxcXCI2NTAxMjM0NTZcXFwiLFxcXCJFUlxcXCI6XFxcIjcxMjM0NTZcXFwiLFxcXCJFU1xcXCI6XFxcIjYxMjM0NTY3OFxcXCIsXFxcIkVUXFxcIjpcXFwiOTExMjM0NTY3XFxcIixcXFwiRklcXFwiOlxcXCI0MTIzNDU2NzhcXFwiLFxcXCJGSlxcXCI6XFxcIjcwMTIzNDVcXFwiLFxcXCJGS1xcXCI6XFxcIjUxMjM0XFxcIixcXFwiRk1cXFwiOlxcXCIzNTAxMjM0XFxcIixcXFwiRk9cXFwiOlxcXCIyMTEyMzRcXFwiLFxcXCJGUlxcXCI6XFxcIjYxMjM0NTY3OFxcXCIsXFxcIkdBXFxcIjpcXFwiMDYwMzEyMzRcXFwiLFxcXCJHQlxcXCI6XFxcIjc0MDAxMjM0NTZcXFwiLFxcXCJHRFxcXCI6XFxcIjQ3MzQwMzEyMzRcXFwiLFxcXCJHRVxcXCI6XFxcIjU1NTEyMzQ1NlxcXCIsXFxcIkdGXFxcIjpcXFwiNjk0MjAxMjM0XFxcIixcXFwiR0dcXFwiOlxcXCI3NzgxMTIzNDU2XFxcIixcXFwiR0hcXFwiOlxcXCIyMzEyMzQ1NjdcXFwiLFxcXCJHSVxcXCI6XFxcIjU3MTIzNDU2XFxcIixcXFwiR0xcXFwiOlxcXCIyMjEyMzRcXFwiLFxcXCJHTVxcXCI6XFxcIjMwMTIzNDVcXFwiLFxcXCJHTlxcXCI6XFxcIjYwMTEyMzQ1NlxcXCIsXFxcIkdQXFxcIjpcXFwiNjkwMDAxMjM0XFxcIixcXFwiR1FcXFwiOlxcXCIyMjIxMjM0NTZcXFwiLFxcXCJHUlxcXCI6XFxcIjY5MTIzNDU2NzhcXFwiLFxcXCJHVFxcXCI6XFxcIjUxMjM0NTY3XFxcIixcXFwiR1VcXFwiOlxcXCI2NzEzMDAxMjM0XFxcIixcXFwiR1dcXFwiOlxcXCI5NTUwMTIzNDVcXFwiLFxcXCJHWVxcXCI6XFxcIjYwOTEyMzRcXFwiLFxcXCJIS1xcXCI6XFxcIjUxMjM0NTY3XFxcIixcXFwiSE5cXFwiOlxcXCI5MTIzNDU2N1xcXCIsXFxcIkhSXFxcIjpcXFwiOTIxMjM0NTY3XFxcIixcXFwiSFRcXFwiOlxcXCIzNDEwMTIzNFxcXCIsXFxcIkhVXFxcIjpcXFwiMjAxMjM0NTY3XFxcIixcXFwiSURcXFwiOlxcXCI4MTIzNDU2NzhcXFwiLFxcXCJJRVxcXCI6XFxcIjg1MDEyMzQ1NlxcXCIsXFxcIklMXFxcIjpcXFwiNTAyMzQ1Njc4XFxcIixcXFwiSU1cXFwiOlxcXCI3OTI0MTIzNDU2XFxcIixcXFwiSU5cXFwiOlxcXCI4MTIzNDU2Nzg5XFxcIixcXFwiSU9cXFwiOlxcXCIzODAxMjM0XFxcIixcXFwiSVFcXFwiOlxcXCI3OTEyMzQ1Njc4XFxcIixcXFwiSVJcXFwiOlxcXCI5MTIzNDU2Nzg5XFxcIixcXFwiSVNcXFwiOlxcXCI2MTExMjM0XFxcIixcXFwiSVRcXFwiOlxcXCIzMTIzNDU2Nzg5XFxcIixcXFwiSkVcXFwiOlxcXCI3Nzk3NzEyMzQ1XFxcIixcXFwiSk1cXFwiOlxcXCI4NzYyMTAxMjM0XFxcIixcXFwiSk9cXFwiOlxcXCI3OTAxMjM0NTZcXFwiLFxcXCJKUFxcXCI6XFxcIjkwMTIzNDU2NzhcXFwiLFxcXCJLRVxcXCI6XFxcIjcxMjEyMzQ1NlxcXCIsXFxcIktHXFxcIjpcXFwiNzAwMTIzNDU2XFxcIixcXFwiS0hcXFwiOlxcXCI5MTIzNDU2N1xcXCIsXFxcIktJXFxcIjpcXFwiNzIwMDEyMzRcXFwiLFxcXCJLTVxcXCI6XFxcIjMyMTIzNDVcXFwiLFxcXCJLTlxcXCI6XFxcIjg2OTc2NTI5MTdcXFwiLFxcXCJLUFxcXCI6XFxcIjE5MjEyMzQ1NjdcXFwiLFxcXCJLUlxcXCI6XFxcIjEwMjAwMDAwMDBcXFwiLFxcXCJLV1xcXCI6XFxcIjUwMDEyMzQ1XFxcIixcXFwiS1lcXFwiOlxcXCIzNDUzMjMxMjM0XFxcIixcXFwiS1pcXFwiOlxcXCI3NzEwMDA5OTk4XFxcIixcXFwiTEFcXFwiOlxcXCIyMDIzMTIzNDU2XFxcIixcXFwiTEJcXFwiOlxcXCI3MTEyMzQ1NlxcXCIsXFxcIkxDXFxcIjpcXFwiNzU4Mjg0NTY3OFxcXCIsXFxcIkxJXFxcIjpcXFwiNjYwMjM0NTY3XFxcIixcXFwiTEtcXFwiOlxcXCI3MTIzNDU2NzhcXFwiLFxcXCJMUlxcXCI6XFxcIjc3MDEyMzQ1NlxcXCIsXFxcIkxTXFxcIjpcXFwiNTAxMjM0NTZcXFwiLFxcXCJMVFxcXCI6XFxcIjYxMjM0NTY3XFxcIixcXFwiTFVcXFwiOlxcXCI2MjgxMjM0NTZcXFwiLFxcXCJMVlxcXCI6XFxcIjIxMjM0NTY3XFxcIixcXFwiTFlcXFwiOlxcXCI5MTIzNDU2NzhcXFwiLFxcXCJNQVxcXCI6XFxcIjY1MDEyMzQ1NlxcXCIsXFxcIk1DXFxcIjpcXFwiNjEyMzQ1Njc4XFxcIixcXFwiTURcXFwiOlxcXCI2MjExMjM0NVxcXCIsXFxcIk1FXFxcIjpcXFwiNjc2MjI5MDFcXFwiLFxcXCJNRlxcXCI6XFxcIjY5MDAwMTIzNFxcXCIsXFxcIk1HXFxcIjpcXFwiMzIxMjM0NTY3XFxcIixcXFwiTUhcXFwiOlxcXCIyMzUxMjM0XFxcIixcXFwiTUtcXFwiOlxcXCI3MjM0NTY3OFxcXCIsXFxcIk1MXFxcIjpcXFwiNjUwMTIzNDVcXFwiLFxcXCJNTVxcXCI6XFxcIjkyMTIzNDU2XFxcIixcXFwiTU5cXFwiOlxcXCI4ODEyMzQ1NlxcXCIsXFxcIk1PXFxcIjpcXFwiNjYxMjM0NTZcXFwiLFxcXCJNUFxcXCI6XFxcIjY3MDIzNDU2NzhcXFwiLFxcXCJNUVxcXCI6XFxcIjY5NjIwMTIzNFxcXCIsXFxcIk1SXFxcIjpcXFwiMjIxMjM0NTZcXFwiLFxcXCJNU1xcXCI6XFxcIjY2NDQ5MjM0NTZcXFwiLFxcXCJNVFxcXCI6XFxcIjk2OTYxMjM0XFxcIixcXFwiTVVcXFwiOlxcXCI1MjUxMjM0NVxcXCIsXFxcIk1WXFxcIjpcXFwiNzcxMjM0NVxcXCIsXFxcIk1XXFxcIjpcXFwiOTkxMjM0NTY3XFxcIixcXFwiTVhcXFwiOlxcXCIxMjIyMTIzNDU2N1xcXCIsXFxcIk1ZXFxcIjpcXFwiMTIzNDU2Nzg5XFxcIixcXFwiTVpcXFwiOlxcXCI4MjEyMzQ1NjdcXFwiLFxcXCJOQVxcXCI6XFxcIjgxMTIzNDU2N1xcXCIsXFxcIk5DXFxcIjpcXFwiNzUxMjM0XFxcIixcXFwiTkVcXFwiOlxcXCI5MzEyMzQ1NlxcXCIsXFxcIk5GXFxcIjpcXFwiMzgxMjM0XFxcIixcXFwiTkdcXFwiOlxcXCI4MDIxMjM0NTY3XFxcIixcXFwiTklcXFwiOlxcXCI4MTIzNDU2N1xcXCIsXFxcIk5MXFxcIjpcXFwiNjEyMzQ1Njc4XFxcIixcXFwiTk9cXFwiOlxcXCI0MDYxMjM0NVxcXCIsXFxcIk5QXFxcIjpcXFwiOTg0MTIzNDU2N1xcXCIsXFxcIk5SXFxcIjpcXFwiNTU1MTIzNFxcXCIsXFxcIk5VXFxcIjpcXFwiODg4NDAxMlxcXCIsXFxcIk5aXFxcIjpcXFwiMjExMjM0NTY3XFxcIixcXFwiT01cXFwiOlxcXCI5MjEyMzQ1NlxcXCIsXFxcIlBBXFxcIjpcXFwiNjEyMzQ1NjdcXFwiLFxcXCJQRVxcXCI6XFxcIjkxMjM0NTY3OFxcXCIsXFxcIlBGXFxcIjpcXFwiODcxMjM0NTZcXFwiLFxcXCJQR1xcXCI6XFxcIjcwMTIzNDU2XFxcIixcXFwiUEhcXFwiOlxcXCI5MDUxMjM0NTY3XFxcIixcXFwiUEtcXFwiOlxcXCIzMDEyMzQ1Njc4XFxcIixcXFwiUExcXFwiOlxcXCI1MTIzNDU2NzhcXFwiLFxcXCJQTVxcXCI6XFxcIjU1MTIzNFxcXCIsXFxcIlBSXFxcIjpcXFwiNzg3MjM0NTY3OFxcXCIsXFxcIlBTXFxcIjpcXFwiNTk5MTIzNDU2XFxcIixcXFwiUFRcXFwiOlxcXCI5MTIzNDU2NzhcXFwiLFxcXCJQV1xcXCI6XFxcIjYyMDEyMzRcXFwiLFxcXCJQWVxcXCI6XFxcIjk2MTQ1Njc4OVxcXCIsXFxcIlFBXFxcIjpcXFwiMzMxMjM0NTZcXFwiLFxcXCJSRVxcXCI6XFxcIjY5MjEyMzQ1NlxcXCIsXFxcIlJPXFxcIjpcXFwiNzEyMDM0NTY3XFxcIixcXFwiUlNcXFwiOlxcXCI2MDEyMzQ1NjdcXFwiLFxcXCJSVVxcXCI6XFxcIjkxMjM0NTY3ODlcXFwiLFxcXCJSV1xcXCI6XFxcIjcyMDEyMzQ1NlxcXCIsXFxcIlNBXFxcIjpcXFwiNTEyMzQ1Njc4XFxcIixcXFwiU0JcXFwiOlxcXCI3NDIxMjM0XFxcIixcXFwiU0NcXFwiOlxcXCIyNTEwMTIzXFxcIixcXFwiU0RcXFwiOlxcXCI5MTEyMzEyMzRcXFwiLFxcXCJTRVxcXCI6XFxcIjcwMTIzNDU2N1xcXCIsXFxcIlNHXFxcIjpcXFwiODEyMzQ1NjdcXFwiLFxcXCJTSFxcXCI6XFxcIjUxMjM0XFxcIixcXFwiU0lcXFwiOlxcXCIzMTIzNDU2N1xcXCIsXFxcIlNKXFxcIjpcXFwiNDEyMzQ1NjdcXFwiLFxcXCJTS1xcXCI6XFxcIjkxMjEyMzQ1NlxcXCIsXFxcIlNMXFxcIjpcXFwiMjUxMjM0NTZcXFwiLFxcXCJTTVxcXCI6XFxcIjY2NjYxMjEyXFxcIixcXFwiU05cXFwiOlxcXCI3MDEyMzQ1NjdcXFwiLFxcXCJTT1xcXCI6XFxcIjcxMTIzNDU2XFxcIixcXFwiU1JcXFwiOlxcXCI3NDEyMzQ1XFxcIixcXFwiU1NcXFwiOlxcXCI5NzcxMjM0NTZcXFwiLFxcXCJTVFxcXCI6XFxcIjk4MTIzNDVcXFwiLFxcXCJTVlxcXCI6XFxcIjcwMTIzNDU2XFxcIixcXFwiU1hcXFwiOlxcXCI3MjE1MjA1Njc4XFxcIixcXFwiU1lcXFwiOlxcXCI5NDQ1Njc4OTBcXFwiLFxcXCJTWlxcXCI6XFxcIjc2MTIzNDU2XFxcIixcXFwiVEFcXFwiOlxcXCI4OTk5XFxcIixcXFwiVENcXFwiOlxcXCI2NDkyMzExMjM0XFxcIixcXFwiVERcXFwiOlxcXCI2MzAxMjM0NVxcXCIsXFxcIlRHXFxcIjpcXFwiOTAxMTIzNDVcXFwiLFxcXCJUSFxcXCI6XFxcIjgxMjM0NTY3OFxcXCIsXFxcIlRKXFxcIjpcXFwiOTE3MTIzNDU2XFxcIixcXFwiVEtcXFwiOlxcXCI3MjkwXFxcIixcXFwiVExcXFwiOlxcXCI3NzIxMjM0NVxcXCIsXFxcIlRNXFxcIjpcXFwiNjYxMjM0NTZcXFwiLFxcXCJUTlxcXCI6XFxcIjIwMTIzNDU2XFxcIixcXFwiVE9cXFwiOlxcXCI3NzE1MTIzXFxcIixcXFwiVFJcXFwiOlxcXCI1MDEyMzQ1Njc4XFxcIixcXFwiVFRcXFwiOlxcXCI4NjgyOTExMjM0XFxcIixcXFwiVFZcXFwiOlxcXCI5MDEyMzRcXFwiLFxcXCJUV1xcXCI6XFxcIjkxMjM0NTY3OFxcXCIsXFxcIlRaXFxcIjpcXFwiNjIxMjM0NTY3XFxcIixcXFwiVUFcXFwiOlxcXCI1MDEyMzQ1NjdcXFwiLFxcXCJVR1xcXCI6XFxcIjcxMjM0NTY3OFxcXCIsXFxcIlVTXFxcIjpcXFwiMjAxNTU1MDEyM1xcXCIsXFxcIlVZXFxcIjpcXFwiOTQyMzEyMzRcXFwiLFxcXCJVWlxcXCI6XFxcIjkxMjM0NTY3OFxcXCIsXFxcIlZBXFxcIjpcXFwiMzEyMzQ1Njc4OVxcXCIsXFxcIlZDXFxcIjpcXFwiNzg0NDMwMTIzNFxcXCIsXFxcIlZFXFxcIjpcXFwiNDEyMTIzNDU2N1xcXCIsXFxcIlZHXFxcIjpcXFwiMjg0MzAwMTIzNFxcXCIsXFxcIlZJXFxcIjpcXFwiMzQwNjQyMTIzNFxcXCIsXFxcIlZOXFxcIjpcXFwiOTEyMzQ1Njc4XFxcIixcXFwiVlVcXFwiOlxcXCI1OTEyMzQ1XFxcIixcXFwiV0ZcXFwiOlxcXCI1MDEyMzRcXFwiLFxcXCJXU1xcXCI6XFxcIjcyMTIzNDVcXFwiLFxcXCJYS1xcXCI6XFxcIjQzMjAxMjM0XFxcIixcXFwiWUVcXFwiOlxcXCI3MTIzNDU2NzhcXFwiLFxcXCJZVFxcXCI6XFxcIjYzOTAxMjM0NVxcXCIsXFxcIlpBXFxcIjpcXFwiNzExMjM0NTY3XFxcIixcXFwiWk1cXFwiOlxcXCI5NTUxMjM0NTZcXFwiLFxcXCJaV1xcXCI6XFxcIjcxMjM0NTY3OFxcXCJ9XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkM2Y0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQ1M2JcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZDg2NFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzlhYVwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkOGU4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkOWY2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlNGFlXCIpO1xudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc5NGJcIik7XG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWJjM1wiKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjhlNjBcIikgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkYmRiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU4NGFcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImU1M2RcIik7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sXG4gIG1vZGU6IF9fd2VicGFja19yZXF1aXJlX18oXCJiOGUzXCIpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlMTFlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImU0YWVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImY3NzJcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImU1MDhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IER5bmFtaWNTY3JvbGxlciAqL1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IER5bmFtaWNTY3JvbGxlckl0ZW0gKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBJZFN0YXRlICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fdnVlX2NvbXBvbmVudF9fOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfcmVzaXplX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjUyY1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfb2JzZXJ2ZV92aXNpYmlsaXR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODVmZVwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBzY3JvbGxwYXJlbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlZDgzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHNjcm9sbHBhcmVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHNjcm9sbHBhcmVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4YmJmXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcblxuXG5cblxuXG52YXIgY29uZmlnID0ge1xuICBpdGVtc0xpbWl0OiAxMDAwXG59O1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8pIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAobyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkpIHtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgczogRixcbiAgICAgICAgbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSxcbiAgICAgICAgZjogRlxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICB2YXIgaXQsXG4gICAgICBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSxcbiAgICAgIGRpZEVyciA9IGZhbHNlLFxuICAgICAgZXJyO1xuICByZXR1cm4ge1xuICAgIHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcbiAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgZXJyID0gZTtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgcHJvcHMgPSB7XG4gIGl0ZW1zOiB7XG4gICAgdHlwZTogQXJyYXksXG4gICAgcmVxdWlyZWQ6IHRydWVcbiAgfSxcbiAga2V5RmllbGQ6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZGVmYXVsdDogJ2lkJ1xuICB9LFxuICBkaXJlY3Rpb246IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZGVmYXVsdDogJ3ZlcnRpY2FsJyxcbiAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFsndmVydGljYWwnLCAnaG9yaXpvbnRhbCddLmluY2x1ZGVzKHZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBzaW1wbGVBcnJheSgpIHtcbiAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoICYmIF90eXBlb2YodGhpcy5pdGVtc1swXSkgIT09ICdvYmplY3QnO1xufVxuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbnZhciB1aWQgPSAwO1xudmFyIHNjcmlwdCA9IHtcbiAgbmFtZTogJ1JlY3ljbGVTY3JvbGxlcicsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBSZXNpemVPYnNlcnZlcjogdnVlX3Jlc2l6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIFJlc2l6ZU9ic2VydmVyICovIFwiYVwiXVxuICB9LFxuICBkaXJlY3RpdmVzOiB7XG4gICAgT2JzZXJ2ZVZpc2liaWxpdHk6IHZ1ZV9vYnNlcnZlX3Zpc2liaWxpdHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBPYnNlcnZlVmlzaWJpbGl0eSAqLyBcImFcIl1cbiAgfSxcbiAgcHJvcHM6IF9vYmplY3RTcHJlYWQyKHt9LCBwcm9wcywge1xuICAgIGl0ZW1TaXplOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBtaW5JdGVtU2l6ZToge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIHNpemVGaWVsZDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ3NpemUnXG4gICAgfSxcbiAgICB0eXBlRmllbGQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICd0eXBlJ1xuICAgIH0sXG4gICAgYnVmZmVyOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiAyMDBcbiAgICB9LFxuICAgIHBhZ2VNb2RlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHByZXJlbmRlcjoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMFxuICAgIH0sXG4gICAgZW1pdFVwZGF0ZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9KSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9vbDogW10sXG4gICAgICB0b3RhbFNpemU6IDAsXG4gICAgICByZWFkeTogZmFsc2UsXG4gICAgICBob3ZlcktleTogbnVsbFxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgc2l6ZXM6IGZ1bmN0aW9uIHNpemVzKCkge1xuICAgICAgaWYgKHRoaXMuaXRlbVNpemUgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIHNpemVzID0ge1xuICAgICAgICAgICctMSc6IHtcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICB2YXIgZmllbGQgPSB0aGlzLnNpemVGaWVsZDtcbiAgICAgICAgdmFyIG1pbkl0ZW1TaXplID0gdGhpcy5taW5JdGVtU2l6ZTtcbiAgICAgICAgdmFyIGNvbXB1dGVkTWluU2l6ZSA9IDEwMDAwO1xuICAgICAgICB2YXIgYWNjdW11bGF0b3IgPSAwO1xuICAgICAgICB2YXIgY3VycmVudDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnQgPSBpdGVtc1tpXVtmaWVsZF0gfHwgbWluSXRlbVNpemU7XG5cbiAgICAgICAgICBpZiAoY3VycmVudCA8IGNvbXB1dGVkTWluU2l6ZSkge1xuICAgICAgICAgICAgY29tcHV0ZWRNaW5TaXplID0gY3VycmVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhY2N1bXVsYXRvciArPSBjdXJyZW50O1xuICAgICAgICAgIHNpemVzW2ldID0ge1xuICAgICAgICAgICAgYWNjdW11bGF0b3I6IGFjY3VtdWxhdG9yLFxuICAgICAgICAgICAgc2l6ZTogY3VycmVudFxuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cblxuICAgICAgICB0aGlzLiRfY29tcHV0ZWRNaW5JdGVtU2l6ZSA9IGNvbXB1dGVkTWluU2l6ZTtcbiAgICAgICAgcmV0dXJuIHNpemVzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBzaW1wbGVBcnJheTogc2ltcGxlQXJyYXlcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBpdGVtczogZnVuY3Rpb24gaXRlbXMoKSB7XG4gICAgICB0aGlzLnVwZGF0ZVZpc2libGVJdGVtcyh0cnVlKTtcbiAgICB9LFxuICAgIHBhZ2VNb2RlOiBmdW5jdGlvbiBwYWdlTW9kZSgpIHtcbiAgICAgIHRoaXMuYXBwbHlQYWdlTW9kZSgpO1xuICAgICAgdGhpcy51cGRhdGVWaXNpYmxlSXRlbXMoZmFsc2UpO1xuICAgIH0sXG4gICAgc2l6ZXM6IHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJsZUl0ZW1zKGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBkZWVwOiB0cnVlXG4gICAgfVxuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuJF9zdGFydEluZGV4ID0gMDtcbiAgICB0aGlzLiRfZW5kSW5kZXggPSAwO1xuICAgIHRoaXMuJF92aWV3cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLiRfdW51c2VkVmlld3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy4kX3Njcm9sbERpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy4kX2xhc3RVcGRhdGVTY3JvbGxQb3NpdGlvbiA9IDA7IC8vIEluIFNTUiBtb2RlLCB3ZSBhbHNvIHByZXJlbmRlciB0aGUgc2FtZSBudW1iZXIgb2YgaXRlbSBmb3IgdGhlIGZpcnN0IHJlbmRlclxuICAgIC8vIHRvIGF2b2lyIG1pc21hdGNoIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgdGVtcGxhdGVzXG5cbiAgICBpZiAodGhpcy5wcmVyZW5kZXIpIHtcbiAgICAgIHRoaXMuJF9wcmVyZW5kZXIgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGVWaXNpYmxlSXRlbXMoZmFsc2UpO1xuICAgIH1cbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5hcHBseVBhZ2VNb2RlKCk7XG4gICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgLy8gSW4gU1NSIG1vZGUsIHJlbmRlciB0aGUgcmVhbCBudW1iZXIgb2YgdmlzaWJsZSBpdGVtc1xuICAgICAgX3RoaXMuJF9wcmVyZW5kZXIgPSBmYWxzZTtcblxuICAgICAgX3RoaXMudXBkYXRlVmlzaWJsZUl0ZW1zKHRydWUpO1xuXG4gICAgICBfdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgfSk7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGFkZFZpZXc6IGZ1bmN0aW9uIGFkZFZpZXcocG9vbCwgaW5kZXgsIGl0ZW0sIGtleSwgdHlwZSkge1xuICAgICAgdmFyIHZpZXcgPSB7XG4gICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgIHBvc2l0aW9uOiAwXG4gICAgICB9O1xuICAgICAgdmFyIG5vblJlYWN0aXZlID0ge1xuICAgICAgICBpZDogdWlkKyssXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgdXNlZDogdHJ1ZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmlldywgJ25yJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogbm9uUmVhY3RpdmVcbiAgICAgIH0pO1xuICAgICAgcG9vbC5wdXNoKHZpZXcpO1xuICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfSxcbiAgICB1bnVzZVZpZXc6IGZ1bmN0aW9uIHVudXNlVmlldyh2aWV3KSB7XG4gICAgICB2YXIgZmFrZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgdW51c2VkVmlld3MgPSB0aGlzLiRfdW51c2VkVmlld3M7XG4gICAgICB2YXIgdHlwZSA9IHZpZXcubnIudHlwZTtcbiAgICAgIHZhciB1bnVzZWRQb29sID0gdW51c2VkVmlld3MuZ2V0KHR5cGUpO1xuXG4gICAgICBpZiAoIXVudXNlZFBvb2wpIHtcbiAgICAgICAgdW51c2VkUG9vbCA9IFtdO1xuICAgICAgICB1bnVzZWRWaWV3cy5zZXQodHlwZSwgdW51c2VkUG9vbCk7XG4gICAgICB9XG5cbiAgICAgIHVudXNlZFBvb2wucHVzaCh2aWV3KTtcblxuICAgICAgaWYgKCFmYWtlKSB7XG4gICAgICAgIHZpZXcubnIudXNlZCA9IGZhbHNlO1xuICAgICAgICB2aWV3LnBvc2l0aW9uID0gLTk5OTk7XG4gICAgICAgIHRoaXMuJF92aWV3cy5kZWxldGUodmlldy5uci5rZXkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlUmVzaXplOiBmdW5jdGlvbiBoYW5kbGVSZXNpemUoKSB7XG4gICAgICB0aGlzLiRlbWl0KCdyZXNpemUnKTtcbiAgICAgIGlmICh0aGlzLnJlYWR5KSB0aGlzLnVwZGF0ZVZpc2libGVJdGVtcyhmYWxzZSk7XG4gICAgfSxcbiAgICBoYW5kbGVTY3JvbGw6IGZ1bmN0aW9uIGhhbmRsZVNjcm9sbChldmVudCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy4kX3Njcm9sbERpcnR5KSB7XG4gICAgICAgIHRoaXMuJF9zY3JvbGxEaXJ0eSA9IHRydWU7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLiRfc2Nyb2xsRGlydHkgPSBmYWxzZTtcblxuICAgICAgICAgIHZhciBfdGhpczIkdXBkYXRlVmlzaWJsZUkgPSBfdGhpczIudXBkYXRlVmlzaWJsZUl0ZW1zKGZhbHNlLCB0cnVlKSxcbiAgICAgICAgICAgICAgY29udGludW91cyA9IF90aGlzMiR1cGRhdGVWaXNpYmxlSS5jb250aW51b3VzOyAvLyBJdCBzZWVtcyBzb21ldGltZXMgY2hyb21lIGRvZXNuJ3QgZmlyZSBzY3JvbGwgZXZlbnQgOi9cbiAgICAgICAgICAvLyBXaGVuIG5vbiBjb250aW5vdXMgc2Nyb2xsaW5nIGlzIGVuZGluZywgd2UgZm9yY2UgYSByZWZyZXNoXG5cblxuICAgICAgICAgIGlmICghY29udGludW91cykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzMi4kX3JlZnJlc2hUaW1vdXQpO1xuICAgICAgICAgICAgX3RoaXMyLiRfcmVmcmVzaFRpbW91dCA9IHNldFRpbWVvdXQoX3RoaXMyLmhhbmRsZVNjcm9sbCwgMTAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZTogZnVuY3Rpb24gaGFuZGxlVmlzaWJpbGl0eUNoYW5nZShpc1Zpc2libGUsIGVudHJ5KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSB8fCBlbnRyeS5ib3VuZGluZ0NsaWVudFJlY3Qud2lkdGggIT09IDAgfHwgZW50cnkuYm91bmRpbmdDbGllbnRSZWN0LmhlaWdodCAhPT0gMCkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ3Zpc2libGUnKTtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVwZGF0ZVZpc2libGVJdGVtcyhmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgnaGlkZGVuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZVZpc2libGVJdGVtczogZnVuY3Rpb24gdXBkYXRlVmlzaWJsZUl0ZW1zKGNoZWNrSXRlbSkge1xuICAgICAgdmFyIGNoZWNrUG9zaXRpb25EaWZmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemU7XG4gICAgICB2YXIgbWluSXRlbVNpemUgPSB0aGlzLiRfY29tcHV0ZWRNaW5JdGVtU2l6ZTtcbiAgICAgIHZhciB0eXBlRmllbGQgPSB0aGlzLnR5cGVGaWVsZDtcbiAgICAgIHZhciBrZXlGaWVsZCA9IHRoaXMuc2ltcGxlQXJyYXkgPyBudWxsIDogdGhpcy5rZXlGaWVsZDtcbiAgICAgIHZhciBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICB2YXIgY291bnQgPSBpdGVtcy5sZW5ndGg7XG4gICAgICB2YXIgc2l6ZXMgPSB0aGlzLnNpemVzO1xuICAgICAgdmFyIHZpZXdzID0gdGhpcy4kX3ZpZXdzO1xuICAgICAgdmFyIHVudXNlZFZpZXdzID0gdGhpcy4kX3VudXNlZFZpZXdzO1xuICAgICAgdmFyIHBvb2wgPSB0aGlzLnBvb2w7XG4gICAgICB2YXIgc3RhcnRJbmRleCwgZW5kSW5kZXg7XG4gICAgICB2YXIgdG90YWxTaXplO1xuXG4gICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBlbmRJbmRleCA9IHRvdGFsU2l6ZSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuJF9wcmVyZW5kZXIpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIGVuZEluZGV4ID0gdGhpcy5wcmVyZW5kZXI7XG4gICAgICAgIHRvdGFsU2l6ZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2Nyb2xsID0gdGhpcy5nZXRTY3JvbGwoKTsgLy8gU2tpcCB1cGRhdGUgaWYgdXNlIGhhc24ndCBzY3JvbGxlZCBlbm91Z2hcblxuICAgICAgICBpZiAoY2hlY2tQb3NpdGlvbkRpZmYpIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb25EaWZmID0gc2Nyb2xsLnN0YXJ0IC0gdGhpcy4kX2xhc3RVcGRhdGVTY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgICBpZiAocG9zaXRpb25EaWZmIDwgMCkgcG9zaXRpb25EaWZmID0gLXBvc2l0aW9uRGlmZjtcblxuICAgICAgICAgIGlmIChpdGVtU2l6ZSA9PT0gbnVsbCAmJiBwb3NpdGlvbkRpZmYgPCBtaW5JdGVtU2l6ZSB8fCBwb3NpdGlvbkRpZmYgPCBpdGVtU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgY29udGludW91czogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRfbGFzdFVwZGF0ZVNjcm9sbFBvc2l0aW9uID0gc2Nyb2xsLnN0YXJ0O1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHNjcm9sbC5zdGFydCAtPSBidWZmZXI7XG4gICAgICAgIHNjcm9sbC5lbmQgKz0gYnVmZmVyOyAvLyBWYXJpYWJsZSBzaXplIG1vZGVcblxuICAgICAgICBpZiAoaXRlbVNpemUgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgaDtcbiAgICAgICAgICB2YXIgYSA9IDA7XG4gICAgICAgICAgdmFyIGIgPSBjb3VudCAtIDE7XG4gICAgICAgICAgdmFyIGkgPSB+fihjb3VudCAvIDIpO1xuICAgICAgICAgIHZhciBvbGRJOyAvLyBTZWFyY2hpbmcgZm9yIHN0YXJ0SW5kZXhcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIG9sZEkgPSBpO1xuICAgICAgICAgICAgaCA9IHNpemVzW2ldLmFjY3VtdWxhdG9yO1xuXG4gICAgICAgICAgICBpZiAoaCA8IHNjcm9sbC5zdGFydCkge1xuICAgICAgICAgICAgICBhID0gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IGNvdW50IC0gMSAmJiBzaXplc1tpICsgMV0uYWNjdW11bGF0b3IgPiBzY3JvbGwuc3RhcnQpIHtcbiAgICAgICAgICAgICAgYiA9IGk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGkgPSB+figoYSArIGIpIC8gMik7XG4gICAgICAgICAgfSB3aGlsZSAoaSAhPT0gb2xkSSk7XG5cbiAgICAgICAgICBpIDwgMCAmJiAoaSA9IDApO1xuICAgICAgICAgIHN0YXJ0SW5kZXggPSBpOyAvLyBGb3IgY29udGFpbmVyIHN0eWxlXG5cbiAgICAgICAgICB0b3RhbFNpemUgPSBzaXplc1tjb3VudCAtIDFdLmFjY3VtdWxhdG9yOyAvLyBTZWFyY2hpbmcgZm9yIGVuZEluZGV4XG5cbiAgICAgICAgICBmb3IgKGVuZEluZGV4ID0gaTsgZW5kSW5kZXggPCBjb3VudCAmJiBzaXplc1tlbmRJbmRleF0uYWNjdW11bGF0b3IgPCBzY3JvbGwuZW5kOyBlbmRJbmRleCsrKSB7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVuZEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgZW5kSW5kZXggPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmRJbmRleCsrOyAvLyBCb3VuZHNcblxuICAgICAgICAgICAgZW5kSW5kZXggPiBjb3VudCAmJiAoZW5kSW5kZXggPSBjb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZpeGVkIHNpemUgbW9kZVxuICAgICAgICAgIHN0YXJ0SW5kZXggPSB+fihzY3JvbGwuc3RhcnQgLyBpdGVtU2l6ZSk7XG4gICAgICAgICAgZW5kSW5kZXggPSBNYXRoLmNlaWwoc2Nyb2xsLmVuZCAvIGl0ZW1TaXplKTsgLy8gQm91bmRzXG5cbiAgICAgICAgICBzdGFydEluZGV4IDwgMCAmJiAoc3RhcnRJbmRleCA9IDApO1xuICAgICAgICAgIGVuZEluZGV4ID4gY291bnQgJiYgKGVuZEluZGV4ID0gY291bnQpO1xuICAgICAgICAgIHRvdGFsU2l6ZSA9IGNvdW50ICogaXRlbVNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZEluZGV4IC0gc3RhcnRJbmRleCA+IGNvbmZpZy5pdGVtc0xpbWl0KSB7XG4gICAgICAgIHRoaXMuaXRlbXNMaW1pdEVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG90YWxTaXplID0gdG90YWxTaXplO1xuICAgICAgdmFyIHZpZXc7XG4gICAgICB2YXIgY29udGludW91cyA9IHN0YXJ0SW5kZXggPD0gdGhpcy4kX2VuZEluZGV4ICYmIGVuZEluZGV4ID49IHRoaXMuJF9zdGFydEluZGV4O1xuXG4gICAgICBpZiAodGhpcy4kX2NvbnRpbnVvdXMgIT09IGNvbnRpbnVvdXMpIHtcbiAgICAgICAgaWYgKGNvbnRpbnVvdXMpIHtcbiAgICAgICAgICB2aWV3cy5jbGVhcigpO1xuICAgICAgICAgIHVudXNlZFZpZXdzLmNsZWFyKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGwgPSBwb29sLmxlbmd0aDsgX2kgPCBsOyBfaSsrKSB7XG4gICAgICAgICAgICB2aWV3ID0gcG9vbFtfaV07XG4gICAgICAgICAgICB0aGlzLnVudXNlVmlldyh2aWV3KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRfY29udGludW91cyA9IGNvbnRpbnVvdXM7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRpbnVvdXMpIHtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX2wgPSBwb29sLmxlbmd0aDsgX2kyIDwgX2w7IF9pMisrKSB7XG4gICAgICAgICAgdmlldyA9IHBvb2xbX2kyXTtcblxuICAgICAgICAgIGlmICh2aWV3Lm5yLnVzZWQpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB2aWV3IGl0ZW0gaW5kZXhcbiAgICAgICAgICAgIGlmIChjaGVja0l0ZW0pIHtcbiAgICAgICAgICAgICAgdmlldy5uci5pbmRleCA9IGl0ZW1zLmZpbmRJbmRleChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXlGaWVsZCA/IGl0ZW1ba2V5RmllbGRdID09PSB2aWV3Lml0ZW1ba2V5RmllbGRdIDogaXRlbSA9PT0gdmlldy5pdGVtO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gLy8gQ2hlY2sgaWYgaW5kZXggaXMgc3RpbGwgaW4gdmlzaWJsZSByYW5nZVxuXG5cbiAgICAgICAgICAgIGlmICh2aWV3Lm5yLmluZGV4ID09PSAtMSB8fCB2aWV3Lm5yLmluZGV4IDwgc3RhcnRJbmRleCB8fCB2aWV3Lm5yLmluZGV4ID49IGVuZEluZGV4KSB7XG4gICAgICAgICAgICAgIHRoaXMudW51c2VWaWV3KHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdW51c2VkSW5kZXggPSBjb250aW51b3VzID8gbnVsbCA6IG5ldyBNYXAoKTtcbiAgICAgIHZhciBpdGVtLCB0eXBlLCB1bnVzZWRQb29sO1xuICAgICAgdmFyIHY7XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IHN0YXJ0SW5kZXg7IF9pMyA8IGVuZEluZGV4OyBfaTMrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbX2kzXTtcbiAgICAgICAgdmFyIGtleSA9IGtleUZpZWxkID8gaXRlbVtrZXlGaWVsZF0gOiBpdGVtO1xuXG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBpcyBcIi5jb25jYXQoa2V5LCBcIiBvbiBpdGVtIChrZXlGaWVsZCBpcyAnXCIpLmNvbmNhdChrZXlGaWVsZCwgXCInKVwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2aWV3ID0gdmlld3MuZ2V0KGtleSk7XG5cbiAgICAgICAgaWYgKCFpdGVtU2l6ZSAmJiAhc2l6ZXNbX2kzXS5zaXplKSB7XG4gICAgICAgICAgaWYgKHZpZXcpIHRoaXMudW51c2VWaWV3KHZpZXcpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIE5vIHZpZXcgYXNzaWduZWQgdG8gaXRlbVxuXG5cbiAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgdHlwZSA9IGl0ZW1bdHlwZUZpZWxkXTtcbiAgICAgICAgICB1bnVzZWRQb29sID0gdW51c2VkVmlld3MuZ2V0KHR5cGUpO1xuXG4gICAgICAgICAgaWYgKGNvbnRpbnVvdXMpIHtcbiAgICAgICAgICAgIC8vIFJldXNlIGV4aXN0aW5nIHZpZXdcbiAgICAgICAgICAgIGlmICh1bnVzZWRQb29sICYmIHVudXNlZFBvb2wubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZpZXcgPSB1bnVzZWRQb29sLnBvcCgpO1xuICAgICAgICAgICAgICB2aWV3Lml0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgICB2aWV3Lm5yLnVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB2aWV3Lm5yLmluZGV4ID0gX2kzO1xuICAgICAgICAgICAgICB2aWV3Lm5yLmtleSA9IGtleTtcbiAgICAgICAgICAgICAgdmlldy5uci50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZpZXcgPSB0aGlzLmFkZFZpZXcocG9vbCwgX2kzLCBpdGVtLCBrZXksIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2UgZXhpc3Rpbmcgdmlld1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgY2FyZSBpZiB0aGV5IGFyZSBhbHJlYWR5IHVzZWRcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgYXJlIG5vdCBpbiBjb250aW5vdXMgc2Nyb2xsaW5nXG4gICAgICAgICAgICB2ID0gdW51c2VkSW5kZXguZ2V0KHR5cGUpIHx8IDA7XG5cbiAgICAgICAgICAgIGlmICghdW51c2VkUG9vbCB8fCB2ID49IHVudXNlZFBvb2wubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZpZXcgPSB0aGlzLmFkZFZpZXcocG9vbCwgX2kzLCBpdGVtLCBrZXksIHR5cGUpO1xuICAgICAgICAgICAgICB0aGlzLnVudXNlVmlldyh2aWV3LCB0cnVlKTtcbiAgICAgICAgICAgICAgdW51c2VkUG9vbCA9IHVudXNlZFZpZXdzLmdldCh0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlldyA9IHVudXNlZFBvb2xbdl07XG4gICAgICAgICAgICB2aWV3Lml0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgdmlldy5uci51c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpZXcubnIuaW5kZXggPSBfaTM7XG4gICAgICAgICAgICB2aWV3Lm5yLmtleSA9IGtleTtcbiAgICAgICAgICAgIHZpZXcubnIudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB1bnVzZWRJbmRleC5zZXQodHlwZSwgdiArIDEpO1xuICAgICAgICAgICAgdisrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZpZXdzLnNldChrZXksIHZpZXcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZpZXcubnIudXNlZCA9IHRydWU7XG4gICAgICAgICAgdmlldy5pdGVtID0gaXRlbTtcbiAgICAgICAgfSAvLyBVcGRhdGUgcG9zaXRpb25cblxuXG4gICAgICAgIGlmIChpdGVtU2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZpZXcucG9zaXRpb24gPSBzaXplc1tfaTMgLSAxXS5hY2N1bXVsYXRvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2aWV3LnBvc2l0aW9uID0gX2kzICogaXRlbVNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy4kX3N0YXJ0SW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgdGhpcy4kX2VuZEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICBpZiAodGhpcy5lbWl0VXBkYXRlKSB0aGlzLiRlbWl0KCd1cGRhdGUnLCBzdGFydEluZGV4LCBlbmRJbmRleCk7IC8vIEFmdGVyIHRoZSB1c2VyIGhhcyBmaW5pc2hlZCBzY3JvbGxpbmdcbiAgICAgIC8vIFNvcnQgdmlld3Mgc28gdGV4dCBzZWxlY3Rpb24gaXMgY29ycmVjdFxuXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4kX3NvcnRUaW1lcik7XG4gICAgICB0aGlzLiRfc29ydFRpbWVyID0gc2V0VGltZW91dCh0aGlzLnNvcnRWaWV3cywgMzAwKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRpbnVvdXM6IGNvbnRpbnVvdXNcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRMaXN0ZW5lclRhcmdldDogZnVuY3Rpb24gZ2V0TGlzdGVuZXJUYXJnZXQoKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gc2Nyb2xscGFyZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCgpKHRoaXMuJGVsKTsgLy8gRml4IGdsb2JhbCBzY3JvbGwgdGFyZ2V0IGZvciBDaHJvbWUgYW5kIFNhZmFyaVxuXG4gICAgICBpZiAod2luZG93LmRvY3VtZW50ICYmICh0YXJnZXQgPT09IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgdGFyZ2V0ID09PSB3aW5kb3cuZG9jdW1lbnQuYm9keSkpIHtcbiAgICAgICAgdGFyZ2V0ID0gd2luZG93O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG4gICAgZ2V0U2Nyb2xsOiBmdW5jdGlvbiBnZXRTY3JvbGwoKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLiRlbCxcbiAgICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjtcbiAgICAgIHZhciBpc1ZlcnRpY2FsID0gZGlyZWN0aW9uID09PSAndmVydGljYWwnO1xuICAgICAgdmFyIHNjcm9sbFN0YXRlO1xuXG4gICAgICBpZiAodGhpcy5wYWdlTW9kZSkge1xuICAgICAgICB2YXIgYm91bmRzID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBib3VuZHNTaXplID0gaXNWZXJ0aWNhbCA/IGJvdW5kcy5oZWlnaHQgOiBib3VuZHMud2lkdGg7XG4gICAgICAgIHZhciBzdGFydCA9IC0oaXNWZXJ0aWNhbCA/IGJvdW5kcy50b3AgOiBib3VuZHMubGVmdCk7XG4gICAgICAgIHZhciBzaXplID0gaXNWZXJ0aWNhbCA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHdpbmRvdy5pbm5lcldpZHRoO1xuXG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICBzaXplICs9IHN0YXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCArIHNpemUgPiBib3VuZHNTaXplKSB7XG4gICAgICAgICAgc2l6ZSA9IGJvdW5kc1NpemUgLSBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjcm9sbFN0YXRlID0ge1xuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IHN0YXJ0ICsgc2l6ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICAgIHNjcm9sbFN0YXRlID0ge1xuICAgICAgICAgIHN0YXJ0OiBlbC5zY3JvbGxUb3AsXG4gICAgICAgICAgZW5kOiBlbC5zY3JvbGxUb3AgKyBlbC5jbGllbnRIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcm9sbFN0YXRlID0ge1xuICAgICAgICAgIHN0YXJ0OiBlbC5zY3JvbGxMZWZ0LFxuICAgICAgICAgIGVuZDogZWwuc2Nyb2xsTGVmdCArIGVsLmNsaWVudFdpZHRoXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzY3JvbGxTdGF0ZTtcbiAgICB9LFxuICAgIGFwcGx5UGFnZU1vZGU6IGZ1bmN0aW9uIGFwcGx5UGFnZU1vZGUoKSB7XG4gICAgICBpZiAodGhpcy5wYWdlTW9kZSkge1xuICAgICAgICB0aGlzLmFkZExpc3RlbmVycygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFkZExpc3RlbmVyczogZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuICAgICAgdGhpcy5saXN0ZW5lclRhcmdldCA9IHRoaXMuZ2V0TGlzdGVuZXJUYXJnZXQoKTtcbiAgICAgIHRoaXMubGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwsIHN1cHBvcnRzUGFzc2l2ZSA/IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSA6IGZhbHNlKTtcbiAgICAgIHRoaXMubGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVSZXNpemUpO1xuICAgIH0sXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgICBpZiAoIXRoaXMubGlzdGVuZXJUYXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgICAgIHRoaXMubGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVSZXNpemUpO1xuICAgICAgdGhpcy5saXN0ZW5lclRhcmdldCA9IG51bGw7XG4gICAgfSxcbiAgICBzY3JvbGxUb0l0ZW06IGZ1bmN0aW9uIHNjcm9sbFRvSXRlbShpbmRleCkge1xuICAgICAgdmFyIHNjcm9sbDtcblxuICAgICAgaWYgKHRoaXMuaXRlbVNpemUgPT09IG51bGwpIHtcbiAgICAgICAgc2Nyb2xsID0gaW5kZXggPiAwID8gdGhpcy5zaXplc1tpbmRleCAtIDFdLmFjY3VtdWxhdG9yIDogMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcm9sbCA9IGluZGV4ICogdGhpcy5pdGVtU2l6ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY3JvbGxUb1Bvc2l0aW9uKHNjcm9sbCk7XG4gICAgfSxcbiAgICBzY3JvbGxUb1Bvc2l0aW9uOiBmdW5jdGlvbiBzY3JvbGxUb1Bvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgdGhpcy4kZWwuc2Nyb2xsVG9wID0gcG9zaXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRlbC5zY3JvbGxMZWZ0ID0gcG9zaXRpb247XG4gICAgICB9XG4gICAgfSxcbiAgICBpdGVtc0xpbWl0RXJyb3I6IGZ1bmN0aW9uIGl0ZW1zTGltaXRFcnJvcigpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0l0IHNlZW1zIHRoZSBzY3JvbGxlciBlbGVtZW50IGlzblxcJ3Qgc2Nyb2xsaW5nLCBzbyBpdCB0cmllcyB0byByZW5kZXIgYWxsIHRoZSBpdGVtcyBhdCBvbmNlLicsICdTY3JvbGxlcjonLCBfdGhpczQuJGVsKTtcbiAgICAgICAgY29uc29sZS5sb2coJ01ha2Ugc3VyZSB0aGUgc2Nyb2xsZXIgaGFzIGEgZml4ZWQgaGVpZ2h0IChvciB3aWR0aCkgYW5kIFxcJ292ZXJmbG93LXlcXCcgKG9yIFxcJ292ZXJmbG93LXhcXCcpIHNldCB0byBcXCdhdXRvXFwnIHNvIGl0IGNhbiBzY3JvbGwgY29ycmVjdGx5IGFuZCBvbmx5IHJlbmRlciB0aGUgaXRlbXMgdmlzaWJsZSBpbiB0aGUgc2Nyb2xsIHZpZXdwb3J0LicpO1xuICAgICAgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIGl0ZW1zIGxpbWl0IHJlYWNoZWQnKTtcbiAgICB9LFxuICAgIHNvcnRWaWV3czogZnVuY3Rpb24gc29ydFZpZXdzKCkge1xuICAgICAgdGhpcy5wb29sLnNvcnQoZnVuY3Rpb24gKHZpZXdBLCB2aWV3Qikge1xuICAgICAgICByZXR1cm4gdmlld0EubnIuaW5kZXggLSB2aWV3Qi5uci5pbmRleDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50KHRlbXBsYXRlLCBzdHlsZSwgc2NyaXB0LCBzY29wZUlkLCBpc0Z1bmN0aW9uYWxUZW1wbGF0ZSwgbW9kdWxlSWRlbnRpZmllciAvKiBzZXJ2ZXIgb25seSAqLywgc2hhZG93TW9kZSwgY3JlYXRlSW5qZWN0b3IsIGNyZWF0ZUluamVjdG9yU1NSLCBjcmVhdGVJbmplY3RvclNoYWRvdykge1xyXG4gICAgaWYgKHR5cGVvZiBzaGFkb3dNb2RlICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICBjcmVhdGVJbmplY3RvclNTUiA9IGNyZWF0ZUluamVjdG9yO1xyXG4gICAgICAgIGNyZWF0ZUluamVjdG9yID0gc2hhZG93TW9kZTtcclxuICAgICAgICBzaGFkb3dNb2RlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wLlxyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHQgPT09ICdmdW5jdGlvbicgPyBzY3JpcHQub3B0aW9ucyA6IHNjcmlwdDtcclxuICAgIC8vIHJlbmRlciBmdW5jdGlvbnNcclxuICAgIGlmICh0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5yZW5kZXIpIHtcclxuICAgICAgICBvcHRpb25zLnJlbmRlciA9IHRlbXBsYXRlLnJlbmRlcjtcclxuICAgICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcclxuICAgICAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWU7XHJcbiAgICAgICAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uYWxUZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICBvcHRpb25zLmZ1bmN0aW9uYWwgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHNjb3BlZElkXHJcbiAgICBpZiAoc2NvcGVJZCkge1xyXG4gICAgICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkO1xyXG4gICAgfVxyXG4gICAgbGV0IGhvb2s7XHJcbiAgICBpZiAobW9kdWxlSWRlbnRpZmllcikge1xyXG4gICAgICAgIC8vIHNlcnZlciBidWlsZFxyXG4gICAgICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICAvLyAyLjMgaW5qZWN0aW9uXHJcbiAgICAgICAgICAgIGNvbnRleHQgPVxyXG4gICAgICAgICAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpOyAvLyBmdW5jdGlvbmFsXHJcbiAgICAgICAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfXztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xyXG4gICAgICAgICAgICBpZiAoc3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmNhbGwodGhpcywgY3JlYXRlSW5qZWN0b3JTU1IoY29udGV4dCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJlbmNlXHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXHJcbiAgICAgICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcclxuICAgICAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2s7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzdHlsZSkge1xyXG4gICAgICAgIGhvb2sgPSBzaGFkb3dNb2RlXHJcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmNhbGwodGhpcywgY3JlYXRlSW5qZWN0b3JTaGFkb3coY29udGV4dCwgdGhpcy4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuY2FsbCh0aGlzLCBjcmVhdGVJbmplY3Rvcihjb250ZXh0KSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoaG9vaykge1xyXG4gICAgICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcclxuICAgICAgICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyV2l0aFN0eWxlSW5qZWN0aW9uKGgsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIGhvb2suY2FsbChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGU7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spIDogW2hvb2tdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzY3JpcHQ7XHJcbn1cblxuLyogc2NyaXB0ICovXG5jb25zdCBfX3Z1ZV9zY3JpcHRfXyA9IHNjcmlwdDtcbi8qIHRlbXBsYXRlICovXG52YXIgX192dWVfcmVuZGVyX18gPSBmdW5jdGlvbigpIHtcbiAgdmFyIF9vYmosIF9vYmokMTtcbiAgdmFyIF92bSA9IHRoaXM7XG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDtcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oO1xuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9ic2VydmUtdmlzaWJpbGl0eVwiLFxuICAgICAgICAgIHJhd05hbWU6IFwidi1vYnNlcnZlLXZpc2liaWxpdHlcIixcbiAgICAgICAgICB2YWx1ZTogX3ZtLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UsXG4gICAgICAgICAgZXhwcmVzc2lvbjogXCJoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlXCJcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHN0YXRpY0NsYXNzOiBcInZ1ZS1yZWN5Y2xlLXNjcm9sbGVyXCIsXG4gICAgICBjbGFzczpcbiAgICAgICAgKChfb2JqID0ge1xuICAgICAgICAgIHJlYWR5OiBfdm0ucmVhZHksXG4gICAgICAgICAgXCJwYWdlLW1vZGVcIjogX3ZtLnBhZ2VNb2RlXG4gICAgICAgIH0pLFxuICAgICAgICAoX29ialtcImRpcmVjdGlvbi1cIiArIF92bS5kaXJlY3Rpb25dID0gdHJ1ZSksXG4gICAgICAgIF9vYmopLFxuICAgICAgb246IHtcbiAgICAgICAgXCImc2Nyb2xsXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdm0uaGFuZGxlU2Nyb2xsKCRldmVudClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgX3ZtLiRzbG90cy5iZWZvcmVcbiAgICAgICAgPyBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcInZ1ZS1yZWN5Y2xlLXNjcm9sbGVyX19zbG90XCIgfSxcbiAgICAgICAgICAgIFtfdm0uX3QoXCJiZWZvcmVcIildLFxuICAgICAgICAgICAgMlxuICAgICAgICAgIClcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHJlZjogXCJ3cmFwcGVyXCIsXG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwidnVlLXJlY3ljbGUtc2Nyb2xsZXJfX2l0ZW0td3JhcHBlclwiLFxuICAgICAgICAgIHN0eWxlOlxuICAgICAgICAgICAgKChfb2JqJDEgPSB7fSksXG4gICAgICAgICAgICAoX29iaiQxW192bS5kaXJlY3Rpb24gPT09IFwidmVydGljYWxcIiA/IFwibWluSGVpZ2h0XCIgOiBcIm1pbldpZHRoXCJdID1cbiAgICAgICAgICAgICAgX3ZtLnRvdGFsU2l6ZSArIFwicHhcIiksXG4gICAgICAgICAgICBfb2JqJDEpXG4gICAgICAgIH0sXG4gICAgICAgIF92bS5fbChfdm0ucG9vbCwgZnVuY3Rpb24odmlldykge1xuICAgICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGtleTogdmlldy5uci5pZCxcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidnVlLXJlY3ljbGUtc2Nyb2xsZXJfX2l0ZW0tdmlld1wiLFxuICAgICAgICAgICAgICBjbGFzczogeyBob3ZlcjogX3ZtLmhvdmVyS2V5ID09PSB2aWV3Lm5yLmtleSB9LFxuICAgICAgICAgICAgICBzdHlsZTogX3ZtLnJlYWR5XG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTpcbiAgICAgICAgICAgICAgICAgICAgICBcInRyYW5zbGF0ZVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAoX3ZtLmRpcmVjdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJZXCIgOiBcIlhcIikgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiKFwiICtcbiAgICAgICAgICAgICAgICAgICAgICB2aWV3LnBvc2l0aW9uICtcbiAgICAgICAgICAgICAgICAgICAgICBcInB4KVwiXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIG1vdXNlZW50ZXI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgX3ZtLmhvdmVyS2V5ID0gdmlldy5uci5rZXk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb3VzZWxlYXZlOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgIF92bS5ob3ZlcktleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfdm0uX3QoXCJkZWZhdWx0XCIsIG51bGwsIHtcbiAgICAgICAgICAgICAgICBpdGVtOiB2aWV3Lml0ZW0sXG4gICAgICAgICAgICAgICAgaW5kZXg6IHZpZXcubnIuaW5kZXgsXG4gICAgICAgICAgICAgICAgYWN0aXZlOiB2aWV3Lm5yLnVzZWRcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAyXG4gICAgICAgICAgKVxuICAgICAgICB9KSxcbiAgICAgICAgMFxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0uJHNsb3RzLmFmdGVyXG4gICAgICAgID8gX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJ2dWUtcmVjeWNsZS1zY3JvbGxlcl9fc2xvdFwiIH0sXG4gICAgICAgICAgICBbX3ZtLl90KFwiYWZ0ZXJcIildLFxuICAgICAgICAgICAgMlxuICAgICAgICAgIClcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcIlJlc2l6ZU9ic2VydmVyXCIsIHsgb246IHsgbm90aWZ5OiBfdm0uaGFuZGxlUmVzaXplIH0gfSlcbiAgICBdLFxuICAgIDFcbiAgKVxufTtcbnZhciBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfXyA9IFtdO1xuX192dWVfcmVuZGVyX18uX3dpdGhTdHJpcHBlZCA9IHRydWU7XG5cbiAgLyogc3R5bGUgKi9cbiAgY29uc3QgX192dWVfaW5qZWN0X3N0eWxlc19fID0gdW5kZWZpbmVkO1xuICAvKiBzY29wZWQgKi9cbiAgY29uc3QgX192dWVfc2NvcGVfaWRfXyA9IHVuZGVmaW5lZDtcbiAgLyogbW9kdWxlIGlkZW50aWZpZXIgKi9cbiAgY29uc3QgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IHVuZGVmaW5lZDtcbiAgLyogZnVuY3Rpb25hbCB0ZW1wbGF0ZSAqL1xuICBjb25zdCBfX3Z1ZV9pc19mdW5jdGlvbmFsX3RlbXBsYXRlX18gPSBmYWxzZTtcbiAgLyogc3R5bGUgaW5qZWN0ICovXG4gIFxuICAvKiBzdHlsZSBpbmplY3QgU1NSICovXG4gIFxuICAvKiBzdHlsZSBpbmplY3Qgc2hhZG93IGRvbSAqL1xuICBcblxuICBcbiAgY29uc3QgX192dWVfY29tcG9uZW50X18gPSBub3JtYWxpemVDb21wb25lbnQoXG4gICAgeyByZW5kZXI6IF9fdnVlX3JlbmRlcl9fLCBzdGF0aWNSZW5kZXJGbnM6IF9fdnVlX3N0YXRpY1JlbmRlckZuc19fIH0sXG4gICAgX192dWVfaW5qZWN0X3N0eWxlc19fLFxuICAgIF9fdnVlX3NjcmlwdF9fLFxuICAgIF9fdnVlX3Njb3BlX2lkX18sXG4gICAgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fLFxuICAgIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18sXG4gICAgZmFsc2UsXG4gICAgdW5kZWZpbmVkLFxuICAgIHVuZGVmaW5lZCxcbiAgICB1bmRlZmluZWRcbiAgKTtcblxudmFyIHNjcmlwdCQxID0ge1xuICBuYW1lOiAnRHluYW1pY1Njcm9sbGVyJyxcbiAgY29tcG9uZW50czoge1xuICAgIFJlY3ljbGVTY3JvbGxlcjogX192dWVfY29tcG9uZW50X19cbiAgfSxcbiAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgcHJvdmlkZTogZnVuY3Rpb24gcHJvdmlkZSgpIHtcbiAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy4kX3Jlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihlbnRyaWVzKSxcbiAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoZW50cnkudGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgncmVzaXplJywge1xuICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgY29udGVudFJlY3Q6IGVudHJ5LmNvbnRlbnRSZWN0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZW50cnkudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdnNjcm9sbERhdGE6IHRoaXMudnNjcm9sbERhdGEsXG4gICAgICB2c2Nyb2xsUGFyZW50OiB0aGlzLFxuICAgICAgdnNjcm9sbFJlc2l6ZU9ic2VydmVyOiB0aGlzLiRfcmVzaXplT2JzZXJ2ZXJcbiAgICB9O1xuICB9LFxuICBwcm9wczogX29iamVjdFNwcmVhZDIoe30sIHByb3BzLCB7XG4gICAgbWluSXRlbVNpemU6IHtcbiAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH1cbiAgfSksXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZzY3JvbGxEYXRhOiB7XG4gICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgc2l6ZXM6IHt9LFxuICAgICAgICB2YWxpZFNpemVzOiB7fSxcbiAgICAgICAga2V5RmllbGQ6IHRoaXMua2V5RmllbGQsXG4gICAgICAgIHNpbXBsZUFycmF5OiBmYWxzZVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgc2ltcGxlQXJyYXk6IHNpbXBsZUFycmF5LFxuICAgIGl0ZW1zV2l0aFNpemU6IGZ1bmN0aW9uIGl0ZW1zV2l0aFNpemUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zLFxuICAgICAgICAgIGtleUZpZWxkID0gdGhpcy5rZXlGaWVsZCxcbiAgICAgICAgICBzaW1wbGVBcnJheSA9IHRoaXMuc2ltcGxlQXJyYXk7XG4gICAgICB2YXIgc2l6ZXMgPSB0aGlzLnZzY3JvbGxEYXRhLnNpemVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIHZhciBpZCA9IHNpbXBsZUFycmF5ID8gaSA6IGl0ZW1ba2V5RmllbGRdO1xuICAgICAgICB2YXIgc2l6ZSA9IHNpemVzW2lkXTtcblxuICAgICAgICBpZiAodHlwZW9mIHNpemUgPT09ICd1bmRlZmluZWQnICYmICF0aGlzLiRfdW5kZWZpbmVkTWFwW2lkXSkge1xuICAgICAgICAgIHNpemUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBsaXN0ZW5lcnM6IGZ1bmN0aW9uIGxpc3RlbmVycygpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB7fTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuJGxpc3RlbmVycykge1xuICAgICAgICBpZiAoa2V5ICE9PSAncmVzaXplJyAmJiBrZXkgIT09ICd2aXNpYmxlJykge1xuICAgICAgICAgIGxpc3RlbmVyc1trZXldID0gdGhpcy4kbGlzdGVuZXJzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgaXRlbXM6IGZ1bmN0aW9uIGl0ZW1zKCkge1xuICAgICAgdGhpcy5mb3JjZVVwZGF0ZShmYWxzZSk7XG4gICAgfSxcbiAgICBzaW1wbGVBcnJheToge1xuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZzY3JvbGxEYXRhLnNpbXBsZUFycmF5ID0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgaW1tZWRpYXRlOiB0cnVlXG4gICAgfSxcbiAgICBkaXJlY3Rpb246IGZ1bmN0aW9uIGRpcmVjdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSh0cnVlKTtcbiAgICB9XG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdGhpcy4kX3VwZGF0ZXMgPSBbXTtcbiAgICB0aGlzLiRfdW5kZWZpbmVkU2l6ZXMgPSAwO1xuICAgIHRoaXMuJF91bmRlZmluZWRNYXAgPSB7fTtcbiAgfSxcbiAgYWN0aXZhdGVkOiBmdW5jdGlvbiBhY3RpdmF0ZWQoKSB7XG4gICAgdGhpcy52c2Nyb2xsRGF0YS5hY3RpdmUgPSB0cnVlO1xuICB9LFxuICBkZWFjdGl2YXRlZDogZnVuY3Rpb24gZGVhY3RpdmF0ZWQoKSB7XG4gICAgdGhpcy52c2Nyb2xsRGF0YS5hY3RpdmUgPSBmYWxzZTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uU2Nyb2xsZXJSZXNpemU6IGZ1bmN0aW9uIG9uU2Nyb2xsZXJSZXNpemUoKSB7XG4gICAgICB2YXIgc2Nyb2xsZXIgPSB0aGlzLiRyZWZzLnNjcm9sbGVyO1xuXG4gICAgICBpZiAoc2Nyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbWl0KCdyZXNpemUnKTtcbiAgICB9LFxuICAgIG9uU2Nyb2xsZXJWaXNpYmxlOiBmdW5jdGlvbiBvblNjcm9sbGVyVmlzaWJsZSgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3ZzY3JvbGw6dXBkYXRlJywge1xuICAgICAgICBmb3JjZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kZW1pdCgndmlzaWJsZScpO1xuICAgIH0sXG4gICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgdmFyIGNsZWFyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgICBpZiAoY2xlYXIgfHwgdGhpcy5zaW1wbGVBcnJheSkge1xuICAgICAgICB0aGlzLnZzY3JvbGxEYXRhLnZhbGlkU2l6ZXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZW1pdCgndnNjcm9sbDp1cGRhdGUnLCB7XG4gICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNjcm9sbFRvSXRlbTogZnVuY3Rpb24gc2Nyb2xsVG9JdGVtKGluZGV4KSB7XG4gICAgICB2YXIgc2Nyb2xsZXIgPSB0aGlzLiRyZWZzLnNjcm9sbGVyO1xuICAgICAgaWYgKHNjcm9sbGVyKSBzY3JvbGxlci5zY3JvbGxUb0l0ZW0oaW5kZXgpO1xuICAgIH0sXG4gICAgZ2V0SXRlbVNpemU6IGZ1bmN0aW9uIGdldEl0ZW1TaXplKGl0ZW0pIHtcbiAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGlkID0gdGhpcy5zaW1wbGVBcnJheSA/IGluZGV4ICE9IG51bGwgPyBpbmRleCA6IHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKSA6IGl0ZW1bdGhpcy5rZXlGaWVsZF07XG4gICAgICByZXR1cm4gdGhpcy52c2Nyb2xsRGF0YS5zaXplc1tpZF0gfHwgMDtcbiAgICB9LFxuICAgIHNjcm9sbFRvQm90dG9tOiBmdW5jdGlvbiBzY3JvbGxUb0JvdHRvbSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLiRfc2Nyb2xsaW5nVG9Cb3R0b20pIHJldHVybjtcbiAgICAgIHRoaXMuJF9zY3JvbGxpbmdUb0JvdHRvbSA9IHRydWU7XG4gICAgICB2YXIgZWwgPSB0aGlzLiRlbDsgLy8gSXRlbSBpcyBpbnNlcnRlZCB0byB0aGUgRE9NXG5cbiAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc2Nyb2xsVG9wID0gZWwuc2Nyb2xsSGVpZ2h0ICsgNTAwMDsgLy8gSXRlbSBzaXplcyBhcmUgY29tcHV0ZWRcblxuICAgICAgICB2YXIgY2IgPSBmdW5jdGlvbiBjYigpIHtcbiAgICAgICAgICBlbC5zY3JvbGxUb3AgPSBlbC5zY3JvbGxIZWlnaHQgKyA1MDAwO1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbC5zY3JvbGxUb3AgPSBlbC5zY3JvbGxIZWlnaHQgKyA1MDAwO1xuXG4gICAgICAgICAgICBpZiAoX3RoaXMuJF91bmRlZmluZWRTaXplcyA9PT0gMCkge1xuICAgICAgICAgICAgICBfdGhpcy4kX3Njcm9sbGluZ1RvQm90dG9tID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qIHNjcmlwdCAqL1xuY29uc3QgX192dWVfc2NyaXB0X18kMSA9IHNjcmlwdCQxO1xuXG4vKiB0ZW1wbGF0ZSAqL1xudmFyIF9fdnVlX3JlbmRlcl9fJDEgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXM7XG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDtcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oO1xuICByZXR1cm4gX2MoXG4gICAgXCJSZWN5Y2xlU2Nyb2xsZXJcIixcbiAgICBfdm0uX2coXG4gICAgICBfdm0uX2IoXG4gICAgICAgIHtcbiAgICAgICAgICByZWY6IFwic2Nyb2xsZXJcIixcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgaXRlbXM6IF92bS5pdGVtc1dpdGhTaXplLFxuICAgICAgICAgICAgXCJtaW4taXRlbS1zaXplXCI6IF92bS5taW5JdGVtU2l6ZSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogX3ZtLmRpcmVjdGlvbixcbiAgICAgICAgICAgIFwia2V5LWZpZWxkXCI6IFwiaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHsgcmVzaXplOiBfdm0ub25TY3JvbGxlclJlc2l6ZSwgdmlzaWJsZTogX3ZtLm9uU2Nyb2xsZXJWaXNpYmxlIH0sXG4gICAgICAgICAgc2NvcGVkU2xvdHM6IF92bS5fdShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtleTogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAgICAgZm46IGZ1bmN0aW9uKHJlZikge1xuICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1XaXRoU2l6ZSA9IHJlZi5pdGVtO1xuICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcmVmLmluZGV4O1xuICAgICAgICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IHJlZi5hY3RpdmU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBfdm0uX3QoXCJkZWZhdWx0XCIsIG51bGwsIG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtV2l0aFNpemUuaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiBhY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgaXRlbVdpdGhTaXplOiBpdGVtV2l0aFNpemVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgXCJSZWN5Y2xlU2Nyb2xsZXJcIixcbiAgICAgICAgX3ZtLiRhdHRycyxcbiAgICAgICAgZmFsc2VcbiAgICAgICksXG4gICAgICBfdm0ubGlzdGVuZXJzXG4gICAgKSxcbiAgICBbXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJ0ZW1wbGF0ZVwiLCB7IHNsb3Q6IFwiYmVmb3JlXCIgfSwgW192bS5fdChcImJlZm9yZVwiKV0sIDIpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwidGVtcGxhdGVcIiwgeyBzbG90OiBcImFmdGVyXCIgfSwgW192bS5fdChcImFmdGVyXCIpXSwgMilcbiAgICBdLFxuICAgIDJcbiAgKVxufTtcbnZhciBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfXyQxID0gW107XG5fX3Z1ZV9yZW5kZXJfXyQxLl93aXRoU3RyaXBwZWQgPSB0cnVlO1xuXG4gIC8qIHN0eWxlICovXG4gIGNvbnN0IF9fdnVlX2luamVjdF9zdHlsZXNfXyQxID0gdW5kZWZpbmVkO1xuICAvKiBzY29wZWQgKi9cbiAgY29uc3QgX192dWVfc2NvcGVfaWRfXyQxID0gdW5kZWZpbmVkO1xuICAvKiBtb2R1bGUgaWRlbnRpZmllciAqL1xuICBjb25zdCBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fJDEgPSB1bmRlZmluZWQ7XG4gIC8qIGZ1bmN0aW9uYWwgdGVtcGxhdGUgKi9cbiAgY29uc3QgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fJDEgPSBmYWxzZTtcbiAgLyogc3R5bGUgaW5qZWN0ICovXG4gIFxuICAvKiBzdHlsZSBpbmplY3QgU1NSICovXG4gIFxuICAvKiBzdHlsZSBpbmplY3Qgc2hhZG93IGRvbSAqL1xuICBcblxuICBcbiAgY29uc3QgX192dWVfY29tcG9uZW50X18kMSA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgICB7IHJlbmRlcjogX192dWVfcmVuZGVyX18kMSwgc3RhdGljUmVuZGVyRm5zOiBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfXyQxIH0sXG4gICAgX192dWVfaW5qZWN0X3N0eWxlc19fJDEsXG4gICAgX192dWVfc2NyaXB0X18kMSxcbiAgICBfX3Z1ZV9zY29wZV9pZF9fJDEsXG4gICAgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fJDEsXG4gICAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyQxLFxuICAgIGZhbHNlLFxuICAgIHVuZGVmaW5lZCxcbiAgICB1bmRlZmluZWQsXG4gICAgdW5kZWZpbmVkXG4gICk7XG5cbnZhciBzY3JpcHQkMiA9IHtcbiAgbmFtZTogJ0R5bmFtaWNTY3JvbGxlckl0ZW0nLFxuICBpbmplY3Q6IFsndnNjcm9sbERhdGEnLCAndnNjcm9sbFBhcmVudCcsICd2c2Nyb2xsUmVzaXplT2JzZXJ2ZXInXSxcbiAgcHJvcHM6IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdnVlL3JlcXVpcmUtcHJvcC10eXBlc1xuICAgIGl0ZW06IHtcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB3YXRjaERhdGE6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHZpZXcgaXMgYWN0aXZlbHkgdXNlZCB0byBkaXNwbGF5IGFuIGl0ZW0uXG4gICAgICovXG4gICAgYWN0aXZlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIGluZGV4OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIHNpemVEZXBlbmRlbmNpZXM6IHtcbiAgICAgIHR5cGU6IFtBcnJheSwgT2JqZWN0XSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGVtaXRSZXNpemU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGl2J1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpZDogZnVuY3Rpb24gaWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy52c2Nyb2xsRGF0YS5zaW1wbGVBcnJheSA/IHRoaXMuaW5kZXggOiB0aGlzLml0ZW1bdGhpcy52c2Nyb2xsRGF0YS5rZXlGaWVsZF07XG4gICAgfSxcbiAgICBzaXplOiBmdW5jdGlvbiBzaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMudnNjcm9sbERhdGEudmFsaWRTaXplc1t0aGlzLmlkXSAmJiB0aGlzLnZzY3JvbGxEYXRhLnNpemVzW3RoaXMuaWRdIHx8IDA7XG4gICAgfSxcbiAgICBmaW5hbEFjdGl2ZTogZnVuY3Rpb24gZmluYWxBY3RpdmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmUgJiYgdGhpcy52c2Nyb2xsRGF0YS5hY3RpdmU7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHdhdGNoRGF0YTogJ3VwZGF0ZVdhdGNoRGF0YScsXG4gICAgaWQ6IGZ1bmN0aW9uIGlkKCkge1xuICAgICAgaWYgKCF0aGlzLnNpemUpIHtcbiAgICAgICAgdGhpcy5vbkRhdGFVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZpbmFsQWN0aXZlOiBmdW5jdGlvbiBmaW5hbEFjdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLnNpemUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnZzY3JvbGxQYXJlbnQuJF91bmRlZmluZWRNYXBbdGhpcy5pZF0pIHtcbiAgICAgICAgICAgIHRoaXMudnNjcm9sbFBhcmVudC4kX3VuZGVmaW5lZFNpemVzKys7XG4gICAgICAgICAgICB0aGlzLnZzY3JvbGxQYXJlbnQuJF91bmRlZmluZWRNYXBbdGhpcy5pZF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy52c2Nyb2xsUGFyZW50LiRfdW5kZWZpbmVkTWFwW3RoaXMuaWRdKSB7XG4gICAgICAgICAgICB0aGlzLnZzY3JvbGxQYXJlbnQuJF91bmRlZmluZWRTaXplcy0tO1xuICAgICAgICAgICAgdGhpcy52c2Nyb2xsUGFyZW50LiRfdW5kZWZpbmVkTWFwW3RoaXMuaWRdID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnZzY3JvbGxSZXNpemVPYnNlcnZlcikge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLm9ic2VydmVTaXplKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51bm9ic2VydmVTaXplKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdGhpcy4kX3BlbmRpbmdWU2Nyb2xsVXBkYXRlID09PSB0aGlzLmlkKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuJGlzU2VydmVyKSByZXR1cm47XG4gICAgdGhpcy4kX2ZvcmNlTmV4dFZTY3JvbGxVcGRhdGUgPSBudWxsO1xuICAgIHRoaXMudXBkYXRlV2F0Y2hEYXRhKCk7XG5cbiAgICBpZiAoIXRoaXMudnNjcm9sbFJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChrKSB7XG4gICAgICAgIF90aGlzLiR3YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnNpemVEZXBlbmRlbmNpZXNba107XG4gICAgICAgIH0sIF90aGlzLm9uRGF0YVVwZGF0ZSk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrIGluIHRoaXMuc2l6ZURlcGVuZGVuY2llcykge1xuICAgICAgICBfbG9vcChrKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52c2Nyb2xsUGFyZW50LiRvbigndnNjcm9sbDp1cGRhdGUnLCB0aGlzLm9uVnNjcm9sbFVwZGF0ZSk7XG4gICAgICB0aGlzLnZzY3JvbGxQYXJlbnQuJG9uKCd2c2Nyb2xsOnVwZGF0ZS1zaXplJywgdGhpcy5vblZzY3JvbGxVcGRhdGVTaXplKTtcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgaWYgKHRoaXMudnNjcm9sbERhdGEuYWN0aXZlKSB7XG4gICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICAgIHRoaXMub2JzZXJ2ZVNpemUoKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy52c2Nyb2xsUGFyZW50LiRvZmYoJ3ZzY3JvbGw6dXBkYXRlJywgdGhpcy5vblZzY3JvbGxVcGRhdGUpO1xuICAgIHRoaXMudnNjcm9sbFBhcmVudC4kb2ZmKCd2c2Nyb2xsOnVwZGF0ZS1zaXplJywgdGhpcy5vblZzY3JvbGxVcGRhdGVTaXplKTtcbiAgICB0aGlzLnVub2JzZXJ2ZVNpemUoKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHVwZGF0ZVNpemU6IGZ1bmN0aW9uIHVwZGF0ZVNpemUoKSB7XG4gICAgICBpZiAodGhpcy5maW5hbEFjdGl2ZSkge1xuICAgICAgICBpZiAodGhpcy4kX3BlbmRpbmdTaXplVXBkYXRlICE9PSB0aGlzLmlkKSB7XG4gICAgICAgICAgdGhpcy4kX3BlbmRpbmdTaXplVXBkYXRlID0gdGhpcy5pZDtcbiAgICAgICAgICB0aGlzLiRfZm9yY2VOZXh0VlNjcm9sbFVwZGF0ZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy4kX3BlbmRpbmdWU2Nyb2xsVXBkYXRlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmNvbXB1dGVTaXplKHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRfZm9yY2VOZXh0VlNjcm9sbFVwZGF0ZSA9IHRoaXMuaWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGVXYXRjaERhdGE6IGZ1bmN0aW9uIHVwZGF0ZVdhdGNoRGF0YSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy53YXRjaERhdGEpIHtcbiAgICAgICAgdGhpcy4kX3dhdGNoRGF0YSA9IHRoaXMuJHdhdGNoKCdkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5vbkRhdGFVcGRhdGUoKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgIGRlZXA6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuJF93YXRjaERhdGEpIHtcbiAgICAgICAgdGhpcy4kX3dhdGNoRGF0YSgpO1xuICAgICAgICB0aGlzLiRfd2F0Y2hEYXRhID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uVnNjcm9sbFVwZGF0ZTogZnVuY3Rpb24gb25Wc2Nyb2xsVXBkYXRlKF9yZWYpIHtcbiAgICAgIHZhciBmb3JjZSA9IF9yZWYuZm9yY2U7XG5cbiAgICAgIC8vIElmIG5vdCBhY3RpdmUsIHNlY2hlZHVsZSBhIHNpemUgdXBkYXRlIHdoZW4gaXQgYmVjb21lcyBhY3RpdmVcbiAgICAgIGlmICghdGhpcy5maW5hbEFjdGl2ZSAmJiBmb3JjZSkge1xuICAgICAgICB0aGlzLiRfcGVuZGluZ1ZTY3JvbGxVcGRhdGUgPSB0aGlzLmlkO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy4kX2ZvcmNlTmV4dFZTY3JvbGxVcGRhdGUgPT09IHRoaXMuaWQgfHwgZm9yY2UgfHwgIXRoaXMuc2l6ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uRGF0YVVwZGF0ZTogZnVuY3Rpb24gb25EYXRhVXBkYXRlKCkge1xuICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgfSxcbiAgICBjb21wdXRlU2l6ZTogZnVuY3Rpb24gY29tcHV0ZVNpemUoaWQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczMuaWQgPT09IGlkKSB7XG4gICAgICAgICAgdmFyIHdpZHRoID0gX3RoaXMzLiRlbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gX3RoaXMzLiRlbC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICBfdGhpczMuYXBwbHlTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMzLiRfcGVuZGluZ1NpemVVcGRhdGUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBhcHBseVNpemU6IGZ1bmN0aW9uIGFwcGx5U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgc2l6ZSA9IE1hdGgucm91bmQodGhpcy52c2Nyb2xsUGFyZW50LmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IGhlaWdodCA6IHdpZHRoKTtcblxuICAgICAgaWYgKHNpemUgJiYgdGhpcy5zaXplICE9PSBzaXplKSB7XG4gICAgICAgIGlmICh0aGlzLnZzY3JvbGxQYXJlbnQuJF91bmRlZmluZWRNYXBbdGhpcy5pZF0pIHtcbiAgICAgICAgICB0aGlzLnZzY3JvbGxQYXJlbnQuJF91bmRlZmluZWRTaXplcy0tO1xuICAgICAgICAgIHRoaXMudnNjcm9sbFBhcmVudC4kX3VuZGVmaW5lZE1hcFt0aGlzLmlkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnZzY3JvbGxEYXRhLnNpemVzLCB0aGlzLmlkLCBzaXplKTtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMudnNjcm9sbERhdGEudmFsaWRTaXplcywgdGhpcy5pZCwgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLmVtaXRSZXNpemUpIHRoaXMuJGVtaXQoJ3Jlc2l6ZScsIHRoaXMuaWQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb2JzZXJ2ZVNpemU6IGZ1bmN0aW9uIG9ic2VydmVTaXplKCkge1xuICAgICAgaWYgKCF0aGlzLnZzY3JvbGxSZXNpemVPYnNlcnZlcikgcmV0dXJuO1xuICAgICAgdGhpcy52c2Nyb2xsUmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLiRlbC5wYXJlbnROb2RlKTtcbiAgICAgIHRoaXMuJGVsLnBhcmVudE5vZGUuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vblJlc2l6ZSk7XG4gICAgfSxcbiAgICB1bm9ic2VydmVTaXplOiBmdW5jdGlvbiB1bm9ic2VydmVTaXplKCkge1xuICAgICAgaWYgKCF0aGlzLnZzY3JvbGxSZXNpemVPYnNlcnZlcikgcmV0dXJuO1xuICAgICAgdGhpcy52c2Nyb2xsUmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMuJGVsLnBhcmVudE5vZGUpO1xuICAgICAgdGhpcy4kZWwucGFyZW50Tm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplKTtcbiAgICB9LFxuICAgIG9uUmVzaXplOiBmdW5jdGlvbiBvblJlc2l6ZShldmVudCkge1xuICAgICAgdmFyIF9ldmVudCRkZXRhaWwkY29udGVudCA9IGV2ZW50LmRldGFpbC5jb250ZW50UmVjdCxcbiAgICAgICAgICB3aWR0aCA9IF9ldmVudCRkZXRhaWwkY29udGVudC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfZXZlbnQkZGV0YWlsJGNvbnRlbnQuaGVpZ2h0O1xuICAgICAgdGhpcy5hcHBseVNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgcmV0dXJuIGgodGhpcy50YWcsIHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICB9XG59O1xuXG4vKiBzY3JpcHQgKi9cbmNvbnN0IF9fdnVlX3NjcmlwdF9fJDIgPSBzY3JpcHQkMjtcblxuLyogdGVtcGxhdGUgKi9cblxuICAvKiBzdHlsZSAqL1xuICBjb25zdCBfX3Z1ZV9pbmplY3Rfc3R5bGVzX18kMiA9IHVuZGVmaW5lZDtcbiAgLyogc2NvcGVkICovXG4gIGNvbnN0IF9fdnVlX3Njb3BlX2lkX18kMiA9IHVuZGVmaW5lZDtcbiAgLyogbW9kdWxlIGlkZW50aWZpZXIgKi9cbiAgY29uc3QgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyQyID0gdW5kZWZpbmVkO1xuICAvKiBmdW5jdGlvbmFsIHRlbXBsYXRlICovXG4gIGNvbnN0IF9fdnVlX2lzX2Z1bmN0aW9uYWxfdGVtcGxhdGVfXyQyID0gdW5kZWZpbmVkO1xuICAvKiBzdHlsZSBpbmplY3QgKi9cbiAgXG4gIC8qIHN0eWxlIGluamVjdCBTU1IgKi9cbiAgXG4gIC8qIHN0eWxlIGluamVjdCBzaGFkb3cgZG9tICovXG4gIFxuXG4gIFxuICBjb25zdCBfX3Z1ZV9jb21wb25lbnRfXyQyID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICAgIHt9LFxuICAgIF9fdnVlX2luamVjdF9zdHlsZXNfXyQyLFxuICAgIF9fdnVlX3NjcmlwdF9fJDIsXG4gICAgX192dWVfc2NvcGVfaWRfXyQyLFxuICAgIF9fdnVlX2lzX2Z1bmN0aW9uYWxfdGVtcGxhdGVfXyQyLFxuICAgIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18kMixcbiAgICBmYWxzZSxcbiAgICB1bmRlZmluZWQsXG4gICAgdW5kZWZpbmVkLFxuICAgIHVuZGVmaW5lZFxuICApO1xuXG5mdW5jdGlvbiBJZFN0YXRlICgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgX3JlZiRpZFByb3AgPSBfcmVmLmlkUHJvcCxcbiAgICAgIGlkUHJvcCA9IF9yZWYkaWRQcm9wID09PSB2b2lkIDAgPyBmdW5jdGlvbiAodm0pIHtcbiAgICByZXR1cm4gdm0uaXRlbS5pZDtcbiAgfSA6IF9yZWYkaWRQcm9wO1xuXG4gIHZhciBzdG9yZSA9IHt9O1xuICB2YXIgdm0gPSBuZXcgdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdC5hKHtcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RvcmU6IHN0b3JlXG4gICAgICB9O1xuICAgIH1cbiAgfSk7IC8vIEB2dWUvY29tcG9uZW50XG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWRTdGF0ZTogbnVsbFxuICAgICAgfTtcbiAgICB9LFxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRfaWQgPSBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIGlkUHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLiRfZ2V0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGlkUHJvcC5jYWxsKF90aGlzLCBfdGhpcyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRfZ2V0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzW2lkUHJvcF07XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJHdhdGNoKHRoaXMuJF9nZXRJZCwge1xuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuJF9pZCA9IHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kX3VwZGF0ZUlkU3RhdGUoKTtcbiAgICB9LFxuICAgIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlKCkge1xuICAgICAgdGhpcy4kX3VwZGF0ZUlkU3RhdGUoKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIC8qKlxuICAgICAgICogSW5pdGlhbGl6ZSBhbiBpZFN0YXRlXG4gICAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGlkIFVuaXF1ZSBpZCBmb3IgdGhlIGRhdGFcbiAgICAgICAqL1xuICAgICAgJF9pZFN0YXRlSW5pdDogZnVuY3Rpb24gJF9pZFN0YXRlSW5pdChpZCkge1xuICAgICAgICB2YXIgZmFjdG9yeSA9IHRoaXMuJG9wdGlvbnMuaWRTdGF0ZTtcblxuICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGZhY3RvcnkuY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgICAgICB2bS4kc2V0KHN0b3JlLCBpZCwgZGF0YSk7XG4gICAgICAgICAgdGhpcy4kX2lkID0gaWQ7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbbWl4aW4gSWRTdGF0ZV0gTWlzc2luZyBgaWRTdGF0ZWAgZnVuY3Rpb24gb24gY29tcG9uZW50IGRlZmluaXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRW5zdXJlIGlkU3RhdGUgaXMgY3JlYXRlZCBhbmQgdXAtdG8tZGF0ZVxuICAgICAgICovXG4gICAgICAkX3VwZGF0ZUlkU3RhdGU6IGZ1bmN0aW9uICRfdXBkYXRlSWRTdGF0ZSgpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy4kX2dldElkKCk7XG5cbiAgICAgICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyBpZCBmb3VuZCBmb3IgSWRTdGF0ZSB3aXRoIGlkUHJvcDogJ1wiLmNvbmNhdChpZFByb3AsIFwiJy5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlkICE9PSB0aGlzLiRfaWQpIHtcbiAgICAgICAgICBpZiAoIXN0b3JlW2lkXSkge1xuICAgICAgICAgICAgdGhpcy4kX2lkU3RhdGVJbml0KGlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmlkU3RhdGUgPSBzdG9yZVtpZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50cyhWdWUsIHByZWZpeCkge1xuICBWdWUuY29tcG9uZW50KFwiXCIuY29uY2F0KHByZWZpeCwgXCJyZWN5Y2xlLXNjcm9sbGVyXCIpLCBfX3Z1ZV9jb21wb25lbnRfXyk7XG4gIFZ1ZS5jb21wb25lbnQoXCJcIi5jb25jYXQocHJlZml4LCBcIlJlY3ljbGVTY3JvbGxlclwiKSwgX192dWVfY29tcG9uZW50X18pO1xuICBWdWUuY29tcG9uZW50KFwiXCIuY29uY2F0KHByZWZpeCwgXCJkeW5hbWljLXNjcm9sbGVyXCIpLCBfX3Z1ZV9jb21wb25lbnRfXyQxKTtcbiAgVnVlLmNvbXBvbmVudChcIlwiLmNvbmNhdChwcmVmaXgsIFwiRHluYW1pY1Njcm9sbGVyXCIpLCBfX3Z1ZV9jb21wb25lbnRfXyQxKTtcbiAgVnVlLmNvbXBvbmVudChcIlwiLmNvbmNhdChwcmVmaXgsIFwiZHluYW1pYy1zY3JvbGxlci1pdGVtXCIpLCBfX3Z1ZV9jb21wb25lbnRfXyQyKTtcbiAgVnVlLmNvbXBvbmVudChcIlwiLmNvbmNhdChwcmVmaXgsIFwiRHluYW1pY1Njcm9sbGVySXRlbVwiKSwgX192dWVfY29tcG9uZW50X18kMik7XG59XG5cbnZhciBwbHVnaW4gPSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2ZXJzaW9uOiBcIjEuMC4xMFwiLFxuICBpbnN0YWxsOiBmdW5jdGlvbiBpbnN0YWxsKFZ1ZSwgb3B0aW9ucykge1xuICAgIHZhciBmaW5hbE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICBpbnN0YWxsQ29tcG9uZW50czogdHJ1ZSxcbiAgICAgIGNvbXBvbmVudHNQcmVmaXg6ICcnXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZmluYWxPcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIGZpbmFsT3B0aW9uc1trZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25maWdba2V5XSA9IGZpbmFsT3B0aW9uc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmaW5hbE9wdGlvbnMuaW5zdGFsbENvbXBvbmVudHMpIHtcbiAgICAgIHJlZ2lzdGVyQ29tcG9uZW50cyhWdWUsIGZpbmFsT3B0aW9ucy5jb21wb25lbnRzUHJlZml4KTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBHbG9iYWxWdWUgPSBudWxsO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgR2xvYmFsVnVlID0gd2luZG93LlZ1ZTtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgR2xvYmFsVnVlID0gZ2xvYmFsLlZ1ZTtcbn1cblxuaWYgKEdsb2JhbFZ1ZSkge1xuICBHbG9iYWxWdWUudXNlKHBsdWdpbik7XG59XG5cbi8qIHVudXNlZCBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBfdW51c2VkX3dlYnBhY2tfZGVmYXVsdF9leHBvcnQgPSAocGx1Z2luKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dnVlLXZpcnR1YWwtc2Nyb2xsZXIuZXNtLmpzLm1hcFxuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXyhcImM4YmFcIikpKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlNTNkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlNmYzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDdlM1wiKTtcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzZjM1wiKTtcbnZhciBhcnJheUluZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWI0ZVwiKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTU1OVwiKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZTg1M1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDNmNFwiKTtcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjExNjlcIik7XG52YXIgU1BFQ0lFUyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYjRjXCIpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbCkpIHtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZWJmZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgTUVUQSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2MmEwXCIpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjc3MlwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDdlM1wiKTtcbnZhciBzZXREZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ5ZjZcIikuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI5NGNcIikoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImVkODNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0cnVlKSB7XG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICB9IGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICB2YXIgcmVnZXggPSAvKGF1dG98c2Nyb2xsKS87XG5cbiAgdmFyIHBhcmVudHMgPSBmdW5jdGlvbiAobm9kZSwgcHMpIHtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlID09PSBudWxsKSB7IHJldHVybiBwczsgfVxuXG4gICAgcmV0dXJuIHBhcmVudHMobm9kZS5wYXJlbnROb2RlLCBwcy5jb25jYXQoW25vZGVdKSk7XG4gIH07XG5cbiAgdmFyIHN0eWxlID0gZnVuY3Rpb24gKG5vZGUsIHByb3ApIHtcbiAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xuICB9O1xuXG4gIHZhciBvdmVyZmxvdyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIHN0eWxlKG5vZGUsIFwib3ZlcmZsb3dcIikgKyBzdHlsZShub2RlLCBcIm92ZXJmbG93LXlcIikgKyBzdHlsZShub2RlLCBcIm92ZXJmbG93LXhcIik7XG4gIH07XG5cbiAgdmFyIHNjcm9sbCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICByZXR1cm4gcmVnZXgudGVzdChvdmVyZmxvdyhub2RlKSk7XG4gIH07XG5cbiAgdmFyIHNjcm9sbFBhcmVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSkge1xuICAgICAgcmV0dXJuIDtcbiAgICB9XG5cbiAgICB2YXIgcHMgPSBwYXJlbnRzKG5vZGUucGFyZW50Tm9kZSwgW10pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHNjcm9sbChwc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIHBzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfTtcblxuICByZXR1cm4gc2Nyb2xsUGFyZW50O1xufSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImYxYWVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODZjY1wiKTtcbnZhciBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ2MzBcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImYyMDFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTRhZVwiKTtcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzlhYVwiKTtcbnZhciBTUEVDSUVTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUxNjhcIikoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZjQxMFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWFmNlwiKTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU4NGFcIikuQXJyYXkuaXNBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmNTU5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcblxudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWNhMVwiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZGVmXCIpO1xudmFyIGNvbnRleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDJjOFwiKTtcbnZhciBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJztcbnZhciAkc3RhcnRzV2l0aCA9ICcnW1NUQVJUU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTE0N1wiKShTVEFSVFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgU1RBUlRTX1dJVEgpO1xuICAgIHZhciBpbmRleCA9IHRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGF0Lmxlbmd0aCkpO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGhcbiAgICAgID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImY3NzJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZjkyMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDE0YlwiKTtcbl9fd2VicGFja19yZXF1aXJlX18oXCJjMjA3XCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY5ZDNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzY1ZFwiKTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU4NGFcIikuU3ltYm9sO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImZhNWJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTUzN1wiKSgnbmF0aXZlLWZ1bmN0aW9uLXRvLXN0cmluZycsIEZ1bmN0aW9uLnRvU3RyaW5nKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmYWIyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NzI2XCIpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZmIxNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdnVlL2NsaS1zZXJ2aWNlL2xpYi9jb21tYW5kcy9idWlsZC9zZXRQdWJsaWNQYXRoLmpzXG4vLyBUaGlzIGZpbGUgaXMgaW1wb3J0ZWQgaW50byBsaWIvd2MgY2xpZW50IGJ1bmRsZXMuXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB2YXIgY3VycmVudFNjcmlwdCA9IHdpbmRvdy5kb2N1bWVudC5jdXJyZW50U2NyaXB0XG4gIGlmICh0cnVlKSB7XG4gICAgdmFyIGdldEN1cnJlbnRTY3JpcHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODg3NVwiKVxuICAgIGN1cnJlbnRTY3JpcHQgPSBnZXRDdXJyZW50U2NyaXB0KClcblxuICAgIC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBiZWNhdXNlIHByZXZpb3VzbHkgd2UgZGlyZWN0bHkgaW5jbHVkZWQgdGhlIHBvbHlmaWxsXG4gICAgaWYgKCEoJ2N1cnJlbnRTY3JpcHQnIGluIGRvY3VtZW50KSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LCAnY3VycmVudFNjcmlwdCcsIHsgZ2V0OiBnZXRDdXJyZW50U2NyaXB0IH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIHNyYyA9IGN1cnJlbnRTY3JpcHQgJiYgY3VycmVudFNjcmlwdC5zcmMubWF0Y2goLyguK1xcLylbXi9dK1xcLmpzKFxcPy4qKT8kLylcbiAgaWYgKHNyYykge1xuICAgIF9fd2VicGFja19yZXF1aXJlX18ucCA9IHNyY1sxXSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIH1cbn1cblxuLy8gSW5kaWNhdGUgdG8gd2VicGFjayB0aGF0IHRoaXMgZmlsZSBjYW4gYmUgY29uY2F0ZW5hdGVkXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzZXRQdWJsaWNQYXRoID0gKG51bGwpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/e1wiY2FjaGVEaXJlY3RvcnlcIjpcIm5vZGVfbW9kdWxlcy8uY2FjaGUvdnVlLWxvYWRlclwiLFwiY2FjaGVJZGVudGlmaWVyXCI6XCJlMzg3OTEwNC12dWUtbG9hZGVyLXRlbXBsYXRlXCJ9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvVnVlUGhvbmVOdW1iZXJJbnB1dC9pbmRleC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MTljOWExYzcmc2NvcGVkPXRydWUmXG52YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2dWUtcGhvbmUtbnVtYmVyLWlucHV0IGZsZXhcIixjbGFzczpbeyAnZGFyayc6IF92bS5kYXJrIH0sIF92bS5zaXplXSxhdHRyczp7XCJpZFwiOl92bS5pZH19LFsoIV92bS5ub0NvdW50cnlTZWxlY3Rvcik/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwic2VsZWN0LWNvdW50cnktY29udGFpbmVyXCJ9LFtfYygnQ291bnRyeVNlbGVjdG9yJyx7cmVmOlwiQ291bnRyeVNlbGVjdG9yXCIsc3RhdGljQ2xhc3M6XCJpbnB1dC1jb3VudHJ5LXNlbGVjdG9yXCIsYXR0cnM6e1wiaWRcIjooX3ZtLnVuaXF1ZUlkICsgXCJfY291bnRyeV9zZWxlY3RvclwiKSxcIml0ZW1zXCI6X3ZtLmNvZGVzQ291bnRyaWVzLFwiY291bnRyaWVzLWhlaWdodFwiOl92bS5jb3VudHJpZXNIZWlnaHQsXCJlcnJvclwiOl92bS5zaG91bGRDaG9vc2VDb3VudHJ5LFwiaGludFwiOl92bS5zaG91bGRDaG9vc2VDb3VudHJ5ID8gX3ZtLnQuY291bnRyeVNlbGVjdG9yRXJyb3IgOiBudWxsLFwiZGlzYWJsZWRcIjpfdm0uZGlzYWJsZWQsXCJ2YWxpZFwiOl92bS5pc1ZhbGlkICYmICFfdm0ubm9WYWxpZGF0b3JTdGF0ZSxcInByZWZlcnJlZC1jb3VudHJpZXNcIjpfdm0ucHJlZmVycmVkQ291bnRyaWVzLFwib25seS1jb3VudHJpZXNcIjpfdm0ub25seUNvdW50cmllcyxcImlnbm9yZWQtY291bnRyaWVzXCI6X3ZtLmlnbm9yZWRDb3VudHJpZXMsXCJsYWJlbFwiOl92bS50LmNvdW50cnlTZWxlY3RvckxhYmVsLFwibm8tZmxhZ3NcIjpfdm0ubm9GbGFncyxcInNob3ctY29kZS1vbi1saXN0XCI6X3ZtLnNob3dDb2RlT25MaXN0LFwic2l6ZVwiOl92bS5zaXplLFwiZGFya1wiOl92bS5kYXJrLFwidGhlbWVcIjpfdm0udGhlbWV9LG1vZGVsOnt2YWx1ZTooX3ZtLmNvdW50cnlDb2RlKSxjYWxsYmFjazpmdW5jdGlvbiAoJCR2KSB7X3ZtLmNvdW50cnlDb2RlPSQkdn0sZXhwcmVzc2lvbjpcImNvdW50cnlDb2RlXCJ9fSxbX3ZtLl90KFwiYXJyb3dcIixudWxsLHtcInNsb3RcIjpcImFycm93XCJ9KV0sMildLDEpOl92bS5fZSgpLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImZsZXgtMVwifSxbX2MoJ0lucHV0VGVsJyxfdm0uX2Ioe3JlZjpcIlBob25lTnVtYmVySW5wdXRcIixzdGF0aWNDbGFzczpcImlucHV0LXBob25lLW51bWJlclwiLGF0dHJzOntcImlkXCI6KF92bS51bmlxdWVJZCArIFwiX3Bob25lX251bWJlclwiKSxcImxhYmVsXCI6X3ZtLnQucGhvbmVOdW1iZXJMYWJlbCxcImhpbnRcIjpfdm0uaGludFZhbHVlLFwiZGFya1wiOl92bS5kYXJrLFwiZGlzYWJsZWRcIjpfdm0uZGlzYWJsZWQsXCJzaXplXCI6X3ZtLnNpemUsXCJlcnJvclwiOl92bS5lcnJvcixcInZhbGlkXCI6X3ZtLmlzVmFsaWQgJiYgIV92bS5ub1ZhbGlkYXRvclN0YXRlLFwicmVxdWlyZWRcIjpfdm0ucmVxdWlyZWQsXCJuby1jb3VudHJ5LXNlbGVjdG9yXCI6X3ZtLm5vQ291bnRyeVNlbGVjdG9yLFwidGhlbWVcIjpfdm0udGhlbWV9LG9uOntcImtleWRvd25cIjpmdW5jdGlvbiAoZSkgeyBfdm0ubGFzdEtleVByZXNzZWQgPSBlLmtleUNvZGUgfSxcImZvY3VzXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLiRlbWl0KCdwaG9uZS1udW1iZXItZm9jdXNlZCcpfSxcImJsdXJcIjpmdW5jdGlvbigkZXZlbnQpe3JldHVybiBfdm0uJGVtaXQoJ3Bob25lLW51bWJlci1ibHVyJyl9fSxtb2RlbDp7dmFsdWU6KF92bS5waG9uZU51bWJlciksY2FsbGJhY2s6ZnVuY3Rpb24gKCQkdikge192bS5waG9uZU51bWJlcj0kJHZ9LGV4cHJlc3Npb246XCJwaG9uZU51bWJlclwifX0sJ0lucHV0VGVsJyxfdm0uJGF0dHJzLGZhbHNlKSldLDEpXSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9WdWVQaG9uZU51bWJlcklucHV0L2luZGV4LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xOWM5YTFjNyZzY29wZWQ9dHJ1ZSZcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzXG52YXIgZXM3X29iamVjdF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjhlNmVcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbnZhciB3ZWJfZG9tX2l0ZXJhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFjNmFcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xudmFyIGVzNl9hcnJheV9pdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYWRmXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanNcbnZhciBlczZfb2JqZWN0X2tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDU2ZFwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanNcbnZhciBlczZfcmVnZXhwX3RvX3N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2YjU0XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xudmFyIHJ1bnRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTZjZlwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2NvcmUtanMvcHJvbWlzZS5qc1xudmFyIHByb21pc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzk1YlwiKTtcbnZhciBwcm9taXNlX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHByb21pc2UpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IuanNcblxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcHJvbWlzZV9kZWZhdWx0LmEucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IHByb21pc2VfZGVmYXVsdC5hKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xudmFyIGRlZmluZV9wcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NWYyXCIpO1xudmFyIGRlZmluZV9wcm9wZXJ0eV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihkZWZpbmVfcHJvcGVydHkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzXG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBkZWZpbmVfcHJvcGVydHlfZGVmYXVsdCgpKG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanNcbnZhciBlczZfbnVtYmVyX2NvbnN0cnVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM1ZjZcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcy5qc1xudmFyIGVzN19hcnJheV9pbmNsdWRlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2NzYyXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzXG52YXIgZXM2X3N0cmluZ19pbmNsdWRlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyZmRiXCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9WdWVQaG9uZU51bWJlcklucHV0L2Fzc2V0cy9qcy9waG9uZUNvZGVDb3VudHJpZXMuanNcbnZhciBhbGxDb3VudHJpZXMgPSBbWydBZmdoYW5pc3RhbiAo4oCr2KfZgdi62KfZhtiz2KrYp9mG4oCs4oCOKScsICdhZicsICc5MyddLCBbJ0FsYmFuaWEgKFNocWlww6tyaSknLCAnYWwnLCAnMzU1J10sIFsnQWxnZXJpYSAo4oCr2KfZhNis2LLYp9im2LHigKzigI4pJywgJ2R6JywgJzIxMyddLCBbJ0FtZXJpY2FuIFNhbW9hJywgJ2FzJywgJzE2ODQnXSwgWydBbmRvcnJhJywgJ2FkJywgJzM3NiddLCBbJ0FuZ29sYScsICdhbycsICcyNDQnXSwgWydBbmd1aWxsYScsICdhaScsICcxMjY0J10sIFsnQW50aWd1YSBhbmQgQmFyYnVkYScsICdhZycsICcxMjY4J10sIFsnQXJnZW50aW5hJywgJ2FyJywgJzU0J10sIFsnQXJtZW5pYSAo1YDVodW11aHVvdW/1aHVtiknLCAnYW0nLCAnMzc0J10sIFsnQXJ1YmEnLCAnYXcnLCAnMjk3J10sIFsnQXVzdHJhbGlhJywgJ2F1JywgJzYxJywgMF0sIFsnQXVzdHJpYSAow5ZzdGVycmVpY2gpJywgJ2F0JywgJzQzJ10sIFsnQXplcmJhaWphbiAoQXrJmXJiYXljYW4pJywgJ2F6JywgJzk5NCddLCBbJ0JhaGFtYXMnLCAnYnMnLCAnMTI0MiddLCBbJ0JhaHJhaW4gKOKAq9in2YTYqNit2LHZitmG4oCs4oCOKScsICdiaCcsICc5NzMnXSwgWydCYW5nbGFkZXNoICjgpqzgpr7gpoLgprLgpr7gpqbgp4fgprYpJywgJ2JkJywgJzg4MCddLCBbJ0JhcmJhZG9zJywgJ2JiJywgJzEyNDYnXSwgWydCZWxhcnVzICjQkdC10LvQsNGA0YPRgdGMKScsICdieScsICczNzUnXSwgWydCZWxnaXVtIChCZWxnacOrKScsICdiZScsICczMiddLCBbJ0JlbGl6ZScsICdieicsICc1MDEnXSwgWydCZW5pbiAoQsOpbmluKScsICdiaicsICcyMjknXSwgWydCZXJtdWRhJywgJ2JtJywgJzE0NDEnXSwgWydCaHV0YW4gKOC9oOC9luC+suC9tOC9giknLCAnYnQnLCAnOTc1J10sIFsnQm9saXZpYScsICdibycsICc1OTEnXSwgWydCb3NuaWEgYW5kIEhlcnplZ292aW5hICjQkdC+0YHQvdCwINC4INCl0LXRgNGG0LXQs9C+0LLQuNC90LApJywgJ2JhJywgJzM4NyddLCBbJ0JvdHN3YW5hJywgJ2J3JywgJzI2NyddLCBbJ0JyYXppbCAoQnJhc2lsKScsICdicicsICc1NSddLCBbJ0JyaXRpc2ggSW5kaWFuIE9jZWFuIFRlcnJpdG9yeScsICdpbycsICcyNDYnXSwgWydCcml0aXNoIFZpcmdpbiBJc2xhbmRzJywgJ3ZnJywgJzEyODQnXSwgWydCcnVuZWknLCAnYm4nLCAnNjczJ10sIFsnQnVsZ2FyaWEgKNCR0YrQu9Cz0LDRgNC40Y8pJywgJ2JnJywgJzM1OSddLCBbJ0J1cmtpbmEgRmFzbycsICdiZicsICcyMjYnXSwgWydCdXJ1bmRpIChVYnVydW5kaSknLCAnYmknLCAnMjU3J10sIFsnQ2FtYm9kaWEgKOGegOGemOGfkuGeluGeu+Geh+GetiknLCAna2gnLCAnODU1J10sIFsnQ2FtZXJvb24gKENhbWVyb3VuKScsICdjbScsICcyMzcnXSwgWydDYW5hZGEnLCAnY2EnLCAnMScsIDEsIFsnMjA0JywgJzIyNicsICcyMzYnLCAnMjQ5JywgJzI1MCcsICcyODknLCAnMzA2JywgJzM0MycsICczNjUnLCAnMzg3JywgJzQwMycsICc0MTYnLCAnNDE4JywgJzQzMScsICc0MzcnLCAnNDM4JywgJzQ1MCcsICc1MDYnLCAnNTE0JywgJzUxOScsICc1NDgnLCAnNTc5JywgJzU4MScsICc1ODcnLCAnNjA0JywgJzYxMycsICc2MzknLCAnNjQ3JywgJzY3MicsICc3MDUnLCAnNzA5JywgJzc0MicsICc3NzgnLCAnNzgwJywgJzc4MicsICc4MDcnLCAnODE5JywgJzgyNScsICc4NjcnLCAnODczJywgJzkwMicsICc5MDUnXV0sIFsnQ2FwZSBWZXJkZSAoS2FidSBWZXJkaSknLCAnY3YnLCAnMjM4J10sIFsnQ2FyaWJiZWFuIE5ldGhlcmxhbmRzJywgJ2JxJywgJzU5OScsIDFdLCBbJ0NheW1hbiBJc2xhbmRzJywgJ2t5JywgJzEzNDUnXSwgWydDZW50cmFsIEFmcmljYW4gUmVwdWJsaWMgKFLDqXB1YmxpcXVlIGNlbnRyYWZyaWNhaW5lKScsICdjZicsICcyMzYnXSwgWydDaGFkIChUY2hhZCknLCAndGQnLCAnMjM1J10sIFsnQ2hpbGUnLCAnY2wnLCAnNTYnXSwgWydDaGluYSAo5Lit5Zu9KScsICdjbicsICc4NiddLCBbJ0NocmlzdG1hcyBJc2xhbmQnLCAnY3gnLCAnNjEnLCAyXSwgWydDb2NvcyAoS2VlbGluZykgSXNsYW5kcycsICdjYycsICc2MScsIDFdLCBbJ0NvbG9tYmlhJywgJ2NvJywgJzU3J10sIFsnQ29tb3JvcyAo4oCr2KzYstixINin2YTZgtmF2LHigKzigI4pJywgJ2ttJywgJzI2OSddLCBbJ0NvbmdvIChEUkMpIChKYW1odXJpIHlhIEtpZGVtb2tyYXNpYSB5YSBLb25nbyknLCAnY2QnLCAnMjQzJ10sIFsnQ29uZ28gKFJlcHVibGljKSAoQ29uZ28tQnJhenphdmlsbGUpJywgJ2NnJywgJzI0MiddLCBbJ0Nvb2sgSXNsYW5kcycsICdjaycsICc2ODInXSwgWydDb3N0YSBSaWNhJywgJ2NyJywgJzUwNiddLCBbJ0PDtHRlIGTigJlJdm9pcmUnLCAnY2knLCAnMjI1J10sIFsnQ3JvYXRpYSAoSHJ2YXRza2EpJywgJ2hyJywgJzM4NSddLCBbJ0N1YmEnLCAnY3UnLCAnNTMnXSwgWydDdXJhw6dhbycsICdjdycsICc1OTknLCAwXSwgWydDeXBydXMgKM6az43PgM+Bzr/PgiknLCAnY3knLCAnMzU3J10sIFsnQ3plY2ggUmVwdWJsaWMgKMSMZXNrw6EgcmVwdWJsaWthKScsICdjeicsICc0MjAnXSwgWydEZW5tYXJrIChEYW5tYXJrKScsICdkaycsICc0NSddLCBbJ0RqaWJvdXRpJywgJ2RqJywgJzI1MyddLCBbJ0RvbWluaWNhJywgJ2RtJywgJzE3NjcnXSwgWydEb21pbmljYW4gUmVwdWJsaWMgKFJlcMO6YmxpY2EgRG9taW5pY2FuYSknLCAnZG8nLCAnMScsIDIsIFsnODA5JywgJzgyOScsICc4NDknXV0sIFsnRWN1YWRvcicsICdlYycsICc1OTMnXSwgWydFZ3lwdCAo4oCr2YXYtdix4oCs4oCOKScsICdlZycsICcyMCddLCBbJ0VsIFNhbHZhZG9yJywgJ3N2JywgJzUwMyddLCBbJ0VxdWF0b3JpYWwgR3VpbmVhIChHdWluZWEgRWN1YXRvcmlhbCknLCAnZ3EnLCAnMjQwJ10sIFsnRXJpdHJlYScsICdlcicsICcyOTEnXSwgWydFc3RvbmlhIChFZXN0aSknLCAnZWUnLCAnMzcyJ10sIFsnRXRoaW9waWEnLCAnZXQnLCAnMjUxJ10sIFsnRmFsa2xhbmQgSXNsYW5kcyAoSXNsYXMgTWFsdmluYXMpJywgJ2ZrJywgJzUwMCddLCBbJ0Zhcm9lIElzbGFuZHMgKEbDuHJveWFyKScsICdmbycsICcyOTgnXSwgWydGaWppJywgJ2ZqJywgJzY3OSddLCBbJ0ZpbmxhbmQgKFN1b21pKScsICdmaScsICczNTgnLCAwXSwgWydGcmFuY2UnLCAnZnInLCAnMzMnXSwgWydGcmVuY2ggR3VpYW5hIChHdXlhbmUgZnJhbsOnYWlzZSknLCAnZ2YnLCAnNTk0J10sIFsnRnJlbmNoIFBvbHluZXNpYSAoUG9seW7DqXNpZSBmcmFuw6dhaXNlKScsICdwZicsICc2ODknXSwgWydHYWJvbicsICdnYScsICcyNDEnXSwgWydHYW1iaWEnLCAnZ20nLCAnMjIwJ10sIFsnR2VvcmdpYSAo4YOh4YOQ4YOl4YOQ4YOg4YOX4YOV4YOU4YOa4YOdKScsICdnZScsICc5OTUnXSwgWydHZXJtYW55IChEZXV0c2NobGFuZCknLCAnZGUnLCAnNDknXSwgWydHaGFuYSAoR2FhbmEpJywgJ2doJywgJzIzMyddLCBbJ0dpYnJhbHRhcicsICdnaScsICczNTAnXSwgWydHcmVlY2UgKM6VzrvOu86szrTOsSknLCAnZ3InLCAnMzAnXSwgWydHcmVlbmxhbmQgKEthbGFhbGxpdCBOdW5hYXQpJywgJ2dsJywgJzI5OSddLCBbJ0dyZW5hZGEnLCAnZ2QnLCAnMTQ3MyddLCBbJ0d1YWRlbG91cGUnLCAnZ3AnLCAnNTkwJywgMF0sIFsnR3VhbScsICdndScsICcxNjcxJ10sIFsnR3VhdGVtYWxhJywgJ2d0JywgJzUwMiddLCBbJ0d1ZXJuc2V5JywgJ2dnJywgJzQ0JywgMV0sIFsnR3VpbmVhIChHdWluw6llKScsICdnbicsICcyMjQnXSwgWydHdWluZWEtQmlzc2F1IChHdWluw6kgQmlzc2F1KScsICdndycsICcyNDUnXSwgWydHdXlhbmEnLCAnZ3knLCAnNTkyJ10sIFsnSGFpdGknLCAnaHQnLCAnNTA5J10sIFsnSG9uZHVyYXMnLCAnaG4nLCAnNTA0J10sIFsnSG9uZyBLb25nICjpppnmuK8pJywgJ2hrJywgJzg1MiddLCBbJ0h1bmdhcnkgKE1hZ3lhcm9yc3rDoWcpJywgJ2h1JywgJzM2J10sIFsnSWNlbGFuZCAow41zbGFuZCknLCAnaXMnLCAnMzU0J10sIFsnSW5kaWEgKOCkreCkvuCksOCkpCknLCAnaW4nLCAnOTEnXSwgWydJbmRvbmVzaWEnLCAnaWQnLCAnNjInXSwgWydJcmFuICjigKvYp9uM2LHYp9mG4oCs4oCOKScsICdpcicsICc5OCddLCBbJ0lyYXEgKOKAq9in2YTYudix2KfZguKArOKAjiknLCAnaXEnLCAnOTY0J10sIFsnSXJlbGFuZCcsICdpZScsICczNTMnXSwgWydJc2xlIG9mIE1hbicsICdpbScsICc0NCcsIDJdLCBbJ0lzcmFlbCAo4oCr15nXqdeo15DXnOKArOKAjiknLCAnaWwnLCAnOTcyJ10sIFsnSXRhbHkgKEl0YWxpYSknLCAnaXQnLCAnMzknLCAwXSwgWydKYW1haWNhJywgJ2ptJywgJzE4NzYnXSwgWydKYXBhbiAo5pel5pysKScsICdqcCcsICc4MSddLCBbJ0plcnNleScsICdqZScsICc0NCcsIDNdLCBbJ0pvcmRhbiAo4oCr2KfZhNij2LHYr9mG4oCs4oCOKScsICdqbycsICc5NjInXSwgWydLYXpha2hzdGFuICjQmtCw0LfQsNGF0YHRgtCw0L0pJywgJ2t6JywgJzcnLCAxXSwgWydLZW55YScsICdrZScsICcyNTQnXSwgWydLaXJpYmF0aScsICdraScsICc2ODYnXSwgWydLb3Nvdm8nLCAneGsnLCAnMzgzJ10sIFsnS3V3YWl0ICjigKvYp9mE2YPZiNmK2KrigKzigI4pJywgJ2t3JywgJzk2NSddLCBbJ0t5cmd5enN0YW4gKNCa0YvRgNCz0YvQt9GB0YLQsNC9KScsICdrZycsICc5OTYnXSwgWydMYW9zICjguqXgurLguqcpJywgJ2xhJywgJzg1NiddLCBbJ0xhdHZpYSAoTGF0dmlqYSknLCAnbHYnLCAnMzcxJ10sIFsnTGViYW5vbiAo4oCr2YTYqNmG2KfZhuKArOKAjiknLCAnbGInLCAnOTYxJ10sIFsnTGVzb3RobycsICdscycsICcyNjYnXSwgWydMaWJlcmlhJywgJ2xyJywgJzIzMSddLCBbJ0xpYnlhICjigKvZhNmK2KjZitin4oCs4oCOKScsICdseScsICcyMTgnXSwgWydMaWVjaHRlbnN0ZWluJywgJ2xpJywgJzQyMyddLCBbJ0xpdGh1YW5pYSAoTGlldHV2YSknLCAnbHQnLCAnMzcwJ10sIFsnTHV4ZW1ib3VyZycsICdsdScsICczNTInXSwgWydNYWNhdSAo5r6z6ZaAKScsICdtbycsICc4NTMnXSwgWydNYWNlZG9uaWEgKEZZUk9NKSAo0JzQsNC60LXQtNC+0L3QuNGY0LApJywgJ21rJywgJzM4OSddLCBbJ01hZGFnYXNjYXIgKE1hZGFnYXNpa2FyYSknLCAnbWcnLCAnMjYxJ10sIFsnTWFsYXdpJywgJ213JywgJzI2NSddLCBbJ01hbGF5c2lhJywgJ215JywgJzYwJ10sIFsnTWFsZGl2ZXMnLCAnbXYnLCAnOTYwJ10sIFsnTWFsaScsICdtbCcsICcyMjMnXSwgWydNYWx0YScsICdtdCcsICczNTYnXSwgWydNYXJzaGFsbCBJc2xhbmRzJywgJ21oJywgJzY5MiddLCBbJ01hcnRpbmlxdWUnLCAnbXEnLCAnNTk2J10sIFsnTWF1cml0YW5pYSAo4oCr2YXZiNix2YrYqtin2YbZitin4oCs4oCOKScsICdtcicsICcyMjInXSwgWydNYXVyaXRpdXMgKE1vcmlzKScsICdtdScsICcyMzAnXSwgWydNYXlvdHRlJywgJ3l0JywgJzI2MicsIDFdLCBbJ01leGljbyAoTcOpeGljbyknLCAnbXgnLCAnNTInXSwgWydNaWNyb25lc2lhJywgJ2ZtJywgJzY5MSddLCBbJ01vbGRvdmEgKFJlcHVibGljYSBNb2xkb3ZhKScsICdtZCcsICczNzMnXSwgWydNb25hY28nLCAnbWMnLCAnMzc3J10sIFsnTW9uZ29saWEgKNCc0L7QvdCz0L7QuyknLCAnbW4nLCAnOTc2J10sIFsnTW9udGVuZWdybyAoQ3JuYSBHb3JhKScsICdtZScsICczODInXSwgWydNb250c2VycmF0JywgJ21zJywgJzE2NjQnXSwgWydNb3JvY2NvICjigKvYp9mE2YXYutix2KjigKzigI4pJywgJ21hJywgJzIxMicsIDBdLCBbJ01vemFtYmlxdWUgKE1vw6dhbWJpcXVlKScsICdteicsICcyNTgnXSwgWydNeWFubWFyIChCdXJtYSkgKOGAmeGAvOGAlOGAuuGAmeGArCknLCAnbW0nLCAnOTUnXSwgWydOYW1pYmlhIChOYW1pYmnDqyknLCAnbmEnLCAnMjY0J10sIFsnTmF1cnUnLCAnbnInLCAnNjc0J10sIFsnTmVwYWwgKOCkqOClh+CkquCkvuCksiknLCAnbnAnLCAnOTc3J10sIFsnTmV0aGVybGFuZHMgKE5lZGVybGFuZCknLCAnbmwnLCAnMzEnXSwgWydOZXcgQ2FsZWRvbmlhIChOb3V2ZWxsZS1DYWzDqWRvbmllKScsICduYycsICc2ODcnXSwgWydOZXcgWmVhbGFuZCcsICdueicsICc2NCddLCBbJ05pY2FyYWd1YScsICduaScsICc1MDUnXSwgWydOaWdlciAoTmlqYXIpJywgJ25lJywgJzIyNyddLCBbJ05pZ2VyaWEnLCAnbmcnLCAnMjM0J10sIFsnTml1ZScsICdudScsICc2ODMnXSwgWydOb3Jmb2xrIElzbGFuZCcsICduZicsICc2NzInXSwgWydOb3J0aCBLb3JlYSAo7KGw7ISgIOuvvOyjvOyjvOydmCDsnbjrr7wg6rO17ZmU6rWtKScsICdrcCcsICc4NTAnXSwgWydOb3J0aGVybiBNYXJpYW5hIElzbGFuZHMnLCAnbXAnLCAnMTY3MCddLCBbJ05vcndheSAoTm9yZ2UpJywgJ25vJywgJzQ3JywgMF0sIFsnT21hbiAo4oCr2LnZj9mF2KfZhuKArOKAjiknLCAnb20nLCAnOTY4J10sIFsnUGFraXN0YW4gKOKAq9m+2Kfaqdiz2KrYp9mG4oCs4oCOKScsICdwaycsICc5MiddLCBbJ1BhbGF1JywgJ3B3JywgJzY4MCddLCBbJ1BhbGVzdGluZSAo4oCr2YHZhNiz2LfZitmG4oCs4oCOKScsICdwcycsICc5NzAnXSwgWydQYW5hbWEgKFBhbmFtw6EpJywgJ3BhJywgJzUwNyddLCBbJ1BhcHVhIE5ldyBHdWluZWEnLCAncGcnLCAnNjc1J10sIFsnUGFyYWd1YXknLCAncHknLCAnNTk1J10sIFsnUGVydSAoUGVyw7opJywgJ3BlJywgJzUxJ10sIFsnUGhpbGlwcGluZXMnLCAncGgnLCAnNjMnXSwgWydQb2xhbmQgKFBvbHNrYSknLCAncGwnLCAnNDgnXSwgWydQb3J0dWdhbCcsICdwdCcsICczNTEnXSwgWydQdWVydG8gUmljbycsICdwcicsICcxJywgMywgWyc3ODcnLCAnOTM5J11dLCBbJ1FhdGFyICjigKvZgti32LHigKzigI4pJywgJ3FhJywgJzk3NCddLCBbJ1LDqXVuaW9uIChMYSBSw6l1bmlvbiknLCAncmUnLCAnMjYyJywgMF0sIFsnUm9tYW5pYSAoUm9tw6JuaWEpJywgJ3JvJywgJzQwJ10sIFsnUnVzc2lhICjQoNC+0YHRgdC40Y8pJywgJ3J1JywgJzcnLCAwXSwgWydSd2FuZGEnLCAncncnLCAnMjUwJ10sIFsnU2FpbnQgQmFydGjDqWxlbXknLCAnYmwnLCAnNTkwJywgMV0sIFsnU2FpbnQgSGVsZW5hJywgJ3NoJywgJzI5MCddLCBbJ1NhaW50IEtpdHRzIGFuZCBOZXZpcycsICdrbicsICcxODY5J10sIFsnU2FpbnQgTHVjaWEnLCAnbGMnLCAnMTc1OCddLCBbJ1NhaW50IE1hcnRpbiAoU2FpbnQtTWFydGluIChwYXJ0aWUgZnJhbsOnYWlzZSkpJywgJ21mJywgJzU5MCcsIDJdLCBbJ1NhaW50IFBpZXJyZSBhbmQgTWlxdWVsb24gKFNhaW50LVBpZXJyZS1ldC1NaXF1ZWxvbiknLCAncG0nLCAnNTA4J10sIFsnU2FpbnQgVmluY2VudCBhbmQgdGhlIEdyZW5hZGluZXMnLCAndmMnLCAnMTc4NCddLCBbJ1NhbW9hJywgJ3dzJywgJzY4NSddLCBbJ1NhbiBNYXJpbm8nLCAnc20nLCAnMzc4J10sIFsnU8OjbyBUb23DqSBhbmQgUHLDrW5jaXBlIChTw6NvIFRvbcOpIGUgUHLDrW5jaXBlKScsICdzdCcsICcyMzknXSwgWydTYXVkaSBBcmFiaWEgKOKAq9in2YTZhdmF2YTZg9ipINin2YTYudix2KjZitipINin2YTYs9i52YjYr9mK2KnigKzigI4pJywgJ3NhJywgJzk2NiddLCBbJ1NlbmVnYWwgKFPDqW7DqWdhbCknLCAnc24nLCAnMjIxJ10sIFsnU2VyYmlhICjQodGA0LHQuNGY0LApJywgJ3JzJywgJzM4MSddLCBbJ1NleWNoZWxsZXMnLCAnc2MnLCAnMjQ4J10sIFsnU2llcnJhIExlb25lJywgJ3NsJywgJzIzMiddLCBbJ1NpbmdhcG9yZScsICdzZycsICc2NSddLCBbJ1NpbnQgTWFhcnRlbicsICdzeCcsICcxNzIxJ10sIFsnU2xvdmFraWEgKFNsb3ZlbnNrbyknLCAnc2snLCAnNDIxJ10sIFsnU2xvdmVuaWEgKFNsb3ZlbmlqYSknLCAnc2knLCAnMzg2J10sIFsnU29sb21vbiBJc2xhbmRzJywgJ3NiJywgJzY3NyddLCBbJ1NvbWFsaWEgKFNvb21hYWxpeWEpJywgJ3NvJywgJzI1MiddLCBbJ1NvdXRoIEFmcmljYScsICd6YScsICcyNyddLCBbJ1NvdXRoIEtvcmVhICjrjIDtlZzrr7zqta0pJywgJ2tyJywgJzgyJ10sIFsnU291dGggU3VkYW4gKOKAq9is2YbZiNioINin2YTYs9mI2K/Yp9mG4oCs4oCOKScsICdzcycsICcyMTEnXSwgWydTcGFpbiAoRXNwYcOxYSknLCAnZXMnLCAnMzQnXSwgWydTcmkgTGFua2EgKOC3geC3iuKAjeC2u+C3kyDgtr3gtoLgtprgt4/gt4ApJywgJ2xrJywgJzk0J10sIFsnU3VkYW4gKOKAq9in2YTYs9mI2K/Yp9mG4oCs4oCOKScsICdzZCcsICcyNDknXSwgWydTdXJpbmFtZScsICdzcicsICc1OTcnXSwgWydTdmFsYmFyZCBhbmQgSmFuIE1heWVuJywgJ3NqJywgJzQ3JywgMV0sIFsnU3dhemlsYW5kJywgJ3N6JywgJzI2OCddLCBbJ1N3ZWRlbiAoU3ZlcmlnZSknLCAnc2UnLCAnNDYnXSwgWydTd2l0emVybGFuZCAoU2Nod2VpeiknLCAnY2gnLCAnNDEnXSwgWydTeXJpYSAo4oCr2LPZiNix2YrYp+KArOKAjiknLCAnc3knLCAnOTYzJ10sIFsnVGFpd2FuICjlj7DngaMpJywgJ3R3JywgJzg4NiddLCBbJ1RhamlraXN0YW4nLCAndGonLCAnOTkyJ10sIFsnVGFuemFuaWEnLCAndHonLCAnMjU1J10sIFsnVGhhaWxhbmQgKOC5hOC4l+C4oiknLCAndGgnLCAnNjYnXSwgWydUaW1vci1MZXN0ZScsICd0bCcsICc2NzAnXSwgWydUb2dvJywgJ3RnJywgJzIyOCddLCBbJ1Rva2VsYXUnLCAndGsnLCAnNjkwJ10sIFsnVG9uZ2EnLCAndG8nLCAnNjc2J10sIFsnVHJpbmlkYWQgYW5kIFRvYmFnbycsICd0dCcsICcxODY4J10sIFsnVHVuaXNpYSAo4oCr2KrZiNmG2LPigKzigI4pJywgJ3RuJywgJzIxNiddLCBbJ1R1cmtleSAoVMO8cmtpeWUpJywgJ3RyJywgJzkwJ10sIFsnVHVya21lbmlzdGFuJywgJ3RtJywgJzk5MyddLCBbJ1R1cmtzIGFuZCBDYWljb3MgSXNsYW5kcycsICd0YycsICcxNjQ5J10sIFsnVHV2YWx1JywgJ3R2JywgJzY4OCddLCBbJ1UuUy4gVmlyZ2luIElzbGFuZHMnLCAndmknLCAnMTM0MCddLCBbJ1VnYW5kYScsICd1ZycsICcyNTYnXSwgWydVa3JhaW5lICjQo9C60YDQsNGX0L3QsCknLCAndWEnLCAnMzgwJ10sIFsnVW5pdGVkIEFyYWIgRW1pcmF0ZXMgKOKAq9in2YTYpdmF2KfYsdin2Kog2KfZhNi52LHYqNmK2Kkg2KfZhNmF2KrYrdiv2KnigKzigI4pJywgJ2FlJywgJzk3MSddLCBbJ1VuaXRlZCBLaW5nZG9tJywgJ2diJywgJzQ0JywgMF0sIFsnVW5pdGVkIFN0YXRlcycsICd1cycsICcxJywgMF0sIFsnVXJ1Z3VheScsICd1eScsICc1OTgnXSwgWydVemJla2lzdGFuIChPyrt6YmVraXN0b24pJywgJ3V6JywgJzk5OCddLCBbJ1ZhbnVhdHUnLCAndnUnLCAnNjc4J10sIFsnVmF0aWNhbiBDaXR5IChDaXR0w6AgZGVsIFZhdGljYW5vKScsICd2YScsICczOScsIDFdLCBbJ1ZlbmV6dWVsYScsICd2ZScsICc1OCddLCBbJ1ZpZXRuYW0gKFZp4buHdCBOYW0pJywgJ3ZuJywgJzg0J10sIFsnV2FsbGlzIGFuZCBGdXR1bmEgKFdhbGxpcy1ldC1GdXR1bmEpJywgJ3dmJywgJzY4MSddLCBbJ1dlc3Rlcm4gU2FoYXJhICjigKvYp9mE2LXYrdix2KfYoSDYp9mE2LrYsdio2YrYqeKArOKAjiknLCAnZWgnLCAnMjEyJywgMV0sIFsnWWVtZW4gKOKAq9in2YTZitmF2YbigKzigI4pJywgJ3llJywgJzk2NyddLCBbJ1phbWJpYScsICd6bScsICcyNjAnXSwgWydaaW1iYWJ3ZScsICd6dycsICcyNjMnXSwgWyfDhWxhbmQgSXNsYW5kcycsICdheCcsICczNTgnLCAxXV07XG52YXIgY291bnRyaWVzSXNvID0gYWxsQ291bnRyaWVzLm1hcChmdW5jdGlvbiAoY291bnRyeSkge1xuICByZXR1cm4gY291bnRyeVsxXS50b1VwcGVyQ2FzZSgpO1xufSk7XG52YXIgY291bnRyaWVzID0gYWxsQ291bnRyaWVzLm1hcChmdW5jdGlvbiAoY291bnRyeSkge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IGNvdW50cnlbMF0sXG4gICAgaXNvMjogY291bnRyeVsxXS50b1VwcGVyQ2FzZSgpLFxuICAgIGRpYWxDb2RlOiBjb3VudHJ5WzJdLFxuICAgIHByaW9yaXR5OiBjb3VudHJ5WzNdIHx8IDAsXG4gICAgYXJlYUNvZGVzOiBjb3VudHJ5WzRdIHx8IG51bGxcbiAgfTtcbn0pO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9leGFtcGxlcy5tb2JpbGUuanNvblxudmFyIGV4YW1wbGVzX21vYmlsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMzkxXCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9tZXRhZGF0YS5taW4uanNvbi5qc1xuLy8gVGhpcyBmaWxlIGlzIGEgd29ya2Fyb3VuZCBmb3IgYSBidWcgaW4gd2ViIGJyb3dzZXJzJyBcIm5hdGl2ZVwiXG4vLyBFUzYgaW1wb3J0aW5nIHN5c3RlbSB3aGljaCBpcyB1bmNhcGFibGUgb2YgaW1wb3J0aW5nIFwiKi5qc29uXCIgZmlsZXMuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2F0YW1waGV0YW1pbmUvbGlicGhvbmVudW1iZXItanMvaXNzdWVzLzIzOVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbWV0YWRhdGFfbWluX2pzb24gPSAoe1widmVyc2lvblwiOlwiMS43LjUxXCIsXCJjb3VudHJ5X2NhbGxpbmdfY29kZXNcIjp7XCIxXCI6W1wiVVNcIixcIkFHXCIsXCJBSVwiLFwiQVNcIixcIkJCXCIsXCJCTVwiLFwiQlNcIixcIkNBXCIsXCJETVwiLFwiRE9cIixcIkdEXCIsXCJHVVwiLFwiSk1cIixcIktOXCIsXCJLWVwiLFwiTENcIixcIk1QXCIsXCJNU1wiLFwiUFJcIixcIlNYXCIsXCJUQ1wiLFwiVFRcIixcIlZDXCIsXCJWR1wiLFwiVklcIl0sXCI3XCI6W1wiUlVcIixcIktaXCJdLFwiMjBcIjpbXCJFR1wiXSxcIjI3XCI6W1wiWkFcIl0sXCIzMFwiOltcIkdSXCJdLFwiMzFcIjpbXCJOTFwiXSxcIjMyXCI6W1wiQkVcIl0sXCIzM1wiOltcIkZSXCJdLFwiMzRcIjpbXCJFU1wiXSxcIjM2XCI6W1wiSFVcIl0sXCIzOVwiOltcIklUXCIsXCJWQVwiXSxcIjQwXCI6W1wiUk9cIl0sXCI0MVwiOltcIkNIXCJdLFwiNDNcIjpbXCJBVFwiXSxcIjQ0XCI6W1wiR0JcIixcIkdHXCIsXCJJTVwiLFwiSkVcIl0sXCI0NVwiOltcIkRLXCJdLFwiNDZcIjpbXCJTRVwiXSxcIjQ3XCI6W1wiTk9cIixcIlNKXCJdLFwiNDhcIjpbXCJQTFwiXSxcIjQ5XCI6W1wiREVcIl0sXCI1MVwiOltcIlBFXCJdLFwiNTJcIjpbXCJNWFwiXSxcIjUzXCI6W1wiQ1VcIl0sXCI1NFwiOltcIkFSXCJdLFwiNTVcIjpbXCJCUlwiXSxcIjU2XCI6W1wiQ0xcIl0sXCI1N1wiOltcIkNPXCJdLFwiNThcIjpbXCJWRVwiXSxcIjYwXCI6W1wiTVlcIl0sXCI2MVwiOltcIkFVXCIsXCJDQ1wiLFwiQ1hcIl0sXCI2MlwiOltcIklEXCJdLFwiNjNcIjpbXCJQSFwiXSxcIjY0XCI6W1wiTlpcIl0sXCI2NVwiOltcIlNHXCJdLFwiNjZcIjpbXCJUSFwiXSxcIjgxXCI6W1wiSlBcIl0sXCI4MlwiOltcIktSXCJdLFwiODRcIjpbXCJWTlwiXSxcIjg2XCI6W1wiQ05cIl0sXCI5MFwiOltcIlRSXCJdLFwiOTFcIjpbXCJJTlwiXSxcIjkyXCI6W1wiUEtcIl0sXCI5M1wiOltcIkFGXCJdLFwiOTRcIjpbXCJMS1wiXSxcIjk1XCI6W1wiTU1cIl0sXCI5OFwiOltcIklSXCJdLFwiMjExXCI6W1wiU1NcIl0sXCIyMTJcIjpbXCJNQVwiLFwiRUhcIl0sXCIyMTNcIjpbXCJEWlwiXSxcIjIxNlwiOltcIlROXCJdLFwiMjE4XCI6W1wiTFlcIl0sXCIyMjBcIjpbXCJHTVwiXSxcIjIyMVwiOltcIlNOXCJdLFwiMjIyXCI6W1wiTVJcIl0sXCIyMjNcIjpbXCJNTFwiXSxcIjIyNFwiOltcIkdOXCJdLFwiMjI1XCI6W1wiQ0lcIl0sXCIyMjZcIjpbXCJCRlwiXSxcIjIyN1wiOltcIk5FXCJdLFwiMjI4XCI6W1wiVEdcIl0sXCIyMjlcIjpbXCJCSlwiXSxcIjIzMFwiOltcIk1VXCJdLFwiMjMxXCI6W1wiTFJcIl0sXCIyMzJcIjpbXCJTTFwiXSxcIjIzM1wiOltcIkdIXCJdLFwiMjM0XCI6W1wiTkdcIl0sXCIyMzVcIjpbXCJURFwiXSxcIjIzNlwiOltcIkNGXCJdLFwiMjM3XCI6W1wiQ01cIl0sXCIyMzhcIjpbXCJDVlwiXSxcIjIzOVwiOltcIlNUXCJdLFwiMjQwXCI6W1wiR1FcIl0sXCIyNDFcIjpbXCJHQVwiXSxcIjI0MlwiOltcIkNHXCJdLFwiMjQzXCI6W1wiQ0RcIl0sXCIyNDRcIjpbXCJBT1wiXSxcIjI0NVwiOltcIkdXXCJdLFwiMjQ2XCI6W1wiSU9cIl0sXCIyNDdcIjpbXCJBQ1wiXSxcIjI0OFwiOltcIlNDXCJdLFwiMjQ5XCI6W1wiU0RcIl0sXCIyNTBcIjpbXCJSV1wiXSxcIjI1MVwiOltcIkVUXCJdLFwiMjUyXCI6W1wiU09cIl0sXCIyNTNcIjpbXCJESlwiXSxcIjI1NFwiOltcIktFXCJdLFwiMjU1XCI6W1wiVFpcIl0sXCIyNTZcIjpbXCJVR1wiXSxcIjI1N1wiOltcIkJJXCJdLFwiMjU4XCI6W1wiTVpcIl0sXCIyNjBcIjpbXCJaTVwiXSxcIjI2MVwiOltcIk1HXCJdLFwiMjYyXCI6W1wiUkVcIixcIllUXCJdLFwiMjYzXCI6W1wiWldcIl0sXCIyNjRcIjpbXCJOQVwiXSxcIjI2NVwiOltcIk1XXCJdLFwiMjY2XCI6W1wiTFNcIl0sXCIyNjdcIjpbXCJCV1wiXSxcIjI2OFwiOltcIlNaXCJdLFwiMjY5XCI6W1wiS01cIl0sXCIyOTBcIjpbXCJTSFwiLFwiVEFcIl0sXCIyOTFcIjpbXCJFUlwiXSxcIjI5N1wiOltcIkFXXCJdLFwiMjk4XCI6W1wiRk9cIl0sXCIyOTlcIjpbXCJHTFwiXSxcIjM1MFwiOltcIkdJXCJdLFwiMzUxXCI6W1wiUFRcIl0sXCIzNTJcIjpbXCJMVVwiXSxcIjM1M1wiOltcIklFXCJdLFwiMzU0XCI6W1wiSVNcIl0sXCIzNTVcIjpbXCJBTFwiXSxcIjM1NlwiOltcIk1UXCJdLFwiMzU3XCI6W1wiQ1lcIl0sXCIzNThcIjpbXCJGSVwiLFwiQVhcIl0sXCIzNTlcIjpbXCJCR1wiXSxcIjM3MFwiOltcIkxUXCJdLFwiMzcxXCI6W1wiTFZcIl0sXCIzNzJcIjpbXCJFRVwiXSxcIjM3M1wiOltcIk1EXCJdLFwiMzc0XCI6W1wiQU1cIl0sXCIzNzVcIjpbXCJCWVwiXSxcIjM3NlwiOltcIkFEXCJdLFwiMzc3XCI6W1wiTUNcIl0sXCIzNzhcIjpbXCJTTVwiXSxcIjM4MFwiOltcIlVBXCJdLFwiMzgxXCI6W1wiUlNcIl0sXCIzODJcIjpbXCJNRVwiXSxcIjM4M1wiOltcIlhLXCJdLFwiMzg1XCI6W1wiSFJcIl0sXCIzODZcIjpbXCJTSVwiXSxcIjM4N1wiOltcIkJBXCJdLFwiMzg5XCI6W1wiTUtcIl0sXCI0MjBcIjpbXCJDWlwiXSxcIjQyMVwiOltcIlNLXCJdLFwiNDIzXCI6W1wiTElcIl0sXCI1MDBcIjpbXCJGS1wiXSxcIjUwMVwiOltcIkJaXCJdLFwiNTAyXCI6W1wiR1RcIl0sXCI1MDNcIjpbXCJTVlwiXSxcIjUwNFwiOltcIkhOXCJdLFwiNTA1XCI6W1wiTklcIl0sXCI1MDZcIjpbXCJDUlwiXSxcIjUwN1wiOltcIlBBXCJdLFwiNTA4XCI6W1wiUE1cIl0sXCI1MDlcIjpbXCJIVFwiXSxcIjU5MFwiOltcIkdQXCIsXCJCTFwiLFwiTUZcIl0sXCI1OTFcIjpbXCJCT1wiXSxcIjU5MlwiOltcIkdZXCJdLFwiNTkzXCI6W1wiRUNcIl0sXCI1OTRcIjpbXCJHRlwiXSxcIjU5NVwiOltcIlBZXCJdLFwiNTk2XCI6W1wiTVFcIl0sXCI1OTdcIjpbXCJTUlwiXSxcIjU5OFwiOltcIlVZXCJdLFwiNTk5XCI6W1wiQ1dcIixcIkJRXCJdLFwiNjcwXCI6W1wiVExcIl0sXCI2NzJcIjpbXCJORlwiXSxcIjY3M1wiOltcIkJOXCJdLFwiNjc0XCI6W1wiTlJcIl0sXCI2NzVcIjpbXCJQR1wiXSxcIjY3NlwiOltcIlRPXCJdLFwiNjc3XCI6W1wiU0JcIl0sXCI2NzhcIjpbXCJWVVwiXSxcIjY3OVwiOltcIkZKXCJdLFwiNjgwXCI6W1wiUFdcIl0sXCI2ODFcIjpbXCJXRlwiXSxcIjY4MlwiOltcIkNLXCJdLFwiNjgzXCI6W1wiTlVcIl0sXCI2ODVcIjpbXCJXU1wiXSxcIjY4NlwiOltcIktJXCJdLFwiNjg3XCI6W1wiTkNcIl0sXCI2ODhcIjpbXCJUVlwiXSxcIjY4OVwiOltcIlBGXCJdLFwiNjkwXCI6W1wiVEtcIl0sXCI2OTFcIjpbXCJGTVwiXSxcIjY5MlwiOltcIk1IXCJdLFwiODUwXCI6W1wiS1BcIl0sXCI4NTJcIjpbXCJIS1wiXSxcIjg1M1wiOltcIk1PXCJdLFwiODU1XCI6W1wiS0hcIl0sXCI4NTZcIjpbXCJMQVwiXSxcIjg4MFwiOltcIkJEXCJdLFwiODg2XCI6W1wiVFdcIl0sXCI5NjBcIjpbXCJNVlwiXSxcIjk2MVwiOltcIkxCXCJdLFwiOTYyXCI6W1wiSk9cIl0sXCI5NjNcIjpbXCJTWVwiXSxcIjk2NFwiOltcIklRXCJdLFwiOTY1XCI6W1wiS1dcIl0sXCI5NjZcIjpbXCJTQVwiXSxcIjk2N1wiOltcIllFXCJdLFwiOTY4XCI6W1wiT01cIl0sXCI5NzBcIjpbXCJQU1wiXSxcIjk3MVwiOltcIkFFXCJdLFwiOTcyXCI6W1wiSUxcIl0sXCI5NzNcIjpbXCJCSFwiXSxcIjk3NFwiOltcIlFBXCJdLFwiOTc1XCI6W1wiQlRcIl0sXCI5NzZcIjpbXCJNTlwiXSxcIjk3N1wiOltcIk5QXCJdLFwiOTkyXCI6W1wiVEpcIl0sXCI5OTNcIjpbXCJUTVwiXSxcIjk5NFwiOltcIkFaXCJdLFwiOTk1XCI6W1wiR0VcIl0sXCI5OTZcIjpbXCJLR1wiXSxcIjk5OFwiOltcIlVaXCJdfSxcImNvdW50cmllc1wiOntcIkFDXCI6W1wiMjQ3XCIsXCIwMFwiLFwiKD86WzAxNTg5XVxcXFxkfFs0Nl0pXFxcXGR7NH1cIixbNSw2XV0sXCJBRFwiOltcIjM3NlwiLFwiMDBcIixcIig/OjF8NlxcXFxkKVxcXFxkezd9fFsxMzUtOV1cXFxcZHs1fVwiLFs2LDgsOV0sW1tcIihcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMlwiLFtcIlsxMzUtOV1cIl1dLFtcIihcXFxcZHs0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIjFcIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCI2XCJdXV1dLFwiQUVcIjpbXCI5NzFcIixcIjAwXCIsXCIoPzpbNC03XVxcXFxkfDlbMC02ODldKVxcXFxkezd9fDgwMFxcXFxkezIsOX18WzItNDY3OV1cXFxcZHs3fVwiLFs1LDYsNyw4LDksMTAsMTEsMTJdLFtbXCIoXFxcXGR7M30pKFxcXFxkezIsOX0pXCIsXCIkMSAkMlwiLFtcIjYwfDhcIl1dLFtcIihcXFxcZCkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCJbMjM2XXxbNDc5XVsyLThdXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGQpKFxcXFxkezV9KVwiLFwiJDEgJDIgJDNcIixbXCJbNDc5XVwiXV0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjVcIl0sXCIwJDFcIl1dLFwiMFwiXSxcIkFGXCI6W1wiOTNcIixcIjAwXCIsXCJbMi03XVxcXFxkezh9XCIsWzldLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiWzItN11cIl0sXCIwJDFcIl1dLFwiMFwiXSxcIkFHXCI6W1wiMVwiLFwiMDExXCIsXCIoPzoyNjh8WzU4XVxcXFxkXFxcXGR8OTAwKVxcXFxkezd9XCIsWzEwXSwwLFwiMVwiLDAsXCIxfChbNDU3XVxcXFxkezZ9KSRcIixcIjI2OCQxXCIsMCxcIjI2OFwiXSxcIkFJXCI6W1wiMVwiLFwiMDExXCIsXCIoPzoyNjR8WzU4XVxcXFxkXFxcXGR8OTAwKVxcXFxkezd9XCIsWzEwXSwwLFwiMVwiLDAsXCIxfChbMjQ1N11cXFxcZHs2fSkkXCIsXCIyNjQkMVwiLDAsXCIyNjRcIl0sXCJBTFwiOltcIjM1NVwiLFwiMDBcIixcIig/OjcwMFxcXFxkXFxcXGR8OTAwKVxcXFxkezN9fDhcXFxcZHs1LDd9fCg/OlsyLTVdfDZcXFxcZClcXFxcZHs3fVwiLFs2LDcsOCw5XSxbW1wiKFxcXFxkezN9KShcXFxcZHszLDR9KVwiLFwiJDEgJDJcIixbXCI4MHw5XCJdLFwiMCQxXCJdLFtcIihcXFxcZCkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCI0WzItNl1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIlsyMzU4XVsyLTVdfDRcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHs1fSlcIixcIiQxICQyXCIsW1wiWzIzNTc4XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiNlwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiQU1cIjpbXCIzNzRcIixcIjAwXCIsXCIoPzpbMS00ODldXFxcXGR8NTV8NjB8NzcpXFxcXGR7Nn1cIixbOF0sW1tcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCJbODldMFwiXSxcIjAgJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHs1fSlcIixcIiQxICQyXCIsW1wiMnwzWzEyXVwiXSxcIigwJDEpXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7Nn0pXCIsXCIkMSAkMlwiLFtcIjF8NDdcIl0sXCIoMCQxKVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezZ9KVwiLFwiJDEgJDJcIixbXCJbMy05XVwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiQU9cIjpbXCIyNDRcIixcIjAwXCIsXCJbMjldXFxcXGR7OH1cIixbOV0sW1tcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCJbMjldXCJdXV1dLFwiQVJcIjpbXCI1NFwiLFwiMDBcIixcIjExXFxcXGR7OH18KD86WzIzNjhdfDlcXFxcZClcXFxcZHs5fVwiLFsxMCwxMV0sW1tcIihcXFxcZHs0fSkoXFxcXGR7Mn0pKFxcXFxkezR9KVwiLFwiJDEgJDItJDNcIixbXCIyKD86MlswMjQtOV18M1swLTU5XXw0N3w2WzI0NV18OVswMi04XSl8Myg/OjNbMjhdfDRbMDMtOV18NVsyLTQ2LThdfDdbMS01NzhdfDhbMi05XSlcIixcIjIoPzpbMjNdMDJ8Nig/OlsyNV18NFs2LThdKXw5KD86WzAyMzU2XXw0WzAyNTY4XXw3Mnw4WzIzXSkpfDMoPzozWzI4XXw0KD86WzA0Njc5XXwzWzUtOF18NVs0LTY4XXw4WzIzNzldKXw1KD86WzI0NjddfDNbMjM3XXw4WzItNV0pfDdbMS01NzhdfDgoPzpbMjQ2OV18M1syNTc4XXw1WzQtOF18N1szNi04XXw4WzUtOF0pKXwyKD86MlsyNC05XXwzWzEtNTldfDQ3KVwiLFwiMig/OlsyM10wMnw2KD86WzI1XXw0KD86NjR8Wzc4XSkpfDkoPzpbMDIzNTZdfDQoPzpbMDI2OF18NVsyLTZdKXw3Mnw4WzIzXSkpfDMoPzozWzI4XXw0KD86WzA0Njc5XXwzWzc4XXw1KD86NFs0Nl18OCl8OFsyMzc5XSl8NSg/OlsyNDY3XXwzWzIzN118OFsyM10pfDdbMS01NzhdfDgoPzpbMjQ2OV18M1syNzhdfDVbNTZdWzQ2XXw4NlszLTZdKSl8Mig/OjJbMjQtOV18M1sxLTU5XXw0Nyl8MzgoPzpbNThdWzc4XXw3WzM3OF0pfDMoPzo0WzM1XVs1Nl18NThbNDVdfDgoPzpbMzhdNXw1NHw3NikpWzQtNl1cIixcIjIoPzpbMjNdMDJ8Nig/OlsyNV18NCg/OjY0fFs3OF0pKXw5KD86WzAyMzU2XXw0KD86WzAyNjhdfDVbMi02XSl8NzJ8OFsyM10pKXwzKD86M1syOF18NCg/OlswNDY3OV18Myg/OjUoPzo0WzAtMjU2ODldfFs1Nl0pfFs3OF0pfDU4fDhbMjM3OV0pfDUoPzpbMjQ2N118M1syMzddfDgoPzpbMjNdfDQoPzpbNDVdfDYwKXw1KD86NFswLTM5XXw1fDY0KSkpfDdbMS01NzhdfDgoPzpbMjQ2OV18M1syNzhdfDU0KD86NHw1WzEzLTddfDZbODldKXw4NlszLTZdKSl8Mig/OjJbMjQtOV18M1sxLTU5XXw0Nyl8MzgoPzpbNThdWzc4XXw3WzM3OF0pfDMoPzo0NTR8ODVbNTZdKVs0Nl18Myg/OjQoPzozNnw1WzU2XSl8OCg/OlszOF01fDc2KSlbNC02XVwiXSxcIjAkMVwiLDFdLFtcIihcXFxcZHsyfSkoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEgJDItJDNcIixbXCIxXCJdLFwiMCQxXCIsMV0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMS0kMi0kM1wiLFtcIls2OF1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMi0kM1wiLFtcIlsyM11cIl0sXCIwJDFcIiwxXSxbXCIoXFxcXGQpKFxcXFxkezR9KShcXFxcZHsyfSkoXFxcXGR7NH0pXCIsXCIkMiAxNS0kMy0kNFwiLFtcIjkoPzoyWzItNDY5XXwzWzMtNTc4XSlcIixcIjkoPzoyKD86MlswMjQtOV18M1swLTU5XXw0N3w2WzI0NV18OVswMi04XSl8Myg/OjNbMjhdfDRbMDMtOV18NVsyLTQ2LThdfDdbMS01NzhdfDhbMi05XSkpXCIsXCI5KD86Mig/OlsyM10wMnw2KD86WzI1XXw0WzYtOF0pfDkoPzpbMDIzNTZdfDRbMDI1NjhdfDcyfDhbMjNdKSl8Myg/OjNbMjhdfDQoPzpbMDQ2NzldfDNbNS04XXw1WzQtNjhdfDhbMjM3OV0pfDUoPzpbMjQ2N118M1syMzddfDhbMi01XSl8N1sxLTU3OF18OCg/OlsyNDY5XXwzWzI1NzhdfDVbNC04XXw3WzM2LThdfDhbNS04XSkpKXw5Mig/OjJbMjQtOV18M1sxLTU5XXw0NylcIixcIjkoPzoyKD86WzIzXTAyfDYoPzpbMjVdfDQoPzo2NHxbNzhdKSl8OSg/OlswMjM1Nl18NCg/OlswMjY4XXw1WzItNl0pfDcyfDhbMjNdKSl8Myg/OjNbMjhdfDQoPzpbMDQ2NzldfDNbNzhdfDUoPzo0WzQ2XXw4KXw4WzIzNzldKXw1KD86WzI0NjddfDNbMjM3XXw4WzIzXSl8N1sxLTU3OF18OCg/OlsyNDY5XXwzWzI3OF18NSg/Ols1Nl1bNDZdfFs3OF0pfDdbMzc4XXw4KD86NlszLTZdfFs3OF0pKSkpfDkyKD86MlsyNC05XXwzWzEtNTldfDQ3KXw5Myg/OjRbMzVdWzU2XXw1OFs0NV18OCg/OlszOF01fDU0fDc2KSlbNC02XVwiLFwiOSg/OjIoPzpbMjNdMDJ8Nig/OlsyNV18NCg/OjY0fFs3OF0pKXw5KD86WzAyMzU2XXw0KD86WzAyNjhdfDVbMi02XSl8NzJ8OFsyM10pKXwzKD86M1syOF18NCg/OlswNDY3OV18Myg/OjUoPzo0WzAtMjU2ODldfFs1Nl0pfFs3OF0pfDUoPzo0WzQ2XXw4KXw4WzIzNzldKXw1KD86WzI0NjddfDNbMjM3XXw4KD86WzIzXXw0KD86WzQ1XXw2MCl8NSg/OjRbMC0zOV18NXw2NCkpKXw3WzEtNTc4XXw4KD86WzI0NjldfDNbMjc4XXw1KD86NCg/OjR8NVsxMy03XXw2Wzg5XSl8WzU2XVs0Nl18Wzc4XSl8N1szNzhdfDgoPzo2WzMtNl18Wzc4XSkpKSl8OTIoPzoyWzI0LTldfDNbMS01OV18NDcpfDkzKD86NCg/OjM2fDVbNTZdKXw4KD86WzM4XTV8NzYpKVs0LTZdXCJdLFwiMCQxXCIsMCxcIiQxICQyICQzLSQ0XCJdLFtcIihcXFxcZCkoXFxcXGR7Mn0pKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQyIDE1LSQzLSQ0XCIsW1wiOTFcIl0sXCIwJDFcIiwwLFwiJDEgJDIgJDMtJDRcIl0sW1wiKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDIgMTUtJDMtJDRcIixbXCI5XCJdLFwiMCQxXCIsMCxcIiQxICQyICQzLSQ0XCJdXSxcIjBcIiwwLFwiMD8oPzooMTF8Mig/OjIoPzowMj98WzEzXXwyWzEzLTc5XXw0WzEtNl18NVsyNDU3XXw2WzEyNC04XXw3WzEtNF18OFsxMy02XXw5WzEyNjddKXwzKD86MDI/fDFbNDY3XXwyWzAzLTZdfDNbMTMtOF18WzQ5XVsyLTZdfDVbMi04XXxbNjddKXw0KD86N1szLTU3OF18OSl8Nig/OlswMTM2XXwyWzI0LTZdfDRbNi04XT98NVsxNS04XSl8ODB8OSg/OjBbMS0zXXxbMTldfDJcXFxcZHwzWzEtNl18NFswMjU2OF0/fDVbMi00XXw2WzItNDZdfDcyP3w4WzIzXT8pKXwzKD86Myg/OjJbNzldfDZ8OFsyNTc4XSl8NCg/OjBbMC0yNC05XXxbMTJdfDNbNS04XT98NFsyNC03XXw1WzQtNjhdP3w2WzAyLTldfDdbMTI2XXw4WzIzNzldP3w5WzEtMzYtOF0pfDUoPzoxfDJbMTI0NV18M1syMzddP3w0WzEtNDYtOV18NlsyLTRdfDdbMS02XXw4WzItNV0/KXw2WzI0XXw3KD86WzA2OV18MVsxNTY4XXwyWzE1XXwzWzE0NV18NFsxM118NVsxNC04XXw3WzItNTddfDhbMTI2XSl8OCg/OlswMV18MlsxNS03XXwzWzI1NzhdP3w0WzEzLTZdfDVbNC04XT98NlsxLTM1Ny05XXw3WzM2LThdP3w4WzUtOF0/fDlbMTI0XSkpKTE1KT9cIixcIjkkMVwiXSxcIkFTXCI6W1wiMVwiLFwiMDExXCIsXCIoPzpbNThdXFxcXGRcXFxcZHw2ODR8OTAwKVxcXFxkezd9XCIsWzEwXSwwLFwiMVwiLDAsXCIxfChbMjY3XVxcXFxkezZ9KSRcIixcIjY4NCQxXCIsMCxcIjY4NFwiXSxcIkFUXCI6W1wiNDNcIixcIjAwXCIsXCIxXFxcXGR7MywxMn18MlxcXFxkezYsMTJ9fDQzKD86KD86MFxcXFxkfDVbMDItOV0pXFxcXGR7Myw5fXwyXFxcXGR7NCw1fXxbMzQ2N11cXFxcZHs0fXw4XFxcXGR7NCw2fXw5XFxcXGR7NCw3fSl8NVxcXFxkezQsMTJ9fDhcXFxcZHs3LDEyfXw5XFxcXGR7OCwxMn18KD86WzM2N11cXFxcZHw0WzAtMjQtOV0pXFxcXGR7NCwxMX1cIixbNCw1LDYsNyw4LDksMTAsMTEsMTIsMTNdLFtbXCIoXFxcXGQpKFxcXFxkezMsMTJ9KVwiLFwiJDEgJDJcIixbXCIxKD86MTF8WzItOV0pXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMlwiLFtcIjUxN1wiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezMsNX0pXCIsXCIkMSAkMlwiLFtcIjVbMDc5XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezMsMTB9KVwiLFwiJDEgJDJcIixbXCIoPzozMXw0KTZ8NTF8Nig/OjVbMC0zNTc5XXxbNi05XSl8Nyg/OjIwfDMyfDgpfFs4OV1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezR9KShcXFxcZHszLDl9KVwiLFwiJDEgJDJcIixbXCJbMi00NjddfDVbMi02XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHszLDR9KVwiLFwiJDEgJDIgJDNcIixbXCI1XCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7NH0pKFxcXFxkezQsN30pXCIsXCIkMSAkMiAkM1wiLFtcIjVcIl0sXCIwJDFcIl1dLFwiMFwiXSxcIkFVXCI6W1wiNjFcIixcIjAwMVsxNC02ODldfDE0KD86MVsxNF18MzR8NFsxN118WzU2XTZ8N1s0N118ODgpMDAxMVwiLFwiMSg/OlswLTc5XVxcXFxkezcsOH18OFswLTI0LTldXFxcXGR7N30pfCg/OlsyLTQ3OF1cXFxcZFxcXFxkfDU1MClcXFxcZHs2fXwxXFxcXGR7NCw3fVwiLFs1LDYsNyw4LDksMTBdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezMsNH0pXCIsXCIkMSAkMlwiLFtcIjE2XCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezIsNH0pXCIsXCIkMSAkMiAkM1wiLFtcIjE2XCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCIxNHxbNDVdXCJdLFwiMCQxXCJdLFtcIihcXFxcZCkoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCJbMjM3OF1cIl0sXCIoMCQxKVwiXSxbXCIoXFxcXGR7NH0pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiMSg/OjMwfFs4OV0pXCJdXV0sXCIwXCIsMCxcIjB8KDE4M1sxMl0pXCIsMCwwLDAsW1tcIig/OlsyMzddXFxcXGR7NX18OCg/OjUxKD86MCg/OjBbMDMtOV18WzEyNDddXFxcXGR8M1syLTldfDVbMC04XXw2WzEtOV18OFswLTZdKXwxKD86MVs2OV18WzIzXVxcXFxkfDRbMC00XSkpfCg/Ols2LThdXFxcXGR7M318OSg/OlswMi05XVxcXFxkXFxcXGR8MSg/OlswLTU3LTldXFxcXGR8NlswMTM1LTldKSkpXFxcXGQpKVxcXFxkezN9XCIsWzldXSxbXCI0KD86ODNbMC0zOF18OTNbMDFdKVxcXFxkezV9fDQoPzpbMC0zXVxcXFxkfDRbMDQ3LTldfDVbMC0yNS05XXw2WzA2LTldfDdbMDItOV18OFswLTI0NTctOV18OVswLTI3LTldKVxcXFxkezZ9XCIsWzldXSxbXCIxODAoPzowXFxcXGR7M318MilcXFxcZHszfVwiLFs3LDEwXV0sW1wiMTkwWzAtMjZdXFxcXGR7Nn1cIixbMTBdXSwwLDAsMCxbXCIxNlxcXFxkezMsN31cIixbNSw2LDcsOCw5XV0sW1wiKD86MTQoPzo1KD86MVswNDU4XXxbMjNdWzQ1OF0pfDcxXFxcXGQpfDU1MFxcXFxkXFxcXGQpXFxcXGR7NH1cIixbOV1dLFtcIjEzKD86MDBcXFxcZHszfXw0NVswLTRdKVxcXFxkezN9fDEzXFxcXGR7NH1cIixbNiw4LDEwXV1dLFwiMDAxMVwiXSxcIkFXXCI6W1wiMjk3XCIsXCIwMFwiLFwiKD86WzI1LTc5XVxcXFxkXFxcXGR8ODAwKVxcXFxkezR9XCIsWzddLFtbXCIoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCJbMjUtOV1cIl1dXV0sXCJBWFwiOltcIjM1OFwiLFwiMDB8OTkoPzpbMDE0NjldfDUoPzpbMTRdMXwzWzIzXXw1WzU5XXw3N3w4OHw5WzA5XSkpXCIsXCIyXFxcXGR7NCw5fXwzNVxcXFxkezQsNX18KD86NjBcXFxcZFxcXFxkfDgwMClcXFxcZHs0LDZ9fDdcXFxcZHs1LDExfXwoPzpbMTRdXFxcXGR8M1swLTQ2LTldfDUwKVxcXFxkezQsOH1cIixbNSw2LDcsOCw5LDEwLDExLDEyXSwwLFwiMFwiLDAsMCwwLDAsXCIxOFwiLDAsXCIwMFwiXSxcIkFaXCI6W1wiOTk0XCIsXCIwMFwiLFwiMzY1XFxcXGR7Nn18KD86WzEyNDU3OV1cXFxcZHw2MHw4OClcXFxcZHs3fVwiLFs5XSxbW1wiKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCI5MFwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIjFbMjhdfDJ8MzY1fDQ2XCIsXCIxWzI4XXwyfDM2NXw0NlwiLFwiMVsyOF18MnwzNjUoPzpbMC00Ni05XXw1WzAtMzUtOV0pfDQ2XCJdLFwiKDAkMSlcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCJbMTMtOV1cIl0sXCIwJDFcIl1dLFwiMFwiXSxcIkJBXCI6W1wiMzg3XCIsXCIwMFwiLFwiNlxcXFxkezh9fCg/OlszNTY4OV1cXFxcZHw0OXw3MClcXFxcZHs2fVwiLFs4LDldLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiNlsxLTNdfFs3LTldXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDItJDNcIixbXCJbMy01XXw2WzU2XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIjZcIl0sXCIwJDFcIl1dLFwiMFwiXSxcIkJCXCI6W1wiMVwiLFwiMDExXCIsXCIoPzoyNDZ8WzU4XVxcXFxkXFxcXGR8OTAwKVxcXFxkezd9XCIsWzEwXSwwLFwiMVwiLDAsXCIxfChbMi05XVxcXFxkezZ9KSRcIixcIjI0NiQxXCIsMCxcIjI0NlwiXSxcIkJEXCI6W1wiODgwXCIsXCIwMFwiLFwiMVxcXFxkezl9fDJcXFxcZHs3LDh9fDg4XFxcXGR7NCw2fXwoPzo4WzAtNzldfDlcXFxcZClcXFxcZHs0LDh9fCg/OlszNDZdXFxcXGR8WzU3XSlcXFxcZHs1LDh9XCIsWzYsNyw4LDksMTBdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezQsNn0pXCIsXCIkMS0kMlwiLFtcIjMxWzUtOF18WzQ1OV0xXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7Myw3fSlcIixcIiQxLSQyXCIsW1wiMyg/Ols2N118OFswMTMtOV0pfDQoPzo2WzE2OF18N3xbODldWzE4XSl8NSg/OjZbMTI4XXw5KXw2KD86Mjh8NFsxNF18NSl8N1syLTU4OV18OCg/OjBbMDE0LTldfFsxMl0pfDlbMzU4XXwoPzozWzItNV18NFsyMzVdfDVbMi01NzhdfDZbMDM4OV18NzZ8OFszLTddfDlbMjRdKTF8KD86NDR8NjYpWzAxMzQ2LTldXCJdLFwiMCQxXCJdLFtcIihcXFxcZHs0fSkoXFxcXGR7Myw2fSlcIixcIiQxLSQyXCIsW1wiWzEzLTldXCJdLFwiMCQxXCJdLFtcIihcXFxcZCkoXFxcXGR7Nyw4fSlcIixcIiQxLSQyXCIsW1wiMlwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiQkVcIjpbXCIzMlwiLFwiMDBcIixcIjRcXFxcZHs4fXxbMS05XVxcXFxkezd9XCIsWzgsOV0sW1tcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCIoPzo4MHw5KTBcIl0sXCIwJDFcIl0sW1wiKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCJbMjM5XXw0WzIzXVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIlsxNS04XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIjRcIl0sXCIwJDFcIl1dLFwiMFwiXSxcIkJGXCI6W1wiMjI2XCIsXCIwMFwiLFwiWzAyNS03XVxcXFxkezd9XCIsWzhdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIlswMjUtN11cIl1dXV0sXCJCR1wiOltcIjM1OVwiLFwiMDBcIixcIlsyLTddXFxcXGR7Niw3fXxbODldXFxcXGR7Niw4fXwyXFxcXGR7NX1cIixbNiw3LDgsOV0sW1tcIihcXFxcZCkoXFxcXGQpKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiMlwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCI0M1sxLTZdfDcwWzEtOV1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7Myw0fSlcIixcIiQxICQyICQzXCIsW1wiMlwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHsyLDN9KVwiLFwiJDEgJDIgJDNcIixbXCJbMzU2XXw0WzEyNC03XXw3WzEtOV18OFsxLTZdfDlbMS03XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiKD86NzB8OCkwXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDNcIixbXCI0M1sxLTddfDdcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Myw0fSlcIixcIiQxICQyICQzXCIsW1wiWzQ4XXw5WzA4XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiOVwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiQkhcIjpbXCI5NzNcIixcIjAwXCIsXCJbMTM2LTldXFxcXGR7N31cIixbOF0sW1tcIihcXFxcZHs0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIlsxMzY3OV18OFswNDddXCJdXV1dLFwiQklcIjpbXCIyNTdcIixcIjAwXCIsXCIoPzpbMjY3XVxcXFxkfDMxKVxcXFxkezZ9XCIsWzhdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIlsyMzY3XVwiXV1dXSxcIkJKXCI6W1wiMjI5XCIsXCIwMFwiLFwiKD86WzI2ODldXFxcXGR8NTEpXFxcXGR7Nn1cIixbOF0sW1tcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzI1Njg5XVwiXV1dXSxcIkJMXCI6W1wiNTkwXCIsXCIwMFwiLFwiKD86NTkwfDY5XFxcXGR8OTc2KVxcXFxkezZ9XCIsWzldLDAsXCIwXCIsMCwwLDAsMCwwLFtbXCI1OTAoPzoyWzctOV18NVsxMl18ODcpXFxcXGR7NH1cIl0sW1wiNjkoPzowXFxcXGRcXFxcZHwxKD86MlsyOV18M1swLTVdKSlcXFxcZHs0fVwiXSwwLDAsMCwwLDAsMCxbXCI5NzZbMDFdXFxcXGR7NX1cIl1dXSxcIkJNXCI6W1wiMVwiLFwiMDExXCIsXCIoPzo0NDF8WzU4XVxcXFxkXFxcXGR8OTAwKVxcXFxkezd9XCIsWzEwXSwwLFwiMVwiLDAsXCIxfChbMi04XVxcXFxkezZ9KSRcIixcIjQ0MSQxXCIsMCxcIjQ0MVwiXSxcIkJOXCI6W1wiNjczXCIsXCIwMFwiLFwiWzItNTc4XVxcXFxkezZ9XCIsWzddLFtbXCIoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCJbMi01NzhdXCJdXV1dLFwiQk9cIjpbXCI1OTFcIixcIjAwKD86MVxcXFxkKT9cIixcIig/OlsyLTQ2N11cXFxcZFxcXFxkfDgwMDEpXFxcXGR7NX1cIixbOCw5XSxbW1wiKFxcXFxkKShcXFxcZHs3fSlcIixcIiQxICQyXCIsW1wiWzIzXXw0WzQ2XVwiXV0sW1wiKFxcXFxkezh9KVwiLFwiJDFcIixbXCJbNjddXCJdXSxbXCIoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiOFwiXV1dLFwiMFwiLDAsXCIwKDFcXFxcZCk/XCJdLFwiQlFcIjpbXCI1OTlcIixcIjAwXCIsXCIoPzpbMzRdMXw3XFxcXGQpXFxcXGR7NX1cIixbN10sMCwwLDAsMCwwLDAsXCJbMzQ3XVwiXSxcIkJSXCI6W1wiNTVcIixcIjAwKD86MVsyNDVdfDJbMS0zNV18MzF8NFsxM118WzU2XTV8OTkpXCIsXCIoPzpbMS00Ni05XVxcXFxkXFxcXGR8NSg/OlswLTQ2LTldXFxcXGR8NVswLTI0Njc5XSkpXFxcXGR7OH18WzEtOV1cXFxcZHs5fXxbMzU4OV1cXFxcZHs4fXxbMzRdXFxcXGR7N31cIixbOCw5LDEwLDExXSxbW1wiKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxLSQyXCIsW1wiMzAwfDQoPzowWzAyXXwzNylcIixcIjQoPzowMnwzNykwfFszNF0wMFwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHsyLDN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiKD86WzM1OF18OTApMFwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyLSQzXCIsW1wiKD86WzE0Njg5XVsxLTldfDJbMTI0NzhdfDNbMS01NzhdfDVbMTMtNV18N1sxMy01NzldKVsyLTU3XVwiXSxcIigkMSlcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHs1fSkoXFxcXGR7NH0pXCIsXCIkMSAkMi0kM1wiLFtcIlsxNl1bMS05XXxbMi01Ny05XVwiXSxcIigkMSlcIl1dLFwiMFwiLDAsXCIwKD86KDFbMjQ1XXwyWzEtMzVdfDMxfDRbMTNdfFs1Nl01fDk5KShcXFxcZHsxMCwxMX0pKT9cIixcIiQyXCJdLFwiQlNcIjpbXCIxXCIsXCIwMTFcIixcIig/OjI0MnxbNThdXFxcXGRcXFxcZHw5MDApXFxcXGR7N31cIixbMTBdLDAsXCIxXCIsMCxcIjF8KFszLThdXFxcXGR7Nn0pJFwiLFwiMjQyJDFcIiwwLFwiMjQyXCJdLFwiQlRcIjpbXCI5NzVcIixcIjAwXCIsXCJbMTddXFxcXGR7N318WzItOF1cXFxcZHs2fVwiLFs3LDhdLFtbXCIoXFxcXGQpKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiWzItNjhdfDdbMjQ2XVwiXV0sW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCIxWzY3XXw3XCJdXV1dLFwiQldcIjpbXCIyNjdcIixcIjAwXCIsXCI5MFxcXFxkezV9fCg/OlsyLTZdfDdcXFxcZClcXFxcZHs2fVwiLFs3LDhdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezV9KVwiLFwiJDEgJDJcIixbXCI5MFwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiWzItNl1cIl1dLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCI3XCJdXV1dLFwiQllcIjpbXCIzNzVcIixcIjgxMFwiLFwiKD86WzEyXVxcXFxkfDMzfDQ0fDkwMilcXFxcZHs3fXw4KD86MFswLTc5XVxcXFxkezUsN318WzEtN11cXFxcZHs5fSl8OCg/OjFbMC00ODldfFs1LTc5XVxcXFxkKVxcXFxkezd9fDhbMS03OV1cXFxcZHs2LDd9fDhbMC03OV1cXFxcZHs1fXw4XFxcXGR7NX1cIixbNiw3LDgsOSwxMCwxMV0sW1tcIihcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMlwiLFtcIjgwMFwiXSxcIjggJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7Miw0fSlcIixcIiQxICQyICQzXCIsW1wiODAwXCJdLFwiOCAkMVwiXSxbXCIoXFxcXGR7NH0pKFxcXFxkezJ9KShcXFxcZHszfSlcIixcIiQxICQyLSQzXCIsW1wiMSg/OjVbMTY5XXw2WzMtNV18N1sxNzldKXwyKD86MVszNV18MlszNF18M1szLTVdKVwiLFwiMSg/OjVbMTY5XXw2KD86M1sxLTNdfDR8NVsxMjVdKXw3KD86MVszLTldfDdbMC0yNC02XXw5WzItN10pKXwyKD86MVszNV18MlszNF18M1szLTVdKVwiXSxcIjggMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyLSQzLSQ0XCIsW1wiMSg/Ols1Nl18N1s0NjddKXwyWzEtM11cIl0sXCI4IDAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMi0kMy0kNFwiLFtcIlsxLTRdXCJdLFwiOCAwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHszLDR9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiWzg5XVwiXSxcIjggJDFcIl1dLFwiOFwiLDAsXCIwfDgwP1wiLDAsMCwwLDAsXCI4fjEwXCJdLFwiQlpcIjpbXCI1MDFcIixcIjAwXCIsXCIoPzowODAwXFxcXGR8WzItOF0pXFxcXGR7Nn1cIixbNywxMV0sW1tcIihcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMS0kMlwiLFtcIlsyLThdXCJdXSxbXCIoXFxcXGQpKFxcXFxkezN9KShcXFxcZHs0fSkoXFxcXGR7M30pXCIsXCIkMS0kMi0kMy0kNFwiLFtcIjBcIl1dXV0sXCJDQVwiOltcIjFcIixcIjAxMVwiLFwiKD86WzItOF1cXFxcZHw5MClcXFxcZHs4fVwiLFsxMF0sMCxcIjFcIiwwLDAsMCwwLDAsW1tcIig/OjIoPzowNHxbMjNdNnxbNDhdOXw1MCl8Myg/OjA2fDQzfDZbNTddKXw0KD86MDN8MVs2OF18M1sxNzhdfDUwKXw1KD86MDZ8MVs0OV18NDh8Nzl8OFsxN10pfDYoPzowNHwxM3wzOXw0N3w3Mil8Nyg/OjBbNTldfDc4fDhbMDJdKXw4KD86WzA2XTd8MTl8MjV8NzMpfDkwWzI1XSlbMi05XVxcXFxkezZ9XCJdLFtcIlwiXSxbXCI4KD86MDB8MzN8NDR8NTV8NjZ8Nzd8ODgpWzItOV1cXFxcZHs2fVwiXSxbXCI5MDBbMi05XVxcXFxkezZ9XCJdLFtcIjUyKD86MzUoPzpbMDItNDYtOV1cXFxcZHwxWzAyLTldfDVbMC00Ni05XSl8NDUoPzpbMDM0XVxcXFxkfDFbMDItOV18MlswMjQtOV18NVswLTQ2LTldKSlcXFxcZHs0fXw1Mig/OjNbMi00Ni05XXw0WzItNF0pKD86WzAyLTldXFxcXGR8MVswMi05XSlcXFxcZHs0fXwoPzo1KD86MDB8MlsxMl18MzN8NDR8NjZ8Nzd8ODgpfDYyMilbMi05XVxcXFxkezZ9XCJdLDAsMCwwLFtcIjYwMFsyLTldXFxcXGR7Nn1cIl1dXSxcIkNDXCI6W1wiNjFcIixcIjAwMVsxNC02ODldfDE0KD86MVsxNF18MzR8NFsxN118WzU2XTZ8N1s0N118ODgpMDAxMVwiLFwiMSg/OlswLTc5XVxcXFxkfDhbMC0yNC05XSlcXFxcZHs3fXwoPzpbMTQ4XVxcXFxkXFxcXGR8NTUwKVxcXFxkezZ9fDFcXFxcZHs1LDd9XCIsWzYsNyw4LDksMTBdLDAsXCIwXCIsMCxcIjB8KFs1OV1cXFxcZHs3fSkkXCIsXCI4JDFcIiwwLDAsW1tcIjgoPzo1MSg/OjAoPzowMnwzMXw2MCl8MTE4KXw5MSg/OjAoPzoxWzAtMl18MjkpfDEoPzpbMjhdMnw1MHw3OSl8Mig/OjEwfDY0KXwzKD86WzA2XTh8MjIpfDRbMjldOHw2MlxcXFxkfDcwWzIzXXw5NTkpKVxcXFxkezN9XCIsWzldXSxbXCI0KD86ODNbMC0zOF18OTNbMDFdKVxcXFxkezV9fDQoPzpbMC0zXVxcXFxkfDRbMDQ3LTldfDVbMC0yNS05XXw2WzA2LTldfDdbMDItOV18OFswLTI0NTctOV18OVswLTI3LTldKVxcXFxkezZ9XCIsWzldXSxbXCIxODAoPzowXFxcXGR7M318MilcXFxcZHszfVwiLFs3LDEwXV0sW1wiMTkwWzAtMjZdXFxcXGR7Nn1cIixbMTBdXSwwLDAsMCwwLFtcIig/OjE0KD86NSg/OjFbMDQ1OF18WzIzXVs0NThdKXw3MVxcXFxkKXw1NTBcXFxcZFxcXFxkKVxcXFxkezR9XCIsWzldXSxbXCIxMyg/OjAwXFxcXGR7M318NDVbMC00XSlcXFxcZHszfXwxM1xcXFxkezR9XCIsWzYsOCwxMF1dXSxcIjAwMTFcIl0sXCJDRFwiOltcIjI0M1wiLFwiMDBcIixcIlsxODldXFxcXGR7OH18WzEtNjhdXFxcXGR7Nn1cIixbNyw5XSxbW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIjg4XCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7NX0pXCIsXCIkMSAkMlwiLFtcIlsxLTZdXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCIxXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCJbODldXCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJDRlwiOltcIjIzNlwiLFwiMDBcIixcIig/OlsyN11cXFxcZHszfXw4Nzc2KVxcXFxkezR9XCIsWzhdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIlsyNzhdXCJdXV1dLFwiQ0dcIjpbXCIyNDJcIixcIjAwXCIsXCIyMjJcXFxcZHs2fXwoPzowXFxcXGR8ODApXFxcXGR7N31cIixbOV0sW1tcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiODAxXCJdXSxbXCIoXFxcXGQpKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiOFwiXV0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIlswMl1cIl1dXV0sXCJDSFwiOltcIjQxXCIsXCIwMFwiLFwiOFxcXFxkezExfXxbMi05XVxcXFxkezh9XCIsWzldLFtbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiOFswNDddfDkwXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzItNzldfDgxXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNCAkNVwiLFtcIjhcIl0sXCIwJDFcIl1dLFwiMFwiXSxcIkNJXCI6W1wiMjI1XCIsXCIwMFwiLFwiWzAyLTldXFxcXGR7N31cIixbOF0sW1tcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzAyLTldXCJdXV1dLFwiQ0tcIjpbXCI2ODJcIixcIjAwXCIsXCJbMi01NzhdXFxcXGR7NH1cIixbNV0sW1tcIihcXFxcZHsyfSkoXFxcXGR7M30pXCIsXCIkMSAkMlwiLFtcIlsyLTU3OF1cIl1dXV0sXCJDTFwiOltcIjU2XCIsXCIoPzowfDEoPzoxWzAtNjldfDJbMDItNV18NVsxMy01OF18Njl8N1swMTY3XXw4WzAxOF0pKTBcIixcIjEyMzAwXFxcXGR7Nn18NlxcXFxkezksMTB9fFsyLTldXFxcXGR7OH1cIixbOSwxMCwxMV0sW1tcIihcXFxcZHs1fSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIjIxOVwiLFwiMjE5NlwiXSxcIigkMSlcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjQ0XCJdXSxbXCIoXFxcXGQpKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiMlsxLTNdXCJdLFwiKCQxKVwiXSxbXCIoXFxcXGQpKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiOVsyLTldXCJdXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiM1syLTVdfFs0N118NVsxLTM1NzhdfDZbMTMtNTddfDgoPzowWzEtOV18WzEtOV0pXCJdLFwiKCQxKVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszLDR9KVwiLFwiJDEgJDIgJDNcIixbXCI2MHw4XCJdXSxbXCIoXFxcXGR7NH0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiMVwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCI2MFwiXV1dXSxcIkNNXCI6W1wiMjM3XCIsXCIwMFwiLFwiKD86WzI2XVxcXFxkXFxcXGR8ODgpXFxcXGR7Nn1cIixbOCw5XSxbW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCI4OFwiXV0sW1wiKFxcXFxkKShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0ICQ1XCIsW1wiWzI2XVwiXV1dXSxcIkNOXCI6W1wiODZcIixcIjAwfDEoPzpbMTJdXFxcXGR8NzkpXFxcXGRcXFxcZDAwXCIsXCIxWzEyN11cXFxcZHs4LDl9fDJcXFxcZHs5fSg/OlxcXFxkezJ9KT98WzEyXVxcXFxkezYsN318ODZcXFxcZHs2fXwoPzoxWzAzLTY4OV1cXFxcZHw2KVxcXFxkezcsOX18KD86WzMtNTc5XVxcXFxkfDhbMC01Ny05XSlcXFxcZHs2LDl9XCIsWzcsOCw5LDEwLDExLDEyXSxbW1wiKFxcXFxkezJ9KShcXFxcZHs1LDZ9KVwiLFwiJDEgJDJcIixbXCIoPzoxMHwyWzAtNTctOV0pWzE5XVwiLFwiKD86MTB8MlswLTU3LTldKSg/OjEwfDlbNTZdKVwiLFwiKD86MTB8MlswLTU3LTldKSg/OjEwMHw5WzU2XSlcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHs1LDZ9KVwiLFwiJDEgJDJcIixbXCIzKD86WzE1N118MzV8NDl8OVsxLTY4XSl8NCg/OlsxN118MlsxNzldfDZbNDctOV18OFsyM10pfDUoPzpbMTM1N118MlszN118NFszNl18NlsxLTQ2XXw4MCl8Nig/OjNbMS01XXw2WzAyMzhdfDlbMTJdKXw3KD86MDF8WzE1NzldfDJbMjQ4XXwzWzAxNC05XXw0WzMtNl18NlswMjM2ODldKXw4KD86MVsyMzYtOF18Mls1LTddfFszN118OFszNi04XXw5WzEtOF0pfDkoPzowWzEtMzY4OV18MVsxLTc5XXxbMzc5XXw0WzEzXXw1WzEtNV0pfCg/OjRbMzVdfDU5fDg1KVsxLTldXCIsXCIoPzozKD86WzE1N11cXFxcZHwzNXw0OXw5WzEtNjhdKXw0KD86WzE3XVxcXFxkfDJbMTc5XXxbMzVdWzEtOV18Nls0Ny05XXw4WzIzXSl8NSg/OlsxMzU3XVxcXFxkfDJbMzddfDRbMzZdfDZbMS00Nl18ODB8OVsxLTldKXw2KD86M1sxLTVdfDZbMDIzOF18OVsxMl0pfDcoPzowMXxbMTU3OV1cXFxcZHwyWzI0OF18M1swMTQtOV18NFszLTZdfDZbMDIzNjg5XSl8OCg/OjFbMjM2LThdfDJbNS03XXxbMzddXFxcXGR8NVsxLTldfDhbMzYtOF18OVsxLThdKXw5KD86MFsxLTM2ODldfDFbMS03OV18WzM3OV1cXFxcZHw0WzEzXXw1WzEtNV0pKVsxOV1cIixcIjg1WzIzXSg/OjEwfDk1KXwoPzozKD86WzE1N11cXFxcZHwzNXw0OXw5WzEtNjhdKXw0KD86WzE3XVxcXFxkfDJbMTc5XXxbMzVdWzEtOV18Nls0Ny05XXw4WzIzXSl8NSg/OlsxMzU3XVxcXFxkfDJbMzddfDRbMzZdfDZbMS00Nl18ODB8OVsxLTldKXw2KD86M1sxLTVdfDZbMDIzOF18OVsxMl0pfDcoPzowMXxbMTU3OV1cXFxcZHwyWzI0OF18M1swMTQtOV18NFszLTZdfDZbMDIzNjg5XSl8OCg/OjFbMjM2LThdfDJbNS03XXxbMzddXFxcXGR8NVsxNC05XXw4WzM2LThdfDlbMS04XSl8OSg/OjBbMS0zNjg5XXwxWzEtNzldfFszNzldXFxcXGR8NFsxM118NVsxLTVdKSkoPzoxMHw5WzU2XSlcIixcIjg1WzIzXSg/OjEwMHw5NSl8KD86Myg/OlsxNTddXFxcXGR8MzV8NDl8OVsxLTY4XSl8NCg/OlsxN11cXFxcZHwyWzE3OV18WzM1XVsxLTldfDZbNDctOV18OFsyM10pfDUoPzpbMTM1N11cXFxcZHwyWzM3XXw0WzM2XXw2WzEtNDZdfDgwfDlbMS05XSl8Nig/OjNbMS01XXw2WzAyMzhdfDlbMTJdKXw3KD86MDF8WzE1NzldXFxcXGR8MlsyNDhdfDNbMDE0LTldfDRbMy02XXw2WzAyMzY4OV0pfDgoPzoxWzIzNi04XXwyWzUtN118WzM3XVxcXFxkfDVbMTQtOV18OFszNi04XXw5WzEtOF0pfDkoPzowWzEtMzY4OV18MVsxLTc5XXxbMzc5XVxcXFxkfDRbMTNdfDVbMS01XSkpKD86MTAwfDlbNTZdKVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiKD86NHw4MCkwXCJdXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiMTB8Mig/OlswMi01Ny05XXwxWzEtOV0pXCIsXCIxMHwyKD86WzAyLTU3LTldfDFbMS05XSlcIixcIjEwWzAtNzldfDIoPzpbMDItNTctOV18MVsxLTc5XSl8KD86MTB8MjEpOCg/OjBbMS05XXxbMS05XSlcIl0sXCIwJDFcIiwxXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiMyg/OlszLTU5XXw3WzAyLTY4XSl8NCg/OlsyNi04XXwzWzMtOV18NVsyLTldKXw1KD86M1swMy05XXxbNDY4XXw3WzAyOF18OVsyLTQ2LTldKXw2fDcoPzpbMC0yNDddfDNbMDQtOV18NVswLTQ2ODldfDZbMjM2OF0pfDgoPzpbMS0zNThdfDlbMS03XSl8OSg/OlswMTM0NzldfDVbMS01XSl8KD86WzM0XTF8NTV8Nzl8ODcpWzAyLTldXCJdLFwiMCQxXCIsMV0sW1wiKFxcXFxkezN9KShcXFxcZHs3LDh9KVwiLFwiJDEgJDJcIixbXCI5XCJdXSxbXCIoXFxcXGR7NH0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiODBcIl0sXCIwJDFcIiwxXSxbXCIoXFxcXGR7M30pKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiWzMtNTc4XVwiXSxcIjAkMVwiLDFdLFtcIihcXFxcZHszfSkoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCIxWzMtOV1cIl1dLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzEyXVwiXSxcIjAkMVwiLDFdXSxcIjBcIiwwLFwiMHwoMSg/OlsxMl1cXFxcZHw3OSlcXFxcZFxcXFxkKVwiLDAsMCwwLDAsXCIwMFwiXSxcIkNPXCI6W1wiNTdcIixcIjAwKD86NCg/OlsxNF00fDU2KXxbNTc5XSlcIixcIig/OjFcXFxcZHwzKVxcXFxkezl9fFsxMjQtOF1cXFxcZHs3fVwiLFs4LDEwLDExXSxbW1wiKFxcXFxkKShcXFxcZHs3fSlcIixcIiQxICQyXCIsW1wiWzE0XVsyLTldfFsyNS04XVwiXSxcIigkMSlcIl0sW1wiKFxcXFxkezN9KShcXFxcZHs3fSlcIixcIiQxICQyXCIsW1wiM1wiXV0sW1wiKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7N30pXCIsXCIkMS0kMi0kM1wiLFtcIjFcIl0sXCIwJDFcIiwwLFwiJDEgJDIgJDNcIl1dLFwiMFwiLDAsXCIwKFszNTc5XXw0KD86WzE0XTR8NTYpKT9cIl0sXCJDUlwiOltcIjUwNlwiLFwiMDBcIixcIig/OjhcXFxcZHw5MClcXFxcZHs4fXwoPzpbMjQtOF1cXFxcZHszfXwzMDA1KVxcXFxkezR9XCIsWzgsMTBdLFtbXCIoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCJbMi03XXw4WzMtOV1cIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEtJDItJDNcIixbXCJbODldXCJdXV0sMCwwLFwiKDE5KD86MFswLTI0NjhdfDFbMDldfDIwfDY2fDc3fDk5KSlcIl0sXCJDVVwiOltcIjUzXCIsXCIxMTlcIixcIlsyN11cXFxcZHs2LDd9fFszNF1cXFxcZHs1LDd9fCg/OjV8OFxcXFxkXFxcXGQpXFxcXGR7N31cIixbNiw3LDgsMTBdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezQsNn0pXCIsXCIkMSAkMlwiLFtcIjJbMS00XXxbMzRdXCJdLFwiKDAkMSlcIl0sW1wiKFxcXFxkKShcXFxcZHs2LDd9KVwiLFwiJDEgJDJcIixbXCI3XCJdLFwiKDAkMSlcIl0sW1wiKFxcXFxkKShcXFxcZHs3fSlcIixcIiQxICQyXCIsW1wiNVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezd9KVwiLFwiJDEgJDJcIixbXCI4XCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJDVlwiOltcIjIzOFwiLFwiMFwiLFwiKD86WzItNTldXFxcXGRcXFxcZHw4MDApXFxcXGR7NH1cIixbN10sW1tcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDNcIixbXCJbMi01ODldXCJdXV1dLFwiQ1dcIjpbXCI1OTlcIixcIjAwXCIsXCIoPzpbMzRdMXw2MHwoPzo3fDlcXFxcZClcXFxcZClcXFxcZHs1fVwiLFs3LDhdLFtbXCIoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCJbMzQ2N11cIl1dLFtcIihcXFxcZCkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCI5WzQtOF1cIl1dXSwwLDAsMCwwLDAsXCJbNjldXCJdLFwiQ1hcIjpbXCI2MVwiLFwiMDAxWzE0LTY4OV18MTQoPzoxWzE0XXwzNHw0WzE3XXxbNTZdNnw3WzQ3XXw4OCkwMDExXCIsXCIxKD86WzAtNzldXFxcXGR8OFswLTI0LTldKVxcXFxkezd9fCg/OlsxNDhdXFxcXGRcXFxcZHw1NTApXFxcXGR7Nn18MVxcXFxkezUsN31cIixbNiw3LDgsOSwxMF0sMCxcIjBcIiwwLFwiMHwoWzU5XVxcXFxkezd9KSRcIixcIjgkMVwiLDAsMCxbW1wiOCg/OjUxKD86MCg/OjAxfDMwfDU5KXwxMTcpfDkxKD86MDBbNi05XXwxKD86WzI4XTF8NDl8NzgpfDIoPzowOXw2Myl8Myg/OjEyfDI2fDc1KXw0KD86NTZ8OTcpfDY0XFxcXGR8Nyg/OjBbMDFdfDFbMC0yXSl8OTU4KSlcXFxcZHszfVwiLFs5XV0sW1wiNCg/OjgzWzAtMzhdfDkzWzAxXSlcXFxcZHs1fXw0KD86WzAtM11cXFxcZHw0WzA0Ny05XXw1WzAtMjUtOV18NlswNi05XXw3WzAyLTldfDhbMC0yNDU3LTldfDlbMC0yNy05XSlcXFxcZHs2fVwiLFs5XV0sW1wiMTgwKD86MFxcXFxkezN9fDIpXFxcXGR7M31cIixbNywxMF1dLFtcIjE5MFswLTI2XVxcXFxkezZ9XCIsWzEwXV0sMCwwLDAsMCxbXCIoPzoxNCg/OjUoPzoxWzA0NThdfFsyM11bNDU4XSl8NzFcXFxcZCl8NTUwXFxcXGRcXFxcZClcXFxcZHs0fVwiLFs5XV0sW1wiMTMoPzowMFxcXFxkezN9fDQ1WzAtNF0pXFxcXGR7M318MTNcXFxcZHs0fVwiLFs2LDgsMTBdXV0sXCIwMDExXCJdLFwiQ1lcIjpbXCIzNTdcIixcIjAwXCIsXCIoPzpbMjc5XVxcXFxkfFs1OF0wKVxcXFxkezZ9XCIsWzhdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezZ9KVwiLFwiJDEgJDJcIixbXCJbMjU3LTldXCJdXV1dLFwiQ1pcIjpbXCI0MjBcIixcIjAwXCIsXCIoPzpbMi01NzhdXFxcXGR8NjApXFxcXGR7N318OVxcXFxkezgsMTF9XCIsWzldLFtbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiWzItOF18OVswMTUtN11cIl1dLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzICQ0XCIsW1wiOVwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCI5XCJdXV1dLFwiREVcIjpbXCI0OVwiLFwiMDBcIixcIlsyNTc5XVxcXFxkezUsMTR9fDQ5KD86WzA1XVxcXFxkezEwfXxbNDZdWzEtOF1cXFxcZHs0LDl9KXw0OSg/OlswLTI1XVxcXFxkfDNbMS02ODldfDdbMS03XSlcXFxcZHs0LDh9fDQ5KD86WzAtMjU3OV1cXFxcZHxbMzRdWzEtOV18NlswLThdKVxcXFxkezN9fDQ5XFxcXGR7Myw0fXwoPzoxfFszNjhdXFxcXGR8NFswLThdKVxcXFxkezMsMTN9XCIsWzQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1XSxbW1wiKFxcXFxkezJ9KShcXFxcZHszLDEzfSlcIixcIiQxICQyXCIsW1wiM1swMl18NDB8WzY4XTlcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHszLDEyfSlcIixcIiQxICQyXCIsW1wiMig/OjBbMS0zODldfDFbMTI0XXwyWzE4XXwzWzE0XSl8Myg/OlszNS05XVsxNV18NFswMTVdKXw5MDZ8KD86Mls0LTldfDRbMi05XXxbNTc5XVsxLTldfFs2OF1bMS04XSkxXCIsXCIyKD86MFsxLTM4OV18MTJbMC04XSl8Myg/OlszNS05XVsxNV18NFswMTVdKXw5MDZ8Mig/OlsxM11bMTRdfDJbMThdKXwoPzoyWzQtOV18NFsyLTldfFs1NzldWzEtOV18WzY4XVsxLThdKTFcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezR9KShcXFxcZHsyLDExfSlcIixcIiQxICQyXCIsW1wiWzI0LTZdfDMoPzpbMzU2OV1bMDItNDYtOV18NFsyLTQ2NzldfDdbMi00NjddfDhbMi00Ni04XSl8NzBbMi04XXw4KD86MFsyLTldfFsxLThdKXw5MFs3LTldfFs3OV1bMS05XVwiLFwiWzI0LTZdfDMoPzozKD86MFsxLTQ2N118MlsxMjctOV18M1sxMjQ1NzhdfDdbMTI1Ny05XXw4WzEyNTZdfDlbMTQ1XSl8NCg/OjJbMTM1XXw0WzEzNTc4XXw5WzEzNDZdKXw1KD86MFsxNF18MlsxLTM1ODldfDZbMS00XXw3WzEzNDY4XXw4WzEzNTY4XSl8Nig/OjJbMS00ODldfDNbMTI0LTZdfDZbMTNdfDdbMTI1NzldfDhbMS0zNTZdfDlbMTM1XSl8Nyg/OjJbMS03XXw0WzE0NV18NlsxLTVdfDdbMS00XSl8OCg/OjIxfDNbMTQ2OF18Nnw3WzE0NjddfDhbMTM2XSl8OSg/OjBbMTI0NzldfDJbMTM1OF18NFsxMzQ2NzldfDZbMS05XXw3WzEzNl18OFsxNDddfDlbMTQ2OF0pKXw3MFsyLThdfDgoPzowWzItOV18WzEtOF0pfDkwWzctOV18Wzc5XVsxLTldfDNbNjhdNFsxMzQ3XXwzKD86NDd8NjApWzEzNTZdfDMoPzozWzQ2XXw0Nnw1WzQ5XSlbMTI0Nl18M1s0NTc5XTNbMTM1N11cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiMTM4XCJdLFwiMCQxXCJdLFtcIihcXFxcZHs1fSkoXFxcXGR7MiwxMH0pXCIsXCIkMSAkMlwiLFtcIjNcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHs1LDExfSlcIixcIiQxICQyXCIsW1wiMTgxXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGQpKFxcXFxkezQsMTB9KVwiLFwiJDEgJDIgJDNcIixbXCIxKD86M3w4MCl8OVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezcsOH0pXCIsXCIkMSAkMlwiLFtcIjFbNjddXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7NywxMn0pXCIsXCIkMSAkMlwiLFtcIjhcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezV9KShcXFxcZHs2fSlcIixcIiQxICQyXCIsW1wiMTg1XCIsXCIxODUwXCIsXCIxODUwMFwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiN1wiXSxcIjAkMVwiXSxbXCIoXFxcXGR7NH0pKFxcXFxkezd9KVwiLFwiJDEgJDJcIixbXCIxOFs2OF1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezV9KShcXFxcZHs2fSlcIixcIiQxICQyXCIsW1wiMTVbMDU2OF1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezR9KShcXFxcZHs3fSlcIixcIiQxICQyXCIsW1wiMTVbMTI3OV1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHs4fSlcIixcIiQxICQyXCIsW1wiMThcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7Nyw4fSlcIixcIiQxICQyICQzXCIsW1wiMSg/OjZbMDIzXXw3KVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7NH0pKFxcXFxkezJ9KShcXFxcZHs3fSlcIixcIiQxICQyICQzXCIsW1wiMTVbMjc5XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHs4fSlcIixcIiQxICQyICQzXCIsW1wiMTVcIl0sXCIwJDFcIl1dLFwiMFwiXSxcIkRKXCI6W1wiMjUzXCIsXCIwMFwiLFwiKD86MlxcXFxkfDc3KVxcXFxkezZ9XCIsWzhdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIlsyN11cIl1dXV0sXCJES1wiOltcIjQ1XCIsXCIwMFwiLFwiWzItOV1cXFxcZHs3fVwiLFs4XSxbW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCJbMi05XVwiXV1dXSxcIkRNXCI6W1wiMVwiLFwiMDExXCIsXCIoPzpbNThdXFxcXGRcXFxcZHw3Njd8OTAwKVxcXFxkezd9XCIsWzEwXSwwLFwiMVwiLDAsXCIxfChbMi03XVxcXFxkezZ9KSRcIixcIjc2NyQxXCIsMCxcIjc2N1wiXSxcIkRPXCI6W1wiMVwiLFwiMDExXCIsXCIoPzpbNThdXFxcXGRcXFxcZHw5MDApXFxcXGR7N31cIixbMTBdLDAsXCIxXCIsMCwwLDAsMCxcIjhbMDI0XTlcIl0sXCJEWlwiOltcIjIxM1wiLFwiMDBcIixcIig/OlsxLTRdfFs1LTc5XVxcXFxkfDgwKVxcXFxkezd9XCIsWzgsOV0sW1tcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzEtNF1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCI5XCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzUtOF1cIl0sXCIwJDFcIl1dLFwiMFwiXSxcIkVDXCI6W1wiNTkzXCIsXCIwMFwiLFwiMVxcXFxkezksMTB9fCg/OlsyLTddfDlcXFxcZClcXFxcZHs3fVwiLFs4LDksMTAsMTFdLFtbXCIoXFxcXGQpKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyLSQzXCIsW1wiWzItN11cIl0sXCIoMCQxKVwiLDAsXCIkMS0kMi0kM1wiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiOVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7NH0pKFxcXFxkezN9KShcXFxcZHszLDR9KVwiLFwiJDEgJDIgJDNcIixbXCIxXCJdXV0sXCIwXCJdLFwiRUVcIjpbXCIzNzJcIixcIjAwXCIsXCI4XFxcXGR7OX18WzQ1NzhdXFxcXGR7N318KD86WzMtOF1cXFxcZHw5MClcXFxcZHs1fVwiLFs3LDgsMTBdLFtbXCIoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCJbMzY5XXw0WzMtOF18NSg/OlswLTJdfDVbMC00NzhdfDZbNDVdKXw3WzEtOV18ODhcIixcIlszNjldfDRbMy04XXw1KD86WzAyXXwxKD86WzAtOF18OTUpfDVbMC00NzhdfDYoPzo0WzAtNF18NVsxLTU4OV0pKXw3WzEtOV18ODhcIl1dLFtcIihcXFxcZHs0fSkoXFxcXGR7Myw0fSlcIixcIiQxICQyXCIsW1wiWzQ1XXw4KD86MDB8WzEtNDldKVwiLFwiWzQ1XXw4KD86MDBbMS05XXxbMS00OV0pXCJdXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiN1wiXV0sW1wiKFxcXFxkezR9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIjhcIl1dXV0sXCJFR1wiOltcIjIwXCIsXCIwMFwiLFwiWzE4OV1cXFxcZHs4LDl9fFsyNC02XVxcXFxkezh9fFsxMzVdXFxcXGR7N31cIixbOCw5LDEwXSxbW1wiKFxcXFxkKShcXFxcZHs3LDh9KVwiLFwiJDEgJDJcIixbXCJbMjNdXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7Niw3fSlcIixcIiQxICQyXCIsW1wiMVszNV18WzQtNl18OFsyNDY4XXw5WzIzNS03XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiWzE4OV1cIl0sXCIwJDFcIl1dLFwiMFwiXSxcIkVIXCI6W1wiMjEyXCIsXCIwMFwiLFwiWzUtOF1cXFxcZHs4fVwiLFs5XSwwLFwiMFwiLDAsMCwwLDAsXCI1MjhbODldXCJdLFwiRVJcIjpbXCIyOTFcIixcIjAwXCIsXCJbMTc4XVxcXFxkezZ9XCIsWzddLFtbXCIoXFxcXGQpKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiWzE3OF1cIl0sXCIwJDFcIl1dLFwiMFwiXSxcIkVTXCI6W1wiMzRcIixcIjAwXCIsXCIoPzo1MXxbNi05XVxcXFxkKVxcXFxkezd9XCIsWzldLFtbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiWzg5XTAwXCJdXSxbXCIoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIls1LTldXCJdXV1dLFwiRVRcIjpbXCIyNTFcIixcIjAwXCIsXCIoPzoxMXxbMi01OV1cXFxcZClcXFxcZHs3fVwiLFs5XSxbW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIlsxLTU5XVwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiRklcIjpbXCIzNThcIixcIjAwfDk5KD86WzAxNDY5XXw1KD86WzE0XTF8M1syM118NVs1OV18Nzd8ODh8OVswOV0pKVwiLFwiWzEtMzU2ODldXFxcXGR7NH18N1xcXFxkezEwLDExfXwoPzpbMTI0LTddXFxcXGR8M1swLTQ2LTldKVxcXFxkezh9fFsxLTldXFxcXGR7NSw4fVwiLFs1LDYsNyw4LDksMTAsMTEsMTJdLFtbXCIoXFxcXGQpKFxcXFxkezQsOX0pXCIsXCIkMSAkMlwiLFtcIlsyNTY4XVsxLThdfDMoPzowWzEtOV18WzEtOV0pfDlcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHszLDd9KVwiLFwiJDEgJDJcIixbXCJbMTJdMDB8WzM2OF18NzBbMDctOV1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHs0LDh9KVwiLFwiJDEgJDJcIixbXCJbMTI0NV18N1sxMzVdXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7NiwxMH0pXCIsXCIkMSAkMlwiLFtcIjdcIl0sXCIwJDFcIl1dLFwiMFwiLDAsMCwwLDAsXCIxWzAzLTc5XXxbMi05XVwiLDAsXCIwMFwiXSxcIkZKXCI6W1wiNjc5XCIsXCIwKD86MHw1MilcIixcIjQ1XFxcXGR7NX18KD86MDgwMFxcXFxkfFsyMzUtOV0pXFxcXGR7Nn1cIixbNywxMV0sW1tcIihcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIlsyMzUtOV18NDVcIl1dLFtcIihcXFxcZHs0fSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCIwXCJdXV0sMCwwLDAsMCwwLDAsMCxcIjAwXCJdLFwiRktcIjpbXCI1MDBcIixcIjAwXCIsXCJbMi03XVxcXFxkezR9XCIsWzVdXSxcIkZNXCI6W1wiNjkxXCIsXCIwMFwiLFwiKD86WzM5XVxcXFxkXFxcXGR8ODIwKVxcXFxkezR9XCIsWzddLFtbXCIoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCJbMzg5XVwiXV1dXSxcIkZPXCI6W1wiMjk4XCIsXCIwMFwiLFwiKD86WzItOF1cXFxcZHw5MClcXFxcZHs0fVwiLFs2XSxbW1wiKFxcXFxkezZ9KVwiLFwiJDFcIixbXCJbMi05XVwiXV1dLDAsMCxcIigxMCg/OjAxfFsxMl0wfDg4KSlcIl0sXCJGUlwiOltcIjMzXCIsXCIwMFwiLFwiWzEtOV1cXFxcZHs4fVwiLFs5XSxbW1wiKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCI4XCJdLFwiMCAkMVwiXSxbXCIoXFxcXGQpKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDQgJDVcIixbXCJbMS03OV1cIl0sXCIwJDFcIl1dLFwiMFwiXSxcIkdBXCI6W1wiMjQxXCIsXCIwMFwiLFwiKD86WzA2N11cXFxcZHwxMSlcXFxcZHs2fXxbMi03XVxcXFxkezZ9XCIsWzcsOF0sW1tcIihcXFxcZCkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzItN11cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCIxMXxbNjddXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiMFwiXV1dLDAsMCxcIjAoMTFcXFxcZHs2fXw2WzI1Nl1cXFxcZHs2fXw3WzQ3XVxcXFxkezZ9KVwiLFwiJDFcIl0sXCJHQlwiOltcIjQ0XCIsXCIwMFwiLFwiWzEtMzU3LTldXFxcXGR7OX18WzE4XVxcXFxkezh9fDhcXFxcZHs2fVwiLFs3LDksMTBdLFtbXCIoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCI4MDBcIixcIjgwMDFcIixcIjgwMDExXCIsXCI4MDAxMTFcIixcIjgwMDExMTFcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkM1wiLFtcIjg0NVwiLFwiODQ1NFwiLFwiODQ1NDZcIixcIjg0NTQ2NFwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezZ9KVwiLFwiJDEgJDJcIixbXCI4MDBcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezV9KShcXFxcZHs0LDV9KVwiLFwiJDEgJDJcIixbXCIxKD86Mzh8NVsyM118Njl8NzZ8OTQpXCIsXCIxKD86KD86Mzh8NjkpN3w1KD86MjR8MzkpfDc2OHw5NDYpXCIsXCIxKD86Mzg3M3w1KD86MjQyfDM5WzQtNl0pfCg/OjY5N3w3NjgpWzM0N118OTQ2NylcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezR9KShcXFxcZHs1LDZ9KVwiLFwiJDEgJDJcIixbXCIxKD86WzItNjldWzAyLTldfFs3OF0pXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCJbMjVdfDcoPzowfDZbMDItOV0pXCIsXCJbMjVdfDcoPzowfDYoPzpbMDMtOV18MlszNTZdKSlcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezR9KShcXFxcZHs2fSlcIixcIiQxICQyXCIsW1wiN1wiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiWzEzODldXCJdLFwiMCQxXCJdXSxcIjBcIiwwLDAsMCwwLDAsW1tcIig/OjEoPzoxKD86Myg/OlswLTU4XVxcXFxkXFxcXGR8NzNbMDNdKXwoPzo0WzAtNV18NVswLTI2LTldfDZbMC00XXxbNzhdWzAtNDldKVxcXFxkXFxcXGQpfDIoPzooPzowWzAyNC05XXwyWzMtOV18M1szLTc5XXw0WzEtNjg5XXxbNThdWzAyLTldfDZbMC00Ny05XXw3WzAxMy05XXw5XFxcXGQpXFxcXGRcXFxcZHwxKD86WzAtN11cXFxcZFxcXFxkfDgoPzowXFxcXGR8MjApKSl8KD86Myg/OjBcXFxcZHwxWzAtOF18WzI1XVswMi05XXwzWzAyLTU3OV18WzQ2OF1bMC00Ni05XXw3WzEtMzUtNzldfDlbMi01NzhdKXw0KD86MFswMy05XXxbMTM3XVxcXFxkfFsyOF1bMDItNTctOV18NFswMi02OV18NVswLThdfFs2OV1bMC03OV0pfDUoPzowWzEtMzUtOV18WzE2XVxcXFxkfDJbMDI0LTldfDNbMDE1Njg5XXw0WzAyLTldfDVbMDMtOV18N1swLTM1LTldfDhbMC00NjhdfDlbMC01Ny05XSl8Nig/OjBbMDM0Njg5XXwxXFxcXGR8MlswLTM1Njg5XXxbMzhdWzAxMy05XXw0WzEtNDY3XXw1WzAtNjldfDZbMTMtOV18N1swLThdfDlbMC0yNDU3OF0pfDcoPzowWzAyNDYtOV18MlxcXFxkfDNbMDIzNi04XXw0WzAzLTldfDVbMC00Ni05XXw2WzAxMy05XXw3WzAtMzUtOV18OFswMjQtOV18OVswMi05XSl8OCg/OjBbMzUtOV18MlsxLTU3LTldfDNbMDItNTc4XXw0WzAtNTc4XXw1WzEyNC05XXw2WzItNjldfDdcXFxcZHw4WzAyLTldfDlbMDI1NjldKXw5KD86MFswMi01ODldfFsxOF1cXFxcZHwyWzAyLTY4OV18M1sxLTU3LTldfDRbMi05XXw1WzAtNTc5XXw2WzItNDctOV18N1swLTI0NTc4XXw5WzItNTddKSlcXFxcZFxcXFxkKXwyKD86MFswMTM0NzhdfDNbMDE4OV18NFswMTddfDhbMC00Ni05XXw5WzAtMl0pXFxcXGR7M30pXFxcXGR7NH18MSg/OjIoPzowKD86NDZbMS00XXw4N1syLTldKXw1NDVbMS03OV18NzYoPzoyXFxcXGR8M1sxLThdfDZbMS02XSl8OSg/OjcoPzoyWzAtNF18M1syLTVdKXw4KD86MlsyLThdfDdbMC00Ny05XXw4WzMtNV0pKSl8Myg/OjYoPzozOFsyLTVdfDQ3WzIzXSl8OCg/OjQ3WzA0LTldfDY0WzAxNTctOV0pKXw0KD86MDQ0WzEtN118MjAoPzoyWzIzXXw4XFxcXGQpfDYoPzowKD86MzB8NVsyLTU3XXw2WzEtOF18N1syLThdKXwxNDApfDgoPzowNTJ8ODdbMS0zXSkpfDUoPzoyKD86NCg/OjNbMi03OV18NlxcXFxkKXw3NlxcXFxkKXw2KD86MjZbMDYtOV18Njg2KSl8Nig/OjA2KD86NFxcXFxkfDdbNC03OV0pfDI5NVs1LTddfDM1WzM0XVxcXFxkfDQ3KD86MjR8NjEpfDU5KD86NVswOF18Nls2N118NzQpfDkoPzo1NVswLTRdfDc3WzIzXSkpfDcoPzoyNig/OjZbMTMtOV18N1swLTddKXwoPzo0NDJ8Njg4KVxcXFxkfDUwKD86MlswLTNdfFszLTY4XTJ8NzYpKXw4KD86MjdbNTZdXFxcXGR8MzcoPzo1WzItNV18OFsyMzldKXw4NDNbMi01OF0pfDkoPzowKD86MCg/OjZbMS04XXw4NSl8NTJcXFxcZCl8MzU4M3w0KD86NjZbMS04XXw5KD86MlswMV18ODEpKXw2Myg/OjIzfDNbMS00XSl8OTU2MSkpXFxcXGR7M31cIixbOSwxMF1dLFtcIjcoPzo0NTdbMC01Ny05XXw3MDBbMDFdfDkxMVswMjhdKVxcXFxkezV9fDcoPzpbMS0zXVxcXFxkXFxcXGR8NCg/OlswLTQ2LTldXFxcXGR8NVswLTY4OV0pfDUoPzowWzAtOF18WzEzLTldXFxcXGR8MlswLTM1LTldKXw3KD86MFsxLTldfFsxLTddXFxcXGR8OFswMi05XXw5WzAtNjg5XSl8OCg/OlswMTQtOV1cXFxcZHxbMjNdWzAtOF0pfDkoPzpbMDI0LTldXFxcXGR8MVswMi05XXwzWzAtNjg5XSkpXFxcXGR7Nn1cIixbMTBdXSxbXCI4MFswOF1cXFxcZHs3fXw4MDBcXFxcZHs2fXw4MDAxMTExXCJdLFtcIig/OjgoPzo0WzItNV18N1swLTNdKXw5KD86WzAxXVxcXFxkfDhbMi00OV0pKVxcXFxkezd9fDg0NTQ2NFxcXFxkXCIsWzcsMTBdXSxbXCI3MFxcXFxkezh9XCIsWzEwXV0sMCxbXCIoPzozWzAzNDddfDU1KVxcXFxkezh9XCIsWzEwXV0sW1wiNzYoPzowWzAtMl18MlszNTZdfDM0fDRbMDEzNF18NVs0OV18NlswLTM2OV18Nzd8ODF8OVszOV0pXFxcXGR7Nn1cIixbMTBdXSxbXCI1NlxcXFxkezh9XCIsWzEwXV1dLDAsXCIgeFwiXSxcIkdEXCI6W1wiMVwiLFwiMDExXCIsXCIoPzo0NzN8WzU4XVxcXFxkXFxcXGR8OTAwKVxcXFxkezd9XCIsWzEwXSwwLFwiMVwiLDAsXCIxfChbMi05XVxcXFxkezZ9KSRcIixcIjQ3MyQxXCIsMCxcIjQ3M1wiXSxcIkdFXCI6W1wiOTk1XCIsXCIwMFwiLFwiKD86WzMtNTddXFxcXGRcXFxcZHw4MDApXFxcXGR7Nn1cIixbOV0sW1tcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCI3MFwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIjMyXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzU3XVwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCJbMzQ4XVwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiR0ZcIjpbXCI1OTRcIixcIjAwXCIsXCIoPzpbNTZdOTR8OTc2KVxcXFxkezZ9XCIsWzldLFtbXCIoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIls1NjldXCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJHR1wiOltcIjQ0XCIsXCIwMFwiLFwiKD86MTQ4MXxbMzU3LTldXFxcXGR7M30pXFxcXGR7Nn18OFxcXFxkezZ9KD86XFxcXGR7Mn0pP1wiLFs3LDksMTBdLDAsXCIwXCIsMCxcIjB8KFsyNS05XVxcXFxkezV9KSRcIixcIjE0ODEkMVwiLDAsMCxbW1wiMTQ4MVsyNS05XVxcXFxkezV9XCIsWzEwXV0sW1wiNyg/Oig/Ojc4MXw4MzkpXFxcXGR8OTExWzE3XSlcXFxcZHs1fVwiLFsxMF1dLFtcIjgwWzA4XVxcXFxkezd9fDgwMFxcXFxkezZ9fDgwMDExMTFcIl0sW1wiKD86OCg/OjRbMi01XXw3WzAtM10pfDkoPzpbMDFdXFxcXGR8OFswLTNdKSlcXFxcZHs3fXw4NDU0NjRcXFxcZFwiLFs3LDEwXV0sW1wiNzBcXFxcZHs4fVwiLFsxMF1dLDAsW1wiKD86M1swMzQ3XXw1NSlcXFxcZHs4fVwiLFsxMF1dLFtcIjc2KD86MFswLTJdfDJbMzU2XXwzNHw0WzAxMzRdfDVbNDldfDZbMC0zNjldfDc3fDgxfDlbMzldKVxcXFxkezZ9XCIsWzEwXV0sW1wiNTZcXFxcZHs4fVwiLFsxMF1dXV0sXCJHSFwiOltcIjIzM1wiLFwiMDBcIixcIig/OlsyMzVdXFxcXGR7M318ODAwKVxcXFxkezV9XCIsWzgsOV0sW1tcIihcXFxcZHszfSkoXFxcXGR7NX0pXCIsXCIkMSAkMlwiLFtcIjhcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIlsyMzVdXCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJHSVwiOltcIjM1MFwiLFwiMDBcIixcIlsyNTZdXFxcXGR7N31cIixbOF0sW1tcIihcXFxcZHszfSkoXFxcXGR7NX0pXCIsXCIkMSAkMlwiLFtcIjJcIl1dXV0sXCJHTFwiOltcIjI5OVwiLFwiMDBcIixcIig/OjE5fFsyLTY4OV1cXFxcZClcXFxcZHs0fVwiLFs2XSxbW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkM1wiLFtcIjE5fFsyLTY4OV1cIl1dXV0sXCJHTVwiOltcIjIyMFwiLFwiMDBcIixcIlsyLTldXFxcXGR7Nn1cIixbN10sW1tcIihcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIlsyLTldXCJdXV1dLFwiR05cIjpbXCIyMjRcIixcIjAwXCIsXCI3MjJcXFxcZHs2fXwoPzozfDZcXFxcZClcXFxcZHs3fVwiLFs4LDldLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIjNcIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzY3XVwiXV1dXSxcIkdQXCI6W1wiNTkwXCIsXCIwMFwiLFwiKD86NTkwfDY5XFxcXGR8OTc2KVxcXFxkezZ9XCIsWzldLFtbXCIoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIls1NjldXCJdLFwiMCQxXCJdXSxcIjBcIiwwLDAsMCwwLDAsW1tcIjU5MCg/OjBbMS02OF18MVswLTJdfDJbMC02OF18M1sxMjg5XXw0WzAtMjQtOV18NVszLTU3OV18NlswMTg5XXw3WzA4XXw4WzAtNjg5XXw5XFxcXGQpXFxcXGR7NH1cIl0sW1wiNjkoPzowXFxcXGRcXFxcZHwxKD86MlsyOV18M1swLTVdKSlcXFxcZHs0fVwiXSwwLDAsMCwwLDAsMCxbXCI5NzZbMDFdXFxcXGR7NX1cIl1dXSxcIkdRXCI6W1wiMjQwXCIsXCIwMFwiLFwiMjIyXFxcXGR7Nn18KD86M1xcXFxkfDU1fFs4OV0wKVxcXFxkezd9XCIsWzldLFtbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiWzIzNV1cIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7Nn0pXCIsXCIkMSAkMlwiLFtcIls4OV1cIl1dXV0sXCJHUlwiOltcIjMwXCIsXCIwMFwiLFwiNTAwNTAwMFxcXFxkezN9fCg/OlsyNjg5XVxcXFxkfDcwKVxcXFxkezh9XCIsWzEwXSxbW1wiKFxcXFxkezJ9KShcXFxcZHs0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjIxfDdcIl1dLFtcIihcXFxcZHs0fSkoXFxcXGR7Nn0pXCIsXCIkMSAkMlwiLFtcIjIoPzoyfDNbMi01Ny05XXw0WzItNDY5XXw1WzItNTldfDZbMi05XXw3WzItNjldfDhbMi00OV0pfDVcIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCJbMjY4OV1cIl1dXV0sXCJHVFwiOltcIjUwMlwiLFwiMDBcIixcIig/OjFcXFxcZHszfXxbMi03XSlcXFxcZHs3fVwiLFs4LDExXSxbW1wiKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiWzItN11cIl1dLFtcIihcXFxcZHs0fSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCIxXCJdXV1dLFwiR1VcIjpbXCIxXCIsXCIwMTFcIixcIig/Ols1OF1cXFxcZFxcXFxkfDY3MXw5MDApXFxcXGR7N31cIixbMTBdLDAsXCIxXCIsMCxcIjF8KFszLTldXFxcXGR7Nn0pJFwiLFwiNjcxJDFcIiwwLFwiNjcxXCJdLFwiR1dcIjpbXCIyNDVcIixcIjAwXCIsXCJbNDldXFxcXGR7OH18NFxcXFxkezZ9XCIsWzcsOV0sW1tcIihcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIjQwXCJdXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiWzQ5XVwiXV1dXSxcIkdZXCI6W1wiNTkyXCIsXCIwMDFcIixcIig/Ojg2MlxcXFxkfDkwMDgpXFxcXGR7M318KD86WzItNDZdXFxcXGR8NzcpXFxcXGR7NX1cIixbN10sW1tcIihcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIlsyLTQ2LTldXCJdXV1dLFwiSEtcIjpbXCI4NTJcIixcIjAwKD86MzB8NVswOV18WzEyNi05XT8pXCIsXCI4WzAtNDYtOV1cXFxcZHs2LDd9fDlcXFxcZHs0fSg/OlxcXFxkKD86XFxcXGQoPzpcXFxcZHs0fSk/KT8pP3woPzpbMjM1LTc5XVxcXFxkfDQ2KVxcXFxkezZ9XCIsWzUsNiw3LDgsOSwxMV0sW1tcIihcXFxcZHszfSkoXFxcXGR7Miw1fSlcIixcIiQxICQyXCIsW1wiOTAwXCIsXCI5MDAzXCJdXSxbXCIoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCJbMi03XXw4WzEtNF18OSg/OjBbMS05XXxbMS04XSlcIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCI4XCJdXSxbXCIoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIjlcIl1dXSwwLDAsMCwwLDAsMCwwLFwiMDBcIl0sXCJITlwiOltcIjUwNFwiLFwiMDBcIixcIjhcXFxcZHsxMH18WzIzNy05XVxcXFxkezd9XCIsWzgsMTFdLFtbXCIoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEtJDJcIixbXCJbMjM3LTldXCJdXV1dLFwiSFJcIjpbXCIzODVcIixcIjAwXCIsXCIoPzpbMjQtNjldXFxcXGR8M1swLTc5XSlcXFxcZHs3fXw4MFxcXFxkezUsN318WzEtNzldXFxcXGR7N318NlxcXFxkezUsNn1cIixbNiw3LDgsOV0sW1tcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezIsM30pXCIsXCIkMSAkMiAkM1wiLFtcIjZbMDFdXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezIsM30pXCIsXCIkMSAkMiAkM1wiLFtcIjhcIl0sXCIwJDFcIl0sW1wiKFxcXFxkKShcXFxcZHs0fSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIjFcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Myw0fSlcIixcIiQxICQyICQzXCIsW1wiWzY3XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHszLDR9KVwiLFwiJDEgJDIgJDNcIixbXCI5XCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezMsNH0pXCIsXCIkMSAkMiAkM1wiLFtcIlsyLTVdXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCI4XCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJIVFwiOltcIjUwOVwiLFwiMDBcIixcIlsyLTQ4OV1cXFxcZHs3fVwiLFs4XSxbW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIlsyLTQ4OV1cIl1dXV0sXCJIVVwiOltcIjM2XCIsXCIwMFwiLFwiWzIzNTddXFxcXGR7OH18WzEtOV1cXFxcZHs3fVwiLFs4LDldLFtbXCIoXFxcXGQpKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiMVwiXSxcIigwNiAkMSlcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIlsyN11bMi05XXwzWzItN118NFsyNC05XXw1WzItNzldfDZ8OFsyLTU3LTldfDlbMi02OV1cIl0sXCIoMDYgJDEpXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezMsNH0pXCIsXCIkMSAkMiAkM1wiLFtcIlsyLTU3LTldXCJdLFwiMDYgJDFcIl1dLFwiMDZcIl0sXCJJRFwiOltcIjYyXCIsXCIwMFsxODldXCIsXCIoPzooPzowMDc4MDN8OFxcXFxkezR9KVxcXFxkfFsxLTM2XSlcXFxcZHs2fXxbMS05XVxcXFxkezgsMTB9fFsyLTldXFxcXGR7N31cIixbNyw4LDksMTAsMTEsMTIsMTNdLFtbXCIoXFxcXGQpKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiMTVcIl1dLFtcIihcXFxcZHsyfSkoXFxcXGR7NSw5fSlcIixcIiQxICQyXCIsW1wiMlsxMjRdfFszNl0xXCJdLFwiKDAkMSlcIl0sW1wiKFxcXFxkezN9KShcXFxcZHs1LDd9KVwiLFwiJDEgJDJcIixbXCI4MDBcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHs1LDh9KVwiLFwiJDEgJDJcIixbXCJbMi03OV1cIl0sXCIoMCQxKVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezMsNH0pKFxcXFxkezN9KVwiLFwiJDEtJDItJDNcIixbXCI4WzEtMzUtOV1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHs2LDh9KVwiLFwiJDEgJDJcIixbXCIxXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCI4MDRcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZCkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCI4MFwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezR9KShcXFxcZHs0LDV9KVwiLFwiJDEtJDItJDNcIixbXCI4XCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJJRVwiOltcIjM1M1wiLFwiMDBcIixcIig/OjFcXFxcZHxbMjU2OV0pXFxcXGR7Niw4fXw0XFxcXGR7Niw5fXw3XFxcXGR7OH18OFxcXFxkezgsOX1cIixbNyw4LDksMTBdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezV9KVwiLFwiJDEgJDJcIixbXCIyWzI0LTldfDQ3fDU4fDZbMjM3LTldfDlbMzUtOV1cIl0sXCIoMCQxKVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezV9KVwiLFwiJDEgJDJcIixbXCJbNDVdMFwiXSxcIigwJDEpXCJdLFtcIihcXFxcZCkoXFxcXGR7Myw0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjFcIl0sXCIoMCQxKVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHszLDR9KVwiLFwiJDEgJDIgJDNcIixbXCJbMjU2OV18NFsxLTY5XXw3WzE0XVwiXSxcIigwJDEpXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCI3MFwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiODFcIl0sXCIoMCQxKVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiWzc4XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7NH0pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiMVwiXV0sW1wiKFxcXFxkezJ9KShcXFxcZHs0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjRcIl0sXCIoMCQxKVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIjhcIl0sXCIwJDFcIl1dLFwiMFwiXSxcIklMXCI6W1wiOTcyXCIsXCIwKD86MHwxWzItOV0pXCIsXCIxXFxcXGR7Nn0oPzpcXFxcZHszLDV9KT98WzU3XVxcXFxkezh9fFsxLTQ4OV1cXFxcZHs3fVwiLFs3LDgsOSwxMCwxMSwxMl0sW1tcIihcXFxcZHs0fSkoXFxcXGR7M30pXCIsXCIkMS0kMlwiLFtcIjEyNVwiXV0sW1wiKFxcXFxkezR9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMS0kMi0kM1wiLFtcIjEyMVwiXV0sW1wiKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMS0kMi0kM1wiLFtcIlsyLTQ4OV1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMS0kMi0kM1wiLFtcIls1N11cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezR9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMS0kMi0kM1wiLFtcIjEyXCJdXSxbXCIoXFxcXGR7NH0pKFxcXFxkezZ9KVwiLFwiJDEtJDJcIixbXCIxNTlcIl1dLFtcIihcXFxcZCkoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxLSQyLSQzLSQ0XCIsW1wiMVs3LTldXCJdXSxbXCIoXFxcXGR7M30pKFxcXFxkezEsMn0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxLSQyICQzLSQ0XCIsW1wiMTVcIl1dXSxcIjBcIl0sXCJJTVwiOltcIjQ0XCIsXCIwMFwiLFwiMTYyNFxcXFxkezZ9fCg/OlszNTc4XVxcXFxkfDkwKVxcXFxkezh9XCIsWzEwXSwwLFwiMFwiLDAsXCIwfChbNS04XVxcXFxkezV9KSRcIixcIjE2MjQkMVwiLDAsXCI3NDU3NnwoPzoxNnw3WzU2XSkyNFwiXSxcIklOXCI6W1wiOTFcIixcIjAwXCIsXCIoPzowMDA4MDB8WzItOV1cXFxcZFxcXFxkKVxcXFxkezd9fDFcXFxcZHs3LDEyfVwiLFs4LDksMTAsMTEsMTIsMTNdLFtbXCIoXFxcXGR7OH0pXCIsXCIkMVwiLFtcIjUoPzowfDJbMjNdfDNbMDNdfFs2N10xfDg4KVwiLFwiNSg/OjB8Mig/OjIxfDMpfDMoPzowfDNbMjNdKXw2MTZ8NzE3fDg4OClcIixcIjUoPzowfDIoPzoyMXwzKXwzKD86MHwzWzIzXSl8NjE2fDcxN3w4ODg4KVwiXSwwLDFdLFtcIihcXFxcZHs0fSkoXFxcXGR7NCw1fSlcIixcIiQxICQyXCIsW1wiMTgwXCIsXCIxODAwXCJdLDAsMV0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjE0MFwiXSwwLDFdLFtcIihcXFxcZHsyfSkoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCIxMXwyWzAyXXwzM3w0WzA0XXw3OVsxLTddfDgwWzItNDZdXCIsXCIxMXwyWzAyXXwzM3w0WzA0XXw3OSg/OlsxLTZdfDdbMTldKXw4MCg/OlsyLTRdfDZbMC01ODldKVwiLFwiMTF8MlswMl18MzN8NFswNF18NzkoPzpbMTI0LTZdfDMoPzpbMDItOV18MVswLTI0LTldKXw3KD86MXw5WzEtNl0pKXw4MCg/OlsyLTRdfDZbMC01ODldKVwiXSxcIjAkMVwiLDFdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCIxKD86MlswLTI0OV18M1swLTI1XXw0WzE0NV18WzY4XXw3WzEyNTddKXwyKD86MVsyNTddfDNbMDEzXXw0WzAxXXw1WzAxMzddfDZbMDE1OF18Nzh8OFsxNTY4XSl8Myg/OjI2fDRbMS0zXXw1WzM0XXw2WzAxNDg5XXw3WzAyLTQ2XXw4WzE1OV0pfDQoPzoxWzM2XXwyWzEtNDddfDVbMTJdfDZbMC0yNi05XXw3WzAtMjQtOV18OFswMTMtNTddfDlbMDE0LTddKXw1KD86MVswMjVdfDIyfFszNl1bMjVdfDRbMjhdfDVbMTJdfFs3OF0xKXw2KD86MTJ8WzItNF0xfDVbMTddfDZbMTNdfDgwKXw3KD86MTJ8M1sxMzRdfDRbNDddfDYxfDg4KXw4KD86MTZ8MlswMTRdfDNbMTI2XXw2WzEzNl18N1swNzhdfDhbMzRdfDkxKXwoPzo0M3w1OXw3NSlbMTVdfCg/OjFbNTldfDI5fDY3fDcyKVsxNF1cIixcIjEoPzoyWzAtMjRdfDNbMC0yNV18NFsxNDVdfFs1OV1bMTRdfDZbMS05XXw3WzEyNTddfDhbMS01Ny05XSl8Mig/OjFbMjU3XXwzWzAxM118NFswMV18NVswMTM3XXw2WzA1OF18Nzh8OFsxNTY4XXw5WzE0XSl8Myg/OjI2fDRbMS0zXXw1WzM0XXw2WzAxNDg5XXw3WzAyLTQ2XXw4WzE1OV0pfDQoPzoxWzM2XXwyWzEtNDddfDNbMTVdfDVbMTJdfDZbMC0yNi05XXw3WzAtMjQtOV18OFswMTMtNTddfDlbMDE0LTddKXw1KD86MVswMjVdfDIyfFszNl1bMjVdfDRbMjhdfFs1NzhdMXw5WzE1XSl8Njc0fDcoPzooPzoyWzE0XXwzWzM0XXw1WzE1XSlbMi02XXw2MVszNDZdfDg4WzAtOF0pfDgoPzo3MFsyLTZdfDg0WzIzNS03XXw5MVszLTddKXwoPzoxKD86Mjl8NjB8OFswNl0pfDI2MXw1NTJ8Nig/OjEyfFsyLTQ3XTF8NVsxN118NlsxM118ODApfDcoPzoxMnwzMXw0WzQ3XSl8OCg/OjE2fDJbMDE0XXwzWzEyNl18NlsxMzZdfDdbNzhdfDgzKSlbMi03XVwiLFwiMSg/OjJbMC0yNF18M1swLTI1XXw0WzE0NV18WzU5XVsxNF18NlsxLTldfDdbMTI1N118OFsxLTU3LTldKXwyKD86MVsyNTddfDNbMDEzXXw0WzAxXXw1WzAxMzddfDZbMDU4XXw3OHw4WzE1NjhdfDlbMTRdKXwzKD86MjZ8NFsxLTNdfDVbMzRdfDZbMDE0ODldfDdbMDItNDZdfDhbMTU5XSl8NCg/OjFbMzZdfDJbMS00N118M1sxNV18NVsxMl18NlswLTI2LTldfDdbMC0yNC05XXw4WzAxMy01N118OVswMTQtN10pfDUoPzoxWzAyNV18MjJ8WzM2XVsyNV18NFsyOF18WzU3OF0xfDlbMTVdKXw2KD86MTIoPzpbMi02XXw3WzAtOF0pfDc0WzItN10pfDcoPzooPzoyWzE0XXw1WzE1XSlbMi02XXwzMTcxfDYxWzM0Nl18ODgoPzpbMi03XXw4MikpfDgoPzo3MFsyLTZdfDg0KD86WzIzNTZdfDdbMTldKXw5MSg/OlszLTZdfDdbMTldKSl8NzNbMTM0XVsyLTZdfCg/Ojc0WzQ3XXw4KD86MTZ8MlswMTRdfDNbMTI2XXw2WzEzNl18N1s3OF18ODMpKSg/OlsyLTZdfDdbMTldKXwoPzoxKD86Mjl8NjB8OFswNl0pfDI2MXw1NTJ8Nig/OlsyLTRdMXw1WzE3XXw2WzEzXXw3KD86MXw0WzAxODldKXw4MCl8Nyg/OjEyfDg4WzAxXSkpWzItN11cIl0sXCIwJDFcIiwxXSxbXCIoXFxcXGR7NH0pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiMSg/OlsyLTQ3OV18NVswMjM1LTldKXxbMi01XXw2KD86MVsxMzU4XXwyWzI0NTctOV18M1syLTVdfDRbMjM1LTddfDVbMi02ODldfDZbMjQ1NzhdfDdbMjM1Njg5XXw4WzEtNl0pfDcoPzoxWzAxMy05XXwyOHwzWzEyOV18NFsxLTM1Njg5XXw1WzI5XXw2WzAyLTVdfDcwKXw4MDdcIixcIjEoPzpbMi00NzldfDVbMDIzNS05XSl8WzItNV18Nig/OjFbMTM1OF18Mig/OlsyNDU3XXw4NHw5NSl8Myg/OlsyLTRdfDU1KXw0WzIzNS03XXw1WzItNjg5XXw2WzI0NTc4XXw3WzIzNTY4OV18OFsxLTZdKXw3KD86MSg/OlswMTMtOF18OVs2LTldKXwyOFs2LThdfDMoPzoxN3wyWzAtNDldfDlbMi01N10pfDQoPzoxWzItNF18WzI5XVswLTddfDNbMC04XXxbNTZdfDhbMC0yNC03XSl8NSg/OjJbMS0zXXw5WzAtNl0pfDYoPzowWzU2ODldfDJbNS05XXwzWzAyLThdfDR8NVswLTM2N10pfDcwWzEzLTddKXw4MDdbMTldXCIsXCIxKD86WzItNDc5XXw1KD86WzAyMzYtOV18NVswMTMtOV0pKXxbMi01XXw2KD86Mig/Ojg0fDk1KXwzNTV8ODMpfDczMTc5fDgwNyg/OjF8OVsxLTNdKXwoPzoxNTUyfDYoPzoxWzEzNThdfDJbMjQ1N118M1syLTRdfDRbMjM1LTddfDVbMi02ODldfDZbMjQ1NzhdfDdbMjM1Njg5XXw4WzEyNC02XSlcXFxcZHw3KD86MSg/OlswMTMtOF1cXFxcZHw5WzYtOV0pfDI4WzYtOF18Myg/OjJbMC00OV18OVsyLTU3XSl8NCg/OjFbMi00XXxbMjldWzAtN118M1swLThdfFs1Nl1cXFxcZHw4WzAtMjQtN10pfDUoPzoyWzEtM118OVswLTZdKXw2KD86MFs1Njg5XXwyWzUtOV18M1swMi04XXw0XFxcXGR8NVswLTM2N10pfDcwWzEzLTddKSlbMi03XVwiXSxcIjAkMVwiLDFdLFtcIihcXFxcZHs1fSkoXFxcXGR7NX0pXCIsXCIkMSAkMlwiLFtcIls2LTldXCJdLFwiMCQxXCIsMV0sW1wiKFxcXFxkezR9KShcXFxcZHsyLDR9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiMSg/OjZ8OFswNl0pXCIsXCIxKD86Nnw4WzA2XTApXCJdLDAsMV0sW1wiKFxcXFxkezR9KShcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCIxOFwiXSwwLDFdXSxcIjBcIl0sXCJJT1wiOltcIjI0NlwiLFwiMDBcIixcIjNcXFxcZHs2fVwiLFs3XSxbW1wiKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiM1wiXV1dXSxcIklRXCI6W1wiOTY0XCIsXCIwMFwiLFwiKD86MXw3XFxcXGRcXFxcZClcXFxcZHs3fXxbMi02XVxcXFxkezcsOH1cIixbOCw5LDEwXSxbW1wiKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjFcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Myw0fSlcIixcIiQxICQyICQzXCIsW1wiWzItNl1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjdcIl0sXCIwJDFcIl1dLFwiMFwiXSxcIklSXCI6W1wiOThcIixcIjAwXCIsXCJbMS05XVxcXFxkezl9fCg/OlsxLThdXFxcXGRcXFxcZHw5KVxcXFxkezMsNH1cIixbNCw1LDYsNywxMF0sW1tcIihcXFxcZHs0LDV9KVwiLFwiJDFcIixbXCI5NlwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezQsNX0pXCIsXCIkMSAkMlwiLFtcIig/OjFbMTM3XXwyWzEzLTY4XXwzWzE0NThdfDRbMTQ1XXw1WzE0NjhdfDZbMTZdfDdbMTQ2N118OFsxMzQ2N10pWzEyNjg5XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszLDR9KVwiLFwiJDEgJDIgJDNcIixbXCI5XCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCJbMS04XVwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiSVNcIjpbXCIzNTRcIixcIjAwfDEoPzowKD86MDF8WzEyXTApfDEwMClcIixcIig/OjM4XFxcXGR8WzQtOV0pXFxcXGR7Nn1cIixbNyw5XSxbW1wiKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiWzQtOV1cIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCIzXCJdXV0sMCwwLDAsMCwwLDAsMCxcIjAwXCJdLFwiSVRcIjpbXCIzOVwiLFwiMDBcIixcIjBcXFxcZHs1LDEwfXwzWzAtOF1cXFxcZHs3LDEwfXw1NVxcXFxkezh9fDhcXFxcZHs1fSg/OlxcXFxkezIsNH0pP3woPzoxXFxcXGR8MzkpXFxcXGR7Nyw4fVwiLFs2LDcsOCw5LDEwLDExXSxbW1wiKFxcXFxkezJ9KShcXFxcZHs0LDZ9KVwiLFwiJDEgJDJcIixbXCIwWzI2XVwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHszLDZ9KVwiLFwiJDEgJDJcIixbXCIwWzEzLTU3LTldWzAxNTldfDgoPzowM3w0WzE3XXw5WzI0NV0pXCIsXCIwWzEzLTU3LTldWzAxNTldfDgoPzowM3w0WzE3XXw5KD86MnxbNDVdWzAtNF0pKVwiXV0sW1wiKFxcXFxkezR9KShcXFxcZHsyLDZ9KVwiLFwiJDEgJDJcIixbXCIwKD86WzEzLTU3OV1bMi00Ni04XXw4WzIzNi04XSlcIl1dLFtcIihcXFxcZHs0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIjg5NFwiXV0sW1wiKFxcXFxkezJ9KShcXFxcZHszLDR9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiMFsyNl18NVwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7Myw0fSlcIixcIiQxICQyICQzXCIsW1wiMVs0Njc5XXxbMzhdXCJdXSxbXCIoXFxcXGR7M30pKFxcXFxkezMsNH0pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCIwWzEzLTU3LTldWzAxNTldXCJdXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezR9KShcXFxcZHs1fSlcIixcIiQxICQyICQzXCIsW1wiMFsyNl1cIl1dLFtcIihcXFxcZHs0fSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCIwXCJdXSxbXCIoXFxcXGR7M30pKFxcXFxkezR9KShcXFxcZHs0LDV9KVwiLFwiJDEgJDIgJDNcIixbXCIzXCJdXV0sMCwwLDAsMCwwLDAsW1tcIjA2NjlbMC03OV1cXFxcZHsxLDZ9fDAoPzoxKD86WzAxNTldXFxcXGR8WzI3XVsxLTVdfDMxfDRbMS00XXw2WzEzNTZdfDhbMi01N10pfDJcXFxcZFxcXFxkfDMoPzpbMDE1OV1cXFxcZHwyWzEtNF18M1sxMl18WzQ4XVsxLTZdfDZbMi01OV18N1sxLTddKXw0KD86WzAxNTldXFxcXGR8WzIzXVsxLTldfDRbMjQ1XXw2WzEtNV18N1sxLTRdfDgxKXw1KD86WzAxNTldXFxcXGR8MlsxLTVdfDNbMi02XXw0WzEtNzldfDZbNC02XXw3WzEtNTc4XXw4WzMtOF0pfDYoPzpbMC01Ny05XVxcXFxkfDZbMC04XSl8Nyg/OlswMTU5XVxcXFxkfDJbMTJdfDNbMS03XXw0WzItNDZdfDZbMTM1NjldfDdbMTMtNl18OFsxLTU5XSl8OCg/OlswMTU5XVxcXFxkfDJbMy01NzhdfDNbMS0zNTZdfFs2LThdWzEtNV0pfDkoPzpbMDE1OV1cXFxcZHxbMjM4XVsxLTVdfDRbMTJdfDZbMS04XXw3WzEtNl0pKVxcXFxkezIsN31cIl0sW1wiM1sxLTldXFxcXGR7OH18M1syLTldXFxcXGR7N31cIixbOSwxMF1dLFtcIjgwKD86MFxcXFxkezN9fDMpXFxcXGR7M31cIixbNiw5XV0sW1wiKD86MDg3OFxcXFxkXFxcXGR8ODkoPzoyfDRbNS05XVxcXFxkKSlcXFxcZHszfXw4OVs0NV1bMC00XVxcXFxkXFxcXGR8KD86MSg/OjQ0fDZbMzQ2XSl8ODkoPzo1WzUtOV18OSkpXFxcXGR7Nn1cIixbNiw4LDksMTBdXSxbXCIxKD86NzhcXFxcZHw5OSlcXFxcZHs2fVwiLFs5LDEwXV0sMCwwLDAsW1wiNTVcXFxcZHs4fVwiLFsxMF1dLFtcIjg0KD86WzA4XVxcXFxkezN9fFsxN10pXFxcXGR7M31cIixbNiw5XV1dXSxcIkpFXCI6W1wiNDRcIixcIjAwXCIsXCIxNTM0XFxcXGR7Nn18KD86WzM1NzhdXFxcXGR8OTApXFxcXGR7OH1cIixbMTBdLDAsXCIwXCIsMCxcIjB8KFswLTI0LThdXFxcXGR7NX0pJFwiLFwiMTUzNCQxXCIsMCwwLFtbXCIxNTM0WzAtMjQtOF1cXFxcZHs1fVwiXSxbXCI3KD86KD86KD86NTB8ODIpOXw5MzcpXFxcXGR8Nyg/OjAwWzM3OF18OTdbNy05XSkpXFxcXGR7NX1cIl0sW1wiODAoPzowNyg/OjM1fDgxKXw4OTAxKVxcXFxkezR9XCJdLFtcIig/OjgoPzo0KD86NCg/OjQoPzowNXw0Mnw2OSl8NzAzKXw1KD86MDQxfDgwMCkpfDcoPzowMDAyfDEyMDYpKXw5MCg/OjA2Nls1OV18MTgxMHw3MSg/OjA3fDU1KSkpXFxcXGR7NH1cIl0sW1wiNzAxNTExXFxcXGR7NH1cIl0sMCxbXCIoPzozKD86MCg/OjA3KD86MzV8ODEpfDg5MDEpfDNcXFxcZHs0fXw0KD86NCg/OjQoPzowNXw0Mnw2OSl8NzAzKXw1KD86MDQxfDgwMCkpfDcoPzowMDAyfDEyMDYpKXw1NVxcXFxkezR9KVxcXFxkezR9XCJdLFtcIjc2KD86MFswLTJdfDJbMzU2XXwzNHw0WzAxMzRdfDVbNDldfDZbMC0zNjldfDc3fDgxfDlbMzldKVxcXFxkezZ9XCJdLFtcIjU2XFxcXGR7OH1cIl1dXSxcIkpNXCI6W1wiMVwiLFwiMDExXCIsXCIoPzpbNThdXFxcXGRcXFxcZHw2NTh8OTAwKVxcXFxkezd9XCIsWzEwXSwwLFwiMVwiLDAsMCwwLDAsXCI2NTh8ODc2XCJdLFwiSk9cIjpbXCI5NjJcIixcIjAwXCIsXCIoPzooPzpbMjY4OV18N1xcXFxkKVxcXFxkfDMyfDUzKVxcXFxkezZ9XCIsWzgsOV0sW1tcIihcXFxcZCkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCJbMjM1Nl18ODdcIl0sXCIoMCQxKVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezUsNn0pXCIsXCIkMSAkMlwiLFtcIls4OV1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHs3fSlcIixcIiQxICQyXCIsW1wiNzBcIl0sXCIwJDFcIl0sW1wiKFxcXFxkKShcXFxcZHs0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjdcIl0sXCIwJDFcIl1dLFwiMFwiXSxcIkpQXCI6W1wiODFcIixcIjAxMFwiLFwiMDBbMS05XVxcXFxkezYsMTR9fFsyNTctOV1cXFxcZHs5fXwoPzowMHxbMS05XVxcXFxkXFxcXGQpXFxcXGR7Nn1cIixbOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3XSxbW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMS0kMi0kM1wiLFtcIig/OjEyfDU3fDk5KTBcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezR9KShcXFxcZCkoXFxcXGR7NH0pXCIsXCIkMS0kMi0kM1wiLFtcIjEoPzoyNnwzWzc5XXw0WzU2XXw1WzQtNjhdfDZbMy01XSl8NDk5fDUoPzo3Nnw5Nyl8NzQ2fDgoPzozWzg5XXw0N3w1MXw2Myl8OSg/OjQ5fDgwfDlbMTZdKVwiLFwiMSg/OjI2N3wzKD86N1syNDddfDlbMjc4XSl8NDY2fDUoPzo0N3w1OHw2NCl8Nig/OjNbMjQ1XXw0OHw1WzQtNjhdKSl8NDk5WzI0NjhdfDUoPzo3Nnw5Nyk5fDc0Njh8OCg/OjMoPzo4Wzc4XXw5Nil8NDc3fDUxWzI0XXw2MzYpfDkoPzo0OTZ8ODAyfDkoPzoxWzIzXXw2OSkpfDEoPzo0NXw1OClbNjddXCIsXCIxKD86MjY3fDMoPzo3WzI0N118OVsyNzhdKXw0NjZ8NSg/OjQ3fDU4fDY0KXw2KD86M1syNDVdfDQ4fDVbNC02OF0pKXw0OTlbMjQ2OF18NSg/Ojc2OXw5NzlbMi02OV0pfDc0Njh8OCg/OjMoPzo4Wzc4XXw5NlsyNDU3LTldKXw0Nzd8NTFbMjRdfDYzNls0NTctOV0pfDkoPzo0OTZ8ODAyfDkoPzoxWzIzXXw2OSkpfDEoPzo0NXw1OClbNjddXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEtJDItJDNcIixbXCI2MFwiXSxcIjAkMVwiXSxbXCIoXFxcXGQpKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxLSQyLSQzXCIsW1wiWzM2XXw0KD86MlswOV18N1swMV0pXCIsXCJbMzZdfDQoPzoyKD86MHw5WzAyLTY5XSl8Nyg/OjBbMDE5XXwxKSlcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMS0kMi0kM1wiLFtcIjEoPzoxfDVbNDVdfDc3fDg4fDlbNjldKXwyKD86MlsxLTM3XXwzWzAtMjY5XXw0WzU5XXw1fDZbMjRdfDdbMS0zNThdfDhbMTM2OV18OVswLTM4XSl8NCg/OlsyOF1bMS05XXwzWzAtNTddfFs0NV18NlsyNDhdfDdbMi01NzldfDlbMjldKXw1KD86MnwzWzA0NV18NFswLTM2OV18NVsyOV18OFswMjM4OV18OVswLTM4OV0pfDcoPzoyWzAyLTQ2LTldfDM0fFs1OF18NlswMjQ5XXw3WzU3XXw5WzItNl0pfDgoPzoyWzEyNDU4OV18M1syNzldfDQ5fDZ8N1swLTQ2OF18OFs2OF18OVswMTldKXw5KD86WzIzXVsxLTldfDRbMTVdfDVbMTM4XXw2WzEtM118N1sxNTZdfDhbMTg5XXw5WzEtNDg5XSlcIixcIjEoPzoxfDUoPzo0WzAxOF18NVswMTddKXw3N3w4OHw5WzY5XSl8Mig/OjIoPzpbMTI3XXwzWzAxNC05XSl8M1swLTI2OV18NFs1OV18NSg/OlswNDY4XVswMV18WzEtM118NVswLTY5XXw5WzE5XSl8NjJ8Nyg/OlsxLTM1XXw4WzAxODldKXw4KD86WzE2XXwzWzAxMzRdfDlbMC01XSl8OSg/OlswMjhdfDE3KSl8NCg/OjIoPzpbMTMtNzldfDJbMDFdfDhbMDE0LTZdKXwzWzAtNTddfFs0NV18NlsyNDhdfDdbMi00N118OFsxLTldKXw1KD86MnwzWzA0NV18NFswLTM2OV18OFswMjM4OV18OVswLTNdKXw3KD86MlswMi00Ni05XXwzNHxbNThdfDZbMDI0OV18N1s1N118OSg/OlsyM118NFswLTU5XXw1WzAxNTY5XXw2WzAxNjddKSl8OCg/OjIoPzpbMTI1OF18NFswLTM5XXw5WzAtMjQ2OV0pfDQ5fDYoPzpbMC0yNF18MzZ8NVswLTM1ODldfDcyfDlbMDE0NTldKXw3WzAtNDY4XXw4WzY4XSl8OSg/OlsyM11bMS05XXw0WzE1XXw1WzEzOF18NlsxLTNdfDdbMTU2XXw4WzE4OV18OSg/OlsxMjg5XXwzWzM0XXw0WzAxNzhdKSl8KD86NDl8NTV8ODMpWzI5XXwoPzoyNjR8ODM3KVswMTYtOV18Mig/OjU3fDkzKVswMTUtOV18KD86NDdbNTldfDU5Wzg5XXw4KD86Nls2OF18OSkpWzAxOV1cIixcIjEoPzoxfDUoPzo0WzAxOF18NVswMTddKXw3N3w4OHw5WzY5XSl8Mig/OjJbMTI3XXwzWzAtMjY5XXw0WzU5XXw1KD86WzA0NjhdWzAxXXxbMS0zXXw1WzAtNjldfDkoPzoxN3w5OSkpfDYoPzoyfDRbMDE2LTldKXw3KD86WzEtMzVdfDhbMDE4OV0pfDgoPzpbMTZdfDNbMDEzNF18OVswLTVdKXw5KD86WzAyOF18MTcpKXw0KD86Mig/OlsxMy03OV18MlswMV18OFswMTQtNl0pfDNbMC01N118WzQ1XXw2WzI0OF18N1syLTQ3XXw5WzI5XSl8NSg/OjJ8M1swNDVdfDRbMC0zNjldfDVbMjldfDhbMDIzODldfDlbMC0zXSl8Nyg/OjJbMDItNDYtOV18MzR8WzU4XXw2WzAyNDldfDdbNTddfDkoPzpbMjNdfDRbMC01OV18NVswMTU2OV18NlswMTY3XSkpfDgoPzoyKD86WzEyNThdfDRbMC0zOV18OVswMTY5XSl8Myg/OlsyOV18Nyg/OlswMTctOV18Nls2LThdKSl8NDl8Nig/OlswLTI0XXwzNlsyM118NSg/OlswLTM4OV18NVsyM10pfDYoPzpbMDFdfDlbMTc4XSl8NzJ8OVswMTQ1XSl8N1swLTQ2OF18OFs2OF0pfDkoPzo0WzE1XXw1WzEzOF18N1sxNTZdfDhbMTg5XXw5KD86WzEyODldfDMoPzozMXw0WzM1N10pfDRbMDE3OF0pKXwoPzo4Mjk0fDk2KVsxLTNdfDIoPzo1N3w5MylbMDE1LTldfCg/OjIyM3w4Njk5KVswMTQtOV18KD86NDh8ODI5Mnw5WzIzXSlbMS05XXwoPzo0N1s1OV18NTlbODldfDgoPzo2OHw5KSlbMDE5XVwiLFwiMSg/OjF8NSg/OjRbMDE4XXw1WzAxN10pfDc3fDg4fDlbNjldKXwyKD86MlsxMjddfDNbMC0yNjldfDRbNTldfDUoPzpbMDQ2OF1bMDFdfFsxLTNdfDVbMC02OV18N1swMTUtOV18OSg/OjE3fDk5KSl8Nig/OjJ8NFswMTYtOV0pfDcoPzpbMS0zNV18OFswMTg5XSl8OCg/OlsxNl18M1swMTM0XXw5WzAtNV0pfDkoPzpbMDI4XXwxN3wzWzAxNS05XSkpfDQoPzoyKD86WzEzLTc5XXwyWzAxXXw4WzAxNC02XSl8M1swLTU3XXxbNDVdfDZbMjQ4XXw3WzItNDddfDlbMjldKXw1KD86MnwzWzA0NV18NFswLTM2OV18NVsyOV18OFswMjM4OV18OVswLTNdKXw3KD86MlswMi00Ni05XXwzNHxbNThdfDZbMDI0OV18N1s1N118OSg/OlsyM118NFswLTU5XXw1WzAxNTY5XXw2WzAxNjddKSl8OCg/OjIoPzpbMTI1OF18NFswLTM5XXw5KD86WzAxOV18NFsxLTNdfDYoPzpbMC00Ny05XXw1WzAxMzQ2LTldKSkpfDMoPzpbMjldfDcoPzpbMDE3LTldfDZbNi04XSkpfDQ5fDYoPzpbMC0yNF18MzZbMjNdfDUoPzpbMC0zODldfDVbMjNdKXw2KD86WzAxXXw5WzE3OF0pfDcyfDlbMDE0NV0pfDdbMC00NjhdfDhbNjhdKXw5KD86NFsxNV18NVsxMzhdfDZbMS0zXXw3WzE1Nl18OFsxODldfDkoPzpbMTI4OV18Myg/OjMxfDRbMzU3XSl8NFswMTc4XSkpfCg/OjIyM3w4Njk5KVswMTQtOV18KD86NDh8ODI5KD86Mnw2Nil8OVsyM10pWzEtOV18KD86NDdbNTldfDU5Wzg5XXw4KD86Njh8OSkpWzAxOV1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7NH0pXCIsXCIkMS0kMi0kM1wiLFtcIlsxNF18WzI5XVsyLTldfDVbMy05XXw3WzItNDY3OV18OCg/OlsyNDYtOV18M1szLThdfDVbMi05XSlcIixcIlsxNF18WzI5XVsyLTldfDVbMy05XXw3WzItNDY3OV18OCg/OlsyNDYtOV18Myg/OlszLTZdWzItOV18N3w4WzItNV0pfDVbMi05XSlcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMS0kMi0kM1wiLFtcIjgwMFwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxLSQyLSQzXCIsW1wiWzI1NzldfDgwXCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJLRVwiOltcIjI1NFwiLFwiMDAwXCIsXCIoPzpbMTddXFxcXGRcXFxcZHw5MDApXFxcXGR7Nn18KD86Mnw4MCkwXFxcXGR7Niw3fXxbNC02XVxcXFxkezYsOH1cIixbNyw4LDksMTBdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezUsN30pXCIsXCIkMSAkMlwiLFtcIlsyNC02XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezZ9KVwiLFwiJDEgJDJcIixbXCJbMTddXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezMsNH0pXCIsXCIkMSAkMiAkM1wiLFtcIls4OV1cIl0sXCIwJDFcIl1dLFwiMFwiXSxcIktHXCI6W1wiOTk2XCIsXCIwMFwiLFwiOFxcXFxkezl9fCg/OlsyMzUtOF1cXFxcZHw5OSlcXFxcZHs3fVwiLFs5LDEwXSxbW1wiKFxcXFxkezR9KShcXFxcZHs1fSlcIixcIiQxICQyXCIsW1wiMyg/OjFbMzQ2XXxbMjQtNzldKVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiWzIzNS03OV18ODhcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGQpKFxcXFxkezIsM30pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIjhcIl0sXCIwJDFcIl1dLFwiMFwiXSxcIktIXCI6W1wiODU1XCIsXCIwMFsxNC05XVwiLFwiMVxcXFxkezl9fFsxLTldXFxcXGR7Nyw4fVwiLFs4LDksMTBdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHszLDR9KVwiLFwiJDEgJDIgJDNcIixbXCJbMS05XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7NH0pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiMVwiXV1dLFwiMFwiXSxcIktJXCI6W1wiNjg2XCIsXCIwMFwiLFwiKD86WzM3XVxcXFxkfDZbMC03OV0pXFxcXGR7Nn18KD86WzItNDhdXFxcXGR8NTApXFxcXGR7M31cIixbNSw4XSwwLFwiMFwiXSxcIktNXCI6W1wiMjY5XCIsXCIwMFwiLFwiWzM0NzhdXFxcXGR7Nn1cIixbN10sW1tcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDNcIixbXCJbMzQ3OF1cIl1dXV0sXCJLTlwiOltcIjFcIixcIjAxMVwiLFwiKD86WzU4XVxcXFxkXFxcXGR8OTAwKVxcXFxkezd9XCIsWzEwXSwwLFwiMVwiLDAsXCIxfChbMi03XVxcXFxkezZ9KSRcIixcIjg2OSQxXCIsMCxcIjg2OVwiXSxcIktQXCI6W1wiODUwXCIsXCIwMHw5OVwiLFwiODVcXFxcZHs2fXwoPzoxOVxcXFxkfFsyLTddKVxcXFxkezd9XCIsWzgsMTBdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiOFwiXSxcIjAkMVwiXSxbXCIoXFxcXGQpKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiWzItN11cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjFcIl0sXCIwJDFcIl1dLFwiMFwiXSxcIktSXCI6W1wiODJcIixcIjAwKD86WzEyNTY4OV18Myg/Ols0Nl01fDkxKXw3KD86MDB8Mjd8M3w1NXw2WzEyNl0pKVwiLFwiMDBbMS05XVxcXFxkezgsMTF9fCg/OlsxMl18NVxcXFxkezN9KVxcXFxkezd9fFsxMy02XVxcXFxkezl9fCg/OlsxLTZdXFxcXGR8ODApXFxcXGR7N318WzMtNl1cXFxcZHs0LDV9fCg/OjAwfDcpMFxcXFxkezh9XCIsWzUsNiw4LDksMTAsMTEsMTIsMTMsMTRdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezMsNH0pXCIsXCIkMS0kMlwiLFtcIig/OjNbMS0zXXxbNDZdWzEtNF18NVsxLTVdKTFcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxLSQyXCIsW1wiMVwiXV0sW1wiKFxcXFxkKShcXFxcZHszLDR9KShcXFxcZHs0fSlcIixcIiQxLSQyLSQzXCIsW1wiMlwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxLSQyLSQzXCIsW1wiNjB8OFwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezMsNH0pKFxcXFxkezR9KVwiLFwiJDEtJDItJDNcIixbXCJbMTM0Nl18NVsxLTVdXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEtJDItJDNcIixbXCJbNTddXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7NX0pKFxcXFxkezR9KVwiLFwiJDEtJDItJDNcIixbXCI1XCJdLFwiMCQxXCJdXSxcIjBcIiwwLFwiMCg4KD86WzEtNDYtOF18NVxcXFxkXFxcXGQpKT9cIl0sXCJLV1wiOltcIjk2NVwiLFwiMDBcIixcIig/OjE4fFsyNTY5XVxcXFxkXFxcXGQpXFxcXGR7NX1cIixbNyw4XSxbW1wiKFxcXFxkezR9KShcXFxcZHszLDR9KVwiLFwiJDEgJDJcIixbXCJbMTY5XXwyKD86WzIzNV18NFsxLTM1LTldKXw1MlwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHs1fSlcIixcIiQxICQyXCIsW1wiWzI1XVwiXV1dXSxcIktZXCI6W1wiMVwiLFwiMDExXCIsXCIoPzozNDV8WzU4XVxcXFxkXFxcXGR8OTAwKVxcXFxkezd9XCIsWzEwXSwwLFwiMVwiLDAsXCIxfChbMi05XVxcXFxkezZ9KSRcIixcIjM0NSQxXCIsMCxcIjM0NVwiXSxcIktaXCI6W1wiN1wiLFwiODEwXCIsXCIzMzYyMlxcXFxkezV9fCg/OjdcXFxcZHw4MClcXFxcZHs4fVwiLFsxMF0sMCxcIjhcIiwwLDAsMCwwLFwiMzN8N1wiLDAsXCI4fjEwXCJdLFwiTEFcIjpbXCI4NTZcIixcIjAwXCIsXCJbMjNdXFxcXGR7OX18M1xcXFxkezh9fCg/OlsyMzUtOF1cXFxcZHw0MSlcXFxcZHs2fVwiLFs4LDksMTBdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiMlsxM118M1sxNF18WzQtOF1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCIzMFswMTMtOV1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCJbMjNdXCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJMQlwiOltcIjk2MVwiLFwiMDBcIixcIls3LTldXFxcXGR7N318WzEzLTldXFxcXGR7Nn1cIixbNyw4XSxbW1wiKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIlsxMy02OV18Nyg/OlsyLTU3XXw2Mnw4WzAtN118OVswNC05XSl8OFswMi05XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiWzctOV1cIl1dXSxcIjBcIl0sXCJMQ1wiOltcIjFcIixcIjAxMVwiLFwiKD86WzU4XVxcXFxkXFxcXGR8NzU4fDkwMClcXFxcZHs3fVwiLFsxMF0sMCxcIjFcIiwwLFwiMXwoWzItOF1cXFxcZHs2fSkkXCIsXCI3NTgkMVwiLDAsXCI3NThcIl0sXCJMSVwiOltcIjQyM1wiLFwiMDBcIixcIjkwXFxcXGR7NX18KD86WzIzNzhdfDZcXFxcZFxcXFxkKVxcXFxkezZ9XCIsWzcsOV0sW1tcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDNcIixbXCJbMjM3LTldXCJdXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiNjlcIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCI2XCJdXV0sXCIwXCIsMCxcIjB8KDEwMDEpXCJdLFwiTEtcIjpbXCI5NFwiLFwiMDBcIixcIlsxLTldXFxcXGR7OH1cIixbOV0sW1tcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCI3XCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCJbMS02ODldXCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJMUlwiOltcIjIzMVwiLFwiMDBcIixcIig/OjJ8MzN8NVxcXFxkfDc3fDg4KVxcXFxkezd9fFs0LTZdXFxcXGR7Nn1cIixbNyw4LDldLFtbXCIoXFxcXGQpKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiWzQtNl1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIjJcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIlszNTc4XVwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiTFNcIjpbXCIyNjZcIixcIjAwXCIsXCIoPzpbMjU2XVxcXFxkXFxcXGR8ODAwKVxcXFxkezV9XCIsWzhdLFtbXCIoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCJbMjU2OF1cIl1dXV0sXCJMVFwiOltcIjM3MFwiLFwiMDBcIixcIig/OlszNDY5XVxcXFxkfDUyfFs3OF0wKVxcXFxkezZ9XCIsWzhdLFtbXCIoXFxcXGQpKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiNTJbMC03XVwiXSxcIig4LSQxKVwiLDFdLFtcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCJbNy05XVwiXSxcIjggJDFcIiwxXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezZ9KVwiLFwiJDEgJDJcIixbXCIzN3w0KD86WzE1XXw2WzEtOF0pXCJdLFwiKDgtJDEpXCIsMV0sW1wiKFxcXFxkezN9KShcXFxcZHs1fSlcIixcIiQxICQyXCIsW1wiWzMtNl1cIl0sXCIoOC0kMSlcIiwxXV0sXCI4XCIsMCxcIlswOF1cIl0sXCJMVVwiOltcIjM1MlwiLFwiMDBcIixcIjM1WzAxMy05XVxcXFxkezQsOH18NlxcXFxkezh9fDM1XFxcXGR7Miw0fXwoPzpbMjQ1Ny05XVxcXFxkfDNbMC00Ni05XSlcXFxcZHsyLDl9XCIsWzQsNSw2LDcsOCw5LDEwLDExXSxbW1wiKFxcXFxkezJ9KShcXFxcZHszfSlcIixcIiQxICQyXCIsW1wiMig/OjBbMi02ODldfFsyLTldKXxbMy01N118OCg/OjBbMi05XXxbMTMtOV0pfDkoPzowWzg5XXxbMi01NzldKVwiXV0sW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkM1wiLFtcIjIoPzowWzItNjg5XXxbMi05XSl8WzMtNTddfDgoPzowWzItOV18WzEzLTldKXw5KD86MFs4OV18WzItNTc5XSlcIl1dLFtcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCIyMFsyLTY4OV1cIl1dLFtcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsxLDJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCIyKD86WzAzNjddfDRbMy04XSlcIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCI4MFswMV18OTBbMDE1XVwiXV0sW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCIyMFwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIjZcIl1dLFtcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7MSwyfSlcIixcIiQxICQyICQzICQ0ICQ1XCIsW1wiMig/OlswMzY3XXw0WzMtOF0pXCJdXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7MSw1fSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzMtNTddfDhbMTMtOV18OSg/OjBbODldfFsyLTU3OV0pfCg/OjJ8ODApWzItOV1cIl1dXSwwLDAsXCIoMTUoPzowWzA2XXwxWzEyXXxbMzVdNXw0WzA0XXw2WzI2XXw3N3w4OHw5OSlcXFxcZClcIl0sXCJMVlwiOltcIjM3MVwiLFwiMDBcIixcIig/OlsyNjhdXFxcXGR8OTApXFxcXGR7Nn1cIixbOF0sW1tcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCJbMjY5XXw4WzAxXVwiXV1dXSxcIkxZXCI6W1wiMjE4XCIsXCIwMFwiLFwiWzItOV1cXFxcZHs4fVwiLFs5XSxbW1wiKFxcXFxkezJ9KShcXFxcZHs3fSlcIixcIiQxLSQyXCIsW1wiWzItOV1cIl0sXCIwJDFcIl1dLFwiMFwiXSxcIk1BXCI6W1wiMjEyXCIsXCIwMFwiLFwiWzUtOF1cXFxcZHs4fVwiLFs5XSxbW1wiKFxcXFxkezV9KShcXFxcZHs0fSlcIixcIiQxLSQyXCIsW1wiNSg/OjI5fDM4KVwiLFwiNSg/OjI5fDM4KVs4OV1cIixcIjUoPzoyOXwzOClbODldMFwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIjVbNDVdXCJdLFwiMCQxXCJdLFtcIihcXFxcZHs0fSkoXFxcXGR7NX0pXCIsXCIkMS0kMlwiLFtcIjUoPzoyWzItNDg5XXwzWzUtOV18OSl8ODkyXCIsXCI1KD86Mig/OlsyLTQ5XXw4WzIzNS05XSl8M1s1LTldfDkpfDg5MlwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezd9KVwiLFwiJDEtJDJcIixbXCI4XCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7Nn0pXCIsXCIkMS0kMlwiLFtcIls1LTddXCJdLFwiMCQxXCJdXSxcIjBcIiwwLDAsMCwwLDAsW1tcIjUoPzoyOSg/OlsxODldWzA1XXwyWzI5XXwzWzAxXSl8MzhbODldWzA1XSlcXFxcZHs0fXw1KD86Mig/OlswMTUtN11cXFxcZHwyWzAyLTldfDNbMC01NzhdfDRbMDItNDYtOF18OFswMjM1LTddfDkwKXwzKD86WzAtNDddXFxcXGR8NVswMi05XXw2WzAyLThdfDgwfDlbMy05XSl8KD86NFswNjddfDVbMDNdKVxcXFxkKVxcXFxkezV9XCJdLFtcIig/OjYoPzpbMC03OV1cXFxcZHw4WzAtMjQ3LTldKXw3KD86MFswMTYtOF18NlsxMjY3XXw3WzAtMjddKSlcXFxcZHs2fVwiXSxbXCI4MFxcXFxkezd9XCJdLFtcIjg5XFxcXGR7N31cIl0sMCwwLDAsMCxbXCI1OTIoPzo0WzAtMl18OTMpXFxcXGR7NH1cIl1dXSxcIk1DXCI6W1wiMzc3XCIsXCIwMFwiLFwiODcwXFxcXGR7NX18KD86WzM0OV18NlxcXFxkKVxcXFxkezd9XCIsWzgsOV0sW1tcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCI0XCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzM5XVwiXV0sW1wiKFxcXFxkKShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0ICQ1XCIsW1wiNlwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiTURcIjpbXCIzNzNcIixcIjAwXCIsXCIoPzpbMjM1LTddXFxcXGR8Wzg5XTApXFxcXGR7Nn1cIixbOF0sW1tcIihcXFxcZHszfSkoXFxcXGR7NX0pXCIsXCIkMSAkMlwiLFtcIls4OV1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIjIyfDNcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIlsyNS03XVwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiTUVcIjpbXCIzODJcIixcIjAwXCIsXCIoPzoyMHxbMy03OV1cXFxcZClcXFxcZHs2fXw4MFxcXFxkezYsN31cIixbOCw5XSxbW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Myw0fSlcIixcIiQxICQyICQzXCIsW1wiWzItOV1cIl0sXCIwJDFcIl1dLFwiMFwiXSxcIk1GXCI6W1wiNTkwXCIsXCIwMFwiLFwiKD86NTkwfDY5XFxcXGR8OTc2KVxcXFxkezZ9XCIsWzldLDAsXCIwXCIsMCwwLDAsMCwwLFtbXCI1OTAoPzowWzA3OV18WzE0XTN8WzI3XVs3OV18MzB8NVswLTI2OF18ODcpXFxcXGR7NH1cIl0sW1wiNjkoPzowXFxcXGRcXFxcZHwxKD86MlsyOV18M1swLTVdKSlcXFxcZHs0fVwiXSwwLDAsMCwwLDAsMCxbXCI5NzZbMDFdXFxcXGR7NX1cIl1dXSxcIk1HXCI6W1wiMjYxXCIsXCIwMFwiLFwiWzIzXVxcXFxkezh9XCIsWzldLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIlsyM11cIl0sXCIwJDFcIl1dLFwiMFwiLDAsXCIwfChbMjQtOV1cXFxcZHs2fSkkXCIsXCIyMCQxXCJdLFwiTUhcIjpbXCI2OTJcIixcIjAxMVwiLFwiMzI5XFxcXGR7NH18KD86WzI1Nl1cXFxcZHw0NSlcXFxcZHs1fVwiLFs3XSxbW1wiKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxLSQyXCIsW1wiWzItNl1cIl1dXSxcIjFcIl0sXCJNS1wiOltcIjM4OVwiLFwiMDBcIixcIlsyLTU3OF1cXFxcZHs3fVwiLFs4XSxbW1wiKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjJcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIlszNDddXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGQpKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzU4XVwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiTUxcIjpbXCIyMjNcIixcIjAwXCIsXCJbMjQtOV1cXFxcZHs3fVwiLFs4XSxbW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCJbMjQtOV1cIl1dXV0sXCJNTVwiOltcIjk1XCIsXCIwMFwiLFwiMVxcXFxkezUsN318OTVcXFxcZHs2fXwoPzpbNC03XXw5WzAtNDYtOV0pXFxcXGR7Niw4fXwoPzoyfDhcXFxcZClcXFxcZHs1LDh9XCIsWzYsNyw4LDksMTBdLFtbXCIoXFxcXGQpKFxcXFxkezJ9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiMTZ8MlwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiWzQ1XXw2KD86MFsyM118WzEtNjg5XXw3WzIzNS03XSl8Nyg/OlswLTRdfDVbMi03XSl8OFsxLTZdXCJdLFwiMCQxXCJdLFtcIihcXFxcZCkoXFxcXGR7M30pKFxcXFxkezMsNH0pXCIsXCIkMSAkMiAkM1wiLFtcIlsxMl1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Myw0fSlcIixcIiQxICQyICQzXCIsW1wiWzQtN118OFsxLTM1XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGQpKFxcXFxkezN9KShcXFxcZHs0LDZ9KVwiLFwiJDEgJDIgJDNcIixbXCI5KD86MlswLTRdfFszNS05XXw0WzEzNy05XSlcIl0sXCIwJDFcIl0sW1wiKFxcXFxkKShcXFxcZHs0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjJcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjhcIl0sXCIwJDFcIl0sW1wiKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCI5MlwiXSxcIjAkMVwiXSxbXCIoXFxcXGQpKFxcXFxkezV9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiOVwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiTU5cIjpbXCI5NzZcIixcIjAwMVwiLFwiWzEyXVxcXFxkezcsOX18WzU3LTldXFxcXGR7N31cIixbOCw5LDEwXSxbW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIlsxMl0xXCJdLFwiMCQxXCJdLFtcIihcXFxcZHs0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIls1Ny05XVwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHs1LDZ9KVwiLFwiJDEgJDJcIixbXCJbMTJdMlsxLTNdXCJdLFwiMCQxXCJdLFtcIihcXFxcZHs0fSkoXFxcXGR7NSw2fSlcIixcIiQxICQyXCIsW1wiWzEyXSg/OjI3fDNbMi04XXw0WzItNjhdfDVbMS00Njg5XSlcIixcIlsxMl0oPzoyN3wzWzItOF18NFsyLTY4XXw1WzEtNDY4OV0pWzAtM11cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezV9KShcXFxcZHs0LDV9KVwiLFwiJDEgJDJcIixbXCJbMTJdXCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJNT1wiOltcIjg1M1wiLFwiMDBcIixcIig/OjI4fFs2OF1cXFxcZClcXFxcZHs2fVwiLFs4XSxbW1wiKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiWzI2OF1cIl1dXV0sXCJNUFwiOltcIjFcIixcIjAxMVwiLFwiWzU4XVxcXFxkezl9fCg/OjY3fDkwKTBcXFxcZHs3fVwiLFsxMF0sMCxcIjFcIiwwLFwiMXwoWzItOV1cXFxcZHs2fSkkXCIsXCI2NzAkMVwiLDAsXCI2NzBcIl0sXCJNUVwiOltcIjU5NlwiLFwiMDBcIixcIjY5XFxcXGR7N318KD86NTl8OTcpNlxcXFxkezZ9XCIsWzldLFtbXCIoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIls1NjldXCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJNUlwiOltcIjIyMlwiLFwiMDBcIixcIig/OlsyLTRdXFxcXGRcXFxcZHw4MDApXFxcXGR7NX1cIixbOF0sW1tcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzItNDhdXCJdXV1dLFwiTVNcIjpbXCIxXCIsXCIwMTFcIixcIig/Ols1OF1cXFxcZFxcXFxkfDY2NHw5MDApXFxcXGR7N31cIixbMTBdLDAsXCIxXCIsMCxcIjF8KFszNF1cXFxcZHs2fSkkXCIsXCI2NjQkMVwiLDAsXCI2NjRcIl0sXCJNVFwiOltcIjM1NlwiLFwiMDBcIixcIjM1NTBcXFxcZHs0fXwoPzpbMjU3OV1cXFxcZFxcXFxkfDgwMClcXFxcZHs1fVwiLFs4XSxbW1wiKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiWzIzNTctOV1cIl1dXV0sXCJNVVwiOltcIjIzMFwiLFwiMCg/OjB8WzI0LTddMHwzWzAzXSlcIixcIig/OlsyLTQ2OF18NVxcXFxkKVxcXFxkezZ9XCIsWzcsOF0sW1tcIihcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIlsyLTQ2XXw4WzAxM11cIl1dLFtcIihcXFxcZHs0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIjVcIl1dXSwwLDAsMCwwLDAsMCwwLFwiMDIwXCJdLFwiTVZcIjpbXCI5NjBcIixcIjAoPzowfDE5KVwiLFwiKD86ODAwfDlbMC01Ny05XVxcXFxkKVxcXFxkezd9fFszNDY3OV1cXFxcZHs2fVwiLFs3LDEwXSxbW1wiKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxLSQyXCIsW1wiWzM0NjddfDlbMTMtOV1cIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCJbODldXCJdXV0sMCwwLDAsMCwwLDAsMCxcIjAwXCJdLFwiTVdcIjpbXCIyNjVcIixcIjAwXCIsXCIxXFxcXGR7Nn0oPzpcXFxcZHsyfSk/fCg/OlsyM10xfDc3fDg4fDk5KVxcXFxkezd9XCIsWzcsOV0sW1tcIihcXFxcZCkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCIxWzItOV1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIjJcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCJbMTM3LTldXCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJNWFwiOltcIjUyXCIsXCIwWzA5XVwiLFwiKD86MSg/OlswMTQ2N11cXFxcZHxbMjM1OV1bMS05XXw4WzEtNzldKXxbMi05XVxcXFxkKVxcXFxkezh9XCIsWzEwLDExXSxbW1wiKFxcXFxkezJ9KShcXFxcZHs0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjMzfDVbNTZdfDgxXCJdLDAsMV0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIlsyLTldXCJdLDAsMV0sW1wiKFxcXFxkKShcXFxcZHsyfSkoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDIgJDMgJDRcIixbXCIxKD86MzN8NVs1Nl18ODEpXCJdLDAsMV0sW1wiKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDIgJDMgJDRcIixbXCIxXCJdLDAsMV1dLFwiMDFcIiwwLFwiMCg/OlsxMl18NFs0NV0pfDFcIiwwLDAsMCwwLFwiMDBcIl0sXCJNWVwiOltcIjYwXCIsXCIwMFwiLFwiMVxcXFxkezgsOX18KD86M1xcXFxkfFs0LTldKVxcXFxkezd9XCIsWzgsOSwxMF0sW1tcIihcXFxcZCkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEtJDIgJDNcIixbXCJbNC03OV1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Myw0fSlcIixcIiQxLSQyICQzXCIsW1wiMSg/OlswMjQ2OV18WzM3OF1bMS05XSl8OFwiXSxcIjAkMVwiXSxbXCIoXFxcXGQpKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxLSQyICQzXCIsW1wiM1wiXSxcIjAkMVwiXSxbXCIoXFxcXGQpKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7NH0pXCIsXCIkMS0kMi0kMy0kNFwiLFtcIjFbMzYtOF1cIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEtJDIgJDNcIixbXCIxNVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxLSQyICQzXCIsW1wiMVwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiTVpcIjpbXCIyNThcIixcIjAwXCIsXCIoPzoyfDhcXFxcZClcXFxcZHs3fVwiLFs4LDldLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHszLDR9KVwiLFwiJDEgJDIgJDNcIixbXCIyfDhbMi03OV1cIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCI4XCJdXV1dLFwiTkFcIjpbXCIyNjRcIixcIjAwXCIsXCJbNjhdXFxcXGR7Nyw4fVwiLFs4LDldLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiODhcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Myw0fSlcIixcIiQxICQyICQzXCIsW1wiNlwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiODdcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjhcIl0sXCIwJDFcIl1dLFwiMFwiXSxcIk5DXCI6W1wiNjg3XCIsXCIwMFwiLFwiWzItNTctOV1cXFxcZHs1fVwiLFs2XSxbW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMS4kMi4kM1wiLFtcIlsyLTU3LTldXCJdXV1dLFwiTkVcIjpbXCIyMjdcIixcIjAwXCIsXCJbMDI4OV1cXFxcZHs3fVwiLFs4XSxbW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIjA4XCJdXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIlswODldfDJbMDEzXVwiXV1dXSxcIk5GXCI6W1wiNjcyXCIsXCIwMFwiLFwiWzEzXVxcXFxkezV9XCIsWzZdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCIxWzAtM11cIl1dLFtcIihcXFxcZCkoXFxcXGR7NX0pXCIsXCIkMSAkMlwiLFtcIlsxM11cIl1dXSwwLDAsXCIoWzAtMjU4XVxcXFxkezR9KSRcIixcIjMkMVwiXSxcIk5HXCI6W1wiMjM0XCIsXCIwMDlcIixcIig/OlsxMjQtN118OVxcXFxkezN9KVxcXFxkezZ9fFsxLTldXFxcXGR7N318Wzc4XVxcXFxkezksMTN9XCIsWzcsOCwxMCwxMSwxMiwxMywxNF0sW1tcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCI3OFwiXSxcIjAkMVwiXSxbXCIoXFxcXGQpKFxcXFxkezN9KShcXFxcZHszLDR9KVwiLFwiJDEgJDIgJDNcIixbXCJbMTJdfDkoPzowWzMtOV18WzEtOV0pXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezIsM30pXCIsXCIkMSAkMiAkM1wiLFtcIlszLTddfDhbMi05XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszLDR9KVwiLFwiJDEgJDIgJDNcIixbXCJbNy05XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezR9KShcXFxcZHs0LDV9KVwiLFwiJDEgJDIgJDNcIixbXCJbNzhdXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7NX0pKFxcXFxkezUsNn0pXCIsXCIkMSAkMiAkM1wiLFtcIls3OF1cIl0sXCIwJDFcIl1dLFwiMFwiXSxcIk5JXCI6W1wiNTA1XCIsXCIwMFwiLFwiKD86MTgwMHxbMjUtOF1cXFxcZHszfSlcXFxcZHs0fVwiLFs4XSxbW1wiKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiWzEyNS04XVwiXV1dXSxcIk5MXCI6W1wiMzFcIixcIjAwXCIsXCIoPzpbMTI0LTddXFxcXGRcXFxcZHwzKD86WzAyLTldXFxcXGR8MVswLThdKSlcXFxcZHs2fXxbODldXFxcXGR7Niw5fXwxXFxcXGR7NCw1fVwiLFs1LDYsNyw4LDksMTBdLFtbXCIoXFxcXGR7M30pKFxcXFxkezQsN30pXCIsXCIkMSAkMlwiLFtcIls4OV0wXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7N30pXCIsXCIkMSAkMlwiLFtcIjY2XCJdLFwiMCQxXCJdLFtcIihcXFxcZCkoXFxcXGR7OH0pXCIsXCIkMSAkMlwiLFtcIjZcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIjFbMTYtOF18MlsyNTldfDNbMTI0XXw0WzE3LTldfDVbMTI0Njc5XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiWzEtNTctOV1cIl0sXCIwJDFcIl1dLFwiMFwiXSxcIk5PXCI6W1wiNDdcIixcIjAwXCIsXCIoPzowfFsyLTldXFxcXGR7M30pXFxcXGR7NH1cIixbNSw4XSxbW1wiKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIls0ODldfDVbODldXCJdXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIlsyMzUtN11cIl1dXSwwLDAsMCwwLDAsXCJbMDItNjg5XXw3WzAtOF1cIl0sXCJOUFwiOltcIjk3N1wiLFwiMDBcIixcIjlcXFxcZHs5fXxbMS05XVxcXFxkezd9XCIsWzgsMTBdLFtbXCIoXFxcXGQpKFxcXFxkezd9KVwiLFwiJDEtJDJcIixbXCIxWzItNl1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHs2fSlcIixcIiQxLSQyXCIsW1wiWzEtOF18OSg/OlsxLTU3OV18NlsyLTZdKVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezd9KVwiLFwiJDEtJDJcIixbXCI5XCJdXV0sXCIwXCJdLFwiTlJcIjpbXCI2NzRcIixcIjAwXCIsXCIoPzo0NDR8KD86NTV8OFxcXFxkKVxcXFxkfDY2NilcXFxcZHs0fVwiLFs3XSxbW1wiKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiWzQtNjhdXCJdXV1dLFwiTlVcIjpbXCI2ODNcIixcIjAwXCIsXCIoPzpbNDddfDg4OFxcXFxkKVxcXFxkezN9XCIsWzQsN10sW1tcIihcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIjhcIl1dXV0sXCJOWlwiOltcIjY0XCIsXCIwKD86MHwxNjEpXCIsXCJbMjldXFxcXGR7Nyw5fXw1MFxcXFxkezV9KD86XFxcXGR7MiwzfSk/fDZbMC0zNS05XVxcXFxkezZ9fDdcXFxcZHs3LDh9fDhcXFxcZHs0LDl9fCg/OjExXFxcXGR8WzM0XSlcXFxcZHs3fVwiLFs1LDYsNyw4LDksMTBdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezMsOH0pXCIsXCIkMSAkMlwiLFtcIjgzXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezIsM30pXCIsXCIkMSAkMiAkM1wiLFtcIjUwWzAzNjddfFs4OV0wXCJdLFwiMCQxXCJdLFtcIihcXFxcZCkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEtJDIgJDNcIixbXCIyNHxbMzQ2XXw3WzItNTctOV18OVsyLTldXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezMsNH0pXCIsXCIkMSAkMiAkM1wiLFtcIjIoPzoxMHw3NCl8WzU5XXw4MFwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezMsNH0pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCIxfDJbMDI4XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHszLDV9KVwiLFwiJDEgJDIgJDNcIixbXCIyKD86WzE2OV18N1swLTM1LTldKXw3fDg2XCJdLFwiMCQxXCJdXSxcIjBcIiwwLDAsMCwwLDAsMCxcIjAwXCJdLFwiT01cIjpbXCI5NjhcIixcIjAwXCIsXCIoPzoxNTA1fFsyNzldXFxcXGR7M318NTAwKVxcXFxkezR9fDgwMDdcXFxcZHs0LDV9XCIsWzcsOCw5XSxbW1wiKFxcXFxkezN9KShcXFxcZHs0LDZ9KVwiLFwiJDEgJDJcIixbXCJbNThdXCJdXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezZ9KVwiLFwiJDEgJDJcIixbXCIyXCJdXSxbXCIoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCJbMTc5XVwiXV1dXSxcIlBBXCI6W1wiNTA3XCIsXCIwMFwiLFwiKD86WzEtNTctOV18NlxcXFxkKVxcXFxkezZ9XCIsWzcsOF0sW1tcIihcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMS0kMlwiLFtcIlsxLTU3LTldXCJdXSxbXCIoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEtJDJcIixbXCI2XCJdXV1dLFwiUEVcIjpbXCI1MVwiLFwiMTkoPzoxWzEyNF18Nzd8OTApMDBcIixcIig/OlsxNC04XXw5XFxcXGQpXFxcXGR7N31cIixbOCw5XSxbW1wiKFxcXFxkezN9KShcXFxcZHs1fSlcIixcIiQxICQyXCIsW1wiODBcIl0sXCIoMCQxKVwiXSxbXCIoXFxcXGQpKFxcXFxkezd9KVwiLFwiJDEgJDJcIixbXCIxXCJdLFwiKDAkMSlcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHs2fSlcIixcIiQxICQyXCIsW1wiWzQtOF1cIl0sXCIoMCQxKVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiOVwiXV1dLFwiMFwiLDAsMCwwLDAsMCwwLDAsXCIgQW5leG8gXCJdLFwiUEZcIjpbXCI2ODlcIixcIjAwXCIsXCJbNDhdXFxcXGR7N318NFxcXFxkezV9XCIsWzYsOF0sW1tcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDNcIixbXCI0NFwiXV0sW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCJbNDhdXCJdXV1dLFwiUEdcIjpbXCI2NzVcIixcIjAwfDE0MFsxLTNdXCIsXCIoPzoxODB8Wzc4XVxcXFxkezN9KVxcXFxkezR9fCg/OlsyLTU4OV1cXFxcZHw2NClcXFxcZHs1fVwiLFs3LDhdLFtbXCIoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCIxOHxbMi02OV18ODVcIl1dLFtcIihcXFxcZHs0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIls3OF1cIl1dXSwwLDAsMCwwLDAsMCwwLFwiMDBcIl0sXCJQSFwiOltcIjYzXCIsXCIwMFwiLFwiMTgwMFxcXFxkezcsOX18KD86MnxbODldXFxcXGR7NH0pXFxcXGR7NX18WzItOF1cXFxcZHs4fXxbMjhdXFxcXGR7N31cIixbNiw4LDksMTAsMTEsMTIsMTNdLFtbXCIoXFxcXGQpKFxcXFxkezV9KVwiLFwiJDEgJDJcIixbXCIyXCJdLFwiKDAkMSlcIl0sW1wiKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjJcIl0sXCIoMCQxKVwiXSxbXCIoXFxcXGR7NH0pKFxcXFxkezQsNn0pXCIsXCIkMSAkMlwiLFtcIjMoPzoyM3wzOXw0Nil8NCg/OjJbMy02XXxbMzVdOXw0WzI2XXw3Nil8NTQ0fDg4WzI0NV18KD86NTJ8NjR8ODYpMlwiLFwiMyg/OjIzMHwzOTd8NDYxKXw0KD86Mig/OjM1fFs0Nl00fDUxKXwzOTZ8NCg/OjIyfDYzKXw1OVszNDddfDc2WzE1XSl8NSg/OjIyMXw0NDYpfDY0MlsyM118OCg/OjYyMnw4KD86WzI0XTJ8NVsxM10pKVwiXSxcIigwJDEpXCJdLFtcIihcXFxcZHs1fSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIjM0Nnw0KD86Mjd8OVszNV0pfDg4M1wiLFwiMzQ2OXw0KD86Mjc5fDkoPzozMHw1NikpfDg4MzRcIl0sXCIoMCQxKVwiXSxbXCIoXFxcXGQpKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiMlwiXSxcIigwJDEpXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCJbMy03XXw4WzItOF1cIl0sXCIoMCQxKVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiWzg5XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7NH0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiMVwiXV0sW1wiKFxcXFxkezR9KShcXFxcZHsxLDJ9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIjFcIl1dXSxcIjBcIl0sXCJQS1wiOltcIjkyXCIsXCIwMFwiLFwiMTIyXFxcXGR7Nn18WzI0LThdXFxcXGR7MTAsMTF9fDkoPzpbMDEzLTldXFxcXGR7OCwxMH18Mig/OlswMV1cXFxcZFxcXFxkfDIoPzpbMDYtOF1cXFxcZHwxWzAxXSkpXFxcXGR7N30pfCg/OlsyLThdXFxcXGR7M318OTIoPzpbMC03XVxcXFxkfDhbMS05XSkpXFxcXGR7Nn18WzI0LTldXFxcXGR7OH18Wzg5XVxcXFxkezd9XCIsWzgsOSwxMCwxMSwxMl0sW1tcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDNcIixbXCJbODldMFwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7NH0pKFxcXFxkezV9KVwiLFwiJDEgJDJcIixbXCIxXCJdXSxbXCIoXFxcXGR7M30pKFxcXFxkezYsN30pXCIsXCIkMSAkMlwiLFtcIjIoPzozWzIzNThdfDRbMi00XXw5WzItOF0pfDQ1WzM0NzldfDU0WzItNDY3XXw2MFs0NjhdfDcyWzIzNl18OCg/OjJbMi02ODldfDNbMjM1NzhdfDRbMzQ3OF18NVsyMzU2XSl8OSg/OjJbMi04XXwzWzI3LTldfDRbMi02XXw2WzM1NjldfDlbMjUtOF0pXCIsXCI5KD86MlszLThdfDk4KXwoPzoyKD86M1syMzU4XXw0WzItNF18OVsyLThdKXw0NVszNDc5XXw1NFsyLTQ2N118NjBbNDY4XXw3MlsyMzZdfDgoPzoyWzItNjg5XXwzWzIzNTc4XXw0WzM0NzhdfDVbMjM1Nl0pfDkoPzoyMnwzWzI3LTldfDRbMi02XXw2WzM1NjldfDlbMjUtN10pKVsyLTldXCJdLFwiKDAkMSlcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHs3LDh9KVwiLFwiJDEgJDJcIixbXCIoPzoyWzEyNV18NFswLTI0Ni05XXw1WzEtMzUtN118NlsxLThdfDdbMTRdfDhbMTZdfDkxKVsyLTldXCJdLFwiKDAkMSlcIl0sW1wiKFxcXFxkezV9KShcXFxcZHs1fSlcIixcIiQxICQyXCIsW1wiNThcIl0sXCIoMCQxKVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezd9KVwiLFwiJDEgJDJcIixbXCIzXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzICQ0XCIsW1wiMlsxMjVdfDRbMC0yNDYtOV18NVsxLTM1LTddfDZbMS04XXw3WzE0XXw4WzE2XXw5MVwiXSxcIigwJDEpXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzI0LTldXCJdLFwiKDAkMSlcIl1dLFwiMFwiXSxcIlBMXCI6W1wiNDhcIixcIjAwXCIsXCJbMS01Ny05XVxcXFxkezZ9KD86XFxcXGR7Mn0pP3w2XFxcXGR7NSw4fVwiLFs2LDcsOCw5XSxbW1wiKFxcXFxkezV9KVwiLFwiJDFcIixbXCIxOVwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyXCIsW1wiMTF8NjRcIl1dLFtcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCIoPzoxWzItOF18MlsyLTY5XXwzWzItNF18NFsxLTQ2OF18NVsyNC02ODldfDZbMS0zNTc4XXw3WzE0LTddfDhbMS03OV18OVsxNDVdKTFcIixcIig/OjFbMi04XXwyWzItNjldfDNbMi00XXw0WzEtNDY4XXw1WzI0LTY4OV18NlsxLTM1NzhdfDdbMTQtN118OFsxLTc5XXw5WzE0NV0pMTlcIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezIsM30pXCIsXCIkMSAkMiAkM1wiLFtcIjY0XCJdXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiMzl8NDV8NVswMTM3XXw2WzA0NjldfDdbMDIzODldfDhbMDhdXCJdXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIjFbMi04XXxbMi04XXw5WzE0NV1cIl1dXV0sXCJQTVwiOltcIjUwOFwiLFwiMDBcIixcIls0NV1cXFxcZHs1fVwiLFs2XSxbW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkM1wiLFtcIls0NV1cIl0sXCIwJDFcIl1dLFwiMFwiXSxcIlBSXCI6W1wiMVwiLFwiMDExXCIsXCIoPzpbNTg5XVxcXFxkXFxcXGR8Nzg3KVxcXFxkezd9XCIsWzEwXSwwLFwiMVwiLDAsMCwwLDAsXCI3ODd8OTM5XCJdLFwiUFNcIjpbXCI5NzBcIixcIjAwXCIsXCJbMjQ4OV0yXFxcXGR7Nn18KD86MVxcXFxkfDUpXFxcXGR7OH1cIixbOCw5LDEwXSxbW1wiKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIlsyNDg5XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiNVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7NH0pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiMVwiXV1dLFwiMFwiXSxcIlBUXCI6W1wiMzUxXCIsXCIwMFwiLFwiKD86WzI2LTldXFxcXGR8MzApXFxcXGR7N31cIixbOV0sW1tcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCIyWzEyXVwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIlsyMzYtOV1cIl1dXV0sXCJQV1wiOltcIjY4MFwiLFwiMDFbMTJdXCIsXCIoPzpbMjQtOF1cXFxcZFxcXFxkfDM0NXw5MDApXFxcXGR7NH1cIixbN10sW1tcIihcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIlsyLTldXCJdXV1dLFwiUFlcIjpbXCI1OTVcIixcIjAwXCIsXCI1OVxcXFxkezQsNn18KD86WzItNDYtOV1cXFxcZHw1WzAtOF0pXFxcXGR7NCw3fVwiLFs2LDcsOCw5XSxbW1wiKFxcXFxkezN9KShcXFxcZHszLDZ9KVwiLFwiJDEgJDJcIixbXCJbMi05XTBcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHs1fSlcIixcIiQxICQyXCIsW1wiWzI2XTF8M1syODldfDRbMTI0Ni04XXw3WzEtM118OFsxLTM2XVwiXSxcIigwJDEpXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7NCw1fSlcIixcIiQxICQyXCIsW1wiMlsyNzldfDNbMTMtNV18NFszNTldfDV8Nig/OlszNF18N1sxLTQ2LThdKXw3WzQ2LThdfDg1XCJdLFwiKDAkMSlcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Myw0fSlcIixcIiQxICQyICQzXCIsW1wiMlsxNC02OF18M1syNi05XXw0WzEyNDYtOF18Nig/OjF8NzUpfDdbMS0zNV18OFsxLTM2XVwiXSxcIigwJDEpXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCI4N1wiXV0sW1wiKFxcXFxkezN9KShcXFxcZHs2fSlcIixcIiQxICQyXCIsW1wiOVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiWzItOF1cIl0sXCIwJDFcIl1dLFwiMFwiXSxcIlFBXCI6W1wiOTc0XCIsXCIwMFwiLFwiWzItN11cXFxcZHs3fXwoPzoyXFxcXGRcXFxcZHw4MDApXFxcXGR7NH1cIixbNyw4XSxbW1wiKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiMlsxMjZdfDhcIl1dLFtcIihcXFxcZHs0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIlsyLTddXCJdXV1dLFwiUkVcIjpbXCIyNjJcIixcIjAwXCIsXCI5NzY5XFxcXGR7NX18KD86MjZ8WzY4XVxcXFxkKVxcXFxkezd9XCIsWzldLFtbXCIoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIlsyNjg5XVwiXSxcIjAkMVwiXV0sXCIwXCIsMCwwLDAsMCxcIjI2WzIzXXw2OXxbODldXCJdLFwiUk9cIjpbXCI0MFwiLFwiMDBcIixcIig/OlsyMzddXFxcXGR8Wzg5XTApXFxcXGR7N318WzIzXVxcXFxkezV9XCIsWzYsOV0sW1tcIihcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMlwiLFtcIjJbMy02XVwiLFwiMlszLTZdXFxcXGQ5XCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIjIxOXwzMVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiWzIzXTFcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIlsyMzctOV1cIl0sXCIwJDFcIl1dLFwiMFwiLDAsMCwwLDAsMCwwLDAsXCIgaW50IFwiXSxcIlJTXCI6W1wiMzgxXCIsXCIwMFwiLFwiMzhbMDItOV1cXFxcZHs2LDl9fDZcXFxcZHs3LDl9fDkwXFxcXGR7NCw4fXwzOFxcXFxkezUsNn18KD86N1xcXFxkXFxcXGR8ODAwKVxcXFxkezMsOX18KD86WzEyXVxcXFxkfDNbMC03OV0pXFxcXGR7NSwxMH1cIixbNiw3LDgsOSwxMCwxMSwxMl0sW1tcIihcXFxcZHszfSkoXFxcXGR7Myw5fSlcIixcIiQxICQyXCIsW1wiKD86MlszODldfDM5KTB8WzctOV1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHs1LDEwfSlcIixcIiQxICQyXCIsW1wiWzEtMzZdXCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJSVVwiOltcIjdcIixcIjgxMFwiLFwiWzM0Ny05XVxcXFxkezl9XCIsWzEwXSxbW1wiKFxcXFxkezR9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCI3KD86MVswLThdfDJbMS05XSlcIixcIjcoPzoxKD86WzAtNl0yfDd8OFsyN10pfDIoPzoxWzIzXXxbMi05XTIpKVwiLFwiNyg/OjEoPzpbMC02XTJ8N3w4WzI3XSl8Mig/OjEzWzAzLTY5XXw2MlswMTMtOV0pKXw3MlsxLTU3LTldMlwiXSxcIjggKCQxKVwiLDFdLFtcIihcXFxcZHs1fSkoXFxcXGQpKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiNyg/OjFbMC02OF18MlsxLTldKVwiLFwiNyg/OjEoPzpbMDZdWzMtNl18WzE4XXwyWzM1XXxbMy01XVszLTVdKXwyKD86WzEzXVszLTVdfFsyNC02ODldfDdbNDU3XSkpXCIsXCI3KD86MSg/OjAoPzpbMzU2XXw0WzAyM10pfFsxOF18Mig/OjNbMDEzLTldfDUpfDNbNDVdfDQzWzAxMy03OV18NSg/OjNbMS04XXw0WzEtN118NSl8Nig/OjNbMC0zNS05XXxbNC02XSkpfDIoPzoxKD86M1sxNzhdfFs0NV0pfFsyNC02ODldfDNbMzVdfDdbNDU3XSkpfDcoPzoxNHwyMyk0WzAtOF18NzEoPzozM3w0NSlbMS03OV1cIl0sXCI4ICgkMSlcIiwxXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiN1wiXSxcIjggKCQxKVwiLDFdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyLSQzLSQ0XCIsW1wiWzM0ODldXCJdLFwiOCAoJDEpXCIsMV1dLFwiOFwiLDAsMCwwLDAsXCIzWzA0LTY4OV18WzQ4OV1cIiwwLFwiOH4xMFwiXSxcIlJXXCI6W1wiMjUwXCIsXCIwMFwiLFwiKD86MDZ8WzI3XVxcXFxkXFxcXGR8Wzg5XTAwKVxcXFxkezZ9XCIsWzgsOV0sW1tcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiMFwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIls3LTldXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCIyXCJdXV0sXCIwXCJdLFwiU0FcIjpbXCI5NjZcIixcIjAwXCIsXCI5MlxcXFxkezd9fCg/OlsxNV18OFxcXFxkKVxcXFxkezh9XCIsWzksMTBdLFtbXCIoXFxcXGR7NH0pKFxcXFxkezV9KVwiLFwiJDEgJDJcIixbXCI5XCJdXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiMVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiNVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszLDR9KVwiLFwiJDEgJDIgJDNcIixbXCI4MVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiOFwiXV1dLFwiMFwiXSxcIlNCXCI6W1wiNjc3XCIsXCIwWzAxXVwiLFwiKD86WzEtNl18WzctOV1cXFxcZFxcXFxkKVxcXFxkezR9XCIsWzUsN10sW1tcIihcXFxcZHsyfSkoXFxcXGR7NX0pXCIsXCIkMSAkMlwiLFtcIjd8OFs0LTldfDkoPzpbMS04XXw5WzAtOF0pXCJdXV1dLFwiU0NcIjpbXCIyNDhcIixcIjAxMHwwWzAtMl1cIixcIjgwMDBcXFxcZHszfXwoPzpbMjQ5XVxcXFxkfDY0KVxcXFxkezV9XCIsWzddLFtbXCIoXFxcXGQpKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiWzI0Nl18OVs1N11cIl1dXSwwLDAsMCwwLDAsMCwwLFwiMDBcIl0sXCJTRFwiOltcIjI0OVwiLFwiMDBcIixcIlsxOV1cXFxcZHs4fVwiLFs5XSxbW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIlsxOV1cIl0sXCIwJDFcIl1dLFwiMFwiXSxcIlNFXCI6W1wiNDZcIixcIjAwXCIsXCIoPzpbMjZdXFxcXGRcXFxcZHw5KVxcXFxkezl9fFsxLTldXFxcXGR7OH18WzEtNjg5XVxcXFxkezd9fFsxLTQ2ODldXFxcXGR7Nn18MlxcXFxkezV9XCIsWzYsNyw4LDksMTBdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezIsM30pKFxcXFxkezJ9KVwiLFwiJDEtJDIgJDNcIixbXCIyMFwiXSxcIjAkMVwiLDAsXCIkMSAkMiAkM1wiXSxbXCIoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEtJDJcIixbXCI5KD86MDB8Mzl8NDQpXCJdLFwiMCQxXCIsMCxcIiQxICQyXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezJ9KVwiLFwiJDEtJDIgJDNcIixbXCJbMTJdWzEzNl18M1szNTZdfDRbMDI0Nl18NlswM118OTBbMS05XVwiXSxcIjAkMVwiLDAsXCIkMSAkMiAkM1wiXSxbXCIoXFxcXGQpKFxcXFxkezIsM30pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxLSQyICQzICQ0XCIsW1wiOFwiXSxcIjAkMVwiLDAsXCIkMSAkMiAkMyAkNFwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezIsM30pKFxcXFxkezJ9KVwiLFwiJDEtJDIgJDNcIixbXCIxWzI0NTddfDIoPzpbMjQ3LTldfDVbMDEzOF0pfDNbMDI0Ny05XXw0WzEzNTctOV18NVswLTM1LTldfDYoPzpbMTI1Njg5XXw0WzAyLTU3XXw3WzAtMl0pfDkoPzpbMTI1LThdfDNbMDItNV18NFswLTNdKVwiXSxcIjAkMVwiLDAsXCIkMSAkMiAkM1wiXSxbXCIoXFxcXGR7M30pKFxcXFxkezIsM30pKFxcXFxkezN9KVwiLFwiJDEtJDIgJDNcIixbXCI5KD86MDB8Mzl8NDQpXCJdLFwiMCQxXCIsMCxcIiQxICQyICQzXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7MiwzfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEtJDIgJDMgJDRcIixbXCIxWzEzNjg5XXwyWzAxMzZdfDNbMTM1Nl18NFswMjQ2XXw1NHw2WzAzXXw5MFsxLTldXCJdLFwiMCQxXCIsMCxcIiQxICQyICQzICQ0XCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxLSQyICQzICQ0XCIsW1wiMTB8N1wiXSxcIjAkMVwiLDAsXCIkMSAkMiAkMyAkNFwiXSxbXCIoXFxcXGQpKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7Mn0pXCIsXCIkMS0kMiAkMyAkNFwiLFtcIjhcIl0sXCIwJDFcIiwwLFwiJDEgJDIgJDMgJDRcIl0sW1wiKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEtJDIgJDMgJDRcIixbXCJbMTMtNV18Mig/OlsyNDctOV18NVswMTM4XSl8Nig/OlsxMjQtNjg5XXw3WzAtMl0pfDkoPzpbMTI1LThdfDNbMDItNV18NFswLTNdKVwiXSxcIjAkMVwiLDAsXCIkMSAkMiAkMyAkNFwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7M30pXCIsXCIkMS0kMiAkMyAkNFwiLFtcIjlcIl0sXCIwJDFcIiwwLFwiJDEgJDIgJDMgJDRcIl0sW1wiKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxLSQyICQzICQ0ICQ1XCIsW1wiWzI2XVwiXSxcIjAkMVwiLDAsXCIkMSAkMiAkMyAkNCAkNVwiXV0sXCIwXCJdLFwiU0dcIjpbXCI2NVwiLFwiMFswLTNdXFxcXGRcIixcIig/Oig/OjFcXFxcZHw4KVxcXFxkXFxcXGR8NzAwMClcXFxcZHs3fXxbMzY4OV1cXFxcZHs3fVwiLFs4LDEwLDExXSxbW1wiKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiWzM2OV18OCg/OjAxfFsxLTldKVwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjhcIl1dLFtcIihcXFxcZHs0fSkoXFxcXGR7NH0pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCI3XCJdXSxbXCIoXFxcXGR7NH0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiMVwiXV1dXSxcIlNIXCI6W1wiMjkwXCIsXCIwMFwiLFwiKD86WzI1Nl1cXFxcZHw4KVxcXFxkezN9XCIsWzQsNV0sMCwwLDAsMCwwLDAsXCJbMjU2XVwiXSxcIlNJXCI6W1wiMzg2XCIsXCIwMHwxMCg/OjIyfDY2fDg4fDk5KVwiLFwiWzEtN11cXFxcZHs3fXw4XFxcXGR7NCw3fXw5MFxcXFxkezQsNn1cIixbNSw2LDcsOF0sW1tcIihcXFxcZHsyfSkoXFxcXGR7Myw2fSlcIixcIiQxICQyXCIsW1wiOFswOV18OVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezV9KVwiLFwiJDEgJDJcIixbXCI1OXw4XCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCJbMzddWzAxXXw0WzAxMzldfDUxfDZcIl0sXCIwJDFcIl0sW1wiKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCJbMS01N11cIl0sXCIoMCQxKVwiXV0sXCIwXCIsMCwwLDAsMCwwLDAsXCIwMFwiXSxcIlNKXCI6W1wiNDdcIixcIjAwXCIsXCIwXFxcXGR7NH18KD86WzQ1ODldXFxcXGR8NzkpXFxcXGR7Nn1cIixbNSw4XSwwLDAsMCwwLDAsMCxcIjc5XCJdLFwiU0tcIjpbXCI0MjFcIixcIjAwXCIsXCJbMi02ODldXFxcXGR7OH18WzItNTldXFxcXGR7Nn18WzItNV1cXFxcZHs1fVwiLFs2LDcsOV0sW1tcIihcXFxcZCkoXFxcXGR7Mn0pKFxcXFxkezMsNH0pXCIsXCIkMSAkMiAkM1wiLFtcIjIxXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezIsM30pXCIsXCIkMSAkMiAkM1wiLFtcIlszLTVdWzEtOF0xXCIsXCJbMy01XVsxLThdMVs2N11cIl0sXCIwJDFcIl0sW1wiKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezJ9KVwiLFwiJDEvJDIgJDMgJDRcIixbXCIyXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCJbNjg5XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMS8kMiAkMyAkNFwiLFtcIlszLTVdXCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJTTFwiOltcIjIzMlwiLFwiMDBcIixcIig/OlsyMzc4XVxcXFxkfDY2fDk5KVxcXFxkezZ9XCIsWzhdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezZ9KVwiLFwiJDEgJDJcIixbXCJbMjM2LTldXCJdLFwiKDAkMSlcIl1dLFwiMFwiXSxcIlNNXCI6W1wiMzc4XCIsXCIwMFwiLFwiKD86MDU0OXxbNS03XVxcXFxkKVxcXFxkezZ9XCIsWzgsMTBdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIls1LTddXCJdXSxbXCIoXFxcXGR7NH0pKFxcXFxkezZ9KVwiLFwiJDEgJDJcIixbXCIwXCJdXV0sMCwwLFwiKFs4OV1cXFxcZHs1fSkkXCIsXCIwNTQ5JDFcIl0sXCJTTlwiOltcIjIyMVwiLFwiMDBcIixcIig/OlszNzhdXFxcXGR7NH18OTMzMzApXFxcXGR7NH1cIixbOV0sW1tcIihcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiOFwiXV0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCJbMzc5XVwiXV1dXSxcIlNPXCI6W1wiMjUyXCIsXCIwMFwiLFwiWzM0Ni05XVxcXFxkezh9fFsxMjY3OV1cXFxcZHs3fXxbMS01XVxcXFxkezZ9fFsxMzQ4XVxcXFxkezV9XCIsWzYsNyw4LDldLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCI4WzEyNV1cIl1dLFtcIihcXFxcZHs2fSlcIixcIiQxXCIsW1wiWzEzNF1cIl1dLFtcIihcXFxcZCkoXFxcXGR7Nn0pXCIsXCIkMSAkMlwiLFtcIlsxNV18MlswLTc5XXwzWzAtNDYtOF18NFswLTddXCJdXSxbXCIoXFxcXGQpKFxcXFxkezd9KVwiLFwiJDEgJDJcIixbXCIyNHxbNjddXCJdXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiWzM0NzhdfDY0fDkwXCJdXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezUsN30pXCIsXCIkMSAkMlwiLFtcIjF8Mjh8NlsxLTM1LTldfDlbMi05XVwiXV1dLFwiMFwiXSxcIlNSXCI6W1wiNTk3XCIsXCIwMFwiLFwiKD86WzItNV18Njh8Wzc4XVxcXFxkKVxcXFxkezV9XCIsWzYsN10sW1tcIihcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEtJDItJDNcIixbXCI1NlwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxLSQyXCIsW1wiWzItNV1cIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMS0kMlwiLFtcIls2LThdXCJdXV1dLFwiU1NcIjpbXCIyMTFcIixcIjAwXCIsXCJbMTldXFxcXGR7OH1cIixbOV0sW1tcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCJbMTldXCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJTVFwiOltcIjIzOVwiLFwiMDBcIixcIig/OjIyfDlcXFxcZClcXFxcZHs1fVwiLFs3XSxbW1wiKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiWzI5XVwiXV1dXSxcIlNWXCI6W1wiNTAzXCIsXCIwMFwiLFwiWzI2N11cXFxcZHs3fXxbODldMDBcXFxcZHs0fSg/OlxcXFxkezR9KT9cIixbNyw4LDExXSxbW1wiKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiWzg5XVwiXV0sW1wiKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiWzI2N11cIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCJbODldXCJdXV1dLFwiU1hcIjpbXCIxXCIsXCIwMTFcIixcIjcyMTVcXFxcZHs2fXwoPzpbNThdXFxcXGRcXFxcZHw5MDApXFxcXGR7N31cIixbMTBdLDAsXCIxXCIsMCxcIjF8KDVcXFxcZHs2fSkkXCIsXCI3MjEkMVwiLDAsXCI3MjFcIl0sXCJTWVwiOltcIjk2M1wiLFwiMDBcIixcIlsxLTM5XVxcXFxkezh9fFsxLTVdXFxcXGR7N31cIixbOCw5XSxbW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Myw0fSlcIixcIiQxICQyICQzXCIsW1wiWzEtNV1cIl0sXCIwJDFcIiwxXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiOVwiXSxcIjAkMVwiLDFdXSxcIjBcIl0sXCJTWlwiOltcIjI2OFwiLFwiMDBcIixcIjA4MDBcXFxcZHs0fXwoPzpbMjM3XVxcXFxkfDkwMClcXFxcZHs2fVwiLFs4LDldLFtbXCIoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCJbMDIzN11cIl1dLFtcIihcXFxcZHs1fSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIjlcIl1dXV0sXCJUQVwiOltcIjI5MFwiLFwiMDBcIixcIjhcXFxcZHszfVwiLFs0XSwwLDAsMCwwLDAsMCxcIjhcIl0sXCJUQ1wiOltcIjFcIixcIjAxMVwiLFwiKD86WzU4XVxcXFxkXFxcXGR8NjQ5fDkwMClcXFxcZHs3fVwiLFsxMF0sMCxcIjFcIiwwLFwiMXwoWzItNDc5XVxcXFxkezZ9KSRcIixcIjY0OSQxXCIsMCxcIjY0OVwiXSxcIlREXCI6W1wiMjM1XCIsXCIwMHwxNlwiLFwiKD86MjJ8WzY5XVxcXFxkfDc3KVxcXFxkezZ9XCIsWzhdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkMyAkNFwiLFtcIlsyNjc5XVwiXV1dLDAsMCwwLDAsMCwwLDAsXCIwMFwiXSxcIlRHXCI6W1wiMjI4XCIsXCIwMFwiLFwiWzI3OV1cXFxcZHs3fVwiLFs4XSxbW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCJbMjc5XVwiXV1dXSxcIlRIXCI6W1wiNjZcIixcIjAwWzEtOV1cIixcIjFcXFxcZHs4LDl9fCg/OlsyLTU3XXxbNjg5XVxcXFxkKVxcXFxkezd9XCIsWzgsOSwxMF0sW1tcIihcXFxcZCkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCIyXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezMsNH0pXCIsXCIkMSAkMiAkM1wiLFtcIjE0fFszLTldXCJdLFwiMCQxXCJdLFtcIihcXFxcZHs0fSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCIxXCJdXV0sXCIwXCJdLFwiVEpcIjpbXCI5OTJcIixcIjgxMFwiLFwiKD86MDB8MTF8WzMtNTc5XVxcXFxkfDg4KVxcXFxkezd9XCIsWzldLFtbXCIoXFxcXGR7Nn0pKFxcXFxkKShcXFxcZHsyfSlcIixcIiQxICQyICQzXCIsW1wiMzMxXCIsXCIzMzE3XCJdLDAsMV0sW1wiKFxcXFxkezN9KShcXFxcZHsyfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIlszNF03fDkxWzc4XVwiXSwwLDFdLFtcIihcXFxcZHs0fSkoXFxcXGQpKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCIzXCJdLDAsMV0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIlswNDU3LTldfDExXCJdLDAsMV1dLFwiOFwiLDAsMCwwLDAsMCwwLFwiOH4xMFwiXSxcIlRLXCI6W1wiNjkwXCIsXCIwMFwiLFwiWzItNDddXFxcXGR7Myw2fVwiLFs0LDUsNiw3XV0sXCJUTFwiOltcIjY3MFwiLFwiMDBcIixcIjdcXFxcZHs3fXwoPzpbMi00N11cXFxcZHxbODldMClcXFxcZHs1fVwiLFs3LDhdLFtbXCIoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCJbMi00ODldfDcwXCJdXSxbXCIoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCI3XCJdXV1dLFwiVE1cIjpbXCI5OTNcIixcIjgxMFwiLFwiWzEtNl1cXFxcZHs3fVwiLFs4XSxbW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDItJDMtJDRcIixbXCIxMlwiXSxcIig4ICQxKVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkKShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMi0kMy0kNFwiLFtcIlsxLTVdXCJdLFwiKDggJDEpXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7Nn0pXCIsXCIkMSAkMlwiLFtcIjZcIl0sXCI4ICQxXCJdXSxcIjhcIiwwLDAsMCwwLDAsMCxcIjh+MTBcIl0sXCJUTlwiOltcIjIxNlwiLFwiMDBcIixcIlsyLTU3LTldXFxcXGR7N31cIixbOF0sW1tcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCJbMi01Ny05XVwiXV1dXSxcIlRPXCI6W1wiNjc2XCIsXCIwMFwiLFwiKD86MDgwMHxbNS04XVxcXFxkezN9KVxcXFxkezN9fFsyLThdXFxcXGR7NH1cIixbNSw3XSxbW1wiKFxcXFxkezJ9KShcXFxcZHszfSlcIixcIiQxLSQyXCIsW1wiWzItNF18NTB8NlswOV18N1swLTI0LTY5XXw4WzA1XVwiXV0sW1wiKFxcXFxkezR9KShcXFxcZHszfSlcIixcIiQxICQyXCIsW1wiMFwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiWzUtOF1cIl1dXV0sXCJUUlwiOltcIjkwXCIsXCIwMFwiLFwiKD86NHw4XFxcXGR7NX0pXFxcXGR7Nn18KD86WzItNThdXFxcXGRcXFxcZHw5MDApXFxcXGR7N31cIixbNywxMCwxMl0sW1tcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCI1MTJ8OFswNTg5XXw5MFwiXSxcIjAkMVwiLDFdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiNSg/OlswLTU5XXw2MSlcIixcIjUoPzpbMC01OV18NjE2KVwiLFwiNSg/OlswLTU5XXw2MTYxKVwiXSxcIjAkMVwiLDFdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzI0XVsxLThdfDNbMS05XVwiXSxcIigwJDEpXCIsMV0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7Nn0pXCIsXCIkMSAkMiAkM1wiLFtcIjgwXCJdLFwiMCQxXCIsMV1dLFwiMFwiXSxcIlRUXCI6W1wiMVwiLFwiMDExXCIsXCIoPzpbNThdXFxcXGRcXFxcZHw5MDApXFxcXGR7N31cIixbMTBdLDAsXCIxXCIsMCxcIjF8KFsyLTQ2LThdXFxcXGR7Nn0pJFwiLFwiODY4JDFcIiwwLFwiODY4XCJdLFwiVFZcIjpbXCI2ODhcIixcIjAwXCIsXCIoPzoyfDdcXFxcZFxcXFxkfDkwKVxcXFxkezR9XCIsWzUsNiw3XSxbW1wiKFxcXFxkezJ9KShcXFxcZHszfSlcIixcIiQxICQyXCIsW1wiMlwiXV0sW1wiKFxcXFxkezJ9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiOTBcIl1dLFtcIihcXFxcZHsyfSkoXFxcXGR7NX0pXCIsXCIkMSAkMlwiLFtcIjdcIl1dXV0sXCJUV1wiOltcIjg4NlwiLFwiMCg/OjBbMjUtNzldfDE5KVwiLFwiWzItNjg5XVxcXFxkezh9fDdcXFxcZHs5LDEwfXxbMi04XVxcXFxkezd9fDJcXFxcZHs2fVwiLFs3LDgsOSwxMCwxMV0sW1tcIihcXFxcZHsyfSkoXFxcXGQpKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCIyMDJcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Myw0fSlcIixcIiQxICQyICQzXCIsW1wiWzI1OF0wXCJdLFwiMCQxXCJdLFtcIihcXFxcZCkoXFxcXGR7Myw0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIlsyMzU2OF18NCg/OjBbMDItNDhdfFsxLTQ3LTldKXw3WzEtOV1cIixcIlsyMzU2OF18NCg/OjBbMi00OF18WzEtNDctOV0pfCg/OjQwMHw3KVsxLTldXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCJbNDldXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7NH0pKFxcXFxkezQsNX0pXCIsXCIkMSAkMiAkM1wiLFtcIjdcIl0sXCIwJDFcIl1dLFwiMFwiLDAsMCwwLDAsMCwwLDAsXCIjXCJdLFwiVFpcIjpbXCIyNTVcIixcIjAwWzA1Nl1cIixcIig/OlsyNi04XVxcXFxkfDQxfDkwKVxcXFxkezd9XCIsWzldLFtbXCIoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiWzg5XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiWzI0XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiWzY3XVwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiVUFcIjpbXCIzODBcIixcIjAwXCIsXCJbODldXFxcXGR7OX18WzMtOV1cXFxcZHs4fVwiLFs5LDEwXSxbW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIjZbMTJdWzI5XXwoPzozWzEtOF18NFsxMzYtOF18NVsxMjQ1N118Nls0OV0pMnwoPzo1Nnw2NSlbMjRdXCIsXCI2WzEyXVsyOV18KD86MzV8NFsxMzc4XXw1WzEyNDU3XXw2WzQ5XSkyfCg/OjU2fDY1KVsyNF18KD86M1sxLTQ2LThdfDQ2KTJbMDEzLTldXCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCI0WzQ1XVswLTVdfDUoPzowfDZbMzddKXw2KD86WzEyXVswMThdfFszNi04XSl8N3w4OXw5WzEtOV18KD86NDh8NTcpWzAxMzctOV1cIixcIjRbNDVdWzAtNV18NSg/OjB8Nig/OjNbMTQtN118NykpfDYoPzpbMTJdWzAxOF18WzM2LThdKXw3fDg5fDlbMS05XXwoPzo0OHw1NylbMDEzNy05XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7NH0pKFxcXFxkezV9KVwiLFwiJDEgJDJcIixbXCJbMy02XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszLDR9KVwiLFwiJDEgJDIgJDNcIixbXCJbODldXCJdLFwiMCQxXCJdXSxcIjBcIiwwLDAsMCwwLDAsMCxcIjB+MFwiXSxcIlVHXCI6W1wiMjU2XCIsXCIwMFswNTddXCIsXCI4MDBcXFxcZHs2fXwoPzpbMjldMHxbMzQ3XVxcXFxkKVxcXFxkezd9XCIsWzldLFtbXCIoXFxcXGR7NH0pKFxcXFxkezV9KVwiLFwiJDEgJDJcIixbXCIyMDJcIixcIjIwMjRcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHs2fSlcIixcIiQxICQyXCIsW1wiWzI3LTldfDQoPzo2WzQ1XXxbNy05XSlcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHs3fSlcIixcIiQxICQyXCIsW1wiWzM0XVwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiVVNcIjpbXCIxXCIsXCIwMTFcIixcIlsyLTldXFxcXGR7OX1cIixbMTBdLFtbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIigkMSkgJDItJDNcIixbXCJbMi05XVwiXSwwLDEsXCIkMS0kMi0kM1wiXV0sXCIxXCIsMCwwLDAsMCwwLFtbXCIoPzoyKD86MFsxLTM1LTldfDFbMDItOV18MlswMy01ODldfDNbMTQ5XXw0WzA4XXw1WzEtNDZdfDZbMDI3OV18N1swMjY5XXw4WzEzXSl8Myg/OjBbMS01Ny05XXwxWzAyLTldfDJbMDEzNV18M1swLTI0Njc5XXw0WzE2N118NVsxMl18NlswMTRdfDhbMDU2XSl8NCg/OjBbMTI0LTldfDFbMDItNTc5XXwyWzMtNV18M1swMjQ1XXw0WzAyMzVdfDU4fDZbMzldfDdbMDU4OV18OFswNF0pfDUoPzowWzEtNTctOV18MVswMjM1LThdfDIwfDNbMDE0OV18NFswMV18NVsxOV18NlsxLTQ3XXw3WzAxMy01XXw4WzA1Nl0pfDYoPzowWzEtMzUtOV18MVswMjQtOV18MlswMzY4OV18WzM0XVswMTZdfDVbMDE3OV18NlswLTI3OV18Nzh8OFswLTI5XSl8Nyg/OjBbMS00Ni04XXwxWzItOV18MlswNC03XXwzWzEyNDddfDRbMDM3XXw1WzQ3XXw2WzAyMzU5XXw3WzAyLTU5XXw4WzE1Nl0pfDgoPzowWzEtNjhdfDFbMDItOF18MlswOF18M1swLTI4XXw0WzM1NzhdfDVbMDQ2LTldfDZbMDItNV18N1swMjhdKXw5KD86MFsxMzQ2LTldfDFbMDItOV18MlswNTg5XXwzWzAxNDYtOF18NFswMTc5XXw1WzEyNDY5XXw3WzAtMzg5XXw4WzA0LTY5XSkpWzItOV1cXFxcZHs2fVwiXSxbXCJcIl0sW1wiOCg/OjAwfDMzfDQ0fDU1fDY2fDc3fDg4KVsyLTldXFxcXGR7Nn1cIl0sW1wiOTAwWzItOV1cXFxcZHs2fVwiXSxbXCI1Mig/OjM1KD86WzAyLTQ2LTldXFxcXGR8MVswMi05XXw1WzAtNDYtOV0pfDQ1KD86WzAzNF1cXFxcZHwxWzAyLTldfDJbMDI0LTldfDVbMC00Ni05XSkpXFxcXGR7NH18NTIoPzozWzItNDYtOV18NFsyLTRdKSg/OlswMi05XVxcXFxkfDFbMDItOV0pXFxcXGR7NH18NSg/OjAwfDJbMTJdfDMzfDQ0fDY2fDc3fDg4KVsyLTldXFxcXGR7Nn1cIl1dXSxcIlVZXCI6W1wiNTk4XCIsXCIwKD86MHwxWzMtOV1cXFxcZClcIixcIig/OlsyNDldXFxcXGRcXFxcZHw4MClcXFxcZHs1fXw5XFxcXGR7Nn1cIixbNyw4XSxbW1wiKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiOHw5MFwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiOVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCJbMjRdXCJdXV0sXCIwXCIsMCwwLDAsMCwwLDAsXCIwMFwiLFwiIGludC4gXCJdLFwiVVpcIjpbXCI5OThcIixcIjgxMFwiLFwiKD86WzY3OV1cXFxcZHw4OClcXFxcZHs3fVwiLFs5XSxbW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Mn0pKFxcXFxkezJ9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCJbNi05XVwiXSxcIjggJDFcIl1dLFwiOFwiLDAsMCwwLDAsMCwwLFwiOH4xMFwiXSxcIlZBXCI6W1wiMzlcIixcIjAwXCIsXCIwXFxcXGR7NSwxMH18M1swLThdXFxcXGR7NywxMH18NTVcXFxcZHs4fXw4XFxcXGR7NX0oPzpcXFxcZHsyLDR9KT98KD86MVxcXFxkfDM5KVxcXFxkezcsOH1cIixbNiw3LDgsOSwxMCwxMV0sMCwwLDAsMCwwLDAsXCIwNjY5OFwiXSxcIlZDXCI6W1wiMVwiLFwiMDExXCIsXCIoPzpbNThdXFxcXGRcXFxcZHw3ODR8OTAwKVxcXFxkezd9XCIsWzEwXSwwLFwiMVwiLDAsXCIxfChbMi03XVxcXFxkezZ9KSRcIixcIjc4NCQxXCIsMCxcIjc4NFwiXSxcIlZFXCI6W1wiNThcIixcIjAwXCIsXCJbNjhdMDBcXFxcZHs3fXwoPzpbMjRdXFxcXGR8WzU5XTApXFxcXGR7OH1cIixbMTBdLFtbXCIoXFxcXGR7M30pKFxcXFxkezd9KVwiLFwiJDEtJDJcIixbXCJbMjQtNjg5XVwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiVkdcIjpbXCIxXCIsXCIwMTFcIixcIig/OjI4NHxbNThdXFxcXGRcXFxcZHw5MDApXFxcXGR7N31cIixbMTBdLDAsXCIxXCIsMCxcIjF8KFsyLTU3OF1cXFxcZHs2fSkkXCIsXCIyODQkMVwiLDAsXCIyODRcIl0sXCJWSVwiOltcIjFcIixcIjAxMVwiLFwiWzU4XVxcXFxkezl9fCg/OjM0fDkwKTBcXFxcZHs3fVwiLFsxMF0sMCxcIjFcIiwwLFwiMXwoWzItOV1cXFxcZHs2fSkkXCIsXCIzNDAkMVwiLDAsXCIzNDBcIl0sXCJWTlwiOltcIjg0XCIsXCIwMFwiLFwiWzEyXVxcXFxkezl9fFsxMzUtOV1cXFxcZHs4fXxbMTZdXFxcXGR7N318WzE2LThdXFxcXGR7Nn1cIixbNyw4LDksMTBdLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezV9KVwiLFwiJDEgJDJcIixbXCI4MFwiXSxcIjAkMVwiLDFdLFtcIihcXFxcZHs0fSkoXFxcXGR7NCw2fSlcIixcIiQxICQyXCIsW1wiMVwiXSwwLDFdLFtcIihcXFxcZHsyfSkoXFxcXGR7M30pKFxcXFxkezJ9KShcXFxcZHsyfSlcIixcIiQxICQyICQzICQ0XCIsW1wiWzY5XVwiXSxcIjAkMVwiLDFdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCJbMzU3OF1cIl0sXCIwJDFcIiwxXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiMls0OF1cIl0sXCIwJDFcIiwxXSxbXCIoXFxcXGR7M30pKFxcXFxkezR9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiMlwiXSxcIjAkMVwiLDFdXSxcIjBcIl0sXCJWVVwiOltcIjY3OFwiLFwiMDBcIixcIig/OlsyM11cXFxcZHxbNDhdOClcXFxcZHszfXwoPzpbNTddXFxcXGR8OTApXFxcXGR7NX1cIixbNSw3XSxbW1wiKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiWzU3OV1cIl1dXV0sXCJXRlwiOltcIjY4MVwiLFwiMDBcIixcIig/Ols0NV0wfDY4fDcyfDhcXFxcZClcXFxcZHs0fVwiLFs2XSxbW1wiKFxcXFxkezJ9KShcXFxcZHsyfSkoXFxcXGR7Mn0pXCIsXCIkMSAkMiAkM1wiLFtcIls0LThdXCJdXV1dLFwiV1NcIjpbXCI2ODVcIixcIjBcIixcIig/OlsyLTZdfDhcXFxcZHs1fSlcXFxcZHs0fXxbNzhdXFxcXGR7Nn18WzY4XVxcXFxkezV9XCIsWzUsNiw3LDEwXSxbW1wiKFxcXFxkezV9KVwiLFwiJDFcIixbXCJbMi01XXw2WzEtOV1cIl1dLFtcIihcXFxcZHszfSkoXFxcXGR7Myw3fSlcIixcIiQxICQyXCIsW1wiWzY4XVwiXV0sW1wiKFxcXFxkezJ9KShcXFxcZHs1fSlcIixcIiQxICQyXCIsW1wiN1wiXV1dXSxcIlhLXCI6W1wiMzgzXCIsXCIwMFwiLFwiWzIzXVxcXFxkezcsOH18KD86NFxcXFxkXFxcXGR8Wzg5XTAwKVxcXFxkezV9XCIsWzgsOV0sW1tcIihcXFxcZHszfSkoXFxcXGR7NX0pXCIsXCIkMSAkMlwiLFtcIls4OV1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIlsyLTRdXCJdLFwiMCQxXCJdLFtcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDNcIixbXCJbMjNdXCJdLFwiMCQxXCJdXSxcIjBcIl0sXCJZRVwiOltcIjk2N1wiLFwiMDBcIixcIig/OjF8N1xcXFxkKVxcXFxkezd9fFsxLTddXFxcXGR7Nn1cIixbNyw4LDldLFtbXCIoXFxcXGQpKFxcXFxkezN9KShcXFxcZHszLDR9KVwiLFwiJDEgJDIgJDNcIixbXCJbMS02XXw3WzI0LTY4XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiN1wiXSxcIjAkMVwiXV0sXCIwXCJdLFwiWVRcIjpbXCIyNjJcIixcIjAwXCIsXCI4MFxcXFxkezd9fCg/OjI2fDYzKTlcXFxcZHs2fVwiLFs5XSwwLFwiMFwiLDAsMCwwLDAsXCIyNjl8NjNcIl0sXCJaQVwiOltcIjI3XCIsXCIwMFwiLFwiWzEtOV1cXFxcZHs4fXw4XFxcXGR7NCw3fVwiLFs1LDYsNyw4LDldLFtbXCIoXFxcXGR7Mn0pKFxcXFxkezMsNH0pXCIsXCIkMSAkMlwiLFtcIjhbMS00XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHsyLDN9KVwiLFwiJDEgJDIgJDNcIixbXCI4WzEtNF1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIjg2MFwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezN9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiWzEtOV1cIl0sXCIwJDFcIl1dLFwiMFwiXSxcIlpNXCI6W1wiMjYwXCIsXCIwMFwiLFwiKD86NjN8ODApMFxcXFxkezZ9fCg/OjIxfFs3OV1cXFxcZClcXFxcZHs3fVwiLFs5XSxbW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIlsyOF1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHs3fSlcIixcIiQxICQyXCIsW1wiWzc5XVwiXSxcIjAkMVwiXV0sXCIwXCJdLFwiWldcIjpbXCIyNjNcIixcIjAwXCIsXCIyKD86WzAtNTctOV1cXFxcZHs2LDh9fDZbMC0yNC05XVxcXFxkezYsN30pfFszOF1cXFxcZHs5fXxbMzUtOF1cXFxcZHs4fXxbMy02XVxcXFxkezd9fFsxLTY4OV1cXFxcZHs2fXxbMS0zNTY5XVxcXFxkezV9fFsxMzU2XVxcXFxkezR9XCIsWzUsNiw3LDgsOSwxMF0sW1tcIihcXFxcZHszfSkoXFxcXGR7Myw1fSlcIixcIiQxICQyXCIsW1wiMig/OjBbNDVdfDJbMjc4XXxbNDldOCl8Myg/OlswOV04fDE3KXw2KD86WzI5XTh8Mzd8NzUpfFsyM11bNzhdfCg/OjMzfDVbMTVdfDZbNjhdKVs3OF1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkKShcXFxcZHszfSkoXFxcXGR7Miw0fSlcIixcIiQxICQyICQzXCIsW1wiWzQ5XVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7M30pKFxcXFxkezR9KVwiLFwiJDEgJDJcIixbXCI4MFwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezd9KVwiLFwiJDEgJDJcIixbXCIyNHw4WzEzLTU5XXwoPzoyWzA1LTc5XXwzOXw1WzQ1XXw2WzE1LThdKTJcIixcIjIoPzowMlswMTRdfDR8WzU2XTIwfFs3OV0yKXwzOTJ8NSg/OjQyfDUyNSl8Nig/OlsxNi04XTIxfDUyWzAxM10pfDhbMTMtNTldXCJdLFwiKDAkMSlcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIjdcIl0sXCIwJDFcIl0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7Myw0fSlcIixcIiQxICQyICQzXCIsW1wiMig/OjFbMzldfDJbMDE1N118WzM3OF18WzU2XVsxNF0pfDMoPzoxMnwyOSlcIixcIjIoPzoxWzM5XXwyWzAxNTddfFszNzhdfFs1Nl1bMTRdKXwzKD86MTIzfDI5KVwiXSxcIjAkMVwiXSxbXCIoXFxcXGR7NH0pKFxcXFxkezZ9KVwiLFwiJDEgJDJcIixbXCI4XCJdLFwiMCQxXCJdLFtcIihcXFxcZHsyfSkoXFxcXGR7Myw1fSlcIixcIiQxICQyXCIsW1wiMXwyKD86MFswLTM2LTldfDEyfDI5fFs1Nl0pfDMoPzoxWzAtNjg5XXxbMjQtNl0pfDUoPzpbMDIzNi05XXwxWzItNF0pfDYoPzpbMDEzLTU5XXw3WzAtNDYtOV0pfCg/OjMzfDU1fDZbNjhdKVswLTY5XXwoPzoyOXwzWzA5XXw2MilbMC03OV1cIl0sXCIwJDFcIl0sW1wiKFxcXFxkezJ9KShcXFxcZHszfSkoXFxcXGR7Myw0fSlcIixcIiQxICQyICQzXCIsW1wiMjlbMDEzLTldfDM5fDU0XCJdLFwiMCQxXCJdLFtcIihcXFxcZHs0fSkoXFxcXGR7Myw1fSlcIixcIiQxICQyXCIsW1wiKD86MjV8NTQpOFwiLFwiMjU4fDU0ODNcIl0sXCIwJDFcIl1dLFwiMFwiXX0sXCJub25HZW9ncmFwaGljXCI6e1wiODAwXCI6W1wiODAwXCIsMCxcIlsxLTldXFxcXGR7N31cIixbOF0sW1tcIihcXFxcZHs0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMlwiLFtcIlsxLTldXCJdXV0sMCwwLDAsMCwwLDAsWzAsMCxbXCJbMS05XVxcXFxkezd9XCJdXV0sXCI4MDhcIjpbXCI4MDhcIiwwLFwiWzEtOV1cXFxcZHs3fVwiLFs4XSxbW1wiKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyXCIsW1wiWzEtOV1cIl1dXSwwLDAsMCwwLDAsMCxbMCwwLDAsMCwwLDAsMCwwLDAsW1wiWzEtOV1cXFxcZHs3fVwiXV1dLFwiODcwXCI6W1wiODcwXCIsMCxcIlszNS03XVxcXFxkezh9XCIsWzldLFtbXCIoXFxcXGR7M30pKFxcXFxkezN9KShcXFxcZHszfSlcIixcIiQxICQyICQzXCIsW1wiWzM1LTddXCJdXV0sMCwwLDAsMCwwLDAsWzAsW1wiKD86WzM1Nl1cXFxcZHw3WzYtOF0pXFxcXGR7N31cIl1dXSxcIjg3OFwiOltcIjg3OFwiLDAsXCIxMFxcXFxkezEwfVwiLFsxMl0sW1tcIihcXFxcZHsyfSkoXFxcXGR7NX0pKFxcXFxkezV9KVwiLFwiJDEgJDIgJDNcIixbXCIxXCJdXV0sMCwwLDAsMCwwLDAsWzAsMCwwLDAsMCwwLDAsMCxbXCIxMFxcXFxkezEwfVwiXV1dLFwiODgxXCI6W1wiODgxXCIsMCxcIlswLTM2LTldXFxcXGR7OH1cIixbOV0sW1tcIihcXFxcZCkoXFxcXGR7M30pKFxcXFxkezV9KVwiLFwiJDEgJDIgJDNcIixbXCJbMC0zNi05XVwiXV1dLDAsMCwwLDAsMCwwLFswLFtcIlswLTM2LTldXFxcXGR7OH1cIl1dXSxcIjg4MlwiOltcIjg4MlwiLDAsXCJbMTNdXFxcXGR7Nn0oPzpcXFxcZHsyLDV9KT98Mjg1XFxcXGR7OX18WzE5XVxcXFxkezd9XCIsWzcsOCw5LDEwLDExLDEyXSxbW1wiKFxcXFxkezJ9KShcXFxcZHs1fSlcIixcIiQxICQyXCIsW1wiMTZ8MzQyXCJdXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezJ9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiWzE5XVwiXV0sW1wiKFxcXFxkezJ9KShcXFxcZHs0fSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIjNbMjNdXCJdXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezMsNH0pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCIxXCJdXSxbXCIoXFxcXGR7Mn0pKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiMzRbNTddXCJdXSxbXCIoXFxcXGR7M30pKFxcXFxkezR9KShcXFxcZHs0fSlcIixcIiQxICQyICQzXCIsW1wiMzRcIl1dLFtcIihcXFxcZHsyfSkoXFxcXGR7NCw1fSkoXFxcXGR7NX0pXCIsXCIkMSAkMiAkM1wiLFtcIlsxLTNdXCJdXV0sMCwwLDAsMCwwLDAsWzAsW1wiMyg/OjM3XFxcXGRcXFxcZHw0MilcXFxcZHs0fXwzKD86Mnw0N3w3XFxcXGR7M30pXFxcXGR7N31cIixbNyw5LDEwLDEyXV0sMCwwLDAsMCwwLDAsW1wiMSg/OjMoPzowWzAzNDddfFsxM11bMDEzOV18MlswMzVdfDRbMDEzNTY4XXw2WzA0NTldfDdbMDZdfDhbMTUtOF18OVswNjg5XSlcXFxcZHs0fXw2XFxcXGR7NSwxMH0pfCg/Oig/OjI4NVxcXFxkXFxcXGR8Myg/OjQ1fFs2OV1cXFxcZHszfSkpXFxcXGR8OVs4OV0pXFxcXGR7Nn1cIl1dXSxcIjg4M1wiOltcIjg4M1wiLDAsXCI1MVxcXFxkezd9KD86XFxcXGR7M30pP1wiLFs5LDEyXSxbW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7M30pXCIsXCIkMSAkMiAkM1wiLFtcIjUxMFwiXV0sW1wiKFxcXFxkezN9KShcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezN9KVwiLFwiJDEgJDIgJDMgJDRcIixbXCI1MTBcIl1dLFtcIihcXFxcZHs0fSkoXFxcXGR7NH0pKFxcXFxkezR9KVwiLFwiJDEgJDIgJDNcIixbXCI1XCJdXV0sMCwwLDAsMCwwLDAsWzAsMCwwLDAsMCwwLDAsMCxbXCI1MVswMTNdMFxcXFxkezh9fDUxMDBcXFxcZHs1fVwiXV1dLFwiODg4XCI6W1wiODg4XCIsMCxcIlxcXFxkezExfVwiLFsxMV0sW1tcIihcXFxcZHszfSkoXFxcXGR7M30pKFxcXFxkezV9KVwiLFwiJDEgJDIgJDNcIl1dLDAsMCwwLDAsMCwwLFswLDAsMCwwLDAsMCxbXCJcXFxcZHsxMX1cIl1dXSxcIjk3OVwiOltcIjk3OVwiLDAsXCJbMTM1OV1cXFxcZHs4fVwiLFs5XSxbW1wiKFxcXFxkKShcXFxcZHs0fSkoXFxcXGR7NH0pXCIsXCIkMSAkMiAkM1wiLFtcIlsxMzU5XVwiXV1dLDAsMCwwLDAsMCwwLFswLDAsMCxbXCJbMTM1OV1cXFxcZHs4fVwiXV1dfX0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvZXM2L2NvbnN0YW50cy5qc1xuLy8gVGhlIG1pbmltdW0gbGVuZ3RoIG9mIHRoZSBuYXRpb25hbCBzaWduaWZpY2FudCBudW1iZXIuXG52YXIgTUlOX0xFTkdUSF9GT1JfTlNOID0gMjsgLy8gVGhlIElUVSBzYXlzIHRoZSBtYXhpbXVtIGxlbmd0aCBzaG91bGQgYmUgMTUsXG4vLyBidXQgb25lIGNhbiBmaW5kIGxvbmdlciBudW1iZXJzIGluIEdlcm1hbnkuXG5cbnZhciBNQVhfTEVOR1RIX0ZPUl9OU04gPSAxNzsgLy8gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBjb3VudHJ5IGNhbGxpbmcgY29kZS5cblxudmFyIE1BWF9MRU5HVEhfQ09VTlRSWV9DT0RFID0gMzsgLy8gRGlnaXRzIGFjY2VwdGVkIGluIHBob25lIG51bWJlcnNcbi8vIChhc2NpaSwgZnVsbHdpZHRoLCBhcmFiaWMtaW5kaWMsIGFuZCBlYXN0ZXJuIGFyYWJpYyBkaWdpdHMpLlxuXG52YXIgVkFMSURfRElHSVRTID0gXCIwLTlcXHVGRjEwLVxcdUZGMTlcXHUwNjYwLVxcdTA2NjlcXHUwNkYwLVxcdTA2RjlcIjsgLy8gYERBU0hFU2Agd2lsbCBiZSByaWdodCBhZnRlciB0aGUgb3BlbmluZyBzcXVhcmUgYnJhY2tldCBvZiB0aGUgXCJjaGFyYWN0ZXIgY2xhc3NcIlxuXG52YXIgREFTSEVTID0gXCItXFx1MjAxMC1cXHUyMDE1XFx1MjIxMlxcdTMwRkNcXHVGRjBEXCI7XG52YXIgU0xBU0hFUyA9IFwiXFx1RkYwRi9cIjtcbnZhciBET1RTID0gXCJcXHVGRjBFLlwiO1xudmFyIFdISVRFU1BBQ0UgPSBcIiBcXHhBMFxceEFEXFx1MjAwQlxcdTIwNjBcXHUzMDAwXCI7XG52YXIgQlJBQ0tFVFMgPSBcIigpXFx1RkYwOFxcdUZGMDlcXHVGRjNCXFx1RkYzRFxcXFxbXFxcXF1cIjsgLy8gZXhwb3J0IGNvbnN0IE9QRU5JTkdfQlJBQ0tFVFMgPSAnKFxcdUZGMDhcXHVGRjNCXFxcXFxcWydcblxudmFyIFRJTERFUyA9IFwiflxcdTIwNTNcXHUyMjNDXFx1RkY1RVwiOyAvLyBSZWd1bGFyIGV4cHJlc3Npb24gb2YgYWNjZXB0YWJsZSBwdW5jdHVhdGlvbiBmb3VuZCBpbiBwaG9uZSBudW1iZXJzLiBUaGlzXG4vLyBleGNsdWRlcyBwdW5jdHVhdGlvbiBmb3VuZCBhcyBhIGxlYWRpbmcgY2hhcmFjdGVyIG9ubHkuIFRoaXMgY29uc2lzdHMgb2YgZGFzaFxuLy8gY2hhcmFjdGVycywgd2hpdGUgc3BhY2UgY2hhcmFjdGVycywgZnVsbCBzdG9wcywgc2xhc2hlcywgc3F1YXJlIGJyYWNrZXRzLFxuLy8gcGFyZW50aGVzZXMgYW5kIHRpbGRlcy4gRnVsbC13aWR0aCB2YXJpYW50cyBhcmUgYWxzbyBwcmVzZW50LlxuXG52YXIgVkFMSURfUFVOQ1RVQVRJT04gPSBcIlwiLmNvbmNhdChEQVNIRVMpLmNvbmNhdChTTEFTSEVTKS5jb25jYXQoRE9UUykuY29uY2F0KFdISVRFU1BBQ0UpLmNvbmNhdChCUkFDS0VUUykuY29uY2F0KFRJTERFUyk7XG52YXIgUExVU19DSEFSUyA9IFwiK1xcdUZGMEJcIjsgLy8gY29uc3QgTEVBRElOR19QTFVTX0NIQVJTX1BBVFRFUk4gPSBuZXcgUmVnRXhwKCdeWycgKyBQTFVTX0NIQVJTICsgJ10rJylcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi91dGlsLmpzXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGVudGlyZSBpbnB1dCBzZXF1ZW5jZSBjYW4gYmUgbWF0Y2hlZFxyXG4gKiBhZ2FpbnN0IHRoZSByZWd1bGFyIGV4cHJlc3Npb24uXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc0VudGlyZWx5KHRleHQsIHJlZ3VsYXJfZXhwcmVzc2lvbikge1xuICAvLyBJZiBhc3NpZ25pbmcgdGhlIGAnJ2AgZGVmYXVsdCB2YWx1ZSBpcyBtb3ZlZCB0byB0aGUgYXJndW1lbnRzIGFib3ZlLFxuICAvLyBjb2RlIGNvdmVyYWdlIHdvdWxkIGRlY3JlYXNlIGZvciBzb21lIHdlaXJkIHJlYXNvbi5cbiAgdGV4dCA9IHRleHQgfHwgJyc7XG4gIHJldHVybiBuZXcgUmVnRXhwKCdeKD86JyArIHJlZ3VsYXJfZXhwcmVzc2lvbiArICcpJCcpLnRlc3QodGV4dCk7XG59XG4vKipcclxuICogTWVyZ2VzIHR3byBhcnJheXMuXHJcbiAqIEBwYXJhbSAgeyp9IGFcclxuICogQHBhcmFtICB7Kn0gYlxyXG4gKiBAcmV0dXJuIHsqfVxyXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VBcnJheXMoYSwgYikge1xuICB2YXIgbWVyZ2VkID0gYS5zbGljZSgpO1xuXG4gIGZvciAodmFyIF9pdGVyYXRvciA9IGIsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IF9yZWY7XG5cbiAgICBpZiAoYS5pbmRleE9mKGVsZW1lbnQpIDwgMCkge1xuICAgICAgbWVyZ2VkLnB1c2goZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xuICB9KTsgLy8gRVM2IHZlcnNpb24sIHJlcXVpcmVzIFNldCBwb2x5ZmlsbC5cbiAgLy8gbGV0IG1lcmdlZCA9IG5ldyBTZXQoYSlcbiAgLy8gZm9yIChjb25zdCBlbGVtZW50IG9mIGIpXG4gIC8vIHtcbiAgLy8gXHRtZXJnZWQuYWRkKGkpXG4gIC8vIH1cbiAgLy8gcmV0dXJuIEFycmF5LmZyb20obWVyZ2VkKS5zb3J0KChhLCBiKSA9PiBhIC0gYilcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9lczYvUGFyc2VFcnJvci5qc1xuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ2OTcxMDQ0Lzk3MDc2OVxudmFyIFBhcnNlRXJyb3IgPSBmdW5jdGlvbiBQYXJzZUVycm9yKGNvZGUpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcnNlRXJyb3IpO1xuXG4gIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgdGhpcy5tZXNzYWdlID0gY29kZTtcbiAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcihjb2RlKS5zdGFjaztcbn07XG5cblxuUGFyc2VFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5QYXJzZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnNlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXJzZUVycm9yLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvZXM2L3Rvb2xzL3NlbXZlci1jb21wYXJlLmpzXG4vLyBDb3B5LXBhc3RlZCBmcm9tOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL3NlbXZlci1jb21wYXJlL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4vL1xuLy8gSW5saW5pbmcgdGhpcyBmdW5jdGlvbiBiZWNhdXNlIHNvbWUgdXNlcnMgcmVwb3J0ZWQgaXNzdWVzIHdpdGhcbi8vIGltcG9ydGluZyBmcm9tIGBzZW12ZXItY29tcGFyZWAgaW4gYSBicm93c2VyIHdpdGggRVM2IFwibmF0aXZlXCIgbW9kdWxlcy5cbi8vXG4vLyBGaXhlcyBgc2VtdmVyLWNvbXBhcmVgIG5vdCBiZWluZyBhYmxlIHRvIGNvbXBhcmUgdmVyc2lvbnMgd2l0aCBhbHBoYS9iZXRhL2V0YyBcInRhZ3NcIi5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRhbXBoZXRhbWluZS9saWJwaG9uZW51bWJlci1qcy9pc3N1ZXMvMzgxXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzZW12ZXJfY29tcGFyZSA9IChmdW5jdGlvbiAoYSwgYikge1xuICBhID0gYS5zcGxpdCgnLScpO1xuICBiID0gYi5zcGxpdCgnLScpO1xuICB2YXIgcGEgPSBhWzBdLnNwbGl0KCcuJyk7XG4gIHZhciBwYiA9IGJbMF0uc3BsaXQoJy4nKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHZhciBuYSA9IE51bWJlcihwYVtpXSk7XG4gICAgdmFyIG5iID0gTnVtYmVyKHBiW2ldKTtcbiAgICBpZiAobmEgPiBuYikgcmV0dXJuIDE7XG4gICAgaWYgKG5iID4gbmEpIHJldHVybiAtMTtcbiAgICBpZiAoIWlzTmFOKG5hKSAmJiBpc05hTihuYikpIHJldHVybiAxO1xuICAgIGlmIChpc05hTihuYSkgJiYgIWlzTmFOKG5iKSkgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKGFbMV0gJiYgYlsxXSkge1xuICAgIHJldHVybiBhWzFdID4gYlsxXSA/IDEgOiBhWzFdIDwgYlsxXSA/IC0xIDogMDtcbiAgfVxuXG4gIHJldHVybiAhYVsxXSAmJiBiWzFdID8gMSA6IGFbMV0gJiYgIWJbMV0gPyAtMSA6IDA7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbXZlci1jb21wYXJlLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvZXM2L21ldGFkYXRhLmpzXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBtZXRhZGF0YV9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuIC8vIEFkZGVkIFwicG9zc2libGVMZW5ndGhzXCIgYW5kIHJlbmFtZWRcbi8vIFwiY291bnRyeV9waG9uZV9jb2RlX3RvX2NvdW50cmllc1wiIHRvIFwiY291bnRyeV9jYWxsaW5nX2NvZGVzXCIuXG5cbnZhciBWMiA9ICcxLjAuMTgnOyAvLyBBZGRlZCBcImlkZF9wcmVmaXhcIiBhbmQgXCJkZWZhdWx0X2lkZF9wcmVmaXhcIi5cblxudmFyIFYzID0gJzEuMi4wJzsgLy8gTW92ZWQgYDAwMWAgY291bnRyeSBjb2RlIHRvIFwibm9uR2VvZ3JhcGhpY1wiIHNlY3Rpb24gb2YgbWV0YWRhdGEuXG5cbnZhciBWNCA9ICcxLjcuMzUnO1xudmFyIERFRkFVTFRfRVhUX1BSRUZJWCA9ICcgZXh0LiAnO1xuLyoqXHJcbiAqIFNlZTogaHR0cHM6Ly9naXRsYWIuY29tL2NhdGFtcGhldGFtaW5lL2xpYnBob25lbnVtYmVyLWpzL2Jsb2IvbWFzdGVyL01FVEFEQVRBLm1kXHJcbiAqL1xuXG52YXIgTWV0YWRhdGEgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgIG1ldGFkYXRhX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1ldGFkYXRhKTtcblxuICAgIHZhbGlkYXRlTWV0YWRhdGEobWV0YWRhdGEpO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICBzZXRWZXJzaW9uLmNhbGwodGhpcywgbWV0YWRhdGEpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1ldGFkYXRhLCBbe1xuICAgIGtleTogXCJnZXRDb3VudHJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q291bnRyaWVzKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubWV0YWRhdGEuY291bnRyaWVzKS5maWx0ZXIoZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIF8gIT09ICcwMDEnO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENvdW50cnlNZXRhZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb3VudHJ5TWV0YWRhdGEoY291bnRyeUNvZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhLmNvdW50cmllc1tjb3VudHJ5Q29kZV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vbkdlb2dyYXBoaWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9uR2VvZ3JhcGhpYygpIHtcbiAgICAgIGlmICh0aGlzLnYxIHx8IHRoaXMudjIgfHwgdGhpcy52MykgcmV0dXJuOyAvLyBgbm9uR2VvZ3JhcGhpY2FsYCB3YXMgYSB0eXBvLlxuICAgICAgLy8gSXQncyBwcmVzZW50IGluIG1ldGFkYXRhIGdlbmVyYXRlZCBmcm9tIGAxLjcuMzVgIHRvIGAxLjcuMzdgLlxuXG4gICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YS5ub25HZW9ncmFwaGljIHx8IHRoaXMubWV0YWRhdGEubm9uR2VvZ3JhcGhpY2FsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNDb3VudHJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0NvdW50cnkoY291bnRyeSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q291bnRyeU1ldGFkYXRhKGNvdW50cnkpICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0NhbGxpbmdDb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0NhbGxpbmdDb2RlKGNhbGxpbmdDb2RlKSB7XG4gICAgICBpZiAodGhpcy5nZXRDb3VudHJ5Q29kZXNGb3JDYWxsaW5nQ29kZShjYWxsaW5nQ29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm5vbkdlb2dyYXBoaWMoKSkge1xuICAgICAgICBpZiAodGhpcy5ub25HZW9ncmFwaGljKClbY2FsbGluZ0NvZGVdKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEEgaGFja3kgd29ya2Fyb3VuZCBmb3Igb2xkIGN1c3RvbSBtZXRhZGF0YSAoZ2VuZXJhdGVkIGJlZm9yZSBWNCkuXG4gICAgICAgIHZhciBjb3VudHJ5Q29kZXMgPSB0aGlzLmNvdW50cnlDYWxsaW5nQ29kZXMoKVtjYWxsaW5nQ29kZV07XG5cbiAgICAgICAgaWYgKGNvdW50cnlDb2RlcyAmJiBjb3VudHJ5Q29kZXMubGVuZ3RoID09PSAxICYmIGNvdW50cnlDb2Rlc1swXSA9PT0gJzAwMScpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc05vbkdlb2dyYXBoaWNDYWxsaW5nQ29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc05vbkdlb2dyYXBoaWNDYWxsaW5nQ29kZShjYWxsaW5nQ29kZSkge1xuICAgICAgaWYgKHRoaXMubm9uR2VvZ3JhcGhpYygpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vbkdlb2dyYXBoaWMoKVtjYWxsaW5nQ29kZV0gPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb3VudHJ5Q29kZXNGb3JDYWxsaW5nQ29kZShjYWxsaW5nQ29kZSkgPyBmYWxzZSA6IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBEZXByZWNhdGVkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiY291bnRyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3VudHJ5KGNvdW50cnlDb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3ROdW1iZXJpbmdQbGFuKGNvdW50cnlDb2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0TnVtYmVyaW5nUGxhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3ROdW1iZXJpbmdQbGFuKGNvdW50cnlDb2RlLCBjYWxsaW5nQ29kZSkge1xuICAgICAgaWYgKGNvdW50cnlDb2RlICYmIGNvdW50cnlDb2RlICE9PSAnMDAxJykge1xuICAgICAgICBpZiAoIXRoaXMuaGFzQ291bnRyeShjb3VudHJ5Q29kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvdW50cnk6IFwiLmNvbmNhdChjb3VudHJ5Q29kZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5udW1iZXJpbmdQbGFuID0gbmV3IE51bWJlcmluZ1BsYW4odGhpcy5nZXRDb3VudHJ5TWV0YWRhdGEoY291bnRyeUNvZGUpLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FsbGluZ0NvZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0NhbGxpbmdDb2RlKGNhbGxpbmdDb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY2FsbGluZyBjb2RlOiBcIi5jb25jYXQoY2FsbGluZ0NvZGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubnVtYmVyaW5nUGxhbiA9IG5ldyBOdW1iZXJpbmdQbGFuKHRoaXMuZ2V0TnVtYmVyaW5nUGxhbk1ldGFkYXRhKGNhbGxpbmdDb2RlKSwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm51bWJlcmluZ1BsYW4gPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb3VudHJ5Q29kZXNGb3JDYWxsaW5nQ29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb3VudHJ5Q29kZXNGb3JDYWxsaW5nQ29kZShjYWxsaW5nQ29kZSkge1xuICAgICAgdmFyIGNvdW50cnlDb2RlcyA9IHRoaXMuY291bnRyeUNhbGxpbmdDb2RlcygpW2NhbGxpbmdDb2RlXTtcblxuICAgICAgaWYgKGNvdW50cnlDb2Rlcykge1xuICAgICAgICAvLyBNZXRhZGF0YSBiZWZvcmUgVjQgaW5jbHVkZWQgXCJub24tZ2VvZ3JhcGhpYyBlbnRpdHlcIiBjYWxsaW5nIGNvZGVzXG4gICAgICAgIC8vIGluc2lkZSBgY291bnRyeV9jYWxsaW5nX2NvZGVzYCAoZm9yIGV4YW1wbGUsIGBcIjg4MVwiOltcIjAwMVwiXWApLlxuICAgICAgICAvLyBOb3cgdGhlIHNlbWFudGljcyBvZiBgY291bnRyeV9jYWxsaW5nX2NvZGVzYCBoYXMgY2hhbmdlZDpcbiAgICAgICAgLy8gaXQncyBzcGVjaWZpY2FsbHkgZm9yIFwiY291bnRyaWVzXCIgbm93LlxuICAgICAgICAvLyBPbGRlciB2ZXJzaW9ucyBvZiBjdXN0b20gbWV0YWRhdGEgd2lsbCBzaW1wbHkgc2tpcCBwYXJzaW5nXG4gICAgICAgIC8vIFwibm9uLWdlb2dyYXBoaWMgZW50aXR5XCIgcGhvbmUgbnVtYmVycyB3aXRoIG5ldyB2ZXJzaW9uc1xuICAgICAgICAvLyBvZiB0aGlzIGxpYnJhcnk6IGl0J3Mgbm90IGNvbnNpZGVyZWQgYSBidWcsXG4gICAgICAgIC8vIGJlY2F1c2Ugc3VjaCBudW1iZXJzIGFyZSBleHRyZW1lbHkgcmFyZSxcbiAgICAgICAgLy8gYW5kIGRldmVsb3BlcnMgZXh0cmVtZWx5IHJhcmVseSB1c2UgY3VzdG9tIG1ldGFkYXRhLlxuICAgICAgICBpZiAoY291bnRyeUNvZGVzLmxlbmd0aCA9PT0gMSAmJiBjb3VudHJ5Q29kZXNbMF0ubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvdW50cnlDb2RlcztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q291bnRyeUNvZGVGb3JDYWxsaW5nQ29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb3VudHJ5Q29kZUZvckNhbGxpbmdDb2RlKGNhbGxpbmdDb2RlKSB7XG4gICAgICB2YXIgY291bnRyeUNvZGVzID0gdGhpcy5nZXRDb3VudHJ5Q29kZXNGb3JDYWxsaW5nQ29kZShjYWxsaW5nQ29kZSk7XG5cbiAgICAgIGlmIChjb3VudHJ5Q29kZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50cnlDb2Rlc1swXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TnVtYmVyaW5nUGxhbk1ldGFkYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE51bWJlcmluZ1BsYW5NZXRhZGF0YShjYWxsaW5nQ29kZSkge1xuICAgICAgdmFyIGNvdW50cnlDb2RlID0gdGhpcy5nZXRDb3VudHJ5Q29kZUZvckNhbGxpbmdDb2RlKGNhbGxpbmdDb2RlKTtcblxuICAgICAgaWYgKGNvdW50cnlDb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvdW50cnlNZXRhZGF0YShjb3VudHJ5Q29kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm5vbkdlb2dyYXBoaWMoKSkge1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSB0aGlzLm5vbkdlb2dyYXBoaWMoKVtjYWxsaW5nQ29kZV07XG5cbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBIGhhY2t5IHdvcmthcm91bmQgZm9yIG9sZCBjdXN0b20gbWV0YWRhdGEgKGdlbmVyYXRlZCBiZWZvcmUgVjQpLlxuICAgICAgICB2YXIgY291bnRyeUNvZGVzID0gdGhpcy5jb3VudHJ5Q2FsbGluZ0NvZGVzKClbY2FsbGluZ0NvZGVdO1xuXG4gICAgICAgIGlmIChjb3VudHJ5Q29kZXMgJiYgY291bnRyeUNvZGVzLmxlbmd0aCA9PT0gMSAmJiBjb3VudHJ5Q29kZXNbMF0gPT09ICcwMDEnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGEuY291bnRyaWVzWycwMDEnXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gRGVwcmVjYXRlZC5cblxuICB9LCB7XG4gICAga2V5OiBcImNvdW50cnlDYWxsaW5nQ29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3VudHJ5Q2FsbGluZ0NvZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5udW1iZXJpbmdQbGFuLmNhbGxpbmdDb2RlKCk7XG4gICAgfSAvLyBEZXByZWNhdGVkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiSUREUHJlZml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIElERFByZWZpeCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm51bWJlcmluZ1BsYW4uSUREUHJlZml4KCk7XG4gICAgfSAvLyBEZXByZWNhdGVkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdElERFByZWZpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0SUREUHJlZml4KCkge1xuICAgICAgcmV0dXJuIHRoaXMubnVtYmVyaW5nUGxhbi5kZWZhdWx0SUREUHJlZml4KCk7XG4gICAgfSAvLyBEZXByZWNhdGVkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwibmF0aW9uYWxOdW1iZXJQYXR0ZXJuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5hdGlvbmFsTnVtYmVyUGF0dGVybigpIHtcbiAgICAgIHJldHVybiB0aGlzLm51bWJlcmluZ1BsYW4ubmF0aW9uYWxOdW1iZXJQYXR0ZXJuKCk7XG4gICAgfSAvLyBEZXByZWNhdGVkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwicG9zc2libGVMZW5ndGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3NpYmxlTGVuZ3RocygpIHtcbiAgICAgIHJldHVybiB0aGlzLm51bWJlcmluZ1BsYW4ucG9zc2libGVMZW5ndGhzKCk7XG4gICAgfSAvLyBEZXByZWNhdGVkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMubnVtYmVyaW5nUGxhbi5mb3JtYXRzKCk7XG4gICAgfSAvLyBEZXByZWNhdGVkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwibmF0aW9uYWxQcmVmaXhGb3JQYXJzaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5hdGlvbmFsUHJlZml4Rm9yUGFyc2luZygpIHtcbiAgICAgIHJldHVybiB0aGlzLm51bWJlcmluZ1BsYW4ubmF0aW9uYWxQcmVmaXhGb3JQYXJzaW5nKCk7XG4gICAgfSAvLyBEZXByZWNhdGVkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwibmF0aW9uYWxQcmVmaXhUcmFuc2Zvcm1SdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5hdGlvbmFsUHJlZml4VHJhbnNmb3JtUnVsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm51bWJlcmluZ1BsYW4ubmF0aW9uYWxQcmVmaXhUcmFuc2Zvcm1SdWxlKCk7XG4gICAgfSAvLyBEZXByZWNhdGVkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwibGVhZGluZ0RpZ2l0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZWFkaW5nRGlnaXRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMubnVtYmVyaW5nUGxhbi5sZWFkaW5nRGlnaXRzKCk7XG4gICAgfSAvLyBEZXByZWNhdGVkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzVHlwZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzVHlwZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5udW1iZXJpbmdQbGFuLmhhc1R5cGVzKCk7XG4gICAgfSAvLyBEZXByZWNhdGVkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0eXBlKF90eXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5udW1iZXJpbmdQbGFuLnR5cGUoX3R5cGUpO1xuICAgIH0gLy8gRGVwcmVjYXRlZC5cblxuICB9LCB7XG4gICAga2V5OiBcImV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5udW1iZXJpbmdQbGFuLmV4dCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3VudHJ5Q2FsbGluZ0NvZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvdW50cnlDYWxsaW5nQ29kZXMoKSB7XG4gICAgICBpZiAodGhpcy52MSkgcmV0dXJuIHRoaXMubWV0YWRhdGEuY291bnRyeV9waG9uZV9jb2RlX3RvX2NvdW50cmllcztcbiAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhLmNvdW50cnlfY2FsbGluZ19jb2RlcztcbiAgICB9IC8vIERlcHJlY2F0ZWQuXG5cbiAgfSwge1xuICAgIGtleTogXCJjaG9vc2VDb3VudHJ5QnlDb3VudHJ5Q2FsbGluZ0NvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hvb3NlQ291bnRyeUJ5Q291bnRyeUNhbGxpbmdDb2RlKGNhbGxpbmdDb2RlKSB7XG4gICAgICB0aGlzLnNlbGVjdE51bWJlcmluZ1BsYW4obnVsbCwgY2FsbGluZ0NvZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNTZWxlY3RlZE51bWJlcmluZ1BsYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzU2VsZWN0ZWROdW1iZXJpbmdQbGFuKCkge1xuICAgICAgcmV0dXJuIHRoaXMubnVtYmVyaW5nUGxhbiAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNZXRhZGF0YTtcbn0oKTtcblxuXG5cbnZhciBOdW1iZXJpbmdQbGFuID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTnVtYmVyaW5nUGxhbihtZXRhZGF0YSwgZ2xvYmFsTWV0YWRhdGFPYmplY3QpIHtcbiAgICBtZXRhZGF0YV9jbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJpbmdQbGFuKTtcblxuICAgIHRoaXMuZ2xvYmFsTWV0YWRhdGFPYmplY3QgPSBnbG9iYWxNZXRhZGF0YU9iamVjdDtcbiAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgc2V0VmVyc2lvbi5jYWxsKHRoaXMsIGdsb2JhbE1ldGFkYXRhT2JqZWN0Lm1ldGFkYXRhKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOdW1iZXJpbmdQbGFuLCBbe1xuICAgIGtleTogXCJjYWxsaW5nQ29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxsaW5nQ29kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhWzBdO1xuICAgIH0gLy8gRm9ybWF0dGluZyBpbmZvcm1hdGlvbiBmb3IgcmVnaW9ucyB3aGljaCBzaGFyZVxuICAgIC8vIGEgY291bnRyeSBjYWxsaW5nIGNvZGUgaXMgY29udGFpbmVkIGJ5IG9ubHkgb25lIHJlZ2lvblxuICAgIC8vIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBGb3IgZXhhbXBsZSwgZm9yIE5BTlBBIHJlZ2lvblxuICAgIC8vIChcIk5vcnRoIEFtZXJpY2FuIE51bWJlcmluZyBQbGFuIEFkbWluaXN0cmF0aW9uXCIsXG4gICAgLy8gIHdoaWNoIGluY2x1ZGVzIFVTQSwgQ2FuYWRhLCBDYXltYW4gSXNsYW5kcywgQmFoYW1hcywgZXRjKVxuICAgIC8vIGl0IHdpbGwgYmUgY29udGFpbmVkIGluIHRoZSBtZXRhZGF0YSBmb3IgYFVTYC5cblxuICB9LCB7XG4gICAga2V5OiBcImdldERlZmF1bHRDb3VudHJ5TWV0YWRhdGFGb3JSZWdpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmYXVsdENvdW50cnlNZXRhZGF0YUZvclJlZ2lvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdsb2JhbE1ldGFkYXRhT2JqZWN0LmdldE51bWJlcmluZ1BsYW5NZXRhZGF0YSh0aGlzLmNhbGxpbmdDb2RlKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJJRERQcmVmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gSUREUHJlZml4KCkge1xuICAgICAgaWYgKHRoaXMudjEgfHwgdGhpcy52MikgcmV0dXJuO1xuICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGFbMV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlZmF1bHRJRERQcmVmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVmYXVsdElERFByZWZpeCgpIHtcbiAgICAgIGlmICh0aGlzLnYxIHx8IHRoaXMudjIpIHJldHVybjtcbiAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhWzEyXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmF0aW9uYWxOdW1iZXJQYXR0ZXJuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5hdGlvbmFsTnVtYmVyUGF0dGVybigpIHtcbiAgICAgIGlmICh0aGlzLnYxIHx8IHRoaXMudjIpIHJldHVybiB0aGlzLm1ldGFkYXRhWzFdO1xuICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGFbMl07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3NpYmxlTGVuZ3Roc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NzaWJsZUxlbmd0aHMoKSB7XG4gICAgICBpZiAodGhpcy52MSkgcmV0dXJuO1xuICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGFbdGhpcy52MiA/IDIgOiAzXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEZvcm1hdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEZvcm1hdHMobWV0YWRhdGEpIHtcbiAgICAgIHJldHVybiBtZXRhZGF0YVt0aGlzLnYxID8gMiA6IHRoaXMudjIgPyAzIDogNF07XG4gICAgfSAvLyBGb3IgY291bnRyaWVzIG9mIHRoZSBzYW1lIHJlZ2lvbiAoZS5nLiBOQU5QQSlcbiAgICAvLyBmb3JtYXRzIGFyZSBhbGwgc3RvcmVkIGluIHRoZSBcIm1haW5cIiBjb3VudHJ5IGZvciB0aGF0IHJlZ2lvbi5cbiAgICAvLyBFLmcuIFwiUlVcIiBhbmQgXCJLWlwiLCBcIlVTXCIgYW5kIFwiQ0FcIi5cblxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JtYXRzID0gdGhpcy5fZ2V0Rm9ybWF0cyh0aGlzLm1ldGFkYXRhKSB8fCB0aGlzLl9nZXRGb3JtYXRzKHRoaXMuZ2V0RGVmYXVsdENvdW50cnlNZXRhZGF0YUZvclJlZ2lvbigpKSB8fCBbXTtcbiAgICAgIHJldHVybiBmb3JtYXRzLm1hcChmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gbmV3IEZvcm1hdChfLCBfdGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmF0aW9uYWxQcmVmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmF0aW9uYWxQcmVmaXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YVt0aGlzLnYxID8gMyA6IHRoaXMudjIgPyA0IDogNV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXROYXRpb25hbFByZWZpeEZvcm1hdHRpbmdSdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXROYXRpb25hbFByZWZpeEZvcm1hdHRpbmdSdWxlKG1ldGFkYXRhKSB7XG4gICAgICByZXR1cm4gbWV0YWRhdGFbdGhpcy52MSA/IDQgOiB0aGlzLnYyID8gNSA6IDZdO1xuICAgIH0gLy8gRm9yIGNvdW50cmllcyBvZiB0aGUgc2FtZSByZWdpb24gKGUuZy4gTkFOUEEpXG4gICAgLy8gbmF0aW9uYWwgcHJlZml4IGZvcm1hdHRpbmcgcnVsZSBpcyBzdG9yZWQgaW4gdGhlIFwibWFpblwiIGNvdW50cnkgZm9yIHRoYXQgcmVnaW9uLlxuICAgIC8vIEUuZy4gXCJSVVwiIGFuZCBcIktaXCIsIFwiVVNcIiBhbmQgXCJDQVwiLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwibmF0aW9uYWxQcmVmaXhGb3JtYXR0aW5nUnVsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuYXRpb25hbFByZWZpeEZvcm1hdHRpbmdSdWxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldE5hdGlvbmFsUHJlZml4Rm9ybWF0dGluZ1J1bGUodGhpcy5tZXRhZGF0YSkgfHwgdGhpcy5fZ2V0TmF0aW9uYWxQcmVmaXhGb3JtYXR0aW5nUnVsZSh0aGlzLmdldERlZmF1bHRDb3VudHJ5TWV0YWRhdGFGb3JSZWdpb24oKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9uYXRpb25hbFByZWZpeEZvclBhcnNpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25hdGlvbmFsUHJlZml4Rm9yUGFyc2luZygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhW3RoaXMudjEgPyA1IDogdGhpcy52MiA/IDYgOiA3XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmF0aW9uYWxQcmVmaXhGb3JQYXJzaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5hdGlvbmFsUHJlZml4Rm9yUGFyc2luZygpIHtcbiAgICAgIC8vIElmIGBuYXRpb25hbF9wcmVmaXhfZm9yX3BhcnNpbmdgIGlzIG5vdCBzZXQgZXhwbGljaXRseSxcbiAgICAgIC8vIHRoZW4gaW5mZXIgaXQgZnJvbSBgbmF0aW9uYWxfcHJlZml4YCAoaWYgYW55KVxuICAgICAgcmV0dXJuIHRoaXMuX25hdGlvbmFsUHJlZml4Rm9yUGFyc2luZygpIHx8IHRoaXMubmF0aW9uYWxQcmVmaXgoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmF0aW9uYWxQcmVmaXhUcmFuc2Zvcm1SdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5hdGlvbmFsUHJlZml4VHJhbnNmb3JtUnVsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhW3RoaXMudjEgPyA2IDogdGhpcy52MiA/IDcgOiA4XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldE5hdGlvbmFsUHJlZml4SXNPcHRpb25hbFdoZW5Gb3JtYXR0aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXROYXRpb25hbFByZWZpeElzT3B0aW9uYWxXaGVuRm9ybWF0dGluZygpIHtcbiAgICAgIHJldHVybiAhIXRoaXMubWV0YWRhdGFbdGhpcy52MSA/IDcgOiB0aGlzLnYyID8gOCA6IDldO1xuICAgIH0gLy8gRm9yIGNvdW50cmllcyBvZiB0aGUgc2FtZSByZWdpb24gKGUuZy4gTkFOUEEpXG4gICAgLy8gXCJuYXRpb25hbCBwcmVmaXggaXMgb3B0aW9uYWwgd2hlbiBmb3JtYXR0aW5nXCIgZmxhZyBpc1xuICAgIC8vIHN0b3JlZCBpbiB0aGUgXCJtYWluXCIgY291bnRyeSBmb3IgdGhhdCByZWdpb24uXG4gICAgLy8gRS5nLiBcIlJVXCIgYW5kIFwiS1pcIiwgXCJVU1wiIGFuZCBcIkNBXCIuXG5cbiAgfSwge1xuICAgIGtleTogXCJuYXRpb25hbFByZWZpeElzT3B0aW9uYWxXaGVuRm9ybWF0dGluZ0luTmF0aW9uYWxGb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmF0aW9uYWxQcmVmaXhJc09wdGlvbmFsV2hlbkZvcm1hdHRpbmdJbk5hdGlvbmFsRm9ybWF0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldE5hdGlvbmFsUHJlZml4SXNPcHRpb25hbFdoZW5Gb3JtYXR0aW5nKHRoaXMubWV0YWRhdGEpIHx8IHRoaXMuX2dldE5hdGlvbmFsUHJlZml4SXNPcHRpb25hbFdoZW5Gb3JtYXR0aW5nKHRoaXMuZ2V0RGVmYXVsdENvdW50cnlNZXRhZGF0YUZvclJlZ2lvbigpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGVhZGluZ0RpZ2l0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZWFkaW5nRGlnaXRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGFbdGhpcy52MSA/IDggOiB0aGlzLnYyID8gOSA6IDEwXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHlwZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YVt0aGlzLnYxID8gOSA6IHRoaXMudjIgPyAxMCA6IDExXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzVHlwZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzVHlwZXMoKSB7XG4gICAgICAvLyBWZXJzaW9ucyAxLjIuMCAtIDEuMi40OiBjYW4gYmUgYFtdYC5cblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGlmICh0aGlzLnR5cGVzKCkgJiYgdGhpcy50eXBlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIFZlcnNpb25zIDw9IDEuMi40OiBjYW4gYmUgYHVuZGVmaW5lZGAuXG4gICAgICAvLyBWZXJzaW9uID49IDEuMi41OiBjYW4gYmUgYDBgLlxuXG5cbiAgICAgIHJldHVybiAhIXRoaXMudHlwZXMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0eXBlKF90eXBlMikge1xuICAgICAgaWYgKHRoaXMuaGFzVHlwZXMoKSAmJiBtZXRhZGF0YV9nZXRUeXBlKHRoaXMudHlwZXMoKSwgX3R5cGUyKSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGUobWV0YWRhdGFfZ2V0VHlwZSh0aGlzLnR5cGVzKCksIF90eXBlMiksIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0KCkge1xuICAgICAgaWYgKHRoaXMudjEgfHwgdGhpcy52MikgcmV0dXJuIERFRkFVTFRfRVhUX1BSRUZJWDtcbiAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhWzEzXSB8fCBERUZBVUxUX0VYVF9QUkVGSVg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE51bWJlcmluZ1BsYW47XG59KCk7XG5cbnZhciBGb3JtYXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb3JtYXQoZm9ybWF0LCBtZXRhZGF0YSkge1xuICAgIG1ldGFkYXRhX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1hdCk7XG5cbiAgICB0aGlzLl9mb3JtYXQgPSBmb3JtYXQ7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZvcm1hdCwgW3tcbiAgICBrZXk6IFwicGF0dGVyblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXR0ZXJuKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdFswXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mb3JtYXRbMV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlYWRpbmdEaWdpdHNQYXR0ZXJuc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZWFkaW5nRGlnaXRzUGF0dGVybnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZm9ybWF0WzJdIHx8IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuYXRpb25hbFByZWZpeEZvcm1hdHRpbmdSdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5hdGlvbmFsUHJlZml4Rm9ybWF0dGluZ1J1bGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZm9ybWF0WzNdIHx8IHRoaXMubWV0YWRhdGEubmF0aW9uYWxQcmVmaXhGb3JtYXR0aW5nUnVsZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuYXRpb25hbFByZWZpeElzT3B0aW9uYWxXaGVuRm9ybWF0dGluZ0luTmF0aW9uYWxGb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmF0aW9uYWxQcmVmaXhJc09wdGlvbmFsV2hlbkZvcm1hdHRpbmdJbk5hdGlvbmFsRm9ybWF0KCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fZm9ybWF0WzRdIHx8IHRoaXMubWV0YWRhdGEubmF0aW9uYWxQcmVmaXhJc09wdGlvbmFsV2hlbkZvcm1hdHRpbmdJbk5hdGlvbmFsRm9ybWF0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5hdGlvbmFsUHJlZml4SXNNYW5kYXRvcnlXaGVuRm9ybWF0dGluZ0luTmF0aW9uYWxGb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmF0aW9uYWxQcmVmaXhJc01hbmRhdG9yeVdoZW5Gb3JtYXR0aW5nSW5OYXRpb25hbEZvcm1hdCgpIHtcbiAgICAgIC8vIE5hdGlvbmFsIHByZWZpeCBpcyBvbWl0dGVkIGlmIHRoZXJlJ3Mgbm8gbmF0aW9uYWwgcHJlZml4IGZvcm1hdHRpbmcgcnVsZVxuICAgICAgLy8gc2V0IGZvciB0aGlzIGNvdW50cnksIG9yIHdoZW4gdGhlIG5hdGlvbmFsIHByZWZpeCBmb3JtYXR0aW5nIHJ1bGVcbiAgICAgIC8vIGNvbnRhaW5zIG5vIG5hdGlvbmFsIHByZWZpeCBpdHNlbGYsIG9yIHdoZW4gdGhpcyBydWxlIGlzIHNldCBidXRcbiAgICAgIC8vIG5hdGlvbmFsIHByZWZpeCBpcyBvcHRpb25hbCBmb3IgdGhpcyBwaG9uZSBudW1iZXIgZm9ybWF0XG4gICAgICAvLyAoYW5kIGl0IGlzIG5vdCBlbmZvcmNlZCBleHBsaWNpdGx5KVxuICAgICAgcmV0dXJuIHRoaXMudXNlc05hdGlvbmFsUHJlZml4KCkgJiYgIXRoaXMubmF0aW9uYWxQcmVmaXhJc09wdGlvbmFsV2hlbkZvcm1hdHRpbmdJbk5hdGlvbmFsRm9ybWF0KCk7XG4gICAgfSAvLyBDaGVja3Mgd2hldGhlciBuYXRpb25hbCBwcmVmaXggZm9ybWF0dGluZyBydWxlIGNvbnRhaW5zIG5hdGlvbmFsIHByZWZpeC5cblxuICB9LCB7XG4gICAga2V5OiBcInVzZXNOYXRpb25hbFByZWZpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1c2VzTmF0aW9uYWxQcmVmaXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYXRpb25hbFByZWZpeEZvcm1hdHRpbmdSdWxlKCkgJiYgLy8gQ2hlY2sgdGhhdCBuYXRpb25hbCBwcmVmaXggZm9ybWF0dGluZyBydWxlIGlzIG5vdCBhIFwiZHVtbXlcIiBvbmUuXG4gICAgICAhRklSU1RfR1JPVVBfT05MWV9QUkVGSVhfUEFUVEVSTi50ZXN0KHRoaXMubmF0aW9uYWxQcmVmaXhGb3JtYXR0aW5nUnVsZSgpKTsgLy8gUHJldmlvdXNseSwgYEZJUlNUX0dST1VQX09OTFlfUFJFRklYX1BBVFRFUk5gIGNoZWNrIHdhcyBpbnN0ZWFkIGRvbmUgdmlhOlxuICAgICAgLy8gLy8gQ2hlY2sgdGhhdCBuYXRpb25hbCBwcmVmaXggZm9ybWF0dGluZyBydWxlIGlzIG5vdCBhIFwiZHVtbXlcIiBvbmUuXG4gICAgICAvLyB0aGlzLm5hdGlvbmFsUHJlZml4Rm9ybWF0dGluZ1J1bGUoKSAhPT0gJyQxJyAmJlxuICAgICAgLy8gLy8gQ2hlY2sgdGhhdCBuYXRpb25hbCBwcmVmaXggZm9ybWF0dGluZyBydWxlIGFjdHVhbGx5IGhhcyBuYXRpb25hbCBwcmVmaXggZGlnaXQocykuXG4gICAgICAvLyAvLyBGaWx0ZXJzIG91dCBjYXNlcyBsaWtlIFwiKCQxKVwiLlxuICAgICAgLy8gLy8gSXMgdXNlZCBpbiBwbGFjZSBvZiBgbGlicGhvbmVudW1iZXJgJ3MgYEZJUlNUX0dST1VQX09OTFlfUFJFRklYX1BBVFRFUk5fYCByZWdleHAuXG4gICAgICAvLyAvXFxkLy50ZXN0KHRoaXMubmF0aW9uYWxQcmVmaXhGb3JtYXR0aW5nUnVsZSgpLnJlcGxhY2UoJyQxJywgJycpKVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcm5hdGlvbmFsRm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVybmF0aW9uYWxGb3JtYXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZm9ybWF0WzVdIHx8IHRoaXMuZm9ybWF0KCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvcm1hdDtcbn0oKTtcbi8qKlxyXG4gKiBBIHBhdHRlcm4gdGhhdCBpcyB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgbmF0aW9uYWwgcHJlZml4IGZvcm1hdHRpbmcgcnVsZVxyXG4gKiBoYXMgdGhlIGZpcnN0IGdyb3VwIG9ubHksIGkuZS4sIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIG5hdGlvbmFsIHByZWZpeC5cclxuICogTm90ZSB0aGF0IHRoZSBwYXR0ZXJuIGV4cGxpY2l0bHkgYWxsb3dzIGZvciB1bmJhbGFuY2VkIHBhcmVudGhlc2VzLlxyXG4gKi9cblxuXG52YXIgRklSU1RfR1JPVVBfT05MWV9QUkVGSVhfUEFUVEVSTiA9IC9eXFwoP1xcJDFcXCk/JC87XG5cbnZhciBUeXBlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHlwZSh0eXBlLCBtZXRhZGF0YSkge1xuICAgIG1ldGFkYXRhX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFR5cGUpO1xuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVHlwZSwgW3tcbiAgICBrZXk6IFwicGF0dGVyblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXR0ZXJuKCkge1xuICAgICAgaWYgKHRoaXMubWV0YWRhdGEudjEpIHJldHVybiB0aGlzLnR5cGU7XG4gICAgICByZXR1cm4gdGhpcy50eXBlWzBdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3NzaWJsZUxlbmd0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zc2libGVMZW5ndGhzKCkge1xuICAgICAgaWYgKHRoaXMubWV0YWRhdGEudjEpIHJldHVybjtcbiAgICAgIHJldHVybiB0aGlzLnR5cGVbMV0gfHwgdGhpcy5tZXRhZGF0YS5wb3NzaWJsZUxlbmd0aHMoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHlwZTtcbn0oKTtcblxuZnVuY3Rpb24gbWV0YWRhdGFfZ2V0VHlwZSh0eXBlcywgdHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdGSVhFRF9MSU5FJzpcbiAgICAgIHJldHVybiB0eXBlc1swXTtcblxuICAgIGNhc2UgJ01PQklMRSc6XG4gICAgICByZXR1cm4gdHlwZXNbMV07XG5cbiAgICBjYXNlICdUT0xMX0ZSRUUnOlxuICAgICAgcmV0dXJuIHR5cGVzWzJdO1xuXG4gICAgY2FzZSAnUFJFTUlVTV9SQVRFJzpcbiAgICAgIHJldHVybiB0eXBlc1szXTtcblxuICAgIGNhc2UgJ1BFUlNPTkFMX05VTUJFUic6XG4gICAgICByZXR1cm4gdHlwZXNbNF07XG5cbiAgICBjYXNlICdWT0lDRU1BSUwnOlxuICAgICAgcmV0dXJuIHR5cGVzWzVdO1xuXG4gICAgY2FzZSAnVUFOJzpcbiAgICAgIHJldHVybiB0eXBlc1s2XTtcblxuICAgIGNhc2UgJ1BBR0VSJzpcbiAgICAgIHJldHVybiB0eXBlc1s3XTtcblxuICAgIGNhc2UgJ1ZPSVAnOlxuICAgICAgcmV0dXJuIHR5cGVzWzhdO1xuXG4gICAgY2FzZSAnU0hBUkVEX0NPU1QnOlxuICAgICAgcmV0dXJuIHR5cGVzWzldO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgaWYgKCFtZXRhZGF0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2xpYnBob25lbnVtYmVyLWpzXSBgbWV0YWRhdGFgIGFyZ3VtZW50IG5vdCBwYXNzZWQuIENoZWNrIHlvdXIgYXJndW1lbnRzLicpO1xuICB9IC8vIGBjb3VudHJ5X3Bob25lX2NvZGVfdG9fY291bnRyaWVzYCB3YXMgcmVuYW1lZCB0b1xuICAvLyBgY291bnRyeV9jYWxsaW5nX2NvZGVzYCBpbiBgMS4wLjE4YC5cblxuXG4gIGlmICghaXNfb2JqZWN0KG1ldGFkYXRhKSB8fCAhaXNfb2JqZWN0KG1ldGFkYXRhLmNvdW50cmllcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbGlicGhvbmVudW1iZXItanNdIGBtZXRhZGF0YWAgYXJndW1lbnQgd2FzIHBhc3NlZCBidXQgaXQncyBub3QgYSB2YWxpZCBtZXRhZGF0YS4gTXVzdCBiZSBhbiBvYmplY3QgaGF2aW5nIGAuY291bnRyaWVzYCBjaGlsZCBvYmplY3QgcHJvcGVydHkuIEdvdCBcIi5jb25jYXQoaXNfb2JqZWN0KG1ldGFkYXRhKSA/ICdhbiBvYmplY3Qgb2Ygc2hhcGU6IHsgJyArIE9iamVjdC5rZXlzKG1ldGFkYXRhKS5qb2luKCcsICcpICsgJyB9JyA6ICdhICcgKyB0eXBlX29mKG1ldGFkYXRhKSArICc6ICcgKyBtZXRhZGF0YSwgXCIuXCIpKTtcbiAgfVxufSAvLyBCYWJlbCB0cmFuc2Zvcm1zIGB0eXBlb2ZgIGludG8gc29tZSBcImJyYW5jaGVzXCJcbi8vIHNvIGlzdGFuYnVsIHdpbGwgc2hvdyB0aGlzIGFzIFwiYnJhbmNoIG5vdCBjb3ZlcmVkXCIuXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbnZhciBpc19vYmplY3QgPSBmdW5jdGlvbiBpc19vYmplY3QoXykge1xuICByZXR1cm4gX3R5cGVvZihfKSA9PT0gJ29iamVjdCc7XG59OyAvLyBCYWJlbCB0cmFuc2Zvcm1zIGB0eXBlb2ZgIGludG8gc29tZSBcImJyYW5jaGVzXCJcbi8vIHNvIGlzdGFuYnVsIHdpbGwgc2hvdyB0aGlzIGFzIFwiYnJhbmNoIG5vdCBjb3ZlcmVkXCIuXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxudmFyIHR5cGVfb2YgPSBmdW5jdGlvbiB0eXBlX29mKF8pIHtcbiAgcmV0dXJuIF90eXBlb2YoXyk7XG59O1xuLyoqXHJcbiAqIFJldHVybnMgZXh0ZW5zaW9uIHByZWZpeCBmb3IgYSBjb3VudHJ5LlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvdW50cnlcclxuICogQHBhcmFtICB7b2JqZWN0fSBtZXRhZGF0YVxyXG4gKiBAcmV0dXJuIHtzdHJpbmc/fVxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBSZXR1cm5zIFwiIGV4dC4gXCJcclxuICogZ2V0RXh0UHJlZml4KFwiVVNcIilcclxuICovXG5cblxuZnVuY3Rpb24gZ2V0RXh0UHJlZml4KGNvdW50cnksIG1ldGFkYXRhKSB7XG4gIG1ldGFkYXRhID0gbmV3IE1ldGFkYXRhKG1ldGFkYXRhKTtcblxuICBpZiAobWV0YWRhdGEuaGFzQ291bnRyeShjb3VudHJ5KSkge1xuICAgIHJldHVybiBtZXRhZGF0YS5jb3VudHJ5KGNvdW50cnkpLmV4dCgpO1xuICB9XG5cbiAgcmV0dXJuIERFRkFVTFRfRVhUX1BSRUZJWDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIFwiY291bnRyeSBjYWxsaW5nIGNvZGVcIiBmb3IgYSBjb3VudHJ5LlxyXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGNvdW50cnkgZG9lc24ndCBleGlzdCBvciBpc24ndCBzdXBwb3J0ZWQgYnkgdGhpcyBsaWJyYXJ5LlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvdW50cnlcclxuICogQHBhcmFtICB7b2JqZWN0fSBtZXRhZGF0YVxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIFJldHVybnMgXCI0NFwiXHJcbiAqIGdldENvdW50cnlDYWxsaW5nQ29kZShcIkdCXCIpXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRDb3VudHJ5Q2FsbGluZ0NvZGUoY291bnRyeSwgbWV0YWRhdGEpIHtcbiAgbWV0YWRhdGEgPSBuZXcgTWV0YWRhdGEobWV0YWRhdGEpO1xuXG4gIGlmIChtZXRhZGF0YS5oYXNDb3VudHJ5KGNvdW50cnkpKSB7XG4gICAgcmV0dXJuIG1ldGFkYXRhLmNvdW50cnkoY291bnRyeSkuY291bnRyeUNhbGxpbmdDb2RlKCk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvdW50cnk6IFwiLmNvbmNhdChjb3VudHJ5KSk7XG59XG5mdW5jdGlvbiBpc1N1cHBvcnRlZENvdW50cnkoY291bnRyeSwgbWV0YWRhdGEpIHtcbiAgLy8gbWV0YWRhdGEgPSBuZXcgTWV0YWRhdGEobWV0YWRhdGEpXG4gIC8vIHJldHVybiBtZXRhZGF0YS5oYXNDb3VudHJ5KGNvdW50cnkpXG4gIHJldHVybiBtZXRhZGF0YS5jb3VudHJpZXNbY291bnRyeV0gIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2V0VmVyc2lvbihtZXRhZGF0YSkge1xuICB0aGlzLnYxID0gIW1ldGFkYXRhLnZlcnNpb247XG4gIHRoaXMudjIgPSBtZXRhZGF0YS52ZXJzaW9uICE9PSB1bmRlZmluZWQgJiYgc2VtdmVyX2NvbXBhcmUobWV0YWRhdGEudmVyc2lvbiwgVjMpID09PSAtMTtcbiAgdGhpcy52MyA9IG1ldGFkYXRhLnZlcnNpb24gIT09IHVuZGVmaW5lZCAmJiBzZW12ZXJfY29tcGFyZShtZXRhZGF0YS52ZXJzaW9uLCBWNCkgPT09IC0xO1xuICB0aGlzLnY0ID0gbWV0YWRhdGEudmVyc2lvbiAhPT0gdW5kZWZpbmVkOyAvLyAmJiBjb21wYXJlKG1ldGFkYXRhLnZlcnNpb24sIFY1KSA9PT0gLTFcbn0gLy8gY29uc3QgSVNPX0NPVU5UUllfQ09ERSA9IC9eW0EtWl17Mn0kL1xuLy8gZnVuY3Rpb24gaXNDb3VudHJ5Q29kZShjb3VudHJ5Q29kZSkge1xuLy8gXHRyZXR1cm4gSVNPX0NPVU5UUllfQ09ERS50ZXN0KGNvdW50cnlDb2RlT3JDb3VudHJ5Q2FsbGluZ0NvZGUpXG4vLyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhZGF0YS5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9leHRlbnNpb24uanNcbiAvLyBUaGUgUkZDIDM5NjYgZm9ybWF0IGZvciBleHRlbnNpb25zLlxuXG52YXIgUkZDMzk2Nl9FWFROX1BSRUZJWCA9ICc7ZXh0PSc7IC8vIFBhdHRlcm4gdG8gY2FwdHVyZSBkaWdpdHMgdXNlZCBpbiBhbiBleHRlbnNpb24uXG4vLyBQbGFjZXMgYSBtYXhpbXVtIGxlbmd0aCBvZiAnNycgZm9yIGFuIGV4dGVuc2lvbi5cblxudmFyIENBUFRVUklOR19FWFROX0RJR0lUUyA9ICcoWycgKyBWQUxJRF9ESUdJVFMgKyAnXXsxLDd9KSc7XG4vKipcclxuICogUmVnZXhwIG9mIGFsbCBwb3NzaWJsZSB3YXlzIHRvIHdyaXRlIGV4dGVuc2lvbnMsIGZvciB1c2Ugd2hlbiBwYXJzaW5nLiBUaGlzXHJcbiAqIHdpbGwgYmUgcnVuIGFzIGEgY2FzZS1pbnNlbnNpdGl2ZSByZWdleHAgbWF0Y2guIFdpZGUgY2hhcmFjdGVyIHZlcnNpb25zIGFyZVxyXG4gKiBhbHNvIHByb3ZpZGVkIGFmdGVyIGVhY2ggQVNDSUkgdmVyc2lvbi4gVGhlcmUgYXJlIHRocmVlIHJlZ3VsYXIgZXhwcmVzc2lvbnNcclxuICogaGVyZS4gVGhlIGZpcnN0IGNvdmVycyBSRkMgMzk2NiBmb3JtYXQsIHdoZXJlIHRoZSBleHRlbnNpb24gaXMgYWRkZWQgdXNpbmdcclxuICogJztleHQ9Jy4gVGhlIHNlY29uZCBtb3JlIGdlbmVyaWMgb25lIHN0YXJ0cyB3aXRoIG9wdGlvbmFsIHdoaXRlIHNwYWNlIGFuZFxyXG4gKiBlbmRzIHdpdGggYW4gb3B0aW9uYWwgZnVsbCBzdG9wICguKSwgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIHNwYWNlcy90YWJzXHJcbiAqIC9jb21tYXMgYW5kIHRoZW4gdGhlIG51bWJlcnMgdGhlbXNlbHZlcy4gVGhlIG90aGVyIG9uZSBjb3ZlcnMgdGhlIHNwZWNpYWxcclxuICogY2FzZSBvZiBBbWVyaWNhbiBudW1iZXJzIHdoZXJlIHRoZSBleHRlbnNpb24gaXMgd3JpdHRlbiB3aXRoIGEgaGFzaCBhdCB0aGVcclxuICogZW5kLCBzdWNoIGFzICctIDUwMyMnLiBOb3RlIHRoYXQgdGhlIG9ubHkgY2FwdHVyaW5nIGdyb3VwcyBzaG91bGQgYmUgYXJvdW5kXHJcbiAqIHRoZSBkaWdpdHMgdGhhdCB5b3Ugd2FudCB0byBjYXB0dXJlIGFzIHBhcnQgb2YgdGhlIGV4dGVuc2lvbiwgb3IgZWxzZSBwYXJzaW5nXHJcbiAqIHdpbGwgZmFpbCEgV2UgYWxsb3cgdHdvIG9wdGlvbnMgZm9yIHJlcHJlc2VudGluZyB0aGUgYWNjZW50ZWQgbyAtIHRoZVxyXG4gKiBjaGFyYWN0ZXIgaXRzZWxmLCBhbmQgb25lIGluIHRoZSB1bmljb2RlIGRlY29tcG9zZWQgZm9ybSB3aXRoIHRoZSBjb21iaW5pbmdcclxuICogYWN1dGUgYWNjZW50LlxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlX2V4dGVuc2lvbl9wYXR0ZXJuKHB1cnBvc2UpIHtcbiAgLy8gT25lLWNoYXJhY3RlciBzeW1ib2xzIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW5kaWNhdGUgYW4gZXh0ZW5zaW9uLlxuICB2YXIgc2luZ2xlX2V4dGVuc2lvbl9jaGFyYWN0ZXJzID0gXCJ4XFx1RkY1OCNcXHVGRjAzflxcdUZGNUVcIjtcblxuICBzd2l0Y2ggKHB1cnBvc2UpIHtcbiAgICAvLyBGb3IgcGFyc2luZywgd2UgYXJlIHNsaWdodGx5IG1vcmUgbGVuaWVudCBpbiBvdXIgaW50ZXJwcmV0YXRpb24gdGhhbiBmb3IgbWF0Y2hpbmcuIEhlcmUgd2VcbiAgICAvLyBhbGxvdyBcImNvbW1hXCIgYW5kIFwic2VtaWNvbG9uXCIgYXMgcG9zc2libGUgZXh0ZW5zaW9uIGluZGljYXRvcnMuIFdoZW4gbWF0Y2hpbmcsIHRoZXNlIGFyZVxuICAgIGNhc2UgJ3BhcnNpbmcnOlxuICAgICAgc2luZ2xlX2V4dGVuc2lvbl9jaGFyYWN0ZXJzID0gJyw7JyArIHNpbmdsZV9leHRlbnNpb25fY2hhcmFjdGVycztcbiAgfVxuXG4gIHJldHVybiBSRkMzOTY2X0VYVE5fUFJFRklYICsgQ0FQVFVSSU5HX0VYVE5fRElHSVRTICsgJ3wnICsgXCJbIFxceEEwXFxcXHQsXSpcIiArIFwiKD86ZT94dCg/OmVuc2koPzpvXFx1MDMwMT98XFx4RjMpKT9uP3xcXHVGRjQ1P1xcdUZGNThcXHVGRjU0XFx1RkY0RT98XCIgKyAvLyBcItC00L7QsS5cIlxuICBcIlxcdTA0MzRcXHUwNDNFXFx1MDQzMXxcIiArICdbJyArIHNpbmdsZV9leHRlbnNpb25fY2hhcmFjdGVycyArIFwiXXxpbnR8YW5leG98XFx1RkY0OVxcdUZGNEVcXHVGRjU0KVwiICsgXCJbOlxcXFwuXFx1RkYwRV0/WyBcXHhBMFxcXFx0LC1dKlwiICsgQ0FQVFVSSU5HX0VYVE5fRElHSVRTICsgJyM/fCcgKyAnWy0gXSsoWycgKyBWQUxJRF9ESUdJVFMgKyAnXXsxLDV9KSMnO1xufVxuLyoqXHJcbiAqIFJlZ2V4cCBvZiBhbGwgcG9zc2libGUgd2F5cyB0byB3cml0ZSBleHRlbnNpb25zLCBmb3IgdXNlIHdoZW4gcGFyc2luZy4gVGhpc1xyXG4gKiB3aWxsIGJlIHJ1biBhcyBhIGNhc2UtaW5zZW5zaXRpdmUgcmVnZXhwIG1hdGNoLiBXaWRlIGNoYXJhY3RlciB2ZXJzaW9ucyBhcmVcclxuICogYWxzbyBwcm92aWRlZCBhZnRlciBlYWNoIEFTQ0lJIHZlcnNpb24uIFRoZXJlIGFyZSB0aHJlZSByZWd1bGFyIGV4cHJlc3Npb25zXHJcbiAqIGhlcmUuIFRoZSBmaXJzdCBjb3ZlcnMgUkZDIDM5NjYgZm9ybWF0LCB3aGVyZSB0aGUgZXh0ZW5zaW9uIGlzIGFkZGVkIHVzaW5nXHJcbiAqICc7ZXh0PScuIFRoZSBzZWNvbmQgbW9yZSBnZW5lcmljIG9uZSBzdGFydHMgd2l0aCBvcHRpb25hbCB3aGl0ZSBzcGFjZSBhbmRcclxuICogZW5kcyB3aXRoIGFuIG9wdGlvbmFsIGZ1bGwgc3RvcCAoLiksIGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBzcGFjZXMvdGFic1xyXG4gKiAvY29tbWFzIGFuZCB0aGVuIHRoZSBudW1iZXJzIHRoZW1zZWx2ZXMuIFRoZSBvdGhlciBvbmUgY292ZXJzIHRoZSBzcGVjaWFsXHJcbiAqIGNhc2Ugb2YgQW1lcmljYW4gbnVtYmVycyB3aGVyZSB0aGUgZXh0ZW5zaW9uIGlzIHdyaXR0ZW4gd2l0aCBhIGhhc2ggYXQgdGhlXHJcbiAqIGVuZCwgc3VjaCBhcyAnLSA1MDMjJy4gTm90ZSB0aGF0IHRoZSBvbmx5IGNhcHR1cmluZyBncm91cHMgc2hvdWxkIGJlIGFyb3VuZFxyXG4gKiB0aGUgZGlnaXRzIHRoYXQgeW91IHdhbnQgdG8gY2FwdHVyZSBhcyBwYXJ0IG9mIHRoZSBleHRlbnNpb24sIG9yIGVsc2UgcGFyc2luZ1xyXG4gKiB3aWxsIGZhaWwhIFdlIGFsbG93IHR3byBvcHRpb25zIGZvciByZXByZXNlbnRpbmcgdGhlIGFjY2VudGVkIG8gLSB0aGVcclxuICogY2hhcmFjdGVyIGl0c2VsZiwgYW5kIG9uZSBpbiB0aGUgdW5pY29kZSBkZWNvbXBvc2VkIGZvcm0gd2l0aCB0aGUgY29tYmluaW5nXHJcbiAqIGFjdXRlIGFjY2VudC5cclxuICovXG5cblxudmFyIEVYVE5fUEFUVEVSTlNfRk9SX1BBUlNJTkcgPSBjcmVhdGVfZXh0ZW5zaW9uX3BhdHRlcm4oJ3BhcnNpbmcnKTtcbnZhciBFWFROX1BBVFRFUk5TX0ZPUl9NQVRDSElORyA9IGNyZWF0ZV9leHRlbnNpb25fcGF0dGVybignbWF0Y2hpbmcnKTsgLy8gUmVnZXhwIG9mIGFsbCBrbm93biBleHRlbnNpb24gcHJlZml4ZXMgdXNlZCBieSBkaWZmZXJlbnQgcmVnaW9ucyBmb2xsb3dlZCBieVxuLy8gMSBvciBtb3JlIHZhbGlkIGRpZ2l0cywgZm9yIHVzZSB3aGVuIHBhcnNpbmcuXG5cbnZhciBFWFROX1BBVFRFUk4gPSBuZXcgUmVnRXhwKCcoPzonICsgRVhUTl9QQVRURVJOU19GT1JfUEFSU0lORyArICcpJCcsICdpJyk7IC8vIFN0cmlwcyBhbnkgZXh0ZW5zaW9uIChhcyBpbiwgdGhlIHBhcnQgb2YgdGhlIG51bWJlciBkaWFsbGVkIGFmdGVyIHRoZSBjYWxsIGlzXG4vLyBjb25uZWN0ZWQsIHVzdWFsbHkgaW5kaWNhdGVkIHdpdGggZXh0biwgZXh0LCB4IG9yIHNpbWlsYXIpIGZyb20gdGhlIGVuZCBvZlxuLy8gdGhlIG51bWJlciwgYW5kIHJldHVybnMgaXQuXG5cbmZ1bmN0aW9uIGV4dHJhY3RFeHRlbnNpb24obnVtYmVyKSB7XG4gIHZhciBzdGFydCA9IG51bWJlci5zZWFyY2goRVhUTl9QQVRURVJOKTtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9IC8vIElmIHdlIGZpbmQgYSBwb3RlbnRpYWwgZXh0ZW5zaW9uLCBhbmQgdGhlIG51bWJlciBwcmVjZWRpbmcgdGhpcyBpcyBhIHZpYWJsZVxuICAvLyBudW1iZXIsIHdlIGFzc3VtZSBpdCBpcyBhbiBleHRlbnNpb24uXG5cblxuICB2YXIgbnVtYmVyX3dpdGhvdXRfZXh0ZW5zaW9uID0gbnVtYmVyLnNsaWNlKDAsIHN0YXJ0KTtcbiAgdmFyIG1hdGNoZXMgPSBudW1iZXIubWF0Y2goRVhUTl9QQVRURVJOKTtcbiAgdmFyIGkgPSAxO1xuXG4gIHdoaWxlIChpIDwgbWF0Y2hlcy5sZW5ndGgpIHtcbiAgICBpZiAobWF0Y2hlc1tpXSAhPSBudWxsICYmIG1hdGNoZXNbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJfd2l0aG91dF9leHRlbnNpb24sXG4gICAgICAgIGV4dDogbWF0Y2hlc1tpXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpKys7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVuc2lvbi5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9pc1ZpYWJsZVBob25lTnVtYmVyLmpzXG5cbiAvLyAgUmVndWxhciBleHByZXNzaW9uIG9mIHZpYWJsZSBwaG9uZSBudW1iZXJzLiBUaGlzIGlzIGxvY2F0aW9uIGluZGVwZW5kZW50LlxuLy8gIENoZWNrcyB3ZSBoYXZlIGF0IGxlYXN0IHRocmVlIGxlYWRpbmcgZGlnaXRzLCBhbmQgb25seSB2YWxpZCBwdW5jdHVhdGlvbixcbi8vICBhbHBoYSBjaGFyYWN0ZXJzIGFuZCBkaWdpdHMgaW4gdGhlIHBob25lIG51bWJlci4gRG9lcyBub3QgaW5jbHVkZSBleHRlbnNpb25cbi8vICBkYXRhLiBUaGUgc3ltYm9sICd4JyBpcyBhbGxvd2VkIGhlcmUgYXMgdmFsaWQgcHVuY3R1YXRpb24gc2luY2UgaXQgaXMgb2Z0ZW5cbi8vICB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIGNhcnJpZXIgY29kZXMsIGZvciBleGFtcGxlIGluIEJyYXppbGlhbiBwaG9uZVxuLy8gIG51bWJlcnMuIFdlIGFsc28gYWxsb3cgbXVsdGlwbGUgJysnIGNoYXJhY3RlcnMgYXQgdGhlIHN0YXJ0LlxuLy9cbi8vICBDb3JyZXNwb25kcyB0byB0aGUgZm9sbG93aW5nOlxuLy8gIFtkaWdpdHNde21pbkxlbmd0aE5zbn18XG4vLyAgcGx1c19zaWduKlxuLy8gICgoW3B1bmN0dWF0aW9uXXxbc3Rhcl0pKltkaWdpdHNdKXszLH0oW3B1bmN0dWF0aW9uXXxbc3Rhcl18W2RpZ2l0c118W2FscGhhXSkqXG4vL1xuLy8gIFRoZSBmaXJzdCByZWctZXggaXMgdG8gYWxsb3cgc2hvcnQgbnVtYmVycyAodHdvIGRpZ2l0cyBsb25nKSB0byBiZSBwYXJzZWQgaWZcbi8vICB0aGV5IGFyZSBlbnRlcmVkIGFzIFwiMTVcIiBldGMsIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vIHB1bmN0dWF0aW9uIGluIHRoZW0uXG4vLyAgVGhlIHNlY29uZCBleHByZXNzaW9uIHJlc3RyaWN0cyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyB0byB0aHJlZSBvciBtb3JlLCBidXRcbi8vICB0aGVuIGFsbG93cyB0aGVtIHRvIGJlIGluIGludGVybmF0aW9uYWwgZm9ybSwgYW5kIHRvIGhhdmUgYWxwaGEtY2hhcmFjdGVyc1xuLy8gIGFuZCBwdW5jdHVhdGlvbi4gV2Ugc3BsaXQgdXAgdGhlIHR3byByZWctZXhlcyBoZXJlIGFuZCBjb21iaW5lIHRoZW0gd2hlblxuLy8gIGNyZWF0aW5nIHRoZSByZWctZXggVkFMSURfUEhPTkVfTlVNQkVSX1BBVFRFUk4gaXRzZWxmIHNvIHdlIGNhbiBwcmVmaXggaXRcbi8vICB3aXRoIF4gYW5kIGFwcGVuZCAkIHRvIGVhY2ggYnJhbmNoLlxuLy9cbi8vICBcIk5vdGUgVkFMSURfUFVOQ1RVQVRJT04gc3RhcnRzIHdpdGggYSAtLFxuLy8gICBzbyBtdXN0IGJlIHRoZSBmaXJzdCBpbiB0aGUgcmFuZ2VcIiAoYykgR29vZ2xlIGRldnMuXG4vLyAgKHd0ZiBkaWQgdGhleSBtZWFuIGJ5IHNheWluZyB0aGF0OyBwcm9iYWJseSBub3RoaW5nKVxuLy9cblxudmFyIE1JTl9MRU5HVEhfUEhPTkVfTlVNQkVSX1BBVFRFUk4gPSAnWycgKyBWQUxJRF9ESUdJVFMgKyAnXXsnICsgTUlOX0xFTkdUSF9GT1JfTlNOICsgJ30nOyAvL1xuLy8gQW5kIHRoaXMgaXMgdGhlIHNlY29uZCByZWctZXhwOlxuLy8gKHNlZSBNSU5fTEVOR1RIX1BIT05FX05VTUJFUl9QQVRURVJOIGZvciBhIGZ1bGwgZGVzY3JpcHRpb24gb2YgdGhpcyByZWctZXhwKVxuLy9cblxudmFyIFZBTElEX1BIT05FX05VTUJFUiA9ICdbJyArIFBMVVNfQ0hBUlMgKyAnXXswLDF9JyArICcoPzonICsgJ1snICsgVkFMSURfUFVOQ1RVQVRJT04gKyAnXSonICsgJ1snICsgVkFMSURfRElHSVRTICsgJ10nICsgJyl7Myx9JyArICdbJyArIFZBTElEX1BVTkNUVUFUSU9OICsgVkFMSURfRElHSVRTICsgJ10qJzsgLy8gVGhlIGNvbWJpbmVkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgdmFsaWQgcGhvbmUgbnVtYmVyczpcbi8vXG5cbnZhciBWQUxJRF9QSE9ORV9OVU1CRVJfUEFUVEVSTiA9IG5ldyBSZWdFeHAoIC8vIEVpdGhlciBhIHNob3J0IHR3by1kaWdpdC1vbmx5IHBob25lIG51bWJlclxuJ14nICsgTUlOX0xFTkdUSF9QSE9ORV9OVU1CRVJfUEFUVEVSTiArICckJyArICd8JyArIC8vIE9yIGEgbG9uZ2VyIGZ1bGx5IHBhcnNlZCBwaG9uZSBudW1iZXIgKG1pbiAzIGNoYXJhY3RlcnMpXG4nXicgKyBWQUxJRF9QSE9ORV9OVU1CRVIgKyAvLyBQaG9uZSBudW1iZXIgZXh0ZW5zaW9uc1xuJyg/OicgKyBFWFROX1BBVFRFUk5TX0ZPUl9QQVJTSU5HICsgJyk/JyArICckJywgJ2knKTsgLy8gQ2hlY2tzIHRvIHNlZSBpZiB0aGUgc3RyaW5nIG9mIGNoYXJhY3RlcnMgY291bGQgcG9zc2libHkgYmUgYSBwaG9uZSBudW1iZXIgYXRcbi8vIGFsbC4gQXQgdGhlIG1vbWVudCwgY2hlY2tzIHRvIHNlZSB0aGF0IHRoZSBzdHJpbmcgYmVnaW5zIHdpdGggYXQgbGVhc3QgMlxuLy8gZGlnaXRzLCBpZ25vcmluZyBhbnkgcHVuY3R1YXRpb24gY29tbW9ubHkgZm91bmQgaW4gcGhvbmUgbnVtYmVycy4gVGhpcyBtZXRob2Rcbi8vIGRvZXMgbm90IHJlcXVpcmUgdGhlIG51bWJlciB0byBiZSBub3JtYWxpemVkIGluIGFkdmFuY2UgLSBidXQgZG9lcyBhc3N1bWVcbi8vIHRoYXQgbGVhZGluZyBub24tbnVtYmVyIHN5bWJvbHMgaGF2ZSBiZWVuIHJlbW92ZWQsIHN1Y2ggYXMgYnkgdGhlIG1ldGhvZFxuLy8gYGV4dHJhY3RfcG9zc2libGVfbnVtYmVyYC5cbi8vXG5cbmZ1bmN0aW9uIGlzVmlhYmxlUGhvbmVOdW1iZXIobnVtYmVyKSB7XG4gIHJldHVybiBudW1iZXIubGVuZ3RoID49IE1JTl9MRU5HVEhfRk9SX05TTiAmJiBWQUxJRF9QSE9ORV9OVU1CRVJfUEFUVEVSTi50ZXN0KG51bWJlcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1ZpYWJsZVBob25lTnVtYmVyLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvZXM2L3BhcnNlRGlnaXRzLmpzXG4vLyBUaGVzZSBtYXBwaW5ncyBtYXAgYSBjaGFyYWN0ZXIgKGtleSkgdG8gYSBzcGVjaWZpYyBkaWdpdCB0aGF0IHNob3VsZFxuLy8gcmVwbGFjZSBpdCBmb3Igbm9ybWFsaXphdGlvbiBwdXJwb3Nlcy4gTm9uLUV1cm9wZWFuIGRpZ2l0cyB0aGF0XG4vLyBtYXkgYmUgdXNlZCBpbiBwaG9uZSBudW1iZXJzIGFyZSBtYXBwZWQgdG8gYSBFdXJvcGVhbiBlcXVpdmFsZW50LlxuLy9cbi8vIEUuZy4gaW4gSXJhcSB0aGV5IGRvbid0IHdyaXRlIGArNDQyMzIzMjM0YCBidXQgcmF0aGVyIGAr2aTZpNmi2aPZotmj2aLZo9mkYC5cbi8vXG52YXIgRElHSVRTID0ge1xuICAnMCc6ICcwJyxcbiAgJzEnOiAnMScsXG4gICcyJzogJzInLFxuICAnMyc6ICczJyxcbiAgJzQnOiAnNCcsXG4gICc1JzogJzUnLFxuICAnNic6ICc2JyxcbiAgJzcnOiAnNycsXG4gICc4JzogJzgnLFxuICAnOSc6ICc5JyxcbiAgXCJcXHVGRjEwXCI6ICcwJyxcbiAgLy8gRnVsbHdpZHRoIGRpZ2l0IDBcbiAgXCJcXHVGRjExXCI6ICcxJyxcbiAgLy8gRnVsbHdpZHRoIGRpZ2l0IDFcbiAgXCJcXHVGRjEyXCI6ICcyJyxcbiAgLy8gRnVsbHdpZHRoIGRpZ2l0IDJcbiAgXCJcXHVGRjEzXCI6ICczJyxcbiAgLy8gRnVsbHdpZHRoIGRpZ2l0IDNcbiAgXCJcXHVGRjE0XCI6ICc0JyxcbiAgLy8gRnVsbHdpZHRoIGRpZ2l0IDRcbiAgXCJcXHVGRjE1XCI6ICc1JyxcbiAgLy8gRnVsbHdpZHRoIGRpZ2l0IDVcbiAgXCJcXHVGRjE2XCI6ICc2JyxcbiAgLy8gRnVsbHdpZHRoIGRpZ2l0IDZcbiAgXCJcXHVGRjE3XCI6ICc3JyxcbiAgLy8gRnVsbHdpZHRoIGRpZ2l0IDdcbiAgXCJcXHVGRjE4XCI6ICc4JyxcbiAgLy8gRnVsbHdpZHRoIGRpZ2l0IDhcbiAgXCJcXHVGRjE5XCI6ICc5JyxcbiAgLy8gRnVsbHdpZHRoIGRpZ2l0IDlcbiAgXCJcXHUwNjYwXCI6ICcwJyxcbiAgLy8gQXJhYmljLWluZGljIGRpZ2l0IDBcbiAgXCJcXHUwNjYxXCI6ICcxJyxcbiAgLy8gQXJhYmljLWluZGljIGRpZ2l0IDFcbiAgXCJcXHUwNjYyXCI6ICcyJyxcbiAgLy8gQXJhYmljLWluZGljIGRpZ2l0IDJcbiAgXCJcXHUwNjYzXCI6ICczJyxcbiAgLy8gQXJhYmljLWluZGljIGRpZ2l0IDNcbiAgXCJcXHUwNjY0XCI6ICc0JyxcbiAgLy8gQXJhYmljLWluZGljIGRpZ2l0IDRcbiAgXCJcXHUwNjY1XCI6ICc1JyxcbiAgLy8gQXJhYmljLWluZGljIGRpZ2l0IDVcbiAgXCJcXHUwNjY2XCI6ICc2JyxcbiAgLy8gQXJhYmljLWluZGljIGRpZ2l0IDZcbiAgXCJcXHUwNjY3XCI6ICc3JyxcbiAgLy8gQXJhYmljLWluZGljIGRpZ2l0IDdcbiAgXCJcXHUwNjY4XCI6ICc4JyxcbiAgLy8gQXJhYmljLWluZGljIGRpZ2l0IDhcbiAgXCJcXHUwNjY5XCI6ICc5JyxcbiAgLy8gQXJhYmljLWluZGljIGRpZ2l0IDlcbiAgXCJcXHUwNkYwXCI6ICcwJyxcbiAgLy8gRWFzdGVybi1BcmFiaWMgZGlnaXQgMFxuICBcIlxcdTA2RjFcIjogJzEnLFxuICAvLyBFYXN0ZXJuLUFyYWJpYyBkaWdpdCAxXG4gIFwiXFx1MDZGMlwiOiAnMicsXG4gIC8vIEVhc3Rlcm4tQXJhYmljIGRpZ2l0IDJcbiAgXCJcXHUwNkYzXCI6ICczJyxcbiAgLy8gRWFzdGVybi1BcmFiaWMgZGlnaXQgM1xuICBcIlxcdTA2RjRcIjogJzQnLFxuICAvLyBFYXN0ZXJuLUFyYWJpYyBkaWdpdCA0XG4gIFwiXFx1MDZGNVwiOiAnNScsXG4gIC8vIEVhc3Rlcm4tQXJhYmljIGRpZ2l0IDVcbiAgXCJcXHUwNkY2XCI6ICc2JyxcbiAgLy8gRWFzdGVybi1BcmFiaWMgZGlnaXQgNlxuICBcIlxcdTA2RjdcIjogJzcnLFxuICAvLyBFYXN0ZXJuLUFyYWJpYyBkaWdpdCA3XG4gIFwiXFx1MDZGOFwiOiAnOCcsXG4gIC8vIEVhc3Rlcm4tQXJhYmljIGRpZ2l0IDhcbiAgXCJcXHUwNkY5XCI6ICc5JyAvLyBFYXN0ZXJuLUFyYWJpYyBkaWdpdCA5XG5cbn07XG5mdW5jdGlvbiBwYXJzZURpZ2l0KGNoYXJhY3Rlcikge1xuICByZXR1cm4gRElHSVRTW2NoYXJhY3Rlcl07XG59XG4vKipcclxuICogUGFyc2VzIHBob25lIG51bWJlciBkaWdpdHMgZnJvbSBhIHN0cmluZy5cclxuICogRHJvcHMgYWxsIHB1bmN0dWF0aW9uIGxlYXZpbmcgb25seSBkaWdpdHMuXHJcbiAqIEFsc28gY29udmVydHMgd2lkZS1hc2NpaSBhbmQgYXJhYmljLWluZGljIG51bWVyYWxzIHRvIGNvbnZlbnRpb25hbCBudW1lcmFscy5cclxuICogRS5nLiBpbiBJcmFxIHRoZXkgZG9uJ3Qgd3JpdGUgYCs0NDIzMjMyMzRgIGJ1dCByYXRoZXIgYCvZpNmk2aLZo9mi2aPZotmj2aRgLlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0cmluZ1xyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIHBhcnNlRGlnaXRzKCc4ICg4MDApIDU1NScpXHJcbiAqIC8vIE91dHB1dHMgJzg4MDA1NTUnLlxyXG4gKiBgYGBcclxuICovXG5cbmZ1bmN0aW9uIHBhcnNlRGlnaXRzKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gJyc7IC8vIFVzaW5nIGAuc3BsaXQoJycpYCBoZXJlIGluc3RlYWQgb2Ygbm9ybWFsIGBmb3IgLi4uIG9mYFxuICAvLyBiZWNhdXNlIHRoZSBpbXBvcnRpbmcgYXBwbGljYXRpb24gZG9lc24ndCBuZWNjZXNzYXJpbHkgaW5jbHVkZSBhbiBFUzYgcG9seWZpbGwuXG4gIC8vIFRoZSBgLnNwbGl0KCcnKWAgYXBwcm9hY2ggZGlzY2FyZHMgXCJleG90aWNcIiBVVEYtOCBjaGFyYWN0ZXJzXG4gIC8vICh0aGUgb25lcyBjb25zaXN0aW5nIG9mIGZvdXIgYnl0ZXMpIGJ1dCBkaWdpdHNcbiAgLy8gKGluY2x1ZGluZyBub24tRXVyb3BlYW4gb25lcykgZG9uJ3QgZmFsbCBpbnRvIHRoYXQgcmFuZ2VcbiAgLy8gc28gc3VjaCBcImV4b3RpY1wiIGNoYXJhY3RlcnMgd291bGQgYmUgZGlzY2FyZGVkIGFueXdheS5cblxuICBmb3IgKHZhciBfaXRlcmF0b3IgPSBzdHJpbmcuc3BsaXQoJycpLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgIHZhciBfcmVmO1xuXG4gICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XG4gICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJhY3RlciA9IF9yZWY7XG4gICAgdmFyIGRpZ2l0ID0gcGFyc2VEaWdpdChjaGFyYWN0ZXIpO1xuXG4gICAgaWYgKGRpZ2l0KSB7XG4gICAgICByZXN1bHQgKz0gZGlnaXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlRGlnaXRzLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvZXM2L3BhcnNlSW5jb21wbGV0ZVBob25lTnVtYmVyLmpzXG5cbi8qKlxyXG4gKiBQYXJzZXMgcGhvbmUgbnVtYmVyIGNoYXJhY3RlcnMgZnJvbSBhIHN0cmluZy5cclxuICogRHJvcHMgYWxsIHB1bmN0dWF0aW9uIGxlYXZpbmcgb25seSBkaWdpdHMgYW5kIHRoZSBsZWFkaW5nIGArYCBzaWduIChpZiBhbnkpLlxyXG4gKiBBbHNvIGNvbnZlcnRzIHdpZGUtYXNjaWkgYW5kIGFyYWJpYy1pbmRpYyBudW1lcmFscyB0byBjb252ZW50aW9uYWwgbnVtZXJhbHMuXHJcbiAqIEUuZy4gaW4gSXJhcSB0aGV5IGRvbid0IHdyaXRlIGArNDQyMzIzMjM0YCBidXQgcmF0aGVyIGAr2aTZpNmi2aPZotmj2aLZo9mkYC5cclxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmdcclxuICogQHJldHVybiB7c3RyaW5nfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiAvLyBPdXRwdXRzICc4ODAwNTU1Jy5cclxuICogcGFyc2VJbmNvbXBsZXRlUGhvbmVOdW1iZXIoJzggKDgwMCkgNTU1JylcclxuICogLy8gT3V0cHV0cyAnKzc4MDA1NTUnLlxyXG4gKiBwYXJzZUluY29tcGxldGVQaG9uZU51bWJlcignKzcgODAwIDU1NScpXHJcbiAqIGBgYFxyXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VJbmNvbXBsZXRlUGhvbmVOdW1iZXIoc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSAnJzsgLy8gVXNpbmcgYC5zcGxpdCgnJylgIGhlcmUgaW5zdGVhZCBvZiBub3JtYWwgYGZvciAuLi4gb2ZgXG4gIC8vIGJlY2F1c2UgdGhlIGltcG9ydGluZyBhcHBsaWNhdGlvbiBkb2Vzbid0IG5lY2Nlc3NhcmlseSBpbmNsdWRlIGFuIEVTNiBwb2x5ZmlsbC5cbiAgLy8gVGhlIGAuc3BsaXQoJycpYCBhcHByb2FjaCBkaXNjYXJkcyBcImV4b3RpY1wiIFVURi04IGNoYXJhY3RlcnNcbiAgLy8gKHRoZSBvbmVzIGNvbnNpc3Rpbmcgb2YgZm91ciBieXRlcykgYnV0IGRpZ2l0c1xuICAvLyAoaW5jbHVkaW5nIG5vbi1FdXJvcGVhbiBvbmVzKSBkb24ndCBmYWxsIGludG8gdGhhdCByYW5nZVxuICAvLyBzbyBzdWNoIFwiZXhvdGljXCIgY2hhcmFjdGVycyB3b3VsZCBiZSBkaXNjYXJkZWQgYW55d2F5LlxuXG4gIGZvciAodmFyIF9pdGVyYXRvciA9IHN0cmluZy5zcGxpdCgnJyksIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hhcmFjdGVyID0gX3JlZjtcbiAgICByZXN1bHQgKz0gcGFyc2VQaG9uZU51bWJlckNoYXJhY3RlcihjaGFyYWN0ZXIsIHJlc3VsdCkgfHwgJyc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXHJcbiAqIGBpbnB1dC1mb3JtYXRgIGBwYXJzZSgpYCBmdW5jdGlvbi5cclxuICogaHR0cHM6Ly9naXRsYWIuY29tL2NhdGFtcGhldGFtaW5lL2lucHV0LWZvcm1hdFxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNoYXJhY3RlciAtIFlldCBhbm90aGVyIGNoYXJhY3RlciBmcm9tIHJhdyBpbnB1dCBzdHJpbmcuXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUgcGFyc2VkIHNvIGZhci5cclxuICogQHBhcmFtICB7b2JqZWN0fSBtZXRhIC0gT3B0aW9uYWwgY3VzdG9tIHVzZS1jYXNlLXNwZWNpZmljIG1ldGFkYXRhLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmc/fSBUaGUgcGFyc2VkIGNoYXJhY3Rlci5cclxuICovXG5cbmZ1bmN0aW9uIHBhcnNlUGhvbmVOdW1iZXJDaGFyYWN0ZXIoY2hhcmFjdGVyLCB2YWx1ZSkge1xuICAvLyBPbmx5IGFsbG93IGEgbGVhZGluZyBgK2AuXG4gIGlmIChjaGFyYWN0ZXIgPT09ICcrJykge1xuICAgIC8vIElmIHRoaXMgYCtgIGlzIG5vdCB0aGUgZmlyc3QgcGFyc2VkIGNoYXJhY3RlclxuICAgIC8vIHRoZW4gZGlzY2FyZCBpdC5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gJysnO1xuICB9IC8vIEFsbG93IGRpZ2l0cy5cblxuXG4gIHJldHVybiBwYXJzZURpZ2l0KGNoYXJhY3Rlcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZUluY29tcGxldGVQaG9uZU51bWJlci5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9nZXROdW1iZXJUeXBlXy5qc1xuXG5cbnZhciBOT05fRklYRURfTElORV9QSE9ORV9UWVBFUyA9IFsnTU9CSUxFJywgJ1BSRU1JVU1fUkFURScsICdUT0xMX0ZSRUUnLCAnU0hBUkVEX0NPU1QnLCAnVk9JUCcsICdQRVJTT05BTF9OVU1CRVInLCAnUEFHRVInLCAnVUFOJywgJ1ZPSUNFTUFJTCddOyAvLyBGaW5kcyBvdXQgbmF0aW9uYWwgcGhvbmUgbnVtYmVyIHR5cGUgKGZpeGVkIGxpbmUsIG1vYmlsZSwgZXRjKVxuXG5mdW5jdGlvbiBnZXROdW1iZXJUeXBlKGlucHV0LCBvcHRpb25zLCBtZXRhZGF0YSkge1xuICAvLyBJZiBhc3NpZ25pbmcgdGhlIGB7fWAgZGVmYXVsdCB2YWx1ZSBpcyBtb3ZlZCB0byB0aGUgYXJndW1lbnRzIGFib3ZlLFxuICAvLyBjb2RlIGNvdmVyYWdlIHdvdWxkIGRlY3JlYXNlIGZvciBzb21lIHdlaXJkIHJlYXNvbi5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIFdoZW4gYHBhcnNlKClgIHJldHVybmVkIGB7fWBcbiAgLy8gbWVhbmluZyB0aGF0IHRoZSBwaG9uZSBudW1iZXIgaXMgbm90IGEgdmFsaWQgb25lLlxuXG4gIGlmICghaW5wdXQuY291bnRyeSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG1ldGFkYXRhID0gbmV3IE1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgbWV0YWRhdGEuc2VsZWN0TnVtYmVyaW5nUGxhbihpbnB1dC5jb3VudHJ5LCBpbnB1dC5jb3VudHJ5Q2FsbGluZ0NvZGUpO1xuICB2YXIgbmF0aW9uYWxOdW1iZXIgPSBvcHRpb25zLnYyID8gaW5wdXQubmF0aW9uYWxOdW1iZXIgOiBpbnB1dC5waG9uZTsgLy8gVGhlIGZvbGxvd2luZyBpcyBjb3B5LXBhc3RlZCBmcm9tIHRoZSBvcmlnaW5hbCBmdW5jdGlvbjpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWkxOG4vbGlicGhvbmVudW1iZXIvYmxvYi8zZWE1NDdkNGZiYWEyZDBiNjc1ODg5MDRkZmE1ZDNmMjU1N2MyN2ZmL2phdmFzY3JpcHQvaTE4bi9waG9uZW51bWJlcnMvcGhvbmVudW1iZXJ1dGlsLmpzI0wyODM1XG4gIC8vIElzIHRoaXMgbmF0aW9uYWwgbnVtYmVyIGV2ZW4gdmFsaWQgZm9yIHRoaXMgY291bnRyeVxuXG4gIGlmICghbWF0Y2hlc0VudGlyZWx5KG5hdGlvbmFsTnVtYmVyLCBtZXRhZGF0YS5uYXRpb25hbE51bWJlclBhdHRlcm4oKSkpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gSXMgaXQgZml4ZWQgbGluZSBudW1iZXJcblxuXG4gIGlmIChpc19vZl90eXBlKG5hdGlvbmFsTnVtYmVyLCAnRklYRURfTElORScsIG1ldGFkYXRhKSkge1xuICAgIC8vIEJlY2F1c2UgZHVwbGljYXRlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYXJlIHJlbW92ZWRcbiAgICAvLyB0byByZWR1Y2UgbWV0YWRhdGEgc2l6ZSwgaWYgXCJtb2JpbGVcIiBwYXR0ZXJuIGlzIFwiXCJcbiAgICAvLyB0aGVuIGl0IG1lYW5zIGl0IHdhcyByZW1vdmVkIGR1ZSB0byBiZWluZyBhIGR1cGxpY2F0ZSBvZiB0aGUgZml4ZWQtbGluZSBwYXR0ZXJuLlxuICAgIC8vXG4gICAgaWYgKG1ldGFkYXRhLnR5cGUoJ01PQklMRScpICYmIG1ldGFkYXRhLnR5cGUoJ01PQklMRScpLnBhdHRlcm4oKSA9PT0gJycpIHtcbiAgICAgIHJldHVybiAnRklYRURfTElORV9PUl9NT0JJTEUnO1xuICAgIH0gLy8gdjEgbWV0YWRhdGEuXG4gICAgLy8gTGVnYWN5LlxuICAgIC8vIERlcHJlY2F0ZWQuXG5cblxuICAgIGlmICghbWV0YWRhdGEudHlwZSgnTU9CSUxFJykpIHtcbiAgICAgIHJldHVybiAnRklYRURfTElORV9PUl9NT0JJTEUnO1xuICAgIH0gLy8gQ2hlY2sgaWYgdGhlIG51bWJlciBoYXBwZW5zIHRvIHF1YWxpZnkgYXMgYm90aCBmaXhlZCBsaW5lIGFuZCBtb2JpbGUuXG4gICAgLy8gKG5vIHN1Y2ggY291bnRyeSBpbiB0aGUgbWluaW1hbCBtZXRhZGF0YSBzZXQpXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuXG4gICAgaWYgKGlzX29mX3R5cGUobmF0aW9uYWxOdW1iZXIsICdNT0JJTEUnLCBtZXRhZGF0YSkpIHtcbiAgICAgIHJldHVybiAnRklYRURfTElORV9PUl9NT0JJTEUnO1xuICAgIH1cblxuICAgIHJldHVybiAnRklYRURfTElORSc7XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IDAsIF9OT05fRklYRURfTElORV9QSE9ORSA9IE5PTl9GSVhFRF9MSU5FX1BIT05FX1RZUEVTOyBfaSA8IF9OT05fRklYRURfTElORV9QSE9ORS5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgX3R5cGUgPSBfTk9OX0ZJWEVEX0xJTkVfUEhPTkVbX2ldO1xuXG4gICAgaWYgKGlzX29mX3R5cGUobmF0aW9uYWxOdW1iZXIsIF90eXBlLCBtZXRhZGF0YSkpIHtcbiAgICAgIHJldHVybiBfdHlwZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzX29mX3R5cGUobmF0aW9uYWxOdW1iZXIsIHR5cGUsIG1ldGFkYXRhKSB7XG4gIHR5cGUgPSBtZXRhZGF0YS50eXBlKHR5cGUpO1xuXG4gIGlmICghdHlwZSB8fCAhdHlwZS5wYXR0ZXJuKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gQ2hlY2sgaWYgYW55IHBvc3NpYmxlIG51bWJlciBsZW5ndGhzIGFyZSBwcmVzZW50O1xuICAvLyBpZiBzbywgd2UgdXNlIHRoZW0gdG8gYXZvaWQgY2hlY2tpbmdcbiAgLy8gdGhlIHZhbGlkYXRpb24gcGF0dGVybiBpZiB0aGV5IGRvbid0IG1hdGNoLlxuICAvLyBJZiB0aGV5IGFyZSBhYnNlbnQsIHRoaXMgbWVhbnMgdGhleSBtYXRjaFxuICAvLyB0aGUgZ2VuZXJhbCBkZXNjcmlwdGlvbiwgd2hpY2ggd2UgaGF2ZVxuICAvLyBhbHJlYWR5IGNoZWNrZWQgYmVmb3JlIGEgc3BlY2lmaWMgbnVtYmVyIHR5cGUuXG5cblxuICBpZiAodHlwZS5wb3NzaWJsZUxlbmd0aHMoKSAmJiB0eXBlLnBvc3NpYmxlTGVuZ3RocygpLmluZGV4T2YobmF0aW9uYWxOdW1iZXIubGVuZ3RoKSA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlc0VudGlyZWx5KG5hdGlvbmFsTnVtYmVyLCB0eXBlLnBhdHRlcm4oKSk7XG59IC8vIFNob3VsZCBvbmx5IGJlIGNhbGxlZCBmb3IgdGhlIFwibmV3XCIgbWV0YWRhdGEgd2hpY2ggaGFzIFwicG9zc2libGUgbGVuZ3Roc1wiLlxuXG5mdW5jdGlvbiBjaGVja051bWJlckxlbmd0aEZvclR5cGUobmF0aW9uYWxOdW1iZXIsIHR5cGUsIG1ldGFkYXRhKSB7XG4gIHZhciB0eXBlX2luZm8gPSBtZXRhZGF0YS50eXBlKHR5cGUpOyAvLyBUaGVyZSBzaG91bGQgYWx3YXlzIGJlIFwiPHBvc3NpYmxlUGVuZ3Rocy8+XCIgc2V0IGZvciBldmVyeSB0eXBlIGVsZW1lbnQuXG4gIC8vIFRoaXMgaXMgZGVjbGFyZWQgaW4gdGhlIFhNTCBzY2hlbWEuXG4gIC8vIEZvciBzaXplIGVmZmljaWVuY3ksIHdoZXJlIGEgc3ViLWRlc2NyaXB0aW9uIChlLmcuIGZpeGVkLWxpbmUpXG4gIC8vIGhhcyB0aGUgc2FtZSBcIjxwb3NzaWJsZVBlbmd0aHMvPlwiIGFzIHRoZSBcImdlbmVyYWwgZGVzY3JpcHRpb25cIiwgdGhpcyBpcyBtaXNzaW5nLFxuICAvLyBzbyB3ZSBmYWxsIGJhY2sgdG8gdGhlIFwiZ2VuZXJhbCBkZXNjcmlwdGlvblwiLiBXaGVyZSBubyBudW1iZXJzIG9mIHRoZSB0eXBlXG4gIC8vIGV4aXN0IGF0IGFsbCwgdGhlcmUgaXMgb25lIHBvc3NpYmxlIGxlbmd0aCAoLTEpIHdoaWNoIGlzIGd1YXJhbnRlZWRcbiAgLy8gbm90IHRvIG1hdGNoIHRoZSBsZW5ndGggb2YgYW55IHJlYWwgcGhvbmUgbnVtYmVyLlxuXG4gIHZhciBwb3NzaWJsZV9sZW5ndGhzID0gdHlwZV9pbmZvICYmIHR5cGVfaW5mby5wb3NzaWJsZUxlbmd0aHMoKSB8fCBtZXRhZGF0YS5wb3NzaWJsZUxlbmd0aHMoKTsgLy8gbGV0IGxvY2FsX2xlbmd0aHMgICAgPSB0eXBlX2luZm8gJiYgdHlwZS5wb3NzaWJsZUxlbmd0aHNMb2NhbCgpIHx8IG1ldGFkYXRhLnBvc3NpYmxlTGVuZ3Roc0xvY2FsKClcbiAgLy8gTWV0YWRhdGEgYmVmb3JlIHZlcnNpb24gYDEuMC4xOGAgZGlkbid0IGNvbnRhaW4gYHBvc3NpYmxlX2xlbmd0aHNgLlxuXG4gIGlmICghcG9zc2libGVfbGVuZ3Rocykge1xuICAgIHJldHVybiAnSVNfUE9TU0lCTEUnO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdGSVhFRF9MSU5FX09SX01PQklMRScpIHtcbiAgICAvLyBObyBzdWNoIGNvdW50cnkgaW4gbWV0YWRhdGEuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICghbWV0YWRhdGEudHlwZSgnRklYRURfTElORScpKSB7XG4gICAgICAvLyBUaGUgcmFyZSBjYXNlIGhhcyBiZWVuIGVuY291bnRlcmVkIHdoZXJlIG5vIGZpeGVkTGluZSBkYXRhIGlzIGF2YWlsYWJsZVxuICAgICAgLy8gKHRydWUgZm9yIHNvbWUgbm9uLWdlb2dyYXBoaWMgZW50aXRpZXMpLCBzbyB3ZSBqdXN0IGNoZWNrIG1vYmlsZS5cbiAgICAgIHJldHVybiBjaGVja051bWJlckxlbmd0aEZvclR5cGUobmF0aW9uYWxOdW1iZXIsICdNT0JJTEUnLCBtZXRhZGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIG1vYmlsZV90eXBlID0gbWV0YWRhdGEudHlwZSgnTU9CSUxFJyk7XG5cbiAgICBpZiAobW9iaWxlX3R5cGUpIHtcbiAgICAgIC8vIE1lcmdlIHRoZSBtb2JpbGUgZGF0YSBpbiBpZiB0aGVyZSB3YXMgYW55LiBcIkNvbmNhdFwiIGNyZWF0ZXMgYSBuZXdcbiAgICAgIC8vIGFycmF5LCBpdCBkb2Vzbid0IGVkaXQgcG9zc2libGVfbGVuZ3RocyBpbiBwbGFjZSwgc28gd2UgZG9uJ3QgbmVlZCBhIGNvcHkuXG4gICAgICAvLyBOb3RlIHRoYXQgd2hlbiBhZGRpbmcgdGhlIHBvc3NpYmxlIGxlbmd0aHMgZnJvbSBtb2JpbGUsIHdlIGhhdmVcbiAgICAgIC8vIHRvIGFnYWluIGNoZWNrIHRoZXkgYXJlbid0IGVtcHR5IHNpbmNlIGlmIHRoZXkgYXJlIHRoaXMgaW5kaWNhdGVzXG4gICAgICAvLyB0aGV5IGFyZSB0aGUgc2FtZSBhcyB0aGUgZ2VuZXJhbCBkZXNjIGFuZCBzaG91bGQgYmUgb2J0YWluZWQgZnJvbSB0aGVyZS5cbiAgICAgIHBvc3NpYmxlX2xlbmd0aHMgPSBtZXJnZUFycmF5cyhwb3NzaWJsZV9sZW5ndGhzLCBtb2JpbGVfdHlwZS5wb3NzaWJsZUxlbmd0aHMoKSk7IC8vIFRoZSBjdXJyZW50IGxpc3QgaXMgc29ydGVkOyB3ZSBuZWVkIHRvIG1lcmdlIGluIHRoZSBuZXcgbGlzdCBhbmRcbiAgICAgIC8vIHJlLXNvcnQgKGR1cGxpY2F0ZXMgYXJlIG9rYXkpLiBTb3J0aW5nIGlzbid0IHNvIGV4cGVuc2l2ZSBiZWNhdXNlXG4gICAgICAvLyB0aGUgbGlzdHMgYXJlIHZlcnkgc21hbGwuXG4gICAgICAvLyBpZiAobG9jYWxfbGVuZ3RocylcbiAgICAgIC8vIHtcbiAgICAgIC8vIFx0bG9jYWxfbGVuZ3RocyA9IG1lcmdlQXJyYXlzKGxvY2FsX2xlbmd0aHMsIG1vYmlsZV90eXBlLnBvc3NpYmxlTGVuZ3Roc0xvY2FsKCkpXG4gICAgICAvLyB9XG4gICAgICAvLyBlbHNlXG4gICAgICAvLyB7XG4gICAgICAvLyBcdGxvY2FsX2xlbmd0aHMgPSBtb2JpbGVfdHlwZS5wb3NzaWJsZUxlbmd0aHNMb2NhbCgpXG4gICAgICAvLyB9XG4gICAgfVxuICB9IC8vIElmIHRoZSB0eXBlIGRvZXNuJ3QgZXhpc3QgdGhlbiByZXR1cm4gJ0lOVkFMSURfTEVOR1RIJy5cbiAgZWxzZSBpZiAodHlwZSAmJiAhdHlwZV9pbmZvKSB7XG4gICAgICByZXR1cm4gJ0lOVkFMSURfTEVOR1RIJztcbiAgICB9XG5cbiAgdmFyIGFjdHVhbF9sZW5ndGggPSBuYXRpb25hbE51bWJlci5sZW5ndGg7IC8vIEluIGBsaWJwaG9uZW51bWJlci1qc2AgYWxsIFwibG9jYWwtb25seVwiIGZvcm1hdHMgYXJlIGRyb3BwZWQgZm9yIHNpbXBsaWNpdHkuXG4gIC8vIC8vIFRoaXMgaXMgc2FmZSBiZWNhdXNlIHRoZXJlIGlzIG5ldmVyIGFuIG92ZXJsYXAgYmV3ZWVuIHRoZSBwb3NzaWJsZSBsZW5ndGhzXG4gIC8vIC8vIGFuZCB0aGUgbG9jYWwtb25seSBsZW5ndGhzOyB0aGlzIGlzIGNoZWNrZWQgYXQgYnVpbGQgdGltZS5cbiAgLy8gaWYgKGxvY2FsX2xlbmd0aHMgJiYgbG9jYWxfbGVuZ3Rocy5pbmRleE9mKG5hdGlvbmFsTnVtYmVyLmxlbmd0aCkgPj0gMClcbiAgLy8ge1xuICAvLyBcdHJldHVybiAnSVNfUE9TU0lCTEVfTE9DQUxfT05MWSdcbiAgLy8gfVxuXG4gIHZhciBtaW5pbXVtX2xlbmd0aCA9IHBvc3NpYmxlX2xlbmd0aHNbMF07XG5cbiAgaWYgKG1pbmltdW1fbGVuZ3RoID09PSBhY3R1YWxfbGVuZ3RoKSB7XG4gICAgcmV0dXJuICdJU19QT1NTSUJMRSc7XG4gIH1cblxuICBpZiAobWluaW11bV9sZW5ndGggPiBhY3R1YWxfbGVuZ3RoKSB7XG4gICAgcmV0dXJuICdUT09fU0hPUlQnO1xuICB9XG5cbiAgaWYgKHBvc3NpYmxlX2xlbmd0aHNbcG9zc2libGVfbGVuZ3Rocy5sZW5ndGggLSAxXSA8IGFjdHVhbF9sZW5ndGgpIHtcbiAgICByZXR1cm4gJ1RPT19MT05HJztcbiAgfSAvLyBXZSBza2lwIHRoZSBmaXJzdCBlbGVtZW50IHNpbmNlIHdlJ3ZlIGFscmVhZHkgY2hlY2tlZCBpdC5cblxuXG4gIHJldHVybiBwb3NzaWJsZV9sZW5ndGhzLmluZGV4T2YoYWN0dWFsX2xlbmd0aCwgMSkgPj0gMCA/ICdJU19QT1NTSUJMRScgOiAnSU5WQUxJRF9MRU5HVEgnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0TnVtYmVyVHlwZV8uanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9lczYvaXNQb3NzaWJsZU51bWJlcl8uanNcblxuXG5mdW5jdGlvbiBpc1Bvc3NpYmxlUGhvbmVOdW1iZXIoaW5wdXQsIG9wdGlvbnMsIG1ldGFkYXRhKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgbWV0YWRhdGEgPSBuZXcgTWV0YWRhdGEobWV0YWRhdGEpO1xuXG4gIGlmIChvcHRpb25zLnYyKSB7XG4gICAgaWYgKCFpbnB1dC5jb3VudHJ5Q2FsbGluZ0NvZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwaG9uZSBudW1iZXIgb2JqZWN0IHBhc3NlZCcpO1xuICAgIH1cblxuICAgIG1ldGFkYXRhLmNob29zZUNvdW50cnlCeUNvdW50cnlDYWxsaW5nQ29kZShpbnB1dC5jb3VudHJ5Q2FsbGluZ0NvZGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaW5wdXQucGhvbmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQuY291bnRyeSkge1xuICAgICAgaWYgKCFtZXRhZGF0YS5oYXNDb3VudHJ5KGlucHV0LmNvdW50cnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY291bnRyeTogXCIuY29uY2F0KGlucHV0LmNvdW50cnkpKTtcbiAgICAgIH1cblxuICAgICAgbWV0YWRhdGEuY291bnRyeShpbnB1dC5jb3VudHJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFpbnB1dC5jb3VudHJ5Q2FsbGluZ0NvZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBob25lIG51bWJlciBvYmplY3QgcGFzc2VkJyk7XG4gICAgICB9XG5cbiAgICAgIG1ldGFkYXRhLmNob29zZUNvdW50cnlCeUNvdW50cnlDYWxsaW5nQ29kZShpbnB1dC5jb3VudHJ5Q2FsbGluZ0NvZGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtZXRhZGF0YS5wb3NzaWJsZUxlbmd0aHMoKSkge1xuICAgIHJldHVybiBpc1Bvc3NpYmxlTnVtYmVyKGlucHV0LnBob25lIHx8IGlucHV0Lm5hdGlvbmFsTnVtYmVyLCB1bmRlZmluZWQsIG1ldGFkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSB3YXMgYSBidWcgYmV0d2VlbiBgMS43LjM1YCBhbmQgYDEuNy4zN2Agd2hlcmUgXCJwb3NzaWJsZV9sZW5ndGhzXCJcbiAgICAvLyB3ZXJlIG1pc3NpbmcgZm9yIFwibm9uLWdlb2dyYXBoaWNhbFwiIG51bWJlcmluZyBwbGFucy5cbiAgICAvLyBKdXN0IGFzc3VtZSB0aGUgbnVtYmVyIGlzIHBvc3NpYmxlIGluIHN1Y2ggY2FzZXM6XG4gICAgLy8gaXQncyB1bmxpa2VseSB0aGF0IGFueW9uZSBnZW5lcmF0ZWQgdGhlaXIgY3VzdG9tIG1ldGFkYXRhXG4gICAgLy8gaW4gdGhhdCBzaG9ydCBwZXJpb2Qgb2YgdGltZSAob25lIGRheSkuXG4gICAgLy8gVGhpcyBjb2RlIGNhbiBiZSByZW1vdmVkIGluIHNvbWUgZnV0dXJlIG1ham9yIHZlcnNpb24gdXBkYXRlLlxuICAgIGlmIChpbnB1dC5jb3VudHJ5Q2FsbGluZ0NvZGUgJiYgbWV0YWRhdGEuaXNOb25HZW9ncmFwaGljQ2FsbGluZ0NvZGUoaW5wdXQuY291bnRyeUNhbGxpbmdDb2RlKSkge1xuICAgICAgLy8gXCJOb24tZ2VvZ3JhcGhpYyBlbnRpdGllc1wiIGRpZCd0IGhhdmUgYHBvc3NpYmxlTGVuZ3Roc2BcbiAgICAgIC8vIGR1ZSB0byBhIGJ1ZyBpbiBtZXRhZGF0YSBnZW5lcmF0aW9uIHByb2Nlc3MuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwicG9zc2libGVMZW5ndGhzXCIgaW4gbWV0YWRhdGEuIFBlcmhhcHMgdGhlIG1ldGFkYXRhIGhhcyBiZWVuIGdlbmVyYXRlZCBiZWZvcmUgdjEuMC4xOC4nKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzUG9zc2libGVOdW1iZXIobmF0aW9uYWxOdW1iZXIsIGlzSW50ZXJuYXRpb25hbCwgbWV0YWRhdGEpIHtcbiAgc3dpdGNoIChjaGVja051bWJlckxlbmd0aEZvclR5cGUobmF0aW9uYWxOdW1iZXIsIHVuZGVmaW5lZCwgbWV0YWRhdGEpKSB7XG4gICAgY2FzZSAnSVNfUE9TU0lCTEUnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gY2FzZSAnSVNfUE9TU0lCTEVfTE9DQUxfT05MWSc6XG4gICAgLy8gXHRyZXR1cm4gIWlzSW50ZXJuYXRpb25hbFxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNQb3NzaWJsZU51bWJlcl8uanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9lczYvSURELmpzXG5cblxudmFyIENBUFRVUklOR19ESUdJVF9QQVRURVJOID0gbmV3IFJlZ0V4cCgnKFsnICsgVkFMSURfRElHSVRTICsgJ10pJyk7XG4vKipcclxuICogUGF0dGVybiB0aGF0IG1ha2VzIGl0IGVhc3kgdG8gZGlzdGluZ3Vpc2ggd2hldGhlciBhIHJlZ2lvbiBoYXMgYSBzaW5nbGVcclxuICogaW50ZXJuYXRpb25hbCBkaWFsaW5nIHByZWZpeCBvciBub3QuIElmIGEgcmVnaW9uIGhhcyBhIHNpbmdsZSBpbnRlcm5hdGlvbmFsXHJcbiAqIHByZWZpeCAoZS5nLiAwMTEgaW4gVVNBKSwgaXQgd2lsbCBiZSByZXByZXNlbnRlZCBhcyBhIHN0cmluZyB0aGF0IGNvbnRhaW5zXHJcbiAqIGEgc2VxdWVuY2Ugb2YgQVNDSUkgZGlnaXRzLCBhbmQgcG9zc2libHkgYSB0aWxkZSwgd2hpY2ggc2lnbmFscyB3YWl0aW5nIGZvclxyXG4gKiB0aGUgdG9uZS4gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGF2YWlsYWJsZSBpbnRlcm5hdGlvbmFsIHByZWZpeGVzIGluIGFcclxuICogcmVnaW9uLCB0aGV5IHdpbGwgYmUgcmVwcmVzZW50ZWQgYXMgYSByZWdleCBzdHJpbmcgdGhhdCBhbHdheXMgY29udGFpbnMgb25lXHJcbiAqIG9yIG1vcmUgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgQVNDSUkgZGlnaXRzIG9yIGEgdGlsZGUuXHJcbiAqL1xuXG52YXIgU0lOR0xFX0lERF9QUkVGSVggPSAvXltcXGRdKyg/Olt+XFx1MjA1M1xcdTIyM0NcXHVGRjVFXVtcXGRdKyk/JC87IC8vIEZvciByZWdpb25zIHRoYXQgaGF2ZSBtdWx0aXBsZSBJREQgcHJlZml4ZXNcbi8vIGEgcHJlZmVycmVkIElERCBwcmVmaXggaXMgcmV0dXJuZWQuXG5cbmZ1bmN0aW9uIGdldElERFByZWZpeChjb3VudHJ5LCBjYWxsaW5nQ29kZSwgbWV0YWRhdGEpIHtcbiAgdmFyIGNvdW50cnlNZXRhZGF0YSA9IG5ldyBNZXRhZGF0YShtZXRhZGF0YSk7XG4gIGNvdW50cnlNZXRhZGF0YS5zZWxlY3ROdW1iZXJpbmdQbGFuKGNvdW50cnksIGNhbGxpbmdDb2RlKTtcblxuICBpZiAoU0lOR0xFX0lERF9QUkVGSVgudGVzdChjb3VudHJ5TWV0YWRhdGEuSUREUHJlZml4KCkpKSB7XG4gICAgcmV0dXJuIGNvdW50cnlNZXRhZGF0YS5JRERQcmVmaXgoKTtcbiAgfVxuXG4gIHJldHVybiBjb3VudHJ5TWV0YWRhdGEuZGVmYXVsdElERFByZWZpeCgpO1xufVxuZnVuY3Rpb24gc3RyaXBJRERQcmVmaXgobnVtYmVyLCBjb3VudHJ5LCBjYWxsaW5nQ29kZSwgbWV0YWRhdGEpIHtcbiAgaWYgKCFjb3VudHJ5KSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIENoZWNrIGlmIHRoZSBudW1iZXIgaXMgSURELXByZWZpeGVkLlxuXG5cbiAgdmFyIGNvdW50cnlNZXRhZGF0YSA9IG5ldyBNZXRhZGF0YShtZXRhZGF0YSk7XG4gIGNvdW50cnlNZXRhZGF0YS5zZWxlY3ROdW1iZXJpbmdQbGFuKGNvdW50cnksIGNhbGxpbmdDb2RlKTtcbiAgdmFyIElERFByZWZpeFBhdHRlcm4gPSBuZXcgUmVnRXhwKGNvdW50cnlNZXRhZGF0YS5JRERQcmVmaXgoKSk7XG5cbiAgaWYgKG51bWJlci5zZWFyY2goSUREUHJlZml4UGF0dGVybikgIT09IDApIHtcbiAgICByZXR1cm47XG4gIH0gLy8gU3RyaXAgSUREIHByZWZpeC5cblxuXG4gIG51bWJlciA9IG51bWJlci5zbGljZShudW1iZXIubWF0Y2goSUREUHJlZml4UGF0dGVybilbMF0ubGVuZ3RoKTsgLy8gU29tZSBraW5kIG9mIGEgd2VpcmQgZWRnZSBjYXNlLlxuICAvLyBObyBleHBsYW5hdGlvbiBmcm9tIEdvb2dsZSBnaXZlbi5cblxuICB2YXIgbWF0Y2hlZEdyb3VwcyA9IG51bWJlci5tYXRjaChDQVBUVVJJTkdfRElHSVRfUEFUVEVSTik7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgaWYgKG1hdGNoZWRHcm91cHMgJiYgbWF0Y2hlZEdyb3Vwc1sxXSAhPSBudWxsICYmIG1hdGNoZWRHcm91cHNbMV0ubGVuZ3RoID4gMCkge1xuICAgIGlmIChtYXRjaGVkR3JvdXBzWzFdID09PSAnMCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVtYmVyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SURELmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvZXM2L1JGQzM5NjYuanNcbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG4gLy8gaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzM5NjYudHh0XG5cbi8qKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBQaG9uZSBVUkkgKFJGQyAzOTY2KS5cclxuICogQHJldHVybiB7b2JqZWN0fSBgeyA/bnVtYmVyLCA/ZXh0IH1gLlxyXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VSRkMzOTY2KHRleHQpIHtcbiAgdmFyIG51bWJlcjtcbiAgdmFyIGV4dDsgLy8gUmVwbGFjZSBcInRlbDpcIiB3aXRoIFwidGVsPVwiIGZvciBwYXJzaW5nIGNvbnZlbmllbmNlLlxuXG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoL150ZWw6LywgJ3RlbD0nKTtcblxuICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0ZXh0LnNwbGl0KCc7JyksIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgcGFydCA9IF9yZWY7XG5cbiAgICB2YXIgX3BhcnQkc3BsaXQgPSBwYXJ0LnNwbGl0KCc9JyksXG4gICAgICAgIF9wYXJ0JHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9wYXJ0JHNwbGl0LCAyKSxcbiAgICAgICAgbmFtZSA9IF9wYXJ0JHNwbGl0MlswXSxcbiAgICAgICAgdmFsdWUgPSBfcGFydCRzcGxpdDJbMV07XG5cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ3RlbCc6XG4gICAgICAgIG51bWJlciA9IHZhbHVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXh0JzpcbiAgICAgICAgZXh0ID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwaG9uZS1jb250ZXh0JzpcbiAgICAgICAgLy8gT25seSBcImNvdW50cnkgY29udGV4dHNcIiBhcmUgc3VwcG9ydGVkLlxuICAgICAgICAvLyBcIkRvbWFpbiBjb250ZXh0c1wiIGFyZSBpZ25vcmVkLlxuICAgICAgICBpZiAodmFsdWVbMF0gPT09ICcrJykge1xuICAgICAgICAgIG51bWJlciA9IHZhbHVlICsgbnVtYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IC8vIElmIHRoZSBwaG9uZSBudW1iZXIgaXMgbm90IHZpYWJsZSwgdGhlbiBhYm9ydC5cblxuXG4gIGlmICghaXNWaWFibGVQaG9uZU51bWJlcihudW1iZXIpKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBudW1iZXI6IG51bWJlclxuICB9O1xuXG4gIGlmIChleHQpIHtcbiAgICByZXN1bHQuZXh0ID0gZXh0O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxyXG4gKiBAcGFyYW0gIHtvYmplY3R9IC0gYHsgP251bWJlciwgP2V4dGVuc2lvbiB9YC5cclxuICogQHJldHVybiB7c3RyaW5nfSBQaG9uZSBVUkkgKFJGQyAzOTY2KS5cclxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdFJGQzM5NjYoX3JlZjIpIHtcbiAgdmFyIG51bWJlciA9IF9yZWYyLm51bWJlcixcbiAgICAgIGV4dCA9IF9yZWYyLmV4dDtcblxuICBpZiAoIW51bWJlcikge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChudW1iZXJbMF0gIT09ICcrJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlxcXCJmb3JtYXRSRkMzOTY2KClcXFwiIGV4cGVjdHMgXFxcIm51bWJlclxcXCIgdG8gYmUgaW4gRS4xNjQgZm9ybWF0LlwiKTtcbiAgfVxuXG4gIHJldHVybiBcInRlbDpcIi5jb25jYXQobnVtYmVyKS5jb25jYXQoZXh0ID8gJztleHQ9JyArIGV4dCA6ICcnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJGQzM5NjYuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9lczYvdmFsaWRhdGVfLmpzXG5cblxuXG4vKipcclxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gcGhvbmUgbnVtYmVyIGlzIHZhbGlkLlxyXG4gKlxyXG4gKiBJZiB0aGUgYG51bWJlcmAgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgcGFyc2VkIHRvIGFuIG9iamVjdCxcclxuICogYnV0IG9ubHkgaWYgaXQgY29udGFpbnMgb25seSB2YWxpZCBwaG9uZSBudW1iZXIgY2hhcmFjdGVycyAoaW5jbHVkaW5nIHB1bmN0dWF0aW9uKS5cclxuICogSWYgdGhlIGBudW1iZXJgIGlzIGFuIG9iamVjdCwgaXQgaXMgdXNlZCBhcyBpcy5cclxuICpcclxuICogVGhlIG9wdGlvbmFsIGBkZWZhdWx0Q291bnRyeWAgYXJndW1lbnQgaXMgdGhlIGRlZmF1bHQgY291bnRyeS5cclxuICogSS5lLiBpdCBkb2VzIG5vdCByZXN0cmljdCB0byBqdXN0IHRoYXQgY291bnRyeSxcclxuICogZS5nLiBpbiB0aG9zZSBjYXNlcyB3aGVyZSBzZXZlcmFsIGNvdW50cmllcyBzaGFyZVxyXG4gKiB0aGUgc2FtZSBwaG9uZSBudW1iZXJpbmcgcnVsZXMgKE5BTlBBLCBCcml0YWluLCBldGMpLlxyXG4gKiBGb3IgZXhhbXBsZSwgZXZlbiB0aG91Z2ggdGhlIG51bWJlciBgMDc2MjQgMzY5MjMwYFxyXG4gKiBiZWxvbmdzIHRvIHRoZSBJc2xlIG9mIE1hbiAoXCJJTVwiIGNvdW50cnkgY29kZSlcclxuICogY2FsbGluZyBgaXNWYWxpZE51bWJlcignMDc2MjQzNjkyMzAnLCAnR0InLCBtZXRhZGF0YSlgXHJcbiAqIHN0aWxsIHJldHVybnMgYHRydWVgIGJlY2F1c2UgdGhlIGNvdW50cnkgaXMgbm90IHJlc3RyaWN0ZWQgdG8gYEdCYCxcclxuICogaXQncyBqdXN0IHRoYXQgYEdCYCBpcyB0aGUgZGVmYXVsdCBvbmUgZm9yIHRoZSBwaG9uZSBudW1iZXJpbmcgcnVsZXMuXHJcbiAqIEZvciByZXN0cmljdGluZyB0aGUgY291bnRyeSBzZWUgYGlzVmFsaWROdW1iZXJGb3JSZWdpb24oKWBcclxuICogdGhvdWdoIHJlc3RyaWN0aW5nIGEgY291bnRyeSBtaWdodCBub3QgYmUgYSBnb29kIGlkZWEuXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVpMThuL2xpYnBob25lbnVtYmVyL2Jsb2IvbWFzdGVyL0ZBUS5tZCN3aGVuLXNob3VsZC1pLXVzZS1pc3ZhbGlkbnVtYmVyZm9ycmVnaW9uXHJcbiAqXHJcbiAqIEV4YW1wbGVzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBpc1ZhbGlkTnVtYmVyKCcrNzgwMDU1NTM1MzUnLCBtZXRhZGF0YSlcclxuICogaXNWYWxpZE51bWJlcignODAwNTU1MzUzNScsICdSVScsIG1ldGFkYXRhKVxyXG4gKiBpc1ZhbGlkTnVtYmVyKCc4ODAwNTU1MzUzNScsICdSVScsIG1ldGFkYXRhKVxyXG4gKiBpc1ZhbGlkTnVtYmVyKHsgcGhvbmU6ICc4MDA1NTUzNTM1JywgY291bnRyeTogJ1JVJyB9LCBtZXRhZGF0YSlcclxuICogYGBgXHJcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkTnVtYmVyKGlucHV0LCBvcHRpb25zLCBtZXRhZGF0YSkge1xuICAvLyBJZiBhc3NpZ25pbmcgdGhlIGB7fWAgZGVmYXVsdCB2YWx1ZSBpcyBtb3ZlZCB0byB0aGUgYXJndW1lbnRzIGFib3ZlLFxuICAvLyBjb2RlIGNvdmVyYWdlIHdvdWxkIGRlY3JlYXNlIGZvciBzb21lIHdlaXJkIHJlYXNvbi5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG1ldGFkYXRhID0gbmV3IE1ldGFkYXRhKG1ldGFkYXRhKTsgLy8gVGhpcyBpcyBqdXN0IHRvIHN1cHBvcnQgYGlzVmFsaWROdW1iZXIoe30pYFxuICAvLyBmb3IgY2FzZXMgd2hlbiBgcGFyc2VOdW1iZXIoKWAgcmV0dXJucyBge31gLlxuXG4gIGlmICghaW5wdXQuY291bnRyeSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG1ldGFkYXRhLnNlbGVjdE51bWJlcmluZ1BsYW4oaW5wdXQuY291bnRyeSwgaW5wdXQuY291bnRyeUNhbGxpbmdDb2RlKTsgLy8gQnkgZGVmYXVsdCwgY291bnRyaWVzIG9ubHkgaGF2ZSB0eXBlIHJlZ2V4cHMgd2hlbiBpdCdzIHJlcXVpcmVkIGZvclxuICAvLyBkaXN0aW5ndWlzaGluZyBkaWZmZXJlbnQgY291bnRyaWVzIGhhdmluZyB0aGUgc2FtZSBgY291bnRyeUNhbGxpbmdDb2RlYC5cblxuICBpZiAobWV0YWRhdGEuaGFzVHlwZXMoKSkge1xuICAgIHJldHVybiBnZXROdW1iZXJUeXBlKGlucHV0LCBvcHRpb25zLCBtZXRhZGF0YS5tZXRhZGF0YSkgIT09IHVuZGVmaW5lZDtcbiAgfSAvLyBJZiB0aGVyZSBhcmUgbm8gdHlwZSByZWdleHBzIGZvciB0aGlzIGNvdW50cnkgaW4gbWV0YWRhdGEgdGhlbiB1c2VcbiAgLy8gYG5hdGlvbmFsTnVtYmVyUGF0dGVybmAgYXMgYSBcImJldHRlciB0aGFuIG5vdGhpbmdcIiByZXBsYWNlbWVudC5cblxuXG4gIHZhciBuYXRpb25hbF9udW1iZXIgPSBvcHRpb25zLnYyID8gaW5wdXQubmF0aW9uYWxOdW1iZXIgOiBpbnB1dC5waG9uZTtcbiAgcmV0dXJuIG1hdGNoZXNFbnRpcmVseShuYXRpb25hbF9udW1iZXIsIG1ldGFkYXRhLm5hdGlvbmFsTnVtYmVyUGF0dGVybigpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRlXy5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9mb3JtYXRfLmpzXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGZvcm1hdF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGZvcm1hdF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIFRoaXMgaXMgYSBwb3J0IG9mIEdvb2dsZSBBbmRyb2lkIGBsaWJwaG9uZW51bWJlcmAnc1xuLy8gYHBob25lbnVtYmVydXRpbC5qc2Agb2YgRGVjZW1iZXIgMzF0aCwgMjAxOC5cbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlaTE4bi9saWJwaG9uZW51bWJlci9jb21taXRzL21hc3Rlci9qYXZhc2NyaXB0L2kxOG4vcGhvbmVudW1iZXJzL3Bob25lbnVtYmVydXRpbC5qc1xuXG5cblxuXG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIGZvcm1hdEV4dGVuc2lvbjogZnVuY3Rpb24gZm9ybWF0RXh0ZW5zaW9uKGZvcm1hdHRlZE51bWJlciwgZXh0ZW5zaW9uLCBtZXRhZGF0YSkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChmb3JtYXR0ZWROdW1iZXIpLmNvbmNhdChtZXRhZGF0YS5leHQoKSkuY29uY2F0KGV4dGVuc2lvbik7XG4gIH0gLy8gRm9ybWF0cyBhIHBob25lIG51bWJlclxuICAvL1xuICAvLyBFeGFtcGxlIHVzZSBjYXNlczpcbiAgLy9cbiAgLy8gYGBganNcbiAgLy8gZm9ybWF0TnVtYmVyKCc4MDA1NTUzNTM1JywgJ1JVJywgJ0lOVEVSTkFUSU9OQUwnKVxuICAvLyBmb3JtYXROdW1iZXIoJzgwMDU1NTM1MzUnLCAnUlUnLCAnSU5URVJOQVRJT05BTCcsIG1ldGFkYXRhKVxuICAvLyBmb3JtYXROdW1iZXIoeyBwaG9uZTogJzgwMDU1NTM1MzUnLCBjb3VudHJ5OiAnUlUnIH0sICdJTlRFUk5BVElPTkFMJylcbiAgLy8gZm9ybWF0TnVtYmVyKHsgcGhvbmU6ICc4MDA1NTUzNTM1JywgY291bnRyeTogJ1JVJyB9LCAnSU5URVJOQVRJT05BTCcsIG1ldGFkYXRhKVxuICAvLyBmb3JtYXROdW1iZXIoJys3ODAwNTU1MzUzNScsICdOQVRJT05BTCcpXG4gIC8vIGZvcm1hdE51bWJlcignKzc4MDA1NTUzNTM1JywgJ05BVElPTkFMJywgbWV0YWRhdGEpXG4gIC8vIGBgYFxuICAvL1xuXG59O1xuZnVuY3Rpb24gZm9ybWF0X2Zvcm1hdE51bWJlcihpbnB1dCwgZm9ybWF0LCBvcHRpb25zLCBtZXRhZGF0YSkge1xuICAvLyBBcHBseSBkZWZhdWx0IG9wdGlvbnMuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IERFRkFVTFRfT1BUSU9OUztcbiAgfVxuXG4gIG1ldGFkYXRhID0gbmV3IE1ldGFkYXRhKG1ldGFkYXRhKTtcblxuICBpZiAoaW5wdXQuY291bnRyeSAmJiBpbnB1dC5jb3VudHJ5ICE9PSAnMDAxJykge1xuICAgIC8vIFZhbGlkYXRlIGBpbnB1dC5jb3VudHJ5YC5cbiAgICBpZiAoIW1ldGFkYXRhLmhhc0NvdW50cnkoaW5wdXQuY291bnRyeSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY291bnRyeTogXCIuY29uY2F0KGlucHV0LmNvdW50cnkpKTtcbiAgICB9XG5cbiAgICBtZXRhZGF0YS5jb3VudHJ5KGlucHV0LmNvdW50cnkpO1xuICB9IGVsc2UgaWYgKGlucHV0LmNvdW50cnlDYWxsaW5nQ29kZSkge1xuICAgIG1ldGFkYXRhLmNob29zZUNvdW50cnlCeUNvdW50cnlDYWxsaW5nQ29kZShpbnB1dC5jb3VudHJ5Q2FsbGluZ0NvZGUpO1xuICB9IGVsc2UgcmV0dXJuIGlucHV0LnBob25lIHx8ICcnO1xuXG4gIHZhciBjb3VudHJ5Q2FsbGluZ0NvZGUgPSBtZXRhZGF0YS5jb3VudHJ5Q2FsbGluZ0NvZGUoKTtcbiAgdmFyIG5hdGlvbmFsTnVtYmVyID0gb3B0aW9ucy52MiA/IGlucHV0Lm5hdGlvbmFsTnVtYmVyIDogaW5wdXQucGhvbmU7IC8vIFRoaXMgdmFyaWFibGUgc2hvdWxkIGhhdmUgYmVlbiBkZWNsYXJlZCBpbnNpZGUgYGNhc2Vgc1xuICAvLyBidXQgQmFiZWwgaGFzIGEgYnVnIGFuZCBpdCBzYXlzIFwiZHVwbGljYXRlIHZhcmlhYmxlIGRlY2xhcmF0aW9uXCIuXG5cbiAgdmFyIG51bWJlcjtcblxuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgJ05BVElPTkFMJzpcbiAgICAgIC8vIExlZ2FjeSBhcmd1bWVudCBzdXBwb3J0LlxuICAgICAgLy8gKGB7IGNvdW50cnk6IC4uLiwgcGhvbmU6ICcnIH1gKVxuICAgICAgaWYgKCFuYXRpb25hbE51bWJlcikge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIG51bWJlciA9IGZvcm1hdE5hdGlvbmFsTnVtYmVyKG5hdGlvbmFsTnVtYmVyLCAnTkFUSU9OQUwnLCBtZXRhZGF0YSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gYWRkRXh0ZW5zaW9uKG51bWJlciwgaW5wdXQuZXh0LCBtZXRhZGF0YSwgb3B0aW9ucy5mb3JtYXRFeHRlbnNpb24pO1xuXG4gICAgY2FzZSAnSU5URVJOQVRJT05BTCc6XG4gICAgICAvLyBMZWdhY3kgYXJndW1lbnQgc3VwcG9ydC5cbiAgICAgIC8vIChgeyBjb3VudHJ5OiAuLi4sIHBob25lOiAnJyB9YClcbiAgICAgIGlmICghbmF0aW9uYWxOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIFwiK1wiLmNvbmNhdChjb3VudHJ5Q2FsbGluZ0NvZGUpO1xuICAgICAgfVxuXG4gICAgICBudW1iZXIgPSBmb3JtYXROYXRpb25hbE51bWJlcihuYXRpb25hbE51bWJlciwgJ0lOVEVSTkFUSU9OQUwnLCBtZXRhZGF0YSwgb3B0aW9ucyk7XG4gICAgICBudW1iZXIgPSBcIitcIi5jb25jYXQoY291bnRyeUNhbGxpbmdDb2RlLCBcIiBcIikuY29uY2F0KG51bWJlcik7XG4gICAgICByZXR1cm4gYWRkRXh0ZW5zaW9uKG51bWJlciwgaW5wdXQuZXh0LCBtZXRhZGF0YSwgb3B0aW9ucy5mb3JtYXRFeHRlbnNpb24pO1xuXG4gICAgY2FzZSAnRS4xNjQnOlxuICAgICAgLy8gYEUuMTY0YCBkb2Vzbid0IGRlZmluZSBcInBob25lIG51bWJlciBleHRlbnNpb25zXCIuXG4gICAgICByZXR1cm4gXCIrXCIuY29uY2F0KGNvdW50cnlDYWxsaW5nQ29kZSkuY29uY2F0KG5hdGlvbmFsTnVtYmVyKTtcblxuICAgIGNhc2UgJ1JGQzM5NjYnOlxuICAgICAgcmV0dXJuIGZvcm1hdFJGQzM5NjYoe1xuICAgICAgICBudW1iZXI6IFwiK1wiLmNvbmNhdChjb3VudHJ5Q2FsbGluZ0NvZGUpLmNvbmNhdChuYXRpb25hbE51bWJlciksXG4gICAgICAgIGV4dDogaW5wdXQuZXh0XG4gICAgICB9KTtcblxuICAgIGNhc2UgJ0lERCc6XG4gICAgICBpZiAoIW9wdGlvbnMuZnJvbUNvdW50cnkpIHtcbiAgICAgICAgcmV0dXJuOyAvLyB0aHJvdyBuZXcgRXJyb3IoJ2Bmcm9tQ291bnRyeWAgb3B0aW9uIG5vdCBwYXNzZWQgZm9yIElERC1wcmVmaXhlZCBmb3JtYXR0aW5nLicpXG4gICAgICB9XG5cbiAgICAgIHZhciBJRERQcmVmaXggPSBnZXRJRERQcmVmaXgob3B0aW9ucy5mcm9tQ291bnRyeSwgdW5kZWZpbmVkLCBtZXRhZGF0YS5tZXRhZGF0YSk7XG5cbiAgICAgIGlmICghSUREUHJlZml4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuaHVtYW5SZWFkYWJsZSkge1xuICAgICAgICB2YXIgZm9ybWF0dGVkRm9yU2FtZUNvdW50cnlDYWxsaW5nQ29kZSA9IGNvdW50cnlDYWxsaW5nQ29kZSAmJiBmb3JtYXRJRERTYW1lQ291bnRyeUNhbGxpbmdDb2RlTnVtYmVyKG5hdGlvbmFsTnVtYmVyLCBtZXRhZGF0YS5jb3VudHJ5Q2FsbGluZ0NvZGUoKSwgb3B0aW9ucy5mcm9tQ291bnRyeSwgbWV0YWRhdGEsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChmb3JtYXR0ZWRGb3JTYW1lQ291bnRyeUNhbGxpbmdDb2RlKSB7XG4gICAgICAgICAgbnVtYmVyID0gZm9ybWF0dGVkRm9yU2FtZUNvdW50cnlDYWxsaW5nQ29kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBudW1iZXIgPSBcIlwiLmNvbmNhdChJRERQcmVmaXgsIFwiIFwiKS5jb25jYXQoY291bnRyeUNhbGxpbmdDb2RlLCBcIiBcIikuY29uY2F0KGZvcm1hdE5hdGlvbmFsTnVtYmVyKG5hdGlvbmFsTnVtYmVyLCAnSU5URVJOQVRJT05BTCcsIG1ldGFkYXRhLCBvcHRpb25zKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWRkRXh0ZW5zaW9uKG51bWJlciwgaW5wdXQuZXh0LCBtZXRhZGF0YSwgb3B0aW9ucy5mb3JtYXRFeHRlbnNpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQoSUREUHJlZml4KS5jb25jYXQoY291bnRyeUNhbGxpbmdDb2RlKS5jb25jYXQobmF0aW9uYWxOdW1iZXIpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gXFxcImZvcm1hdFxcXCIgYXJndW1lbnQgcGFzc2VkIHRvIFxcXCJmb3JtYXROdW1iZXIoKVxcXCI6IFxcXCJcIi5jb25jYXQoZm9ybWF0LCBcIlxcXCJcIikpO1xuICB9XG59IC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgc2V0IHRvICQxIGJ1dCB0aGVyZSBhcmUgc29tZSBjb3VudHJpZXMgZm9yIHdoaWNoIHRoZVxuLy8gZmlyc3QgZ3JvdXAgaXMgbm90IHVzZWQgaW4gdGhlIG5hdGlvbmFsIHBhdHRlcm4gKGUuZy4gQXJnZW50aW5hKSBzbyB0aGUgJDFcbi8vIGdyb3VwIGRvZXMgbm90IG1hdGNoIGNvcnJlY3RseS4gIFRoZXJlZm9yZSwgd2UgdXNlIFxcZCwgc28gdGhhdCB0aGUgZmlyc3Rcbi8vIGdyb3VwIGFjdHVhbGx5IHVzZWQgaW4gdGhlIHBhdHRlcm4gd2lsbCBiZSBtYXRjaGVkLlxuXG52YXIgRklSU1RfR1JPVVBfUEFUVEVSTiA9IC8oXFwkXFxkKS87XG5mdW5jdGlvbiBmb3JtYXROYXRpb25hbE51bWJlclVzaW5nRm9ybWF0KG51bWJlciwgZm9ybWF0LCB1c2VJbnRlcm5hdGlvbmFsU2VwYXJhdG9yLCB1c2VOYXRpb25hbFByZWZpeEZvcm1hdHRpbmdSdWxlLCBtZXRhZGF0YSkge1xuICB2YXIgZm9ybWF0dGVkTnVtYmVyID0gbnVtYmVyLnJlcGxhY2UobmV3IFJlZ0V4cChmb3JtYXQucGF0dGVybigpKSwgdXNlSW50ZXJuYXRpb25hbFNlcGFyYXRvciA/IGZvcm1hdC5pbnRlcm5hdGlvbmFsRm9ybWF0KCkgOiB1c2VOYXRpb25hbFByZWZpeEZvcm1hdHRpbmdSdWxlICYmIGZvcm1hdC5uYXRpb25hbFByZWZpeEZvcm1hdHRpbmdSdWxlKCkgPyBmb3JtYXQuZm9ybWF0KCkucmVwbGFjZShGSVJTVF9HUk9VUF9QQVRURVJOLCBmb3JtYXQubmF0aW9uYWxQcmVmaXhGb3JtYXR0aW5nUnVsZSgpKSA6IGZvcm1hdC5mb3JtYXQoKSk7XG5cbiAgaWYgKHVzZUludGVybmF0aW9uYWxTZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gYXBwbHlJbnRlcm5hdGlvbmFsU2VwYXJhdG9yU3R5bGUoZm9ybWF0dGVkTnVtYmVyKTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXR0ZWROdW1iZXI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE5hdGlvbmFsTnVtYmVyKG51bWJlciwgZm9ybWF0QXMsIG1ldGFkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBmb3JtYXQgPSBjaG9vc2VGb3JtYXRGb3JOdW1iZXIobWV0YWRhdGEuZm9ybWF0cygpLCBudW1iZXIpO1xuXG4gIGlmICghZm9ybWF0KSB7XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXROYXRpb25hbE51bWJlclVzaW5nRm9ybWF0KG51bWJlciwgZm9ybWF0LCBmb3JtYXRBcyA9PT0gJ0lOVEVSTkFUSU9OQUwnLCBmb3JtYXQubmF0aW9uYWxQcmVmaXhJc09wdGlvbmFsV2hlbkZvcm1hdHRpbmdJbk5hdGlvbmFsRm9ybWF0KCkgJiYgb3B0aW9ucy5uYXRpb25hbFByZWZpeCA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWUsIG1ldGFkYXRhKTtcbn1cblxuZnVuY3Rpb24gY2hvb3NlRm9ybWF0Rm9yTnVtYmVyKGF2YWlsYWJsZUZvcm1hdHMsIG5hdGlvbmFsTm51bWJlcikge1xuICBmb3IgKHZhciBfaXRlcmF0b3IgPSBhdmFpbGFibGVGb3JtYXRzLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgIHZhciBfcmVmO1xuXG4gICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XG4gICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdCA9IF9yZWY7XG5cbiAgICAvLyBWYWxpZGF0ZSBsZWFkaW5nIGRpZ2l0c1xuICAgIGlmIChmb3JtYXQubGVhZGluZ0RpZ2l0c1BhdHRlcm5zKCkubGVuZ3RoID4gMCkge1xuICAgICAgLy8gVGhlIGxhc3QgbGVhZGluZ19kaWdpdHNfcGF0dGVybiBpcyB1c2VkIGhlcmUsIGFzIGl0IGlzIHRoZSBtb3N0IGRldGFpbGVkXG4gICAgICB2YXIgbGFzdExlYWRpbmdEaWdpdHNQYXR0ZXJuID0gZm9ybWF0LmxlYWRpbmdEaWdpdHNQYXR0ZXJucygpW2Zvcm1hdC5sZWFkaW5nRGlnaXRzUGF0dGVybnMoKS5sZW5ndGggLSAxXTsgLy8gSWYgbGVhZGluZyBkaWdpdHMgZG9uJ3QgbWF0Y2ggdGhlbiBtb3ZlIG9uIHRvIHRoZSBuZXh0IHBob25lIG51bWJlciBmb3JtYXRcblxuICAgICAgaWYgKG5hdGlvbmFsTm51bWJlci5zZWFyY2gobGFzdExlYWRpbmdEaWdpdHNQYXR0ZXJuKSAhPT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IC8vIENoZWNrIHRoYXQgdGhlIG5hdGlvbmFsIG51bWJlciBtYXRjaGVzIHRoZSBwaG9uZSBudW1iZXIgZm9ybWF0IHJlZ3VsYXIgZXhwcmVzc2lvblxuXG5cbiAgICBpZiAobWF0Y2hlc0VudGlyZWx5KG5hdGlvbmFsTm51bWJlciwgZm9ybWF0LnBhdHRlcm4oKSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuICB9XG59IC8vIFJlbW92ZXMgYnJhY2tldHMgYW5kIHJlcGxhY2VzIGRhc2hlcyB3aXRoIHNwYWNlcy5cbi8vXG4vLyBFLmcuIFwiKDk5OSkgMTExLTIyLTMzXCIgLT4gXCI5OTkgMTExIDIyIDMzXCJcbi8vXG4vLyBGb3Igc29tZSByZWFzb24gR29vZ2xlJ3MgbWV0YWRhdGEgY29udGFpbnMgYDxpbnRsRm9ybWF0Lz5gcyB3aXRoIGJyYWNrZXRzIGFuZCBkYXNoZXMuXG4vLyBNZWFud2hpbGUsIHRoZXJlJ3Mgbm8gc2luZ2xlIG9waW5pb24gYWJvdXQgdXNpbmcgcHVuY3R1YXRpb24gaW4gaW50ZXJuYXRpb25hbCBwaG9uZSBudW1iZXJzLlxuLy9cbi8vIEZvciBleGFtcGxlLCBHb29nbGUncyBgPGludGxGb3JtYXQvPmAgZm9yIFVTQSBpcyBgKzEgMjEzLTM3My00MjUzYC5cbi8vIEFuZCBoZXJlJ3MgYSBxdW90ZSBmcm9tIFdpa2lQZWRpYSdzIFwiTm9ydGggQW1lcmljYW4gTnVtYmVyaW5nIFBsYW5cIiBwYWdlOlxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTm9ydGhfQW1lcmljYW5fTnVtYmVyaW5nX1BsYW5cbi8vXG4vLyBcIlRoZSBjb3VudHJ5IGNhbGxpbmcgY29kZSBmb3IgYWxsIGNvdW50cmllcyBwYXJ0aWNpcGF0aW5nIGluIHRoZSBOQU5QIGlzIDEuXG4vLyBJbiBpbnRlcm5hdGlvbmFsIGZvcm1hdCwgYW4gTkFOUCBudW1iZXIgc2hvdWxkIGJlIGxpc3RlZCBhcyArMSAzMDEgNTU1IDAxIDAwLFxuLy8gd2hlcmUgMzAxIGlzIGFuIGFyZWEgY29kZSAoTWFyeWxhbmQpLlwiXG4vL1xuLy8gSSBwZXJzb25hbGx5IHByZWZlciB0aGUgaW50ZXJuYXRpb25hbCBmb3JtYXQgd2l0aG91dCBhbnkgcHVuY3R1YXRpb24uXG4vLyBGb3IgZXhhbXBsZSwgYnJhY2tldHMgYXJlIHJlbW5hbnRzIG9mIHRoZSBvbGQgYWdlLCBtZWFuaW5nIHRoYXQgdGhlXG4vLyBwaG9uZSBudW1iZXIgcGFydCBpbiBicmFja2V0cyAoc28gY2FsbGVkIFwiYXJlYSBjb2RlXCIpIGNhbiBiZSBvbWl0dGVkXG4vLyBpZiBkaWFsaW5nIHdpdGhpbiB0aGUgc2FtZSBcImFyZWFcIi5cbi8vIEFuZCBoeXBoZW5zIHdlcmUgY2xlYXJseSBpbnRyb2R1Y2VkIGZvciBzcGxpdHRpbmcgbG9jYWwgbnVtYmVycyBpbnRvIG1lbW9yaXphYmxlIGdyb3Vwcy5cbi8vIEZvciBleGFtcGxlLCByZW1lbWJlcmluZyBcIjU1NTM1MzVcIiBpcyBkaWZmaWN1bHQgYnV0IFwiNTU1LTM1LTM1XCIgaXMgbXVjaCBzaW1wbGVyLlxuLy8gSW1hZ2luZSBhIG1hbiB0YWtpbmcgYSBidXMgZnJvbSBob21lIHRvIHdvcmsgYW5kIHNlZWluZyBhbiBhZCB3aXRoIGEgcGhvbmUgbnVtYmVyLlxuLy8gSGUgaGFzIGEgY291cGxlIG9mIHNlY29uZHMgdG8gbWVtb3JpemUgdGhhdCBudW1iZXIgdW50aWwgaXQgcGFzc2VzIGJ5LlxuLy8gSWYgaXQgd2VyZSBzcGFjZXMgaW5zdGVhZCBvZiBoeXBoZW5zIHRoZSBtYW4gd291bGRuJ3QgbmVjZXNzYXJpbHkgZ2V0IGl0LFxuLy8gYnV0IHdpdGggaHlwaGVucyBpbnN0ZWFkIG9mIHNwYWNlcyB0aGUgZ3JvdXBpbmcgaXMgbW9yZSBleHBsaWNpdC5cbi8vIEkgcGVyc29uYWxseSB0aGluayB0aGF0IGh5cGhlbnMgaW50cm9kdWNlIHZpc3VhbCBjbHV0dGVyLFxuLy8gc28gSSBwcmVmZXIgcmVwbGFjaW5nIHRoZW0gd2l0aCBzcGFjZXMgaW4gaW50ZXJuYXRpb25hbCBudW1iZXJzLlxuLy8gSW4gdGhlIG1vZGVybiBhZ2UgYWxsIG91dHB1dCBpcyBkb25lIG9uIGRpc3BsYXlzIHdoZXJlIHNwYWNlcyBhcmUgY2xlYXJseSBkaXN0aW5ndWlzaGFibGVcbi8vIHNvIGh5cGhlbnMgY2FuIGJlIHNhZmVseSByZXBsYWNlZCB3aXRoIHNwYWNlcyB3aXRob3V0IGxvc2luZyBhbnkgbGVnaWJpbGl0eS5cbi8vXG5cblxuZnVuY3Rpb24gYXBwbHlJbnRlcm5hdGlvbmFsU2VwYXJhdG9yU3R5bGUobG9jYWwpIHtcbiAgcmV0dXJuIGxvY2FsLnJlcGxhY2UobmV3IFJlZ0V4cChcIltcIi5jb25jYXQoVkFMSURfUFVOQ1RVQVRJT04sIFwiXStcIiksICdnJyksICcgJykudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBhZGRFeHRlbnNpb24oZm9ybWF0dGVkTnVtYmVyLCBleHQsIG1ldGFkYXRhLCBmb3JtYXRFeHRlbnNpb24pIHtcbiAgcmV0dXJuIGV4dCA/IGZvcm1hdEV4dGVuc2lvbihmb3JtYXR0ZWROdW1iZXIsIGV4dCwgbWV0YWRhdGEpIDogZm9ybWF0dGVkTnVtYmVyO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRJRERTYW1lQ291bnRyeUNhbGxpbmdDb2RlTnVtYmVyKG51bWJlciwgdG9Db3VudHJ5Q2FsbGluZ0NvZGUsIGZyb21Db3VudHJ5LCB0b0NvdW50cnlNZXRhZGF0YSwgb3B0aW9ucykge1xuICB2YXIgZnJvbUNvdW50cnlNZXRhZGF0YSA9IG5ldyBNZXRhZGF0YSh0b0NvdW50cnlNZXRhZGF0YS5tZXRhZGF0YSk7XG4gIGZyb21Db3VudHJ5TWV0YWRhdGEuY291bnRyeShmcm9tQ291bnRyeSk7IC8vIElmIGNhbGxpbmcgd2l0aGluIHRoZSBzYW1lIGNvdW50cnkgY2FsbGluZyBjb2RlLlxuXG4gIGlmICh0b0NvdW50cnlDYWxsaW5nQ29kZSA9PT0gZnJvbUNvdW50cnlNZXRhZGF0YS5jb3VudHJ5Q2FsbGluZ0NvZGUoKSkge1xuICAgIC8vIEZvciBOQU5QQSByZWdpb25zLCByZXR1cm4gdGhlIG5hdGlvbmFsIGZvcm1hdCBmb3IgdGhlc2UgcmVnaW9uc1xuICAgIC8vIGJ1dCBwcmVmaXggaXQgd2l0aCB0aGUgY291bnRyeSBjYWxsaW5nIGNvZGUuXG4gICAgaWYgKHRvQ291bnRyeUNhbGxpbmdDb2RlID09PSAnMScpIHtcbiAgICAgIHJldHVybiB0b0NvdW50cnlDYWxsaW5nQ29kZSArICcgJyArIGZvcm1hdE5hdGlvbmFsTnVtYmVyKG51bWJlciwgJ05BVElPTkFMJywgdG9Db3VudHJ5TWV0YWRhdGEsIG9wdGlvbnMpO1xuICAgIH0gLy8gSWYgcmVnaW9ucyBzaGFyZSBhIGNvdW50cnkgY2FsbGluZyBjb2RlLCB0aGUgY291bnRyeSBjYWxsaW5nIGNvZGUgbmVlZFxuICAgIC8vIG5vdCBiZSBkaWFsbGVkLiBUaGlzIGFsc28gYXBwbGllcyB3aGVuIGRpYWxsaW5nIHdpdGhpbiBhIHJlZ2lvbiwgc28gdGhpc1xuICAgIC8vIGlmIGNsYXVzZSBjb3ZlcnMgYm90aCB0aGVzZSBjYXNlcy4gVGVjaG5pY2FsbHkgdGhpcyBpcyB0aGUgY2FzZSBmb3JcbiAgICAvLyBkaWFsbGluZyBmcm9tIExhIFJldW5pb24gdG8gb3RoZXIgb3ZlcnNlYXMgZGVwYXJ0bWVudHMgb2YgRnJhbmNlIChGcmVuY2hcbiAgICAvLyBHdWlhbmEsIE1hcnRpbmlxdWUsIEd1YWRlbG91cGUpLCBidXQgbm90IHZpY2UgdmVyc2EgLSBzbyB3ZSBkb24ndCBjb3ZlclxuICAgIC8vIHRoaXMgZWRnZSBjYXNlIGZvciBub3cgYW5kIGZvciB0aG9zZSBjYXNlcyByZXR1cm4gdGhlIHZlcnNpb24gaW5jbHVkaW5nXG4gICAgLy8gY291bnRyeSBjYWxsaW5nIGNvZGUuIERldGFpbHMgaGVyZTpcbiAgICAvLyBodHRwOi8vd3d3LnBldGl0ZnV0ZS5jb20vdm95YWdlLzIyNS1pbmZvLXByYXRpcXVlcy1yZXVuaW9uXG4gICAgLy9cblxuXG4gICAgcmV0dXJuIGZvcm1hdE5hdGlvbmFsTnVtYmVyKG51bWJlciwgJ05BVElPTkFMJywgdG9Db3VudHJ5TWV0YWRhdGEsIG9wdGlvbnMpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXRfLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvZXM2L1Bob25lTnVtYmVyLmpzXG5mdW5jdGlvbiBQaG9uZU51bWJlcl9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykgeyBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlOyB9KSk7IH0gb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgUGhvbmVOdW1iZXJfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBQaG9uZU51bWJlcl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIFBob25lTnVtYmVyX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gUGhvbmVOdW1iZXJfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIFBob25lTnVtYmVyX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgUGhvbmVOdW1iZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIFBob25lTnVtYmVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblxuXG5cblxuXG5cbnZhciBVU0VfTk9OX0dFT0dSQVBISUNfQ09VTlRSWV9DT0RFID0gZmFsc2U7XG5cbnZhciBQaG9uZU51bWJlcl9QaG9uZU51bWJlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBob25lTnVtYmVyKGNvdW50cnlDYWxsaW5nQ29kZSwgbmF0aW9uYWxOdW1iZXIsIG1ldGFkYXRhKSB7XG4gICAgUGhvbmVOdW1iZXJfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGhvbmVOdW1iZXIpO1xuXG4gICAgaWYgKCFjb3VudHJ5Q2FsbGluZ0NvZGUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Bjb3VudHJ5YCBvciBgY291bnRyeUNhbGxpbmdDb2RlYCBub3QgcGFzc2VkJyk7XG4gICAgfVxuXG4gICAgaWYgKCFuYXRpb25hbE51bWJlcikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYG5hdGlvbmFsTnVtYmVyYCBub3QgcGFzc2VkJyk7XG4gICAgfVxuXG4gICAgdmFyIF9tZXRhZGF0YSA9IG5ldyBNZXRhZGF0YShtZXRhZGF0YSk7IC8vIElmIGNvdW50cnkgY29kZSBpcyBwYXNzZWQgdGhlbiBkZXJpdmUgYGNvdW50cnlDYWxsaW5nQ29kZWAgZnJvbSBpdC5cbiAgICAvLyBBbHNvIHN0b3JlIHRoZSBjb3VudHJ5IGNvZGUgYXMgYC5jb3VudHJ5YC5cblxuXG4gICAgaWYgKGlzQ291bnRyeUNvZGUoY291bnRyeUNhbGxpbmdDb2RlKSkge1xuICAgICAgdGhpcy5jb3VudHJ5ID0gY291bnRyeUNhbGxpbmdDb2RlO1xuXG4gICAgICBfbWV0YWRhdGEuY291bnRyeShjb3VudHJ5Q2FsbGluZ0NvZGUpO1xuXG4gICAgICBjb3VudHJ5Q2FsbGluZ0NvZGUgPSBfbWV0YWRhdGEuY291bnRyeUNhbGxpbmdDb2RlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKFVTRV9OT05fR0VPR1JBUEhJQ19DT1VOVFJZX0NPREUpIHtcbiAgICAgICAgaWYgKF9tZXRhZGF0YS5pc05vbkdlb2dyYXBoaWNDYWxsaW5nQ29kZShjb3VudHJ5Q2FsbGluZ0NvZGUpKSB7XG4gICAgICAgICAgdGhpcy5jb3VudHJ5ID0gJzAwMSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvdW50cnlDYWxsaW5nQ29kZSA9IGNvdW50cnlDYWxsaW5nQ29kZTtcbiAgICB0aGlzLm5hdGlvbmFsTnVtYmVyID0gbmF0aW9uYWxOdW1iZXI7XG4gICAgdGhpcy5udW1iZXIgPSAnKycgKyB0aGlzLmNvdW50cnlDYWxsaW5nQ29kZSArIHRoaXMubmF0aW9uYWxOdW1iZXI7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICB9XG5cbiAgUGhvbmVOdW1iZXJfY3JlYXRlQ2xhc3MoUGhvbmVOdW1iZXIsIFt7XG4gICAga2V5OiBcImlzUG9zc2libGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNQb3NzaWJsZSgpIHtcbiAgICAgIHJldHVybiBpc1Bvc3NpYmxlUGhvbmVOdW1iZXIodGhpcywge1xuICAgICAgICB2MjogdHJ1ZVxuICAgICAgfSwgdGhpcy5tZXRhZGF0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVmFsaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWxpZCgpIHtcbiAgICAgIHJldHVybiBpc1ZhbGlkTnVtYmVyKHRoaXMsIHtcbiAgICAgICAgdjI6IHRydWVcbiAgICAgIH0sIHRoaXMubWV0YWRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc05vbkdlb2dyYXBoaWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNOb25HZW9ncmFwaGljKCkge1xuICAgICAgdmFyIG1ldGFkYXRhID0gbmV3IE1ldGFkYXRhKHRoaXMubWV0YWRhdGEpO1xuICAgICAgcmV0dXJuIG1ldGFkYXRhLmlzTm9uR2VvZ3JhcGhpY0NhbGxpbmdDb2RlKHRoaXMuY291bnRyeUNhbGxpbmdDb2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNFcXVhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VxdWFsKHBob25lTnVtYmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5udW1iZXIgPT09IHBob25lTnVtYmVyLm51bWJlciAmJiB0aGlzLmV4dCA9PT0gcGhvbmVOdW1iZXIuZXh0O1xuICAgIH0gLy8gLy8gSXMganVzdCBhbiBhbGlhcyBmb3IgYHRoaXMuaXNWYWxpZCgpICYmIHRoaXMuY291bnRyeSA9PT0gY291bnRyeWAuXG4gICAgLy8gLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWkxOG4vbGlicGhvbmVudW1iZXIvYmxvYi9tYXN0ZXIvRkFRLm1kI3doZW4tc2hvdWxkLWktdXNlLWlzdmFsaWRudW1iZXJmb3JyZWdpb25cbiAgICAvLyBpc1ZhbGlkRm9yUmVnaW9uKGNvdW50cnkpIHtcbiAgICAvLyBcdHJldHVybiBpc1ZhbGlkTnVtYmVyRm9yUmVnaW9uKHRoaXMsIGNvdW50cnksIHsgdjI6IHRydWUgfSwgdGhpcy5tZXRhZGF0YSlcbiAgICAvLyB9XG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFR5cGUoKSB7XG4gICAgICByZXR1cm4gZ2V0TnVtYmVyVHlwZSh0aGlzLCB7XG4gICAgICAgIHYyOiB0cnVlXG4gICAgICB9LCB0aGlzLm1ldGFkYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChfZm9ybWF0LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gZm9ybWF0X2Zvcm1hdE51bWJlcih0aGlzLCBfZm9ybWF0LCBvcHRpb25zID8gUGhvbmVOdW1iZXJfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHYyOiB0cnVlXG4gICAgICB9KSA6IHtcbiAgICAgICAgdjI6IHRydWVcbiAgICAgIH0sIHRoaXMubWV0YWRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXROYXRpb25hbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXROYXRpb25hbChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXQoJ05BVElPTkFMJywgb3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdEludGVybmF0aW9uYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0SW50ZXJuYXRpb25hbChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXQoJ0lOVEVSTkFUSU9OQUwnLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VVJJXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVSSShvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXQoJ1JGQzM5NjYnLCBvcHRpb25zKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGhvbmVOdW1iZXI7XG59KCk7XG5cblxuXG52YXIgaXNDb3VudHJ5Q29kZSA9IGZ1bmN0aW9uIGlzQ291bnRyeUNvZGUodmFsdWUpIHtcbiAgcmV0dXJuIC9eW0EtWl17Mn0kLy50ZXN0KHZhbHVlKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QaG9uZU51bWJlci5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9wYXJzZV8uanNcbi8vIFRoaXMgaXMgYSBwb3J0IG9mIEdvb2dsZSBBbmRyb2lkIGBsaWJwaG9uZW51bWJlcmAnc1xuLy8gYHBob25lbnVtYmVydXRpbC5qc2Agb2YgRGVjZW1iZXIgMzF0aCwgMjAxOC5cbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlaTE4bi9saWJwaG9uZW51bWJlci9jb21taXRzL21hc3Rlci9qYXZhc2NyaXB0L2kxOG4vcGhvbmVudW1iZXJzL3Bob25lbnVtYmVydXRpbC5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuIC8vIFdlIGRvbid0IGFsbG93IGlucHV0IHN0cmluZ3MgZm9yIHBhcnNpbmcgdG8gYmUgbG9uZ2VyIHRoYW4gMjUwIGNoYXJzLlxuLy8gVGhpcyBwcmV2ZW50cyBtYWxpY2lvdXMgaW5wdXQgZnJvbSBjb25zdW1pbmcgQ1BVLlxuXG52YXIgTUFYX0lOUFVUX1NUUklOR19MRU5HVEggPSAyNTA7IC8vIFRoaXMgY29uc2lzdHMgb2YgdGhlIHBsdXMgc3ltYm9sLCBkaWdpdHMsIGFuZCBhcmFiaWMtaW5kaWMgZGlnaXRzLlxuXG52YXIgUEhPTkVfTlVNQkVSX1NUQVJUX1BBVFRFUk4gPSBuZXcgUmVnRXhwKCdbJyArIFBMVVNfQ0hBUlMgKyBWQUxJRF9ESUdJVFMgKyAnXScpOyAvLyBSZWd1bGFyIGV4cHJlc3Npb24gb2YgdHJhaWxpbmcgY2hhcmFjdGVycyB0aGF0IHdlIHdhbnQgdG8gcmVtb3ZlLlxuXG52YXIgQUZURVJfUEhPTkVfTlVNQkVSX0VORF9QQVRURVJOID0gbmV3IFJlZ0V4cCgnW14nICsgVkFMSURfRElHSVRTICsgJ10rJCcpO1xudmFyIHBhcnNlX1VTRV9OT05fR0VPR1JBUEhJQ19DT1VOVFJZX0NPREUgPSBmYWxzZTsgLy8gYG9wdGlvbnNgOlxuLy8gIHtcbi8vICAgIGNvdW50cnk6XG4vLyAgICB7XG4vLyAgICAgIHJlc3RyaWN0IC0gKGEgdHdvLWxldHRlciBjb3VudHJ5IGNvZGUpXG4vLyAgICAgICAgICAgICAgICAgdGhlIHBob25lIG51bWJlciBtdXN0IGJlIGluIHRoaXMgY291bnRyeVxuLy9cbi8vICAgICAgZGVmYXVsdCAtIChhIHR3by1sZXR0ZXIgY291bnRyeSBjb2RlKVxuLy8gICAgICAgICAgICAgICAgZGVmYXVsdCBjb3VudHJ5IHRvIHVzZSBmb3IgcGhvbmUgbnVtYmVyIHBhcnNpbmcgYW5kIHZhbGlkYXRpb25cbi8vICAgICAgICAgICAgICAgIChpZiBubyBjb3VudHJ5IGNvZGUgY291bGQgYmUgZGVyaXZlZCBmcm9tIHRoZSBwaG9uZSBudW1iZXIpXG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vIFJldHVybnMgYHsgY291bnRyeSwgbnVtYmVyIH1gXG4vL1xuLy8gRXhhbXBsZSB1c2UgY2FzZXM6XG4vL1xuLy8gYGBganNcbi8vIHBhcnNlKCc4ICg4MDApIDU1NS0zNS0zNScsICdSVScpXG4vLyBwYXJzZSgnOCAoODAwKSA1NTUtMzUtMzUnLCAnUlUnLCBtZXRhZGF0YSlcbi8vIHBhcnNlKCc4ICg4MDApIDU1NS0zNS0zNScsIHsgY291bnRyeTogeyBkZWZhdWx0OiAnUlUnIH0gfSlcbi8vIHBhcnNlKCc4ICg4MDApIDU1NS0zNS0zNScsIHsgY291bnRyeTogeyBkZWZhdWx0OiAnUlUnIH0gfSwgbWV0YWRhdGEpXG4vLyBwYXJzZSgnKzcgODAwIDU1NSAzNSAzNScpXG4vLyBwYXJzZSgnKzcgODAwIDU1NSAzNSAzNScsIG1ldGFkYXRhKVxuLy8gYGBgXG4vL1xuXG5mdW5jdGlvbiBwYXJzZSh0ZXh0LCBvcHRpb25zLCBtZXRhZGF0YSkge1xuICAvLyBJZiBhc3NpZ25pbmcgdGhlIGB7fWAgZGVmYXVsdCB2YWx1ZSBpcyBtb3ZlZCB0byB0aGUgYXJndW1lbnRzIGFib3ZlLFxuICAvLyBjb2RlIGNvdmVyYWdlIHdvdWxkIGRlY3JlYXNlIGZvciBzb21lIHdlaXJkIHJlYXNvbi5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG1ldGFkYXRhID0gbmV3IE1ldGFkYXRhKG1ldGFkYXRhKTsgLy8gVmFsaWRhdGUgYGRlZmF1bHRDb3VudHJ5YC5cblxuICBpZiAob3B0aW9ucy5kZWZhdWx0Q291bnRyeSAmJiAhbWV0YWRhdGEuaGFzQ291bnRyeShvcHRpb25zLmRlZmF1bHRDb3VudHJ5KSkge1xuICAgIGlmIChvcHRpb25zLnYyKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcignSU5WQUxJRF9DT1VOVFJZJyk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb3VudHJ5OiBcIi5jb25jYXQob3B0aW9ucy5kZWZhdWx0Q291bnRyeSkpO1xuICB9IC8vIFBhcnNlIHRoZSBwaG9uZSBudW1iZXIuXG5cblxuICB2YXIgX3BhcnNlSW5wdXQgPSBwYXJzZUlucHV0KHRleHQsIG9wdGlvbnMudjIpLFxuICAgICAgZm9ybWF0dGVkUGhvbmVOdW1iZXIgPSBfcGFyc2VJbnB1dC5udW1iZXIsXG4gICAgICBleHQgPSBfcGFyc2VJbnB1dC5leHQ7IC8vIElmIHRoZSBwaG9uZSBudW1iZXIgaXMgbm90IHZpYWJsZSB0aGVuIHJldHVybiBub3RoaW5nLlxuXG5cbiAgaWYgKCFmb3JtYXR0ZWRQaG9uZU51bWJlcikge1xuICAgIGlmIChvcHRpb25zLnYyKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcignTk9UX0FfTlVNQkVSJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdmFyIF9wYXJzZVBob25lTnVtYmVyID0gcGFyc2VQaG9uZU51bWJlcihmb3JtYXR0ZWRQaG9uZU51bWJlciwgb3B0aW9ucy5kZWZhdWx0Q291bnRyeSwgb3B0aW9ucy5kZWZhdWx0Q2FsbGluZ0NvZGUsIG1ldGFkYXRhKSxcbiAgICAgIGNvdW50cnkgPSBfcGFyc2VQaG9uZU51bWJlci5jb3VudHJ5LFxuICAgICAgbmF0aW9uYWxOdW1iZXIgPSBfcGFyc2VQaG9uZU51bWJlci5uYXRpb25hbE51bWJlcixcbiAgICAgIGNvdW50cnlDYWxsaW5nQ29kZSA9IF9wYXJzZVBob25lTnVtYmVyLmNvdW50cnlDYWxsaW5nQ29kZSxcbiAgICAgIGNhcnJpZXJDb2RlID0gX3BhcnNlUGhvbmVOdW1iZXIuY2FycmllckNvZGU7XG5cbiAgaWYgKCFtZXRhZGF0YS5oYXNTZWxlY3RlZE51bWJlcmluZ1BsYW4oKSkge1xuICAgIGlmIChvcHRpb25zLnYyKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcignSU5WQUxJRF9DT1VOVFJZJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHt9O1xuICB9IC8vIFZhbGlkYXRlIG5hdGlvbmFsIChzaWduaWZpY2FudCkgbnVtYmVyIGxlbmd0aC5cblxuXG4gIGlmICghbmF0aW9uYWxOdW1iZXIgfHwgbmF0aW9uYWxOdW1iZXIubGVuZ3RoIDwgTUlOX0xFTkdUSF9GT1JfTlNOKSB7XG4gICAgLy8gV29uJ3QgdGhyb3cgaGVyZSBiZWNhdXNlIHRoZSByZWdleHAgYWxyZWFkeSBkZW1hbmRzIGxlbmd0aCA+IDEuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAob3B0aW9ucy52Mikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoJ1RPT19TSE9SVCcpO1xuICAgIH0gLy8gR29vZ2xlJ3MgZGVtbyBqdXN0IHRocm93cyBhbiBlcnJvciBpbiB0aGlzIGNhc2UuXG5cblxuICAgIHJldHVybiB7fTtcbiAgfSAvLyBWYWxpZGF0ZSBuYXRpb25hbCAoc2lnbmlmaWNhbnQpIG51bWJlciBsZW5ndGguXG4gIC8vXG4gIC8vIEEgc2lkZW5vdGU6XG4gIC8vXG4gIC8vIFRoZXkgc2F5IHRoYXQgc29tZXRpbWVzIG5hdGlvbmFsIChzaWduaWZpY2FudCkgbnVtYmVyc1xuICAvLyBjYW4gYmUgbG9uZ2VyIHRoYW4gYE1BWF9MRU5HVEhfRk9SX05TTmAgKGUuZy4gaW4gR2VybWFueSkuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVpMThuL2xpYnBob25lbnVtYmVyL2Jsb2IvN2UxNzQ4NjQ1NTUyZGEzOWM0ZTFiYTczMWU0Nzk2OWQ5N2JkYjUzOS9yZXNvdXJjZXMvcGhvbmVudW1iZXIucHJvdG8jTDM2XG4gIC8vIFN1Y2ggbnVtYmVycyB3aWxsIGp1c3QgYmUgZGlzY2FyZGVkLlxuICAvL1xuXG5cbiAgaWYgKG5hdGlvbmFsTnVtYmVyLmxlbmd0aCA+IE1BWF9MRU5HVEhfRk9SX05TTikge1xuICAgIGlmIChvcHRpb25zLnYyKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcignVE9PX0xPTkcnKTtcbiAgICB9IC8vIEdvb2dsZSdzIGRlbW8ganVzdCB0aHJvd3MgYW4gZXJyb3IgaW4gdGhpcyBjYXNlLlxuXG5cbiAgICByZXR1cm4ge307XG4gIH1cblxuICBpZiAob3B0aW9ucy52Mikge1xuICAgIHZhciBwaG9uZU51bWJlciA9IG5ldyBQaG9uZU51bWJlcl9QaG9uZU51bWJlcihjb3VudHJ5Q2FsbGluZ0NvZGUsIG5hdGlvbmFsTnVtYmVyLCBtZXRhZGF0YS5tZXRhZGF0YSk7XG5cbiAgICBpZiAoY291bnRyeSkge1xuICAgICAgcGhvbmVOdW1iZXIuY291bnRyeSA9IGNvdW50cnk7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJpZXJDb2RlKSB7XG4gICAgICBwaG9uZU51bWJlci5jYXJyaWVyQ29kZSA9IGNhcnJpZXJDb2RlO1xuICAgIH1cblxuICAgIGlmIChleHQpIHtcbiAgICAgIHBob25lTnVtYmVyLmV4dCA9IGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGhvbmVOdW1iZXI7XG4gIH0gLy8gQ2hlY2sgaWYgbmF0aW9uYWwgcGhvbmUgbnVtYmVyIHBhdHRlcm4gbWF0Y2hlcyB0aGUgbnVtYmVyLlxuICAvLyBOYXRpb25hbCBudW1iZXIgcGF0dGVybiBpcyBkaWZmZXJlbnQgZm9yIGVhY2ggY291bnRyeSxcbiAgLy8gZXZlbiBmb3IgdGhvc2Ugb25lcyB3aGljaCBhcmUgcGFydCBvZiB0aGUgXCJOQU5QQVwiIGdyb3VwLlxuXG5cbiAgdmFyIHZhbGlkID0gKG9wdGlvbnMuZXh0ZW5kZWQgPyBtZXRhZGF0YS5oYXNTZWxlY3RlZE51bWJlcmluZ1BsYW4oKSA6IGNvdW50cnkpID8gbWF0Y2hlc0VudGlyZWx5KG5hdGlvbmFsTnVtYmVyLCBtZXRhZGF0YS5uYXRpb25hbE51bWJlclBhdHRlcm4oKSkgOiBmYWxzZTtcblxuICBpZiAoIW9wdGlvbnMuZXh0ZW5kZWQpIHtcbiAgICByZXR1cm4gdmFsaWQgPyBwYXJzZV9yZXN1bHQoY291bnRyeSwgbmF0aW9uYWxOdW1iZXIsIGV4dCkgOiB7fTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY291bnRyeTogY291bnRyeSxcbiAgICBjb3VudHJ5Q2FsbGluZ0NvZGU6IGNvdW50cnlDYWxsaW5nQ29kZSxcbiAgICBjYXJyaWVyQ29kZTogY2FycmllckNvZGUsXG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIHBvc3NpYmxlOiB2YWxpZCA/IHRydWUgOiBvcHRpb25zLmV4dGVuZGVkID09PSB0cnVlICYmIG1ldGFkYXRhLnBvc3NpYmxlTGVuZ3RocygpICYmIGlzUG9zc2libGVOdW1iZXIobmF0aW9uYWxOdW1iZXIsIGNvdW50cnlDYWxsaW5nQ29kZSAhPT0gdW5kZWZpbmVkLCBtZXRhZGF0YSkgPyB0cnVlIDogZmFsc2UsXG4gICAgcGhvbmU6IG5hdGlvbmFsTnVtYmVyLFxuICAgIGV4dDogZXh0XG4gIH07XG59XG4vKipcclxuICogRXh0cmFjdHMgYSBmb3JtYXR0ZWQgcGhvbmUgbnVtYmVyIGZyb20gdGV4dC5cclxuICogRG9lc24ndCBndWFyYW50ZWUgdGhhdCB0aGUgZXh0cmFjdGVkIHBob25lIG51bWJlclxyXG4gKiBpcyBhIHZhbGlkIHBob25lIG51bWJlciAoZm9yIGV4YW1wbGUsIGRvZXNuJ3QgdmFsaWRhdGUgaXRzIGxlbmd0aCkuXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gdGV4dFxyXG4gKiBAcGFyYW0gIHtib29sZWFufSB0aHJvd09uRXJyb3Ig4oCUIEJ5IGRlZmF1bHQsIGl0IHdvbid0IHRocm93IGlmIHRoZSB0ZXh0IGlzIHRvbyBsb25nLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIFJldHVybnMgXCIoMjEzKSAzNzMtNDI1M1wiLlxyXG4gKiBleHRyYWN0Rm9ybWF0dGVkUGhvbmVOdW1iZXIoXCJDYWxsICgyMTMpIDM3My00MjUzIGZvciBhc3Npc3RhbmNlLlwiKVxyXG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdEZvcm1hdHRlZFBob25lTnVtYmVyKHRleHQsIHRocm93T25FcnJvcikge1xuICBpZiAoIXRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGV4dC5sZW5ndGggPiBNQVhfSU5QVVRfU1RSSU5HX0xFTkdUSCkge1xuICAgIGlmICh0aHJvd09uRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCdUT09fTE9ORycpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSAvLyBBdHRlbXB0IHRvIGV4dHJhY3QgYSBwb3NzaWJsZSBudW1iZXIgZnJvbSB0aGUgc3RyaW5nIHBhc3NlZCBpblxuXG5cbiAgdmFyIHN0YXJ0c0F0ID0gdGV4dC5zZWFyY2goUEhPTkVfTlVNQkVSX1NUQVJUX1BBVFRFUk4pO1xuXG4gIGlmIChzdGFydHNBdCA8IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gdGV4dCAvLyBUcmltIGV2ZXJ5dGhpbmcgdG8gdGhlIGxlZnQgb2YgdGhlIHBob25lIG51bWJlclxuICAuc2xpY2Uoc3RhcnRzQXQpIC8vIFJlbW92ZSB0cmFpbGluZyBub24tbnVtZXJpY2FsIGNoYXJhY3RlcnNcbiAgLnJlcGxhY2UoQUZURVJfUEhPTkVfTlVNQkVSX0VORF9QQVRURVJOLCAnJyk7XG59XG4vKipcclxuICogU3RyaXBzIGFueSBuYXRpb25hbCBwcmVmaXggKHN1Y2ggYXMgMCwgMSkgcHJlc2VudCBpbiBhXHJcbiAqIChwb3NzaWJseSBpbmNvbXBsZXRlKSBudW1iZXIgcHJvdmlkZWQuXHJcbiAqIFwiQ2FycmllciBjb2Rlc1wiIGFyZSBvbmx5IHVzZWQgIGluIENvbG9tYmlhIGFuZCBCcmF6aWwsXHJcbiAqIGFuZCBvbmx5IHdoZW4gZGlhbGluZyB3aXRoaW4gdGhvc2UgY291bnRyaWVzIGZyb20gYSBtb2JpbGUgcGhvbmUgdG8gYSBmaXhlZCBsaW5lIG51bWJlci5cclxuICogU29tZXRpbWVzIGl0IHdvbid0IGFjdHVhbGx5IHN0cmlwIG5hdGlvbmFsIHByZWZpeFxyXG4gKiBhbmQgd2lsbCBpbnN0ZWFkIHByZXBlbmQgc29tZSBkaWdpdHMgdG8gdGhlIGBudW1iZXJgOlxyXG4gKiBmb3IgZXhhbXBsZSwgd2hlbiBudW1iZXIgYDIzNDU2NzhgIGlzIHBhc3NlZCB3aXRoIGBWSWAgY291bnRyeSBzZWxlY3RlZCxcclxuICogaXQgd2lsbCByZXR1cm4gYHsgbnVtYmVyOiBcIjM0MDIzNDU2NzhcIiB9YCwgYmVjYXVzZSBgMzQwYCBhcmVhIGNvZGUgaXMgcHJlcGVuZGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbnVtYmVyIOKAlCBOYXRpb25hbCBudW1iZXIgZGlnaXRzLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbWV0YWRhdGEg4oCUIE1ldGFkYXRhIHdpdGggY291bnRyeSBzZWxlY3RlZC5cclxuICogQHJldHVybiB7b2JqZWN0fSBgeyBuYXRpb25hbE51bWJlcjogc3RyaW5nLCBjYXJyaWVyQ29kZTogc3RyaW5nPyB9YC5cclxuICovXG5cbmZ1bmN0aW9uIHN0cmlwTmF0aW9uYWxQcmVmaXhBbmRDYXJyaWVyQ29kZShudW1iZXIsIG1ldGFkYXRhKSB7XG4gIGlmIChudW1iZXIgJiYgbWV0YWRhdGEubmF0aW9uYWxQcmVmaXhGb3JQYXJzaW5nKCkpIHtcbiAgICAvLyBTZWUgTUVUQURBVEEubWQgZm9yIHRoZSBkZXNjcmlwdGlvbiBvZlxuICAgIC8vIGBuYXRpb25hbF9wcmVmaXhfZm9yX3BhcnNpbmdgIGFuZCBgbmF0aW9uYWxfcHJlZml4X3RyYW5zZm9ybV9ydWxlYC5cbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBmaXJzdCBkaWdpdHMgYXMgYSBuYXRpb25hbCBwcmVmaXguXG4gICAgdmFyIHByZWZpeFBhdHRlcm4gPSBuZXcgUmVnRXhwKCdeKD86JyArIG1ldGFkYXRhLm5hdGlvbmFsUHJlZml4Rm9yUGFyc2luZygpICsgJyknKTtcbiAgICB2YXIgcHJlZml4TWF0Y2ggPSBwcmVmaXhQYXR0ZXJuLmV4ZWMobnVtYmVyKTtcblxuICAgIGlmIChwcmVmaXhNYXRjaCkge1xuICAgICAgdmFyIG5hdGlvbmFsTnVtYmVyO1xuICAgICAgdmFyIGNhcnJpZXJDb2RlOyAvLyBJZiBhIFwiY2FwdHVyaW5nIGdyb3VwXCIgZGlkbid0IG1hdGNoXG4gICAgICAvLyB0aGVuIGl0cyBlbGVtZW50IGluIGBwcmVmaXhNYXRjaFtdYCBhcnJheSB3aWxsIGJlIGB1bmRlZmluZWRgLlxuXG4gICAgICB2YXIgY2FwdHVyZWRHcm91cHNDb3VudCA9IHByZWZpeE1hdGNoLmxlbmd0aCAtIDE7XG5cbiAgICAgIGlmIChtZXRhZGF0YS5uYXRpb25hbFByZWZpeFRyYW5zZm9ybVJ1bGUoKSAmJiBjYXB0dXJlZEdyb3Vwc0NvdW50ID4gMCAmJiBwcmVmaXhNYXRjaFtjYXB0dXJlZEdyb3Vwc0NvdW50XSkge1xuICAgICAgICBuYXRpb25hbE51bWJlciA9IG51bWJlci5yZXBsYWNlKHByZWZpeFBhdHRlcm4sIG1ldGFkYXRhLm5hdGlvbmFsUHJlZml4VHJhbnNmb3JtUnVsZSgpKTsgLy8gQ2FycmllciBjb2RlIGlzIHRoZSBsYXN0IGNhcHR1cmVkIGdyb3VwLFxuICAgICAgICAvLyBidXQgb25seSB3aGVuIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZSBjYXB0dXJlZCBncm91cC5cblxuICAgICAgICBpZiAoY2FwdHVyZWRHcm91cHNDb3VudCA+IDEgJiYgcHJlZml4TWF0Y2hbY2FwdHVyZWRHcm91cHNDb3VudF0pIHtcbiAgICAgICAgICBjYXJyaWVyQ29kZSA9IHByZWZpeE1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICB9IC8vIElmIGl0J3MgYSBzaW1wbGUtZW5vdWdoIGNhc2UgdGhlbiBqdXN0XG4gICAgICAvLyBzdHJpcCB0aGUgbmF0aW9uYWwgcHJlZml4IGZyb20gdGhlIG51bWJlci5cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIE5hdGlvbmFsIHByZWZpeCBpcyB0aGUgd2hvbGUgc3Vic3RyaW5nIG1hdGNoZWQgYnlcbiAgICAgICAgICAvLyB0aGUgYG5hdGlvbmFsX3ByZWZpeF9mb3JfcGFyc2luZ2AgcmVnZXhwLlxuICAgICAgICAgIHZhciBuYXRpb25hbFByZWZpeCA9IHByZWZpeE1hdGNoWzBdO1xuICAgICAgICAgIG5hdGlvbmFsTnVtYmVyID0gbnVtYmVyLnNsaWNlKG5hdGlvbmFsUHJlZml4Lmxlbmd0aCk7IC8vIENhcnJpZXIgY29kZSBpcyB0aGUgbGFzdCBjYXB0dXJlZCBncm91cC5cblxuICAgICAgICAgIGlmIChjYXB0dXJlZEdyb3Vwc0NvdW50ID4gMCkge1xuICAgICAgICAgICAgY2FycmllckNvZGUgPSBwcmVmaXhNYXRjaFsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gV2UgcmVxdWlyZSB0aGF0IHRoZSBuYXRpb25hbCAoc2lnbmlmaWNhbnQpIG51bWJlciByZW1haW5pbmcgYWZ0ZXJcbiAgICAgIC8vIHN0cmlwcGluZyB0aGUgbmF0aW9uYWwgcHJlZml4IGFuZCBjYXJyaWVyIGNvZGUgYmUgbG9uZyBlbm91Z2hcbiAgICAgIC8vIHRvIGJlIGEgcG9zc2libGUgbGVuZ3RoIGZvciB0aGUgcmVnaW9uLiBPdGhlcndpc2UsIHdlIGRvbid0IGRvXG4gICAgICAvLyB0aGUgc3RyaXBwaW5nLCBzaW5jZSB0aGUgb3JpZ2luYWwgbnVtYmVyIGNvdWxkIGJlIGEgdmFsaWQgbnVtYmVyLlxuICAgICAgLy8gRm9yIGV4YW1wbGUsIGluIHNvbWUgY291bnRyaWVzIChSdXNzaWEsIEJlbGFydXMpIHRoZSBzYW1lIGRpZ2l0XG4gICAgICAvLyBjb3VsZCBiZSBib3RoIGEgbmF0aW9uYWwgcHJlZml4IGFuZCBhIGxlYWRpbmcgZGlnaXQgb2YgYSB2YWxpZFxuICAgICAgLy8gbmF0aW9uYWwgcGhvbmUgbnVtYmVyLCBsaWtlIGA4YCBpcyB0aGUgbmF0aW9uYWwgcHJlZml4IGZvciBSdXNzaWFcbiAgICAgIC8vIGFuZCBgODAwIDU1NSAzNSAzNWAgaXMgYSB2YWxpZCBuYXRpb25hbCAoc2lnbmlmaWNhbnQpIG51bWJlci5cblxuXG4gICAgICBpZiAobWF0Y2hlc0VudGlyZWx5KG51bWJlciwgbWV0YWRhdGEubmF0aW9uYWxOdW1iZXJQYXR0ZXJuKCkpICYmICFtYXRjaGVzRW50aXJlbHkobmF0aW9uYWxOdW1iZXIsIG1ldGFkYXRhLm5hdGlvbmFsTnVtYmVyUGF0dGVybigpKSkgey8vIERvbid0IHN0cmlwIG5hdGlvbmFsIHByZWZpeCBvciBjYXJyaWVyIGNvZGUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hdGlvbmFsTnVtYmVyOiBuYXRpb25hbE51bWJlcixcbiAgICAgICAgICBjYXJyaWVyQ29kZTogY2FycmllckNvZGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hdGlvbmFsTnVtYmVyOiBudW1iZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRDb3VudHJ5Q29kZShjYWxsaW5nQ29kZSwgbmF0aW9uYWxQaG9uZU51bWJlciwgbWV0YWRhdGEpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwYXJzZV9VU0VfTk9OX0dFT0dSQVBISUNfQ09VTlRSWV9DT0RFKSB7XG4gICAgaWYgKG1ldGFkYXRhLmlzTm9uR2VvZ3JhcGhpY0NhbGxpbmdDb2RlKGNhbGxpbmdDb2RlKSkge1xuICAgICAgcmV0dXJuICcwMDEnO1xuICAgIH1cbiAgfSAvLyBJcyBhbHdheXMgbm9uLWVtcHR5LCBiZWNhdXNlIGBjYWxsaW5nQ29kZWAgaXMgYWx3YXlzIHZhbGlkXG5cblxuICB2YXIgcG9zc2libGVDb3VudHJpZXMgPSBtZXRhZGF0YS5nZXRDb3VudHJ5Q29kZXNGb3JDYWxsaW5nQ29kZShjYWxsaW5nQ29kZSk7XG5cbiAgaWYgKCFwb3NzaWJsZUNvdW50cmllcykge1xuICAgIHJldHVybjtcbiAgfSAvLyBJZiB0aGVyZSdzIGp1c3Qgb25lIGNvdW50cnkgY29ycmVzcG9uZGluZyB0byB0aGUgY291bnRyeSBjb2RlLFxuICAvLyB0aGVuIGp1c3QgcmV0dXJuIGl0LCB3aXRob3V0IGZ1cnRoZXIgcGhvbmUgbnVtYmVyIGRpZ2l0cyB2YWxpZGF0aW9uLlxuXG5cbiAgaWYgKHBvc3NpYmxlQ291bnRyaWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBwb3NzaWJsZUNvdW50cmllc1swXTtcbiAgfVxuXG4gIHJldHVybiBfZmluZENvdW50cnlDb2RlKHBvc3NpYmxlQ291bnRyaWVzLCBuYXRpb25hbFBob25lTnVtYmVyLCBtZXRhZGF0YS5tZXRhZGF0YSk7XG59IC8vIENoYW5nZXMgYG1ldGFkYXRhYCBgY291bnRyeWAuXG5cbmZ1bmN0aW9uIF9maW5kQ291bnRyeUNvZGUocG9zc2libGVDb3VudHJpZXMsIG5hdGlvbmFsUGhvbmVOdW1iZXIsIG1ldGFkYXRhKSB7XG4gIG1ldGFkYXRhID0gbmV3IE1ldGFkYXRhKG1ldGFkYXRhKTtcblxuICBmb3IgKHZhciBfaXRlcmF0b3IgPSBwb3NzaWJsZUNvdW50cmllcywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgIH1cblxuICAgIHZhciBjb3VudHJ5ID0gX3JlZjtcbiAgICBtZXRhZGF0YS5jb3VudHJ5KGNvdW50cnkpOyAvLyBMZWFkaW5nIGRpZ2l0cyBjaGVjayB3b3VsZCBiZSB0aGUgc2ltcGxlc3Qgb25lXG5cbiAgICBpZiAobWV0YWRhdGEubGVhZGluZ0RpZ2l0cygpKSB7XG4gICAgICBpZiAobmF0aW9uYWxQaG9uZU51bWJlciAmJiBuYXRpb25hbFBob25lTnVtYmVyLnNlYXJjaChtZXRhZGF0YS5sZWFkaW5nRGlnaXRzKCkpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjb3VudHJ5O1xuICAgICAgfVxuICAgIH0gLy8gRWxzZSBwZXJmb3JtIGZ1bGwgdmFsaWRhdGlvbiB3aXRoIGFsbCBvZiB0aG9zZVxuICAgIC8vIGZpeGVkLWxpbmUvbW9iaWxlL2V0YyByZWd1bGFyIGV4cHJlc3Npb25zLlxuICAgIGVsc2UgaWYgKGdldE51bWJlclR5cGUoe1xuICAgICAgICBwaG9uZTogbmF0aW9uYWxQaG9uZU51bWJlcixcbiAgICAgICAgY291bnRyeTogY291bnRyeVxuICAgICAgfSwgdW5kZWZpbmVkLCBtZXRhZGF0YS5tZXRhZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50cnk7XG4gICAgICB9XG4gIH1cbn1cbi8qKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBJbnB1dC5cclxuICogQHJldHVybiB7b2JqZWN0fSBgeyA/bnVtYmVyLCA/ZXh0IH1gLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUlucHV0KHRleHQsIHYyKSB7XG4gIC8vIFBhcnNlIFJGQyAzOTY2IHBob25lIG51bWJlciBVUkkuXG4gIGlmICh0ZXh0ICYmIHRleHQuaW5kZXhPZigndGVsOicpID09PSAwKSB7XG4gICAgcmV0dXJuIHBhcnNlUkZDMzk2Nih0ZXh0KTtcbiAgfVxuXG4gIHZhciBudW1iZXIgPSBleHRyYWN0Rm9ybWF0dGVkUGhvbmVOdW1iZXIodGV4dCwgdjIpOyAvLyBJZiB0aGUgcGhvbmUgbnVtYmVyIGlzIG5vdCB2aWFibGUsIHRoZW4gYWJvcnQuXG5cbiAgaWYgKCFudW1iZXIgfHwgIWlzVmlhYmxlUGhvbmVOdW1iZXIobnVtYmVyKSkge1xuICAgIHJldHVybiB7fTtcbiAgfSAvLyBBdHRlbXB0IHRvIHBhcnNlIGV4dGVuc2lvbiBmaXJzdCwgc2luY2UgaXQgZG9lc24ndCByZXF1aXJlIHJlZ2lvbi1zcGVjaWZpY1xuICAvLyBkYXRhIGFuZCB3ZSB3YW50IHRvIGhhdmUgdGhlIG5vbi1ub3JtYWxpc2VkIG51bWJlciBoZXJlLlxuXG5cbiAgdmFyIHdpdGhFeHRlbnNpb25TdHJpcHBlZCA9IGV4dHJhY3RFeHRlbnNpb24obnVtYmVyKTtcblxuICBpZiAod2l0aEV4dGVuc2lvblN0cmlwcGVkLmV4dCkge1xuICAgIHJldHVybiB3aXRoRXh0ZW5zaW9uU3RyaXBwZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG51bWJlcjogbnVtYmVyXG4gIH07XG59XG4vKipcclxuICogQ3JlYXRlcyBgcGFyc2UoKWAgcmVzdWx0IG9iamVjdC5cclxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VfcmVzdWx0KGNvdW50cnksIG5hdGlvbmFsTnVtYmVyLCBleHQpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBjb3VudHJ5OiBjb3VudHJ5LFxuICAgIHBob25lOiBuYXRpb25hbE51bWJlclxuICB9O1xuXG4gIGlmIChleHQpIHtcbiAgICByZXN1bHQuZXh0ID0gZXh0O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxyXG4gKiBQYXJzZXMgYSB2aWFibGUgcGhvbmUgbnVtYmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0dGVkUGhvbmVOdW1iZXIg4oCUIEV4YW1wbGU6IFwiKDIxMykgMzczLTQyNTNcIi5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0Q291bnRyeV1cclxuICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0Q2FsbGluZ0NvZGVdXHJcbiAqIEBwYXJhbSB7TWV0YWRhdGF9IG1ldGFkYXRhXHJcbiAqIEByZXR1cm4ge29iamVjdH0gUmV0dXJucyBgeyBjb3VudHJ5OiBzdHJpbmc/LCBjb3VudHJ5Q2FsbGluZ0NvZGU6IHN0cmluZz8sIG5hdGlvbmFsTnVtYmVyOiBzdHJpbmc/IH1gLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVBob25lTnVtYmVyKGZvcm1hdHRlZFBob25lTnVtYmVyLCBkZWZhdWx0Q291bnRyeSwgZGVmYXVsdENhbGxpbmdDb2RlLCBtZXRhZGF0YSkge1xuICAvLyBFeHRyYWN0IGNhbGxpbmcgY29kZSBmcm9tIHBob25lIG51bWJlci5cbiAgdmFyIF9leHRyYWN0Q291bnRyeUNhbGxpbiA9IHBhcnNlX2V4dHJhY3RDb3VudHJ5Q2FsbGluZ0NvZGUocGFyc2VJbmNvbXBsZXRlUGhvbmVOdW1iZXIoZm9ybWF0dGVkUGhvbmVOdW1iZXIpLCBkZWZhdWx0Q291bnRyeSwgZGVmYXVsdENhbGxpbmdDb2RlLCBtZXRhZGF0YS5tZXRhZGF0YSksXG4gICAgICBjb3VudHJ5Q2FsbGluZ0NvZGUgPSBfZXh0cmFjdENvdW50cnlDYWxsaW4uY291bnRyeUNhbGxpbmdDb2RlLFxuICAgICAgbnVtYmVyID0gX2V4dHJhY3RDb3VudHJ5Q2FsbGluLm51bWJlcjsgLy8gQ2hvb3NlIGEgY291bnRyeSBieSBgY291bnRyeUNhbGxpbmdDb2RlYC5cblxuXG4gIHZhciBjb3VudHJ5O1xuXG4gIGlmIChjb3VudHJ5Q2FsbGluZ0NvZGUpIHtcbiAgICBtZXRhZGF0YS5jaG9vc2VDb3VudHJ5QnlDb3VudHJ5Q2FsbGluZ0NvZGUoY291bnRyeUNhbGxpbmdDb2RlKTtcbiAgfSAvLyBJZiBgZm9ybWF0dGVkUGhvbmVOdW1iZXJgIGlzIGluIFwibmF0aW9uYWxcIiBmb3JtYXRcbiAgLy8gdGhlbiBgbnVtYmVyYCBpcyBkZWZpbmVkIGFuZCBgY291bnRyeUNhbGxpbmdDb2RlYCBpc24ndC5cbiAgZWxzZSBpZiAobnVtYmVyICYmIChkZWZhdWx0Q291bnRyeSB8fCBkZWZhdWx0Q2FsbGluZ0NvZGUpKSB7XG4gICAgICBtZXRhZGF0YS5zZWxlY3ROdW1iZXJpbmdQbGFuKGRlZmF1bHRDb3VudHJ5LCBkZWZhdWx0Q2FsbGluZ0NvZGUpO1xuXG4gICAgICBpZiAoZGVmYXVsdENvdW50cnkpIHtcbiAgICAgICAgY291bnRyeSA9IGRlZmF1bHRDb3VudHJ5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwYXJzZV9VU0VfTk9OX0dFT0dSQVBISUNfQ09VTlRSWV9DT0RFKSB7XG4gICAgICAgICAgaWYgKG1ldGFkYXRhLmlzTm9uR2VvZ3JhcGhpY0NhbGxpbmdDb2RlKGRlZmF1bHRDYWxsaW5nQ29kZSkpIHtcbiAgICAgICAgICAgIGNvdW50cnkgPSAnMDAxJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY291bnRyeUNhbGxpbmdDb2RlID0gZGVmYXVsdENhbGxpbmdDb2RlIHx8IGdldENvdW50cnlDYWxsaW5nQ29kZShkZWZhdWx0Q291bnRyeSwgbWV0YWRhdGEubWV0YWRhdGEpO1xuICAgIH0gZWxzZSByZXR1cm4ge307XG5cbiAgaWYgKCFudW1iZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY291bnRyeUNhbGxpbmdDb2RlOiBjb3VudHJ5Q2FsbGluZ0NvZGVcbiAgICB9O1xuICB9XG5cbiAgdmFyIF9zdHJpcE5hdGlvbmFsUHJlZml4QSA9IHN0cmlwTmF0aW9uYWxQcmVmaXhBbmRDYXJyaWVyQ29kZUZyb21Db21wbGV0ZU51bWJlcihwYXJzZUluY29tcGxldGVQaG9uZU51bWJlcihudW1iZXIpLCBtZXRhZGF0YSksXG4gICAgICBuYXRpb25hbE51bWJlciA9IF9zdHJpcE5hdGlvbmFsUHJlZml4QS5uYXRpb25hbE51bWJlcixcbiAgICAgIGNhcnJpZXJDb2RlID0gX3N0cmlwTmF0aW9uYWxQcmVmaXhBLmNhcnJpZXJDb2RlOyAvLyBTb21ldGltZXMgdGhlcmUgYXJlIHNldmVyYWwgY291bnRyaWVzXG4gIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNhbWUgY291bnRyeSBwaG9uZSBjb2RlXG4gIC8vIChlLmcuIE5BTlBBIGNvdW50cmllcyBhbGwgaGF2aW5nIGAxYCBjb3VudHJ5IHBob25lIGNvZGUpLlxuICAvLyBUaGVyZWZvcmUsIHRvIHJlbGlhYmx5IGRldGVybWluZSB0aGUgZXhhY3QgY291bnRyeSxcbiAgLy8gbmF0aW9uYWwgKHNpZ25pZmljYW50KSBudW1iZXIgc2hvdWxkIGhhdmUgYmVlbiBwYXJzZWQgZmlyc3QuXG4gIC8vXG4gIC8vIFdoZW4gYG1ldGFkYXRhLmpzb25gIGlzIGdlbmVyYXRlZCwgYWxsIFwiYW1iaWd1b3VzXCIgY291bnRyeSBwaG9uZSBjb2Rlc1xuICAvLyBnZXQgdGhlaXIgY291bnRyaWVzIHBvcHVsYXRlZCB3aXRoIHRoZSBmdWxsIHNldCBvZlxuICAvLyBcInBob25lIG51bWJlciB0eXBlXCIgcmVndWxhciBleHByZXNzaW9ucy5cbiAgLy9cblxuXG4gIHZhciBleGFjdENvdW50cnkgPSBmaW5kQ291bnRyeUNvZGUoY291bnRyeUNhbGxpbmdDb2RlLCBuYXRpb25hbE51bWJlciwgbWV0YWRhdGEpO1xuXG4gIGlmIChleGFjdENvdW50cnkpIHtcbiAgICBjb3VudHJ5ID0gZXhhY3RDb3VudHJ5O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXG4gICAgaWYgKGV4YWN0Q291bnRyeSA9PT0gJzAwMScpIHsvLyBDYW4ndCBoYXBwZW4gd2l0aCBgVVNFX05PTl9HRU9HUkFQSElDX0NPVU5UUllfQ09ERWAgYmVpbmcgYGZhbHNlYC5cbiAgICAgIC8vIElmIGBVU0VfTk9OX0dFT0dSQVBISUNfQ09VTlRSWV9DT0RFYCBpcyBzZXQgdG8gYHRydWVgIGZvciBzb21lIHJlYXNvbixcbiAgICAgIC8vIHRoZW4gcmVtb3ZlIHRoZSBcImlzdGFuYnVsIGlnbm9yZSBpZlwiLlxuICAgIH0gZWxzZSB7XG4gICAgICBtZXRhZGF0YS5jb3VudHJ5KGNvdW50cnkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY291bnRyeTogY291bnRyeSxcbiAgICBjb3VudHJ5Q2FsbGluZ0NvZGU6IGNvdW50cnlDYWxsaW5nQ29kZSxcbiAgICBuYXRpb25hbE51bWJlcjogbmF0aW9uYWxOdW1iZXIsXG4gICAgY2FycmllckNvZGU6IGNhcnJpZXJDb2RlXG4gIH07XG59XG4vKipcclxuICogU3RyaXBzIG5hdGlvbmFsIHByZWZpeCBhbmQgY2FycmllciBjb2RlIGZyb20gYSBjb21wbGV0ZSBwaG9uZSBudW1iZXIuXHJcbiAqIFRoZSBkaWZmZXJlbmNlIGZyb20gdGhlIG5vbi1cIkZyb21Db21wbGV0ZU51bWJlclwiIGZ1bmN0aW9uIGlzIHRoYXRcclxuICogaXQgd29uJ3QgZXh0cmFjdCBuYXRpb25hbCBwcmVmaXggaWYgdGhlIHJlc3VsdGFudCBudW1iZXIgaXMgdG9vIHNob3J0XHJcbiAqIHRvIGJlIGEgY29tcGxldGUgbnVtYmVyIGZvciB0aGUgc2VsZWN0ZWQgcGhvbmUgbnVtYmVyaW5nIHBsYW4uXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gbnVtYmVyIOKAlCBDb21wbGV0ZSBwaG9uZSBudW1iZXIgZGlnaXRzLlxyXG4gKiBAcGFyYW0gIHtNZXRhZGF0YX0gbWV0YWRhdGEg4oCUIE1ldGFkYXRhIHdpdGggYSBwaG9uZSBudW1iZXJpbmcgcGxhbiBzZWxlY3RlZC5cclxuICogQHJldHVybiB7b2JqZWN0fSBgeyBuYXRpb25hbE51bWJlcjogc3RyaW5nLCBjYXJyaWVyQ29kZTogc3RyaW5nPyB9YC5cclxuICovXG5cblxuZnVuY3Rpb24gc3RyaXBOYXRpb25hbFByZWZpeEFuZENhcnJpZXJDb2RlRnJvbUNvbXBsZXRlTnVtYmVyKG51bWJlciwgbWV0YWRhdGEpIHtcbiAgLy8gUGFyc2luZyBuYXRpb25hbCBwcmVmaXhlcyBhbmQgY2FycmllciBjb2Rlc1xuICAvLyBpcyBvbmx5IHJlcXVpcmVkIGZvciBsb2NhbCBwaG9uZSBudW1iZXJzXG4gIC8vIGJ1dCBzb21lIHBlb3BsZSBkb24ndCB1bmRlcnN0YW5kIHRoYXRcbiAgLy8gYW5kIHNvbWV0aW1lcyB3cml0ZSBpbnRlcm5hdGlvbmFsIHBob25lIG51bWJlcnNcbiAgLy8gd2l0aCBuYXRpb25hbCBwcmVmaXhlcyAob3IgbWF5YmUgZXZlbiBjYXJyaWVyIGNvZGVzKS5cbiAgLy8gaHR0cDovL3Vja2VuLmJsb2dzcG90LnJ1LzIwMTYvMDMvdHJ1bmstcHJlZml4ZXMtaW4tc2t5cGU0Yi5odG1sXG4gIC8vIEdvb2dsZSdzIG9yaWdpbmFsIGxpYnJhcnkgZm9yZ2l2ZXMgc3VjaCBtaXN0YWtlc1xuICAvLyBhbmQgc28gZG9lcyB0aGlzIGxpYnJhcnksIGJlY2F1c2UgaXQgaGFzIGJlZW4gcmVxdWVzdGVkOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2F0YW1waGV0YW1pbmUvbGlicGhvbmVudW1iZXItanMvaXNzdWVzLzEyN1xuICB2YXIgX3N0cmlwTmF0aW9uYWxQcmVmaXhBMiA9IHN0cmlwTmF0aW9uYWxQcmVmaXhBbmRDYXJyaWVyQ29kZShwYXJzZUluY29tcGxldGVQaG9uZU51bWJlcihudW1iZXIpLCBtZXRhZGF0YSksXG4gICAgICBuYXRpb25hbE51bWJlciA9IF9zdHJpcE5hdGlvbmFsUHJlZml4QTIubmF0aW9uYWxOdW1iZXIsXG4gICAgICBjYXJyaWVyQ29kZSA9IF9zdHJpcE5hdGlvbmFsUHJlZml4QTIuY2FycmllckNvZGU7IC8vIElmIGEgbmF0aW9uYWwgcHJlZml4IGhhcyBiZWVuIGV4dHJhY3RlZCwgY2hlY2sgdG8gc2VlXG4gIC8vIGlmIHRoZSByZXN1bHRhbnQgbnVtYmVyIGlzbid0IHRvbyBzaG9ydC5cblxuXG4gIGlmIChuYXRpb25hbE51bWJlci5sZW5ndGggIT09IG51bWJlci5sZW5ndGggKyAoY2FycmllckNvZGUgPyBjYXJyaWVyQ29kZS5sZW5ndGggOiAwKSkge1xuICAgIC8vIElmIG5vdCB1c2luZyBsZWdhY3kgZ2VuZXJhdGVkIG1ldGFkYXRhIChiZWZvcmUgdmVyc2lvbiBgMS4wLjE4YClcbiAgICAvLyB0aGVuIGl0IGhhcyBcInBvc3NpYmxlIGxlbmd0aHNcIiwgc28gdXNlIHRob3NlIHRvIHZhbGlkYXRlIHRoZSBudW1iZXIgbGVuZ3RoLlxuICAgIGlmIChtZXRhZGF0YS5wb3NzaWJsZUxlbmd0aHMoKSkge1xuICAgICAgLy8gXCJXZSByZXF1aXJlIHRoYXQgdGhlIE5TTiByZW1haW5pbmcgYWZ0ZXIgc3RyaXBwaW5nIHRoZSBuYXRpb25hbCBwcmVmaXggYW5kXG4gICAgICAvLyBjYXJyaWVyIGNvZGUgYmUgbG9uZyBlbm91Z2ggdG8gYmUgYSBwb3NzaWJsZSBsZW5ndGggZm9yIHRoZSByZWdpb24uXG4gICAgICAvLyBPdGhlcndpc2UsIHdlIGRvbid0IGRvIHRoZSBzdHJpcHBpbmcsIHNpbmNlIHRoZSBvcmlnaW5hbCBudW1iZXIgY291bGQgYmVcbiAgICAgIC8vIGEgdmFsaWQgc2hvcnQgbnVtYmVyLlwiXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2xpYnBob25lbnVtYmVyL2Jsb2IvODc2MjY4ZWIxYWQ2Y2RjMWI3YjViZWYxN2ZjNWU0MzA1MjcwMmQ1Ny9qYXZhL2xpYnBob25lbnVtYmVyL3NyYy9jb20vZ29vZ2xlL2kxOG4vcGhvbmVudW1iZXJzL1Bob25lTnVtYmVyVXRpbC5qYXZhI0wzMjM2LUwzMjUwXG4gICAgICBzd2l0Y2ggKGNoZWNrTnVtYmVyTGVuZ3RoRm9yVHlwZShuYXRpb25hbE51bWJlciwgdW5kZWZpbmVkLCBtZXRhZGF0YSkpIHtcbiAgICAgICAgY2FzZSAnVE9PX1NIT1JUJzpcbiAgICAgICAgY2FzZSAnSU5WQUxJRF9MRU5HVEgnOlxuICAgICAgICAgIC8vIGNhc2UgJ0lTX1BPU1NJQkxFX0xPQ0FMX09OTFknOlxuICAgICAgICAgIC8vIERvbid0IHN0cmlwIHRoZSBuYXRpb25hbCBwcmVmaXguXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hdGlvbmFsTnVtYmVyOiBudW1iZXJcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmF0aW9uYWxOdW1iZXI6IG5hdGlvbmFsTnVtYmVyLFxuICAgIGNhcnJpZXJDb2RlOiBjYXJyaWVyQ29kZVxuICB9O1xufVxuLyoqXHJcbiAqIENvbnZlcnRzIGEgcGhvbmUgbnVtYmVyIGRpZ2l0cyAocG9zc2libHkgd2l0aCBhIGArYClcclxuICogaW50byBhIGNhbGxpbmcgY29kZSBhbmQgdGhlIHJlc3QgcGhvbmUgbnVtYmVyIGRpZ2l0cy5cclxuICogVGhlIFwicmVzdCBwaG9uZSBudW1iZXIgZGlnaXRzXCIgY291bGQgaW5jbHVkZVxyXG4gKiBhIG5hdGlvbmFsIHByZWZpeCwgY2FycmllciBjb2RlLCBhbmQgbmF0aW9uYWxcclxuICogKHNpZ25pZmljYW50KSBudW1iZXIuXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gbnVtYmVyIOKAlCBQaG9uZSBudW1iZXIgZGlnaXRzIChwb3NzaWJseSB3aXRoIGEgYCtgKS5cclxuICogQHBhcmFtICB7c3RyaW5nfSBbY291bnRyeV0g4oCUwqBEZWZhdWx0IGNvdW50cnkuXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gW2NhbGxpbmdDb2RlXSDigJQgRGVmYXVsdCBjYWxsaW5nIGNvZGUgKHNvbWUgcGhvbmUgbnVtYmVyaW5nIHBsYW5zIGFyZSBub24tZ2VvZ3JhcGhpYykuXHJcbiAqIEBwYXJhbSAge29iamVjdH0gbWV0YWRhdGFcclxuICogQHJldHVybiB7b2JqZWN0fSBgeyBjb3VudHJ5Q2FsbGluZ0NvZGU6IHN0cmluZz8sIG51bWJlcjogc3RyaW5nIH1gXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIFJldHVybnMgYHsgY291bnRyeUNhbGxpbmdDb2RlOiBcIjFcIiwgbnVtYmVyOiBcIjIxMzM3MzQyNTNcIiB9YC5cclxuICogZXh0cmFjdENvdW50cnlDYWxsaW5nQ29kZSgnMjEzMzczNDI1MycsICdVUycsIG51bGwsIG1ldGFkYXRhKVxyXG4gKiBleHRyYWN0Q291bnRyeUNhbGxpbmdDb2RlKCcyMTMzNzM0MjUzJywgbnVsbCwgJzEnLCBtZXRhZGF0YSlcclxuICogZXh0cmFjdENvdW50cnlDYWxsaW5nQ29kZSgnKzEyMTMzNzM0MjUzJywgbnVsbCwgbnVsbCwgbWV0YWRhdGEpXHJcbiAqIGV4dHJhY3RDb3VudHJ5Q2FsbGluZ0NvZGUoJysxMjEzMzczNDI1MycsICdSVScsIG51bGwsIG1ldGFkYXRhKVxyXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VfZXh0cmFjdENvdW50cnlDYWxsaW5nQ29kZShudW1iZXIsIGNvdW50cnksIGNhbGxpbmdDb2RlLCBtZXRhZGF0YSkge1xuICBpZiAoIW51bWJlcikge1xuICAgIHJldHVybiB7fTtcbiAgfSAvLyBJZiB0aGlzIGlzIG5vdCBhbiBpbnRlcm5hdGlvbmFsIHBob25lIG51bWJlcixcbiAgLy8gdGhlbiBlaXRoZXIgZXh0cmFjdCBhbiBcIklERFwiIHByZWZpeCwgb3IgZXh0cmFjdCBhXG4gIC8vIGNvdW50cnkgY2FsbGluZyBjb2RlIGZyb20gYSBudW1iZXIgYnkgYXV0b2NvcnJlY3RpbmcgaXRcbiAgLy8gYnkgcHJlcGVuZGluZyBhIGxlYWRpbmcgYCtgIGluIGNhc2VzIHdoZW4gaXQgc3RhcnRzXG4gIC8vIHdpdGggdGhlIGNvdW50cnkgY2FsbGluZyBjb2RlLlxuICAvLyBodHRwczovL3dpa2l0cmF2ZWwub3JnL2VuL0ludGVybmF0aW9uYWxfZGlhbGxpbmdfcHJlZml4XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRhbXBoZXRhbWluZS9saWJwaG9uZW51bWJlci1qcy9pc3N1ZXMvMzc2XG5cblxuICBpZiAobnVtYmVyWzBdICE9PSAnKycpIHtcbiAgICAvLyBDb252ZXJ0IGFuIFwib3V0LW9mLWNvdW50cnlcIiBkaWFsaW5nIHBob25lIG51bWJlclxuICAgIC8vIHRvIGEgcHJvcGVyIGludGVybmF0aW9uYWwgcGhvbmUgbnVtYmVyLlxuICAgIHZhciBudW1iZXJXaXRob3V0SUREID0gc3RyaXBJRERQcmVmaXgobnVtYmVyLCBjb3VudHJ5LCBjYWxsaW5nQ29kZSwgbWV0YWRhdGEpOyAvLyBJZiBhbiBJREQgcHJlZml4IHdhcyBzdHJpcHBlZCB0aGVuXG4gICAgLy8gY29udmVydCB0aGUgbnVtYmVyIHRvIGludGVybmF0aW9uYWwgb25lXG4gICAgLy8gZm9yIHN1YnNlcXVlbnQgcGFyc2luZy5cblxuICAgIGlmIChudW1iZXJXaXRob3V0SUREICYmIG51bWJlcldpdGhvdXRJREQgIT09IG51bWJlcikge1xuICAgICAgbnVtYmVyID0gJysnICsgbnVtYmVyV2l0aG91dElERDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBudW1iZXIgc3RhcnRzIHdpdGggdGhlIGNvdW50cnkgY2FsbGluZyBjb2RlXG4gICAgICAvLyBmb3IgdGhlIGRlZmF1bHQgY291bnRyeS4gSWYgc28sIHdlIHJlbW92ZSB0aGUgY291bnRyeSBjYWxsaW5nIGNvZGUsXG4gICAgICAvLyBhbmQgZG8gc29tZSBjaGVja3Mgb24gdGhlIHZhbGlkaXR5IG9mIHRoZSBudW1iZXIgYmVmb3JlIGFuZCBhZnRlci5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRhbXBoZXRhbWluZS9saWJwaG9uZW51bWJlci1qcy9pc3N1ZXMvMzc2XG4gICAgICBpZiAoY291bnRyeSB8fCBjYWxsaW5nQ29kZSkge1xuICAgICAgICB2YXIgX2V4dHJhY3RDb3VudHJ5Q2FsbGluMiA9IGV4dHJhY3RDb3VudHJ5Q2FsbGluZ0NvZGVGcm9tSW50ZXJuYXRpb25hbE51bWJlcldpdGhvdXRQbHVzU2lnbihudW1iZXIsIGNvdW50cnksIGNhbGxpbmdDb2RlLCBtZXRhZGF0YSksXG4gICAgICAgICAgICBjb3VudHJ5Q2FsbGluZ0NvZGUgPSBfZXh0cmFjdENvdW50cnlDYWxsaW4yLmNvdW50cnlDYWxsaW5nQ29kZSxcbiAgICAgICAgICAgIHNob3J0ZXJOdW1iZXIgPSBfZXh0cmFjdENvdW50cnlDYWxsaW4yLm51bWJlcjtcblxuICAgICAgICBpZiAoY291bnRyeUNhbGxpbmdDb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvdW50cnlDYWxsaW5nQ29kZTogY291bnRyeUNhbGxpbmdDb2RlLFxuICAgICAgICAgICAgbnVtYmVyOiBzaG9ydGVyTnVtYmVyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gRmFzdCBhYm9ydGlvbjogY291bnRyeSBjb2RlcyBkbyBub3QgYmVnaW4gd2l0aCBhICcwJ1xuXG5cbiAgaWYgKG51bWJlclsxXSA9PT0gJzAnKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgbWV0YWRhdGEgPSBuZXcgTWV0YWRhdGEobWV0YWRhdGEpOyAvLyBUaGUgdGhpbmcgd2l0aCBjb3VudHJ5IHBob25lIGNvZGVzXG4gIC8vIGlzIHRoYXQgdGhleSBhcmUgb3J0aG9nb25hbCB0byBlYWNoIG90aGVyXG4gIC8vIGkuZS4gdGhlcmUncyBubyBzdWNoIGNvdW50cnkgcGhvbmUgY29kZSBBXG4gIC8vIGZvciB3aGljaCBjb3VudHJ5IHBob25lIGNvZGUgQiBleGlzdHNcbiAgLy8gd2hlcmUgQiBzdGFydHMgd2l0aCBBLlxuICAvLyBUaGVyZWZvcmUsIHdoaWxlIHNjYW5uaW5nIGRpZ2l0cyxcbiAgLy8gaWYgYSB2YWxpZCBjb3VudHJ5IGNvZGUgaXMgZm91bmQsXG4gIC8vIHRoYXQgbWVhbnMgdGhhdCBpdCBpcyB0aGUgY291bnRyeSBjb2RlLlxuICAvL1xuXG4gIHZhciBpID0gMjtcblxuICB3aGlsZSAoaSAtIDEgPD0gTUFYX0xFTkdUSF9DT1VOVFJZX0NPREUgJiYgaSA8PSBudW1iZXIubGVuZ3RoKSB7XG4gICAgdmFyIF9jb3VudHJ5Q2FsbGluZ0NvZGUgPSBudW1iZXIuc2xpY2UoMSwgaSk7XG5cbiAgICBpZiAobWV0YWRhdGEuaGFzQ2FsbGluZ0NvZGUoX2NvdW50cnlDYWxsaW5nQ29kZSkpIHtcbiAgICAgIG1ldGFkYXRhLnNlbGVjdE51bWJlcmluZ1BsYW4odW5kZWZpbmVkLCBfY291bnRyeUNhbGxpbmdDb2RlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvdW50cnlDYWxsaW5nQ29kZTogX2NvdW50cnlDYWxsaW5nQ29kZSxcbiAgICAgICAgbnVtYmVyOiBudW1iZXIuc2xpY2UoaSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHt9O1xufVxuLyoqXHJcbiAqIFNvbWV0aW1lcyBzb21lIHBlb3BsZSBpbmNvcnJlY3RseSBpbnB1dCBpbnRlcm5hdGlvbmFsIHBob25lIG51bWJlcnNcclxuICogd2l0aG91dCB0aGUgbGVhZGluZyBgK2AuIFRoaXMgZnVuY3Rpb24gY29ycmVjdHMgc3VjaCBpbnB1dC5cclxuICogQHBhcmFtICB7c3RyaW5nfSBudW1iZXIg4oCUIFBob25lIG51bWJlciBkaWdpdHMuXHJcbiAqIEBwYXJhbSAge3N0cmluZz99IGNvdW50cnlcclxuICogQHBhcmFtICB7c3RyaW5nP30gY2FsbGluZ0NvZGVcclxuICogQHBhcmFtICB7b2JqZWN0fSBtZXRhZGF0YVxyXG4gKiBAcmV0dXJuIHtvYmplY3R9IGB7IGNvdW50cnlDYWxsaW5nQ29kZTogc3RyaW5nPywgbnVtYmVyOiBzdHJpbmcgfWAuXHJcbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0Q291bnRyeUNhbGxpbmdDb2RlRnJvbUludGVybmF0aW9uYWxOdW1iZXJXaXRob3V0UGx1c1NpZ24obnVtYmVyLCBjb3VudHJ5LCBjYWxsaW5nQ29kZSwgbWV0YWRhdGEpIHtcbiAgdmFyIGNvdW50cnlDYWxsaW5nQ29kZSA9IGNvdW50cnkgPyBnZXRDb3VudHJ5Q2FsbGluZ0NvZGUoY291bnRyeSwgbWV0YWRhdGEpIDogY2FsbGluZ0NvZGU7XG5cbiAgaWYgKG51bWJlci5pbmRleE9mKGNvdW50cnlDYWxsaW5nQ29kZSkgPT09IDApIHtcbiAgICBtZXRhZGF0YSA9IG5ldyBNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgbWV0YWRhdGEuc2VsZWN0TnVtYmVyaW5nUGxhbihjb3VudHJ5LCBjYWxsaW5nQ29kZSk7XG4gICAgdmFyIHBvc3NpYmxlU2hvcnRlck51bWJlciA9IG51bWJlci5zbGljZShjb3VudHJ5Q2FsbGluZ0NvZGUubGVuZ3RoKTtcblxuICAgIHZhciBfc3RyaXBOYXRpb25hbFByZWZpeEEzID0gc3RyaXBOYXRpb25hbFByZWZpeEFuZENhcnJpZXJDb2RlKHBvc3NpYmxlU2hvcnRlck51bWJlciwgbWV0YWRhdGEpLFxuICAgICAgICBwb3NzaWJsZVNob3J0ZXJOYXRpb25hbE51bWJlciA9IF9zdHJpcE5hdGlvbmFsUHJlZml4QTMubmF0aW9uYWxOdW1iZXI7XG5cbiAgICB2YXIgX3N0cmlwTmF0aW9uYWxQcmVmaXhBNCA9IHN0cmlwTmF0aW9uYWxQcmVmaXhBbmRDYXJyaWVyQ29kZShudW1iZXIsIG1ldGFkYXRhKSxcbiAgICAgICAgbmF0aW9uYWxOdW1iZXIgPSBfc3RyaXBOYXRpb25hbFByZWZpeEE0Lm5hdGlvbmFsTnVtYmVyOyAvLyBJZiB0aGUgbnVtYmVyIHdhcyBub3QgdmFsaWQgYmVmb3JlIGJ1dCBpcyB2YWxpZCBub3csXG4gICAgLy8gb3IgaWYgaXQgd2FzIHRvbyBsb25nIGJlZm9yZSwgd2UgY29uc2lkZXIgdGhlIG51bWJlclxuICAgIC8vIHdpdGggdGhlIGNvdW50cnkgY2FsbGluZyBjb2RlIHN0cmlwcGVkIHRvIGJlIGEgYmV0dGVyIHJlc3VsdFxuICAgIC8vIGFuZCBrZWVwIHRoYXQgaW5zdGVhZC5cbiAgICAvLyBGb3IgZXhhbXBsZSwgaW4gR2VybWFueSAoKzQ5KSwgYDQ5YCBpcyBhIHZhbGlkIGFyZWEgY29kZSxcbiAgICAvLyBzbyBpZiBhIG51bWJlciBzdGFydHMgd2l0aCBgNDlgLCBpdCBjb3VsZCBiZSBib3RoIGEgdmFsaWRcbiAgICAvLyBuYXRpb25hbCBHZXJtYW4gbnVtYmVyIG9yIGFuIGludGVybmF0aW9uYWwgbnVtYmVyIHdpdGhvdXRcbiAgICAvLyBhIGxlYWRpbmcgYCtgLlxuXG5cbiAgICBpZiAoIW1hdGNoZXNFbnRpcmVseShuYXRpb25hbE51bWJlciwgbWV0YWRhdGEubmF0aW9uYWxOdW1iZXJQYXR0ZXJuKCkpICYmIG1hdGNoZXNFbnRpcmVseShwb3NzaWJsZVNob3J0ZXJOYXRpb25hbE51bWJlciwgbWV0YWRhdGEubmF0aW9uYWxOdW1iZXJQYXR0ZXJuKCkpIHx8IGNoZWNrTnVtYmVyTGVuZ3RoRm9yVHlwZShuYXRpb25hbE51bWJlciwgdW5kZWZpbmVkLCBtZXRhZGF0YSkgPT09ICdUT09fTE9ORycpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvdW50cnlDYWxsaW5nQ29kZTogY291bnRyeUNhbGxpbmdDb2RlLFxuICAgICAgICBudW1iZXI6IHBvc3NpYmxlU2hvcnRlck51bWJlclxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG51bWJlcjogbnVtYmVyXG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZV8uanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9lczYvcGFyc2VQaG9uZU51bWJlcl8uanNcbmZ1bmN0aW9uIHBhcnNlUGhvbmVOdW1iZXJfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHBhcnNlUGhvbmVOdW1iZXJfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBwYXJzZVBob25lTnVtYmVyX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuXG5mdW5jdGlvbiBwYXJzZVBob25lTnVtYmVyX3BhcnNlUGhvbmVOdW1iZXIodGV4dCwgb3B0aW9ucywgbWV0YWRhdGEpIHtcbiAgcmV0dXJuIHBhcnNlKHRleHQsIHBhcnNlUGhvbmVOdW1iZXJfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgdjI6IHRydWVcbiAgfSksIG1ldGFkYXRhKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlUGhvbmVOdW1iZXJfLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvZXM2L3BhcnNlUGhvbmVOdW1iZXIuanNcbmZ1bmN0aW9uIHBhcnNlUGhvbmVOdW1iZXJfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgcGFyc2VQaG9uZU51bWJlcl90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgcGFyc2VQaG9uZU51bWJlcl90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gcGFyc2VQaG9uZU51bWJlcl90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBlczZfcGFyc2VQaG9uZU51bWJlcl9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykgeyBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlOyB9KSk7IH0gb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZXM2X3BhcnNlUGhvbmVOdW1iZXJfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBlczZfcGFyc2VQaG9uZU51bWJlcl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIHBhcnNlUGhvbmVOdW1iZXJfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIHBhcnNlUGhvbmVOdW1iZXJfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBwYXJzZVBob25lTnVtYmVyX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgcGFyc2VQaG9uZU51bWJlcl9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBwYXJzZVBob25lTnVtYmVyX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gcGFyc2VQaG9uZU51bWJlcl9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIHBhcnNlUGhvbmVOdW1iZXJfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuXG5mdW5jdGlvbiBlczZfcGFyc2VQaG9uZU51bWJlcl9wYXJzZVBob25lTnVtYmVyKCkge1xuICB2YXIgX25vcm1hbGl6ZUFyZ3VtZW50cyA9IG5vcm1hbGl6ZUFyZ3VtZW50cyhhcmd1bWVudHMpLFxuICAgICAgdGV4dCA9IF9ub3JtYWxpemVBcmd1bWVudHMudGV4dCxcbiAgICAgIG9wdGlvbnMgPSBfbm9ybWFsaXplQXJndW1lbnRzLm9wdGlvbnMsXG4gICAgICBtZXRhZGF0YSA9IF9ub3JtYWxpemVBcmd1bWVudHMubWV0YWRhdGE7XG5cbiAgcmV0dXJuIHBhcnNlUGhvbmVOdW1iZXJfcGFyc2VQaG9uZU51bWJlcih0ZXh0LCBvcHRpb25zLCBtZXRhZGF0YSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVBcmd1bWVudHMoYXJncykge1xuICB2YXIgX0FycmF5JHByb3RvdHlwZSRzbGljID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyksXG4gICAgICBfQXJyYXkkcHJvdG90eXBlJHNsaWMyID0gcGFyc2VQaG9uZU51bWJlcl9zbGljZWRUb0FycmF5KF9BcnJheSRwcm90b3R5cGUkc2xpYywgNCksXG4gICAgICBhcmdfMSA9IF9BcnJheSRwcm90b3R5cGUkc2xpYzJbMF0sXG4gICAgICBhcmdfMiA9IF9BcnJheSRwcm90b3R5cGUkc2xpYzJbMV0sXG4gICAgICBhcmdfMyA9IF9BcnJheSRwcm90b3R5cGUkc2xpYzJbMl0sXG4gICAgICBhcmdfNCA9IF9BcnJheSRwcm90b3R5cGUkc2xpYzJbM107XG5cbiAgdmFyIHRleHQ7XG4gIHZhciBvcHRpb25zO1xuICB2YXIgbWV0YWRhdGE7IC8vIElmIHRoZSBwaG9uZSBudW1iZXIgaXMgcGFzc2VkIGFzIGEgc3RyaW5nLlxuICAvLyBgcGFyc2VQaG9uZU51bWJlcignODgwMDU1NTM1MzUnLCAuLi4pYC5cblxuICBpZiAodHlwZW9mIGFyZ18xID09PSAnc3RyaW5nJykge1xuICAgIHRleHQgPSBhcmdfMTtcbiAgfSBlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgdGV4dCBmb3IgcGFyc2luZyBtdXN0IGJlIGEgc3RyaW5nLicpOyAvLyBJZiBcImRlZmF1bHQgY291bnRyeVwiIGFyZ3VtZW50IGlzIGJlaW5nIHBhc3NlZCB0aGVuIG1vdmUgaXQgdG8gYG9wdGlvbnNgLlxuICAvLyBgcGFyc2VQaG9uZU51bWJlcignODgwMDU1NTM1MzUnLCAnUlUnLCBbb3B0aW9uc10sIG1ldGFkYXRhKWAuXG5cblxuICBpZiAoIWFyZ18yIHx8IHR5cGVvZiBhcmdfMiA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJnXzQpIHtcbiAgICAgIG9wdGlvbnMgPSBhcmdfMztcbiAgICAgIG1ldGFkYXRhID0gYXJnXzQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICBtZXRhZGF0YSA9IGFyZ18zO1xuICAgIH1cblxuICAgIGlmIChhcmdfMikge1xuICAgICAgb3B0aW9ucyA9IGVzNl9wYXJzZVBob25lTnVtYmVyX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGRlZmF1bHRDb3VudHJ5OiBhcmdfMlxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICB9IC8vIGBkZWZhdWx0Q291bnRyeWAgaXMgbm90IHBhc3NlZC5cbiAgLy8gRXhhbXBsZTogYHBhcnNlUGhvbmVOdW1iZXIoJys3ODAwNTU1MzUzNScsIFtvcHRpb25zXSwgbWV0YWRhdGEpYC5cbiAgZWxzZSBpZiAoaXNPYmplY3QoYXJnXzIpKSB7XG4gICAgICBpZiAoYXJnXzMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZ18yO1xuICAgICAgICBtZXRhZGF0YSA9IGFyZ18zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWV0YWRhdGEgPSBhcmdfMjtcbiAgICAgIH1cbiAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWNvbmQgYXJndW1lbnQ6IFwiLmNvbmNhdChhcmdfMikpO1xuXG4gIHJldHVybiB7XG4gICAgdGV4dDogdGV4dCxcbiAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgIG1ldGFkYXRhOiBtZXRhZGF0YVxuICB9O1xufSAvLyBPdGhlcndpc2UgaXN0YW5idWwgd291bGQgc2hvdyB0aGlzIGFzIFwiYnJhbmNoIG5vdCBjb3ZlcmVkXCIuXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbnZhciBpc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KF8pIHtcbiAgcmV0dXJuIHBhcnNlUGhvbmVOdW1iZXJfdHlwZW9mKF8pID09PSAnb2JqZWN0Jztcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZVBob25lTnVtYmVyLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvZXM2L3BhcnNlUGhvbmVOdW1iZXJGcm9tU3RyaW5nXy5qc1xuZnVuY3Rpb24gcGFyc2VQaG9uZU51bWJlckZyb21TdHJpbmdfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHBhcnNlUGhvbmVOdW1iZXJGcm9tU3RyaW5nX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gcGFyc2VQaG9uZU51bWJlckZyb21TdHJpbmdfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5cblxuXG5mdW5jdGlvbiBwYXJzZVBob25lTnVtYmVyRnJvbVN0cmluZyh0ZXh0LCBvcHRpb25zLCBtZXRhZGF0YSkge1xuICAvLyBWYWxpZGF0ZSBgZGVmYXVsdENvdW50cnlgLlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlZmF1bHRDb3VudHJ5ICYmICFpc1N1cHBvcnRlZENvdW50cnkob3B0aW9ucy5kZWZhdWx0Q291bnRyeSwgbWV0YWRhdGEpKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlUGhvbmVOdW1iZXJGcm9tU3RyaW5nX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgZGVmYXVsdENvdW50cnk6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9IC8vIFBhcnNlIHBob25lIG51bWJlci5cblxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHBhcnNlUGhvbmVOdW1iZXJfcGFyc2VQaG9uZU51bWJlcih0ZXh0LCBvcHRpb25zLCBtZXRhZGF0YSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQYXJzZUVycm9yKSB7Ly9cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZVBob25lTnVtYmVyRnJvbVN0cmluZ18uanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9lczYvcGFyc2VQaG9uZU51bWJlckZyb21TdHJpbmcuanNcblxuXG5mdW5jdGlvbiBwYXJzZVBob25lTnVtYmVyRnJvbVN0cmluZ19wYXJzZVBob25lTnVtYmVyRnJvbVN0cmluZygpIHtcbiAgdmFyIF9ub3JtYWxpemVBcmd1bWVudHMgPSBub3JtYWxpemVBcmd1bWVudHMoYXJndW1lbnRzKSxcbiAgICAgIHRleHQgPSBfbm9ybWFsaXplQXJndW1lbnRzLnRleHQsXG4gICAgICBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgbWV0YWRhdGEgPSBfbm9ybWFsaXplQXJndW1lbnRzLm1ldGFkYXRhO1xuXG4gIHJldHVybiBwYXJzZVBob25lTnVtYmVyRnJvbVN0cmluZyh0ZXh0LCBvcHRpb25zLCBtZXRhZGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZVBob25lTnVtYmVyRnJvbVN0cmluZy5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9wYXJzZS5qc1xuXG4gLy8gYG9wdGlvbnNgOlxuLy8gIHtcbi8vICAgIGNvdW50cnk6XG4vLyAgICB7XG4vLyAgICAgIHJlc3RyaWN0IC0gKGEgdHdvLWxldHRlciBjb3VudHJ5IGNvZGUpXG4vLyAgICAgICAgICAgICAgICAgdGhlIHBob25lIG51bWJlciBtdXN0IGJlIGluIHRoaXMgY291bnRyeVxuLy9cbi8vICAgICAgZGVmYXVsdCAtIChhIHR3by1sZXR0ZXIgY291bnRyeSBjb2RlKVxuLy8gICAgICAgICAgICAgICAgZGVmYXVsdCBjb3VudHJ5IHRvIHVzZSBmb3IgcGhvbmUgbnVtYmVyIHBhcnNpbmcgYW5kIHZhbGlkYXRpb25cbi8vICAgICAgICAgICAgICAgIChpZiBubyBjb3VudHJ5IGNvZGUgY291bGQgYmUgZGVyaXZlZCBmcm9tIHRoZSBwaG9uZSBudW1iZXIpXG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vIFJldHVybnMgYHsgY291bnRyeSwgbnVtYmVyIH1gXG4vL1xuLy8gRXhhbXBsZSB1c2UgY2FzZXM6XG4vL1xuLy8gYGBganNcbi8vIHBhcnNlKCc4ICg4MDApIDU1NS0zNS0zNScsICdSVScpXG4vLyBwYXJzZSgnOCAoODAwKSA1NTUtMzUtMzUnLCAnUlUnLCBtZXRhZGF0YSlcbi8vIHBhcnNlKCc4ICg4MDApIDU1NS0zNS0zNScsIHsgY291bnRyeTogeyBkZWZhdWx0OiAnUlUnIH0gfSlcbi8vIHBhcnNlKCc4ICg4MDApIDU1NS0zNS0zNScsIHsgY291bnRyeTogeyBkZWZhdWx0OiAnUlUnIH0gfSwgbWV0YWRhdGEpXG4vLyBwYXJzZSgnKzcgODAwIDU1NSAzNSAzNScpXG4vLyBwYXJzZSgnKzcgODAwIDU1NSAzNSAzNScsIG1ldGFkYXRhKVxuLy8gYGBgXG4vL1xuXG5mdW5jdGlvbiBwYXJzZU51bWJlcigpIHtcbiAgdmFyIF9ub3JtYWxpemVBcmd1bWVudHMgPSBub3JtYWxpemVBcmd1bWVudHMoYXJndW1lbnRzKSxcbiAgICAgIHRleHQgPSBfbm9ybWFsaXplQXJndW1lbnRzLnRleHQsXG4gICAgICBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgbWV0YWRhdGEgPSBfbm9ybWFsaXplQXJndW1lbnRzLm1ldGFkYXRhO1xuXG4gIHJldHVybiBwYXJzZSh0ZXh0LCBvcHRpb25zLCBtZXRhZGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9mb3JtYXQuanNcbmZ1bmN0aW9uIGZvcm1hdF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBmb3JtYXRfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IGZvcm1hdF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gZm9ybWF0X3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIGZvcm1hdF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gZm9ybWF0X2FycmF5V2l0aEhvbGVzKGFycikgfHwgZm9ybWF0X2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgZm9ybWF0X25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIGZvcm1hdF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIGZvcm1hdF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIGZvcm1hdF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5cblxuZnVuY3Rpb24gZXM2X2Zvcm1hdF9mb3JtYXROdW1iZXIoKSB7XG4gIHZhciBfbm9ybWFsaXplQXJndW1lbnRzID0gZm9ybWF0X25vcm1hbGl6ZUFyZ3VtZW50cyhhcmd1bWVudHMpLFxuICAgICAgaW5wdXQgPSBfbm9ybWFsaXplQXJndW1lbnRzLmlucHV0LFxuICAgICAgZm9ybWF0ID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5mb3JtYXQsXG4gICAgICBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgbWV0YWRhdGEgPSBfbm9ybWFsaXplQXJndW1lbnRzLm1ldGFkYXRhO1xuXG4gIHJldHVybiBmb3JtYXRfZm9ybWF0TnVtYmVyKGlucHV0LCBmb3JtYXQsIG9wdGlvbnMsIG1ldGFkYXRhKTtcbn0gLy8gU29ydCBvdXQgYXJndW1lbnRzXG5cbmZ1bmN0aW9uIGZvcm1hdF9ub3JtYWxpemVBcmd1bWVudHMoYXJncykge1xuICB2YXIgX0FycmF5JHByb3RvdHlwZSRzbGljID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyksXG4gICAgICBfQXJyYXkkcHJvdG90eXBlJHNsaWMyID0gZm9ybWF0X3NsaWNlZFRvQXJyYXkoX0FycmF5JHByb3RvdHlwZSRzbGljLCA1KSxcbiAgICAgIGFyZ18xID0gX0FycmF5JHByb3RvdHlwZSRzbGljMlswXSxcbiAgICAgIGFyZ18yID0gX0FycmF5JHByb3RvdHlwZSRzbGljMlsxXSxcbiAgICAgIGFyZ18zID0gX0FycmF5JHByb3RvdHlwZSRzbGljMlsyXSxcbiAgICAgIGFyZ180ID0gX0FycmF5JHByb3RvdHlwZSRzbGljMlszXSxcbiAgICAgIGFyZ181ID0gX0FycmF5JHByb3RvdHlwZSRzbGljMls0XTtcblxuICB2YXIgaW5wdXQ7XG4gIHZhciBmb3JtYXQ7XG4gIHZhciBvcHRpb25zO1xuICB2YXIgbWV0YWRhdGE7IC8vIFNvcnQgb3V0IGFyZ3VtZW50cy5cbiAgLy8gSWYgdGhlIHBob25lIG51bWJlciBpcyBwYXNzZWQgYXMgYSBzdHJpbmcuXG4gIC8vIGBmb3JtYXQoJzgwMDU1NTM1MzUnLCAuLi4pYC5cblxuICBpZiAodHlwZW9mIGFyZ18xID09PSAnc3RyaW5nJykge1xuICAgIC8vIElmIGNvdW50cnkgY29kZSBpcyBzdXBwbGllZC5cbiAgICAvLyBgZm9ybWF0KCc4MDA1NTUzNTM1JywgJ1JVJywgJ05BVElPTkFMJywgW29wdGlvbnNdLCBtZXRhZGF0YSlgLlxuICAgIGlmICh0eXBlb2YgYXJnXzMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmb3JtYXQgPSBhcmdfMztcblxuICAgICAgaWYgKGFyZ181KSB7XG4gICAgICAgIG9wdGlvbnMgPSBhcmdfNDtcbiAgICAgICAgbWV0YWRhdGEgPSBhcmdfNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGFkYXRhID0gYXJnXzQ7XG4gICAgICB9XG5cbiAgICAgIGlucHV0ID0gcGFyc2UoYXJnXzEsIHtcbiAgICAgICAgZGVmYXVsdENvdW50cnk6IGFyZ18yLFxuICAgICAgICBleHRlbmRlZDogdHJ1ZVxuICAgICAgfSwgbWV0YWRhdGEpO1xuICAgIH0gLy8gSnVzdCBhbiBpbnRlcm5hdGlvbmFsIHBob25lIG51bWJlciBpcyBzdXBwbGllZFxuICAgIC8vIGBmb3JtYXQoJys3ODAwNTU1MzUzNScsICdOQVRJT05BTCcsIFtvcHRpb25zXSwgbWV0YWRhdGEpYC5cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdfMiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bmb3JtYXRgIGFyZ3VtZW50IG5vdCBwYXNzZWQgdG8gYGZvcm1hdE51bWJlcihudW1iZXIsIGZvcm1hdClgJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBhcmdfMjtcblxuICAgICAgICBpZiAoYXJnXzQpIHtcbiAgICAgICAgICBvcHRpb25zID0gYXJnXzM7XG4gICAgICAgICAgbWV0YWRhdGEgPSBhcmdfNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXRhZGF0YSA9IGFyZ18zO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQgPSBwYXJzZShhcmdfMSwge1xuICAgICAgICAgIGV4dGVuZGVkOiB0cnVlXG4gICAgICAgIH0sIG1ldGFkYXRhKTtcbiAgICAgIH1cbiAgfSAvLyBJZiB0aGUgcGhvbmUgbnVtYmVyIGlzIHBhc3NlZCBhcyBhIHBhcnNlZCBudW1iZXIgb2JqZWN0LlxuICAvLyBgZm9ybWF0KHsgcGhvbmU6ICc4MDA1NTUzNTM1JywgY291bnRyeTogJ1JVJyB9LCAnTkFUSU9OQUwnLCBbb3B0aW9uc10sIG1ldGFkYXRhKWAuXG4gIGVsc2UgaWYgKGZvcm1hdF9pc19vYmplY3QoYXJnXzEpKSB7XG4gICAgICBpbnB1dCA9IGFyZ18xO1xuICAgICAgZm9ybWF0ID0gYXJnXzI7XG5cbiAgICAgIGlmIChhcmdfNCkge1xuICAgICAgICBvcHRpb25zID0gYXJnXzM7XG4gICAgICAgIG1ldGFkYXRhID0gYXJnXzQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXRhZGF0YSA9IGFyZ18zO1xuICAgICAgfVxuICAgIH0gZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHBob25lIG51bWJlciBtdXN0IGVpdGhlciBiZSBhIHN0cmluZyBvciBhbiBvYmplY3Qgb2Ygc2hhcGUgeyBwaG9uZSwgW2NvdW50cnldIH0uJyk7IC8vIExlZ2FjeSBsb3dlcmNhc2UgZm9ybWF0cy5cblxuXG4gIGlmIChmb3JtYXQgPT09ICdJbnRlcm5hdGlvbmFsJykge1xuICAgIGZvcm1hdCA9ICdJTlRFUk5BVElPTkFMJztcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdOYXRpb25hbCcpIHtcbiAgICBmb3JtYXQgPSAnTkFUSU9OQUwnO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpbnB1dDogaW5wdXQsXG4gICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICBtZXRhZGF0YTogbWV0YWRhdGFcbiAgfTtcbn0gLy8gQmFiZWwgdHJhbnNmb3JtcyBgdHlwZW9mYCBpbnRvIHNvbWUgXCJicmFuY2hlc1wiXG4vLyBzbyBpc3RhbmJ1bCB3aWxsIHNob3cgdGhpcyBhcyBcImJyYW5jaCBub3QgY292ZXJlZFwiLlxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbnZhciBmb3JtYXRfaXNfb2JqZWN0ID0gZnVuY3Rpb24gaXNfb2JqZWN0KF8pIHtcbiAgcmV0dXJuIGZvcm1hdF90eXBlb2YoXykgPT09ICdvYmplY3QnO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdC5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9nZXROdW1iZXJUeXBlLmpzXG5mdW5jdGlvbiBnZXROdW1iZXJUeXBlX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IGdldE51bWJlclR5cGVfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IGdldE51bWJlclR5cGVfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIGdldE51bWJlclR5cGVfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gZ2V0TnVtYmVyVHlwZV9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gZ2V0TnVtYmVyVHlwZV9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IGdldE51bWJlclR5cGVfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBnZXROdW1iZXJUeXBlX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIGdldE51bWJlclR5cGVfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfVxuXG5mdW5jdGlvbiBnZXROdW1iZXJUeXBlX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gZ2V0TnVtYmVyVHlwZV9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5cblxuIC8vIEZpbmRzIG91dCBuYXRpb25hbCBwaG9uZSBudW1iZXIgdHlwZSAoZml4ZWQgbGluZSwgbW9iaWxlLCBldGMpXG5cbmZ1bmN0aW9uIGdldE51bWJlclR5cGVfZ2V0TnVtYmVyVHlwZSgpIHtcbiAgdmFyIF9ub3JtYWxpemVBcmd1bWVudHMgPSBnZXROdW1iZXJUeXBlX25vcm1hbGl6ZUFyZ3VtZW50cyhhcmd1bWVudHMpLFxuICAgICAgaW5wdXQgPSBfbm9ybWFsaXplQXJndW1lbnRzLmlucHV0LFxuICAgICAgb3B0aW9ucyA9IF9ub3JtYWxpemVBcmd1bWVudHMub3B0aW9ucyxcbiAgICAgIG1ldGFkYXRhID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5tZXRhZGF0YTtcblxuICByZXR1cm4gZ2V0TnVtYmVyVHlwZShpbnB1dCwgb3B0aW9ucywgbWV0YWRhdGEpO1xufSAvLyBTb3J0IG91dCBhcmd1bWVudHNcblxuZnVuY3Rpb24gZ2V0TnVtYmVyVHlwZV9ub3JtYWxpemVBcmd1bWVudHMoYXJncykge1xuICB2YXIgX0FycmF5JHByb3RvdHlwZSRzbGljID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyksXG4gICAgICBfQXJyYXkkcHJvdG90eXBlJHNsaWMyID0gZ2V0TnVtYmVyVHlwZV9zbGljZWRUb0FycmF5KF9BcnJheSRwcm90b3R5cGUkc2xpYywgNCksXG4gICAgICBhcmdfMSA9IF9BcnJheSRwcm90b3R5cGUkc2xpYzJbMF0sXG4gICAgICBhcmdfMiA9IF9BcnJheSRwcm90b3R5cGUkc2xpYzJbMV0sXG4gICAgICBhcmdfMyA9IF9BcnJheSRwcm90b3R5cGUkc2xpYzJbMl0sXG4gICAgICBhcmdfNCA9IF9BcnJheSRwcm90b3R5cGUkc2xpYzJbM107XG5cbiAgdmFyIGlucHV0O1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIgbWV0YWRhdGE7IC8vIElmIHRoZSBwaG9uZSBudW1iZXIgaXMgcGFzc2VkIGFzIGEgc3RyaW5nLlxuICAvLyBgZ2V0TnVtYmVyVHlwZSgnODgwMDU1NTM1MzUnLCAuLi4pYC5cblxuICBpZiAodHlwZW9mIGFyZ18xID09PSAnc3RyaW5nJykge1xuICAgIC8vIElmIFwiZGVmYXVsdCBjb3VudHJ5XCIgYXJndW1lbnQgaXMgYmVpbmcgcGFzc2VkXG4gICAgLy8gdGhlbiBjb252ZXJ0IGl0IHRvIGFuIGBvcHRpb25zYCBvYmplY3QuXG4gICAgLy8gYGdldE51bWJlclR5cGUoJzg4MDA1NTUzNTM1JywgJ1JVJywgbWV0YWRhdGEpYC5cbiAgICBpZiAoZ2V0TnVtYmVyVHlwZV90eXBlb2YoYXJnXzIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGFyZ180KSB7XG4gICAgICAgIG9wdGlvbnMgPSBhcmdfMztcbiAgICAgICAgbWV0YWRhdGEgPSBhcmdfNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGFkYXRhID0gYXJnXzM7XG4gICAgICB9IC8vIGBwYXJzZWAgZXh0cmFjdHMgcGhvbmUgbnVtYmVycyBmcm9tIHJhdyB0ZXh0LFxuICAgICAgLy8gdGhlcmVmb3JlIGl0IHdpbGwgY3V0IG9mZiBhbGwgXCJnYXJiYWdlXCIgY2hhcmFjdGVycyxcbiAgICAgIC8vIHdoaWxlIHRoaXMgYHZhbGlkYXRlYCBmdW5jdGlvbiBuZWVkcyB0byB2ZXJpZnlcbiAgICAgIC8vIHRoYXQgdGhlIHBob25lIG51bWJlciBjb250YWlucyBubyBcImdhcmJhZ2VcIlxuICAgICAgLy8gdGhlcmVmb3JlIHRoZSBleHBsaWNpdCBgaXNWaWFibGVQaG9uZU51bWJlcmAgY2hlY2suXG5cblxuICAgICAgaWYgKGlzVmlhYmxlUGhvbmVOdW1iZXIoYXJnXzEpKSB7XG4gICAgICAgIGlucHV0ID0gcGFyc2UoYXJnXzEsIHtcbiAgICAgICAgICBkZWZhdWx0Q291bnRyeTogYXJnXzJcbiAgICAgICAgfSwgbWV0YWRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQgPSB7fTtcbiAgICAgIH1cbiAgICB9IC8vIE5vIFwicmVzcmljdCBjb3VudHJ5XCIgYXJndW1lbnQgaXMgYmVpbmcgcGFzc2VkLlxuICAgIC8vIEludGVybmF0aW9uYWwgcGhvbmUgbnVtYmVyIGlzIHBhc3NlZC5cbiAgICAvLyBgZ2V0TnVtYmVyVHlwZSgnKzc4MDA1NTUzNTM1JywgbWV0YWRhdGEpYC5cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGFyZ18zKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZ18yO1xuICAgICAgICAgIG1ldGFkYXRhID0gYXJnXzM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWV0YWRhdGEgPSBhcmdfMjtcbiAgICAgICAgfSAvLyBgcGFyc2VgIGV4dHJhY3RzIHBob25lIG51bWJlcnMgZnJvbSByYXcgdGV4dCxcbiAgICAgICAgLy8gdGhlcmVmb3JlIGl0IHdpbGwgY3V0IG9mZiBhbGwgXCJnYXJiYWdlXCIgY2hhcmFjdGVycyxcbiAgICAgICAgLy8gd2hpbGUgdGhpcyBgdmFsaWRhdGVgIGZ1bmN0aW9uIG5lZWRzIHRvIHZlcmlmeVxuICAgICAgICAvLyB0aGF0IHRoZSBwaG9uZSBudW1iZXIgY29udGFpbnMgbm8gXCJnYXJiYWdlXCJcbiAgICAgICAgLy8gdGhlcmVmb3JlIHRoZSBleHBsaWNpdCBgaXNWaWFibGVQaG9uZU51bWJlcmAgY2hlY2suXG5cblxuICAgICAgICBpZiAoaXNWaWFibGVQaG9uZU51bWJlcihhcmdfMSkpIHtcbiAgICAgICAgICBpbnB1dCA9IHBhcnNlKGFyZ18xLCB1bmRlZmluZWQsIG1ldGFkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dCA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gIH0gLy8gSWYgdGhlIHBob25lIG51bWJlciBpcyBwYXNzZWQgYXMgYSBwYXJzZWQgcGhvbmUgbnVtYmVyLlxuICAvLyBgZ2V0TnVtYmVyVHlwZSh7IHBob25lOiAnODgwMDU1NTM1MzUnLCBjb3VudHJ5OiAnUlUnIH0sIC4uLilgLlxuICBlbHNlIGlmIChnZXROdW1iZXJUeXBlX2lzX29iamVjdChhcmdfMSkpIHtcbiAgICAgIGlucHV0ID0gYXJnXzE7XG5cbiAgICAgIGlmIChhcmdfMykge1xuICAgICAgICBvcHRpb25zID0gYXJnXzI7XG4gICAgICAgIG1ldGFkYXRhID0gYXJnXzM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXRhZGF0YSA9IGFyZ18yO1xuICAgICAgfVxuICAgIH0gZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHBob25lIG51bWJlciBtdXN0IGVpdGhlciBiZSBhIHN0cmluZyBvciBhbiBvYmplY3Qgb2Ygc2hhcGUgeyBwaG9uZSwgW2NvdW50cnldIH0uJyk7XG5cbiAgcmV0dXJuIHtcbiAgICBpbnB1dDogaW5wdXQsXG4gICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICBtZXRhZGF0YTogbWV0YWRhdGFcbiAgfTtcbn0gLy8gQmFiZWwgdHJhbnNmb3JtcyBgdHlwZW9mYCBpbnRvIHNvbWUgXCJicmFuY2hlc1wiXG4vLyBzbyBpc3RhbmJ1bCB3aWxsIHNob3cgdGhpcyBhcyBcImJyYW5jaCBub3QgY292ZXJlZFwiLlxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG52YXIgZ2V0TnVtYmVyVHlwZV9pc19vYmplY3QgPSBmdW5jdGlvbiBpc19vYmplY3QoXykge1xuICByZXR1cm4gZ2V0TnVtYmVyVHlwZV90eXBlb2YoXykgPT09ICdvYmplY3QnO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldE51bWJlclR5cGUuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9lczYvZ2V0RXhhbXBsZU51bWJlci5qc1xuXG5mdW5jdGlvbiBnZXRFeGFtcGxlTnVtYmVyKGNvdW50cnksIGV4YW1wbGVzLCBtZXRhZGF0YSkge1xuICBpZiAoZXhhbXBsZXNbY291bnRyeV0pIHtcbiAgICByZXR1cm4gbmV3IFBob25lTnVtYmVyX1Bob25lTnVtYmVyKGNvdW50cnksIGV4YW1wbGVzW2NvdW50cnldLCBtZXRhZGF0YSk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEV4YW1wbGVOdW1iZXIuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9lczYvaXNQb3NzaWJsZU51bWJlci5qc1xuXG5cbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBwaG9uZSBudW1iZXIgaXMgcG9zc2libGUuXHJcbiAqIFdoaWNoIG1lYW5zIGl0IG9ubHkgY2hlY2tzIHBob25lIG51bWJlciBsZW5ndGhcclxuICogYW5kIGRvZXNuJ3QgdGVzdCBhbnkgcmVndWxhciBleHByZXNzaW9ucy5cclxuICpcclxuICogRXhhbXBsZXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGlzUG9zc2libGVOdW1iZXIoJys3ODAwNTU1MzUzNScsIG1ldGFkYXRhKVxyXG4gKiBpc1Bvc3NpYmxlTnVtYmVyKCc4MDA1NTUzNTM1JywgJ1JVJywgbWV0YWRhdGEpXHJcbiAqIGlzUG9zc2libGVOdW1iZXIoJzg4MDA1NTUzNTM1JywgJ1JVJywgbWV0YWRhdGEpXHJcbiAqIGlzUG9zc2libGVOdW1iZXIoeyBwaG9uZTogJzgwMDU1NTM1MzUnLCBjb3VudHJ5OiAnUlUnIH0sIG1ldGFkYXRhKVxyXG4gKiBgYGBcclxuICovXG5cbmZ1bmN0aW9uIGlzUG9zc2libGVOdW1iZXJfaXNQb3NzaWJsZU51bWJlcigpIHtcbiAgdmFyIF9ub3JtYWxpemVBcmd1bWVudHMgPSBnZXROdW1iZXJUeXBlX25vcm1hbGl6ZUFyZ3VtZW50cyhhcmd1bWVudHMpLFxuICAgICAgaW5wdXQgPSBfbm9ybWFsaXplQXJndW1lbnRzLmlucHV0LFxuICAgICAgb3B0aW9ucyA9IF9ub3JtYWxpemVBcmd1bWVudHMub3B0aW9ucyxcbiAgICAgIG1ldGFkYXRhID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5tZXRhZGF0YTtcblxuICByZXR1cm4gaXNQb3NzaWJsZVBob25lTnVtYmVyKGlucHV0LCBvcHRpb25zLCBtZXRhZGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1Bvc3NpYmxlTnVtYmVyLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvZXM2L3ZhbGlkYXRlLmpzXG5cbiAvLyBGaW5kcyBvdXQgbmF0aW9uYWwgcGhvbmUgbnVtYmVyIHR5cGUgKGZpeGVkIGxpbmUsIG1vYmlsZSwgZXRjKVxuXG5mdW5jdGlvbiB2YWxpZGF0ZV9pc1ZhbGlkTnVtYmVyKCkge1xuICB2YXIgX25vcm1hbGl6ZUFyZ3VtZW50cyA9IGdldE51bWJlclR5cGVfbm9ybWFsaXplQXJndW1lbnRzKGFyZ3VtZW50cyksXG4gICAgICBpbnB1dCA9IF9ub3JtYWxpemVBcmd1bWVudHMuaW5wdXQsXG4gICAgICBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgbWV0YWRhdGEgPSBfbm9ybWFsaXplQXJndW1lbnRzLm1ldGFkYXRhO1xuXG4gIHJldHVybiBpc1ZhbGlkTnVtYmVyKGlucHV0LCBvcHRpb25zLCBtZXRhZGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0ZS5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9pc1ZhbGlkTnVtYmVyRm9yUmVnaW9uXy5qc1xuXG4vKipcclxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gcGhvbmUgbnVtYmVyIGlzIHZhbGlkIHdpdGhpbiBhIGdpdmVuIHJlZ2lvbi5cclxuICogSXMganVzdCBhbiBhbGlhcyBmb3IgYHBob25lTnVtYmVyLmlzVmFsaWQoKSAmJiBwaG9uZU51bWJlci5jb3VudHJ5ID09PSBjb3VudHJ5YC5cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWkxOG4vbGlicGhvbmVudW1iZXIvYmxvYi9tYXN0ZXIvRkFRLm1kI3doZW4tc2hvdWxkLWktdXNlLWlzdmFsaWRudW1iZXJmb3JyZWdpb25cclxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWROdW1iZXJGb3JSZWdpb24oaW5wdXQsIGNvdW50cnksIG9wdGlvbnMsIG1ldGFkYXRhKSB7XG4gIC8vIElmIGFzc2lnbmluZyB0aGUgYHt9YCBkZWZhdWx0IHZhbHVlIGlzIG1vdmVkIHRvIHRoZSBhcmd1bWVudHMgYWJvdmUsXG4gIC8vIGNvZGUgY292ZXJhZ2Ugd291bGQgZGVjcmVhc2UgZm9yIHNvbWUgd2VpcmQgcmVhc29uLlxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgcmV0dXJuIGlucHV0LmNvdW50cnkgPT09IGNvdW50cnkgJiYgaXNWYWxpZE51bWJlcihpbnB1dCwgb3B0aW9ucywgbWV0YWRhdGEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNWYWxpZE51bWJlckZvclJlZ2lvbl8uanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9lczYvaXNWYWxpZE51bWJlckZvclJlZ2lvbi5qc1xuXG5cblxuZnVuY3Rpb24gaXNWYWxpZE51bWJlckZvclJlZ2lvbl9pc1ZhbGlkTnVtYmVyRm9yUmVnaW9uKG51bWJlciwgY291bnRyeSwgbWV0YWRhdGEpIHtcbiAgaWYgKHR5cGVvZiBudW1iZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbnVtYmVyIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY291bnRyeSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb3VudHJ5IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgfSAvLyBgcGFyc2VgIGV4dHJhY3RzIHBob25lIG51bWJlcnMgZnJvbSByYXcgdGV4dCxcbiAgLy8gdGhlcmVmb3JlIGl0IHdpbGwgY3V0IG9mZiBhbGwgXCJnYXJiYWdlXCIgY2hhcmFjdGVycyxcbiAgLy8gd2hpbGUgdGhpcyBgdmFsaWRhdGVgIGZ1bmN0aW9uIG5lZWRzIHRvIHZlcmlmeVxuICAvLyB0aGF0IHRoZSBwaG9uZSBudW1iZXIgY29udGFpbnMgbm8gXCJnYXJiYWdlXCJcbiAgLy8gdGhlcmVmb3JlIHRoZSBleHBsaWNpdCBgaXNWaWFibGVQaG9uZU51bWJlcmAgY2hlY2suXG5cblxuICB2YXIgaW5wdXQ7XG5cbiAgaWYgKGlzVmlhYmxlUGhvbmVOdW1iZXIobnVtYmVyKSkge1xuICAgIGlucHV0ID0gcGFyc2UobnVtYmVyLCB7XG4gICAgICBkZWZhdWx0Q291bnRyeTogY291bnRyeVxuICAgIH0sIG1ldGFkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBpbnB1dCA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIGlzVmFsaWROdW1iZXJGb3JSZWdpb24oaW5wdXQsIGNvdW50cnksIHVuZGVmaW5lZCwgbWV0YWRhdGEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNWYWxpZE51bWJlckZvclJlZ2lvbi5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9maW5kTnVtYmVycy91dGlsLmpzXG4vKiogUmV0dXJucyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBxdWFudGlmaWVyIHdpdGggYW4gdXBwZXIgYW5kIGxvd2VyIGxpbWl0LiAqL1xuZnVuY3Rpb24gbGltaXQobG93ZXIsIHVwcGVyKSB7XG4gIGlmIChsb3dlciA8IDAgfHwgdXBwZXIgPD0gMCB8fCB1cHBlciA8IGxvd2VyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICB9XG5cbiAgcmV0dXJuIFwie1wiLmNvbmNhdChsb3dlciwgXCIsXCIpLmNvbmNhdCh1cHBlciwgXCJ9XCIpO1xufVxuLyoqXHJcbiAqIFRyaW1zIGF3YXkgYW55IGNoYXJhY3RlcnMgYWZ0ZXIgdGhlIGZpcnN0IG1hdGNoIG9mIHtAY29kZSBwYXR0ZXJufSBpbiB7QGNvZGUgY2FuZGlkYXRlfSxcclxuICogcmV0dXJuaW5nIHRoZSB0cmltbWVkIHZlcnNpb24uXHJcbiAqL1xuXG5mdW5jdGlvbiB0cmltQWZ0ZXJGaXJzdE1hdGNoKHJlZ2V4cCwgc3RyaW5nKSB7XG4gIHZhciBpbmRleCA9IHN0cmluZy5zZWFyY2gocmVnZXhwKTtcblxuICBpZiAoaW5kZXggPj0gMCkge1xuICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgaW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZztcbn1cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCBzdWJzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5pbmRleE9mKHN1YnN0cmluZykgPT09IDA7XG59XG5mdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIHN1YnN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLmluZGV4T2Yoc3Vic3RyaW5nLCBzdHJpbmcubGVuZ3RoIC0gc3Vic3RyaW5nLmxlbmd0aCkgPT09IHN0cmluZy5sZW5ndGggLSBzdWJzdHJpbmcubGVuZ3RoO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9maW5kTnVtYmVycy9wYXJzZVByZUNhbmRpZGF0ZS5qc1xuIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiBvZiBjaGFyYWN0ZXJzIHR5cGljYWxseSB1c2VkIHRvIHN0YXJ0IGEgc2Vjb25kIHBob25lIG51bWJlciBmb3IgdGhlIHB1cnBvc2VzXG4vLyBvZiBwYXJzaW5nLiBUaGlzIGFsbG93cyB1cyB0byBzdHJpcCBvZmYgcGFydHMgb2YgdGhlIG51bWJlciB0aGF0IGFyZSBhY3R1YWxseSB0aGUgc3RhcnQgb2Zcbi8vIGFub3RoZXIgbnVtYmVyLCBzdWNoIGFzIGZvcjogKDUzMCkgNTgzLTY5ODUgeDMwMi94MjMwMyAtPiB0aGUgc2Vjb25kIGV4dGVuc2lvbiBoZXJlIG1ha2VzIHRoaXNcbi8vIGFjdHVhbGx5IHR3byBwaG9uZSBudW1iZXJzLCAoNTMwKSA1ODMtNjk4NSB4MzAyIGFuZCAoNTMwKSA1ODMtNjk4NSB4MjMwMy4gV2UgcmVtb3ZlIHRoZSBzZWNvbmRcbi8vIGV4dGVuc2lvbiBzbyB0aGF0IHRoZSBmaXJzdCBudW1iZXIgaXMgcGFyc2VkIGNvcnJlY3RseS5cbi8vXG4vLyBNYXRjaGVzIGEgc2xhc2ggKFxcIG9yIC8pIGZvbGxvd2VkIGJ5IGEgc3BhY2UgZm9sbG93ZWQgYnkgYW4gYHhgLlxuLy9cblxudmFyIFNFQ09ORF9OVU1CRVJfU1RBUlRfUEFUVEVSTiA9IC9bXFxcXC9dICp4LztcbmZ1bmN0aW9uIHBhcnNlUHJlQ2FuZGlkYXRlKGNhbmRpZGF0ZSkge1xuICAvLyBDaGVjayBmb3IgZXh0cmEgbnVtYmVycyBhdCB0aGUgZW5kLlxuICAvLyBUT0RPOiBUaGlzIGlzIHRoZSBwbGFjZSB0byBzdGFydCB3aGVuIHRyeWluZyB0byBzdXBwb3J0IGV4dHJhY3Rpb24gb2YgbXVsdGlwbGUgcGhvbmUgbnVtYmVyXG4gIC8vIGZyb20gc3BsaXQgbm90YXRpb25zICgrNDEgNzkgMTIzIDQ1IDY3IC8gNjgpLlxuICByZXR1cm4gdHJpbUFmdGVyRmlyc3RNYXRjaChTRUNPTkRfTlVNQkVSX1NUQVJUX1BBVFRFUk4sIGNhbmRpZGF0ZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZVByZUNhbmRpZGF0ZS5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9maW5kTnVtYmVycy9pc1ZhbGlkUHJlQ2FuZGlkYXRlLmpzXG4vLyBNYXRjaGVzIHN0cmluZ3MgdGhhdCBsb29rIGxpa2UgZGF0ZXMgdXNpbmcgXCIvXCIgYXMgYSBzZXBhcmF0b3IuXG4vLyBFeGFtcGxlczogMy8xMC8yMDExLCAzMS8xMC85NiBvciAwOC8zMS85NS5cbnZhciBTTEFTSF9TRVBBUkFURURfREFURVMgPSAvKD86KD86WzAtM10/XFxkXFwvWzAxXT9cXGQpfCg/OlswMV0/XFxkXFwvWzAtM10/XFxkKSlcXC8oPzpbMTJdXFxkKT9cXGR7Mn0vOyAvLyBNYXRjaGVzIHRpbWVzdGFtcHMuXG4vLyBFeGFtcGxlczogXCIyMDEyLTAxLTAyIDA4OjAwXCIuXG4vLyBOb3RlIHRoYXQgdGhlIHJlZy1leCBkb2VzIG5vdCBpbmNsdWRlIHRoZVxuLy8gdHJhaWxpbmcgXCI6XFxkXFxkXCIgLS0gdGhhdCBpcyBjb3ZlcmVkIGJ5IFRJTUVfU1RBTVBTX1NVRkZJWC5cblxudmFyIFRJTUVfU1RBTVBTID0gL1sxMl1cXGR7M31bLS9dP1swMV1cXGRbLS9dP1swLTNdXFxkICtbMC0yXVxcZCQvO1xudmFyIFRJTUVfU1RBTVBTX1NVRkZJWF9MRUFESU5HID0gL146WzAtNV1cXGQvO1xuZnVuY3Rpb24gaXNWYWxpZFByZUNhbmRpZGF0ZShjYW5kaWRhdGUsIG9mZnNldCwgdGV4dCkge1xuICAvLyBTa2lwIGEgbWF0Y2ggdGhhdCBpcyBtb3JlIGxpa2VseSB0byBiZSBhIGRhdGUuXG4gIGlmIChTTEFTSF9TRVBBUkFURURfREFURVMudGVzdChjYW5kaWRhdGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFNraXAgcG90ZW50aWFsIHRpbWUtc3RhbXBzLlxuXG5cbiAgaWYgKFRJTUVfU1RBTVBTLnRlc3QoY2FuZGlkYXRlKSkge1xuICAgIHZhciBmb2xsb3dpbmdUZXh0ID0gdGV4dC5zbGljZShvZmZzZXQgKyBjYW5kaWRhdGUubGVuZ3RoKTtcblxuICAgIGlmIChUSU1FX1NUQU1QU19TVUZGSVhfTEVBRElORy50ZXN0KGZvbGxvd2luZ1RleHQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1ZhbGlkUHJlQ2FuZGlkYXRlLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvZXM2L2ZpbmROdW1iZXJzL3V0Zi04LmpzXG4vLyBKYXZhc2NyaXB0IGRvZXNuJ3Qgc3VwcG9ydCBVVEYtOCByZWd1bGFyIGV4cHJlc3Npb25zLlxuLy8gU28gbWltaWNraW5nIHRoZW0gaGVyZS5cbi8vIENvcHktcGFzdGVkIGZyb20gYFBob25lTnVtYmVyTWF0Y2hlci5qc2AuXG5cbi8qKlxyXG4gKiBcIlxccHtafVwiIGlzIGFueSBraW5kIG9mIHdoaXRlc3BhY2Ugb3IgaW52aXNpYmxlIHNlcGFyYXRvciAoXCJTZXBhcmF0b3JcIikuXHJcbiAqIGh0dHA6Ly93d3cucmVndWxhci1leHByZXNzaW9ucy5pbmZvL3VuaWNvZGUuaHRtbFxyXG4gKiBcIlxcUHtafVwiIGlzIHRoZSByZXZlcnNlIG9mIFwiXFxwe1p9XCIuXHJcbiAqIFwiXFxwe059XCIgaXMgYW55IGtpbmQgb2YgbnVtZXJpYyBjaGFyYWN0ZXIgaW4gYW55IHNjcmlwdCAoXCJOdW1iZXJcIikuXHJcbiAqIFwiXFxwe05kfVwiIGlzIGEgZGlnaXQgemVybyB0aHJvdWdoIG5pbmUgaW4gYW55IHNjcmlwdCBleGNlcHQgXCJpZGVvZ3JhcGhpYyBzY3JpcHRzXCIgKFwiRGVjaW1hbF9EaWdpdF9OdW1iZXJcIikuXHJcbiAqIFwiXFxwe1NjfVwiIGlzIGEgY3VycmVuY3kgc3ltYm9sIChcIkN1cnJlbmN5X1N5bWJvbFwiKS5cclxuICogXCJcXHB7TH1cIiBpcyBhbnkga2luZCBvZiBsZXR0ZXIgZnJvbSBhbnkgbGFuZ3VhZ2UgKFwiTGV0dGVyXCIpLlxyXG4gKiBcIlxccHtNbn1cIiBpcyBcIm5vbi1zcGFjaW5nIG1hcmtcIi5cclxuICpcclxuICogSmF2YXNjcmlwdCBkb2Vzbid0IHN1cHBvcnQgVW5pY29kZSBSZWd1bGFyIEV4cHJlc3Npb25zXHJcbiAqIHNvIHN1YnN0aXR1dGluZyBpdCB3aXRoIHRoaXMgZXhwbGljaXQgc2V0IG9mIGNoYXJhY3RlcnMuXHJcbiAqXHJcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMjEwMTk0L2phdmFzY3JpcHQtcmVnZXgtZXF1aXZhbGVudC1vZi1hLXphLXotdXNpbmctcGxcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2RhbmllbGJlcm5kdC9iYWJlbC1wbHVnaW4tdXRmLTgtcmVnZXgvYmxvYi9tYXN0ZXIvc3JjL3RyYW5zZm9ybWVyLmpzXHJcbiAqL1xudmFyIF9wWiA9IFwiIFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMEFcXHUyMDI4XFx1MjAyOVxcdTIwMkZcXHUyMDVGXFx1MzAwMFwiO1xudmFyIHBaID0gXCJbXCIuY29uY2F0KF9wWiwgXCJdXCIpO1xudmFyIFBaID0gXCJbXlwiLmNvbmNhdChfcFosIFwiXVwiKTtcbnZhciBfcE4gPSBcIjAtOVxceEIyXFx4QjNcXHhCOVxceEJDLVxceEJFXFx1MDY2MC1cXHUwNjY5XFx1MDZGMC1cXHUwNkY5XFx1MDdDMC1cXHUwN0M5XFx1MDk2Ni1cXHUwOTZGXFx1MDlFNi1cXHUwOUVGXFx1MDlGNC1cXHUwOUY5XFx1MEE2Ni1cXHUwQTZGXFx1MEFFNi1cXHUwQUVGXFx1MEI2Ni1cXHUwQjZGXFx1MEI3Mi1cXHUwQjc3XFx1MEJFNi1cXHUwQkYyXFx1MEM2Ni1cXHUwQzZGXFx1MEM3OC1cXHUwQzdFXFx1MENFNi1cXHUwQ0VGXFx1MEQ2Ni1cXHUwRDc1XFx1MEU1MC1cXHUwRTU5XFx1MEVEMC1cXHUwRUQ5XFx1MEYyMC1cXHUwRjMzXFx1MTA0MC1cXHUxMDQ5XFx1MTA5MC1cXHUxMDk5XFx1MTM2OS1cXHUxMzdDXFx1MTZFRS1cXHUxNkYwXFx1MTdFMC1cXHUxN0U5XFx1MTdGMC1cXHUxN0Y5XFx1MTgxMC1cXHUxODE5XFx1MTk0Ni1cXHUxOTRGXFx1MTlEMC1cXHUxOURBXFx1MUE4MC1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUI1MC1cXHUxQjU5XFx1MUJCMC1cXHUxQkI5XFx1MUM0MC1cXHUxQzQ5XFx1MUM1MC1cXHUxQzU5XFx1MjA3MFxcdTIwNzQtXFx1MjA3OVxcdTIwODAtXFx1MjA4OVxcdTIxNTAtXFx1MjE4MlxcdTIxODUtXFx1MjE4OVxcdTI0NjAtXFx1MjQ5QlxcdTI0RUEtXFx1MjRGRlxcdTI3NzYtXFx1Mjc5M1xcdTJDRkRcXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzOC1cXHUzMDNBXFx1MzE5Mi1cXHUzMTk1XFx1MzIyMC1cXHUzMjI5XFx1MzI0OC1cXHUzMjRGXFx1MzI1MS1cXHUzMjVGXFx1MzI4MC1cXHUzMjg5XFx1MzJCMS1cXHUzMkJGXFx1QTYyMC1cXHVBNjI5XFx1QTZFNi1cXHVBNkVGXFx1QTgzMC1cXHVBODM1XFx1QThEMC1cXHVBOEQ5XFx1QTkwMC1cXHVBOTA5XFx1QTlEMC1cXHVBOUQ5XFx1QUE1MC1cXHVBQTU5XFx1QUJGMC1cXHVBQkY5XFx1RkYxMC1cXHVGRjE5XCI7IC8vIGNvbnN0IHBOID0gYFske19wTn1dYFxuXG52YXIgX3BOZCA9IFwiMC05XFx1MDY2MC1cXHUwNjY5XFx1MDZGMC1cXHUwNkY5XFx1MDdDMC1cXHUwN0M5XFx1MDk2Ni1cXHUwOTZGXFx1MDlFNi1cXHUwOUVGXFx1MEE2Ni1cXHUwQTZGXFx1MEFFNi1cXHUwQUVGXFx1MEI2Ni1cXHUwQjZGXFx1MEJFNi1cXHUwQkVGXFx1MEM2Ni1cXHUwQzZGXFx1MENFNi1cXHUwQ0VGXFx1MEQ2Ni1cXHUwRDZGXFx1MEU1MC1cXHUwRTU5XFx1MEVEMC1cXHUwRUQ5XFx1MEYyMC1cXHUwRjI5XFx1MTA0MC1cXHUxMDQ5XFx1MTA5MC1cXHUxMDk5XFx1MTdFMC1cXHUxN0U5XFx1MTgxMC1cXHUxODE5XFx1MTk0Ni1cXHUxOTRGXFx1MTlEMC1cXHUxOUQ5XFx1MUE4MC1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUI1MC1cXHUxQjU5XFx1MUJCMC1cXHUxQkI5XFx1MUM0MC1cXHUxQzQ5XFx1MUM1MC1cXHUxQzU5XFx1QTYyMC1cXHVBNjI5XFx1QThEMC1cXHVBOEQ5XFx1QTkwMC1cXHVBOTA5XFx1QTlEMC1cXHVBOUQ5XFx1QUE1MC1cXHVBQTU5XFx1QUJGMC1cXHVBQkY5XFx1RkYxMC1cXHVGRjE5XCI7XG52YXIgcE5kID0gXCJbXCIuY29uY2F0KF9wTmQsIFwiXVwiKTtcbnZhciBfcEwgPSBcIkEtWmEtelxceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwXFx1MDhBMi1cXHUwOEFDXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N0ZcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzM1xcdTBDMzUtXFx1MEMzOVxcdTBDM0RcXHUwQzU4XFx1MEM1OVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDYwXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUNcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUMxLVxcdTE5QzdcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTgzXFx1MjE4NFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDVcXHUzMDA2XFx1MzAzMS1cXHUzMDM1XFx1MzAzQlxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5N1xcdUE2QTAtXFx1QTZFNVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTc5M1xcdUE3QTAtXFx1QTdBQVxcdUE3RjgtXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBODAtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUJDMC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXCI7XG52YXIgcEwgPSBcIltcIi5jb25jYXQoX3BMLCBcIl1cIik7XG52YXIgcExfcmVnZXhwID0gbmV3IFJlZ0V4cChwTCk7XG52YXIgX3BTYyA9IFwiJFxceEEyLVxceEE1XFx1MDU4RlxcdTA2MEJcXHUwOUYyXFx1MDlGM1xcdTA5RkJcXHUwQUYxXFx1MEJGOVxcdTBFM0ZcXHUxN0RCXFx1MjBBMC1cXHUyMEI5XFx1QTgzOFxcdUZERkNcXHVGRTY5XFx1RkYwNFxcdUZGRTBcXHVGRkUxXFx1RkZFNVxcdUZGRTZcIjtcbnZhciBwU2MgPSBcIltcIi5jb25jYXQoX3BTYywgXCJdXCIpO1xudmFyIHBTY19yZWdleHAgPSBuZXcgUmVnRXhwKHBTYyk7XG52YXIgX3BNbiA9IFwiXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RTQtXFx1MDhGRVxcdTA5MDAtXFx1MDkwMlxcdTA5M0FcXHUwOTNDXFx1MDk0MS1cXHUwOTQ4XFx1MDk0RFxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5QkNcXHUwOUMxLVxcdTA5QzRcXHUwOUNEXFx1MDlFMlxcdTA5RTNcXHUwQTAxXFx1MEEwMlxcdTBBM0NcXHUwQTQxXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODFcXHUwQTgyXFx1MEFCQ1xcdTBBQzEtXFx1MEFDNVxcdTBBQzdcXHUwQUM4XFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEIwMVxcdTBCM0NcXHUwQjNGXFx1MEI0MS1cXHUwQjQ0XFx1MEI0RFxcdTBCNTZcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkMwXFx1MEJDRFxcdTBDM0UtXFx1MEM0MFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQ0JDXFx1MENCRlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRTJcXHUwQ0UzXFx1MEQ0MS1cXHUwRDQ0XFx1MEQ0RFxcdTBENjJcXHUwRDYzXFx1MERDQVxcdTBERDItXFx1MERENFxcdTBERDZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCOVxcdTBFQkJcXHUwRUJDXFx1MEVDOC1cXHUwRUNEXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0XFx1MTdCNVxcdTE3QjctXFx1MTdCRFxcdTE3QzZcXHUxN0M5LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUE1NlxcdTFBNTgtXFx1MUE1RVxcdTFBNjBcXHUxQTYyXFx1MUE2NS1cXHUxQTZDXFx1MUE3My1cXHUxQTdDXFx1MUE3RlxcdTFCMDAtXFx1MUIwM1xcdTFCMzRcXHUxQjM2LVxcdTFCM0FcXHUxQjNDXFx1MUI0MlxcdTFCNkItXFx1MUI3M1xcdTFCODBcXHUxQjgxXFx1MUJBMi1cXHUxQkE1XFx1MUJBOFxcdTFCQTlcXHUxQkFCXFx1MUJFNlxcdTFCRThcXHUxQkU5XFx1MUJFRFxcdTFCRUYtXFx1MUJGMVxcdTFDMkMtXFx1MUMzM1xcdTFDMzZcXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxREMwLVxcdTFERTZcXHUxREZDLVxcdTFERkZcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRFxcdTMwOTlcXHUzMDlBXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QThDNFxcdUE4RTAtXFx1QThGMVxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QUEyOS1cXHVBQTJFXFx1QUEzMVxcdUFBMzJcXHVBQTM1XFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyNlwiO1xudmFyIHBNbiA9IFwiW1wiLmNvbmNhdChfcE1uLCBcIl1cIik7XG52YXIgcE1uX3JlZ2V4cCA9IG5ldyBSZWdFeHAocE1uKTtcbnZhciBfSW5CYXNpY19MYXRpbiA9IFwiXFwwLVxceDdGXCI7XG52YXIgX0luTGF0aW5fMV9TdXBwbGVtZW50ID0gXCJcXHg4MC1cXHhGRlwiO1xudmFyIF9JbkxhdGluX0V4dGVuZGVkX0EgPSBcIlxcdTAxMDAtXFx1MDE3RlwiO1xudmFyIF9JbkxhdGluX0V4dGVuZGVkX0FkZGl0aW9uYWwgPSBcIlxcdTFFMDAtXFx1MUVGRlwiO1xudmFyIF9JbkxhdGluX0V4dGVuZGVkX0IgPSBcIlxcdTAxODAtXFx1MDI0RlwiO1xudmFyIF9JbkNvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcyA9IFwiXFx1MDMwMC1cXHUwMzZGXCI7XG52YXIgbGF0aW5MZXR0ZXJSZWdleHAgPSBuZXcgUmVnRXhwKCdbJyArIF9JbkJhc2ljX0xhdGluICsgX0luTGF0aW5fMV9TdXBwbGVtZW50ICsgX0luTGF0aW5fRXh0ZW5kZWRfQSArIF9JbkxhdGluX0V4dGVuZGVkX0FkZGl0aW9uYWwgKyBfSW5MYXRpbl9FeHRlbmRlZF9CICsgX0luQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzICsgJ10nKTtcbi8qKlxyXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGRldGVybWluZSBpZiBhIGNoYXJhY3RlciBpcyBhIExhdGluLXNjcmlwdCBsZXR0ZXIgb3Igbm90LlxyXG4gKiBGb3Igb3VyIHB1cnBvc2VzLCBjb21iaW5pbmcgbWFya3Mgc2hvdWxkIGFsc28gcmV0dXJuIHRydWUgc2luY2Ugd2UgYXNzdW1lXHJcbiAqIHRoZXkgaGF2ZSBiZWVuIGFkZGVkIHRvIGEgcHJlY2VkaW5nIExhdGluIGNoYXJhY3Rlci5cclxuICovXG5cbmZ1bmN0aW9uIGlzTGF0aW5MZXR0ZXIobGV0dGVyKSB7XG4gIC8vIENvbWJpbmluZyBtYXJrcyBhcmUgYSBzdWJzZXQgb2Ygbm9uLXNwYWNpbmctbWFyay5cbiAgaWYgKCFwTF9yZWdleHAudGVzdChsZXR0ZXIpICYmICFwTW5fcmVnZXhwLnRlc3QobGV0dGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBsYXRpbkxldHRlclJlZ2V4cC50ZXN0KGxldHRlcik7XG59XG5mdW5jdGlvbiBpc0ludmFsaWRQdW5jdHVhdGlvblN5bWJvbChjaGFyYWN0ZXIpIHtcbiAgcmV0dXJuIGNoYXJhY3RlciA9PT0gJyUnIHx8IHBTY19yZWdleHAudGVzdChjaGFyYWN0ZXIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmLTguanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9lczYvZmluZE51bWJlcnMvaXNWYWxpZENhbmRpZGF0ZS5qc1xuLy8gQ29weS1wYXN0ZWQgZnJvbSBgUGhvbmVOdW1iZXJNYXRjaGVyLmpzYC5cblxuXG5cbnZhciBPUEVOSU5HX1BBUkVOUyA9IFwiKFxcXFxbXFx1RkYwOFxcdUZGM0JcIjtcbnZhciBDTE9TSU5HX1BBUkVOUyA9IFwiKVxcXFxdXFx1RkYwOVxcdUZGM0RcIjtcbnZhciBOT05fUEFSRU5TID0gXCJbXlwiLmNvbmNhdChPUEVOSU5HX1BBUkVOUykuY29uY2F0KENMT1NJTkdfUEFSRU5TLCBcIl1cIik7XG52YXIgTEVBRF9DTEFTUyA9IFwiW1wiLmNvbmNhdChPUEVOSU5HX1BBUkVOUykuY29uY2F0KFBMVVNfQ0hBUlMsIFwiXVwiKTsgLy8gUHVuY3R1YXRpb24gdGhhdCBtYXkgYmUgYXQgdGhlIHN0YXJ0IG9mIGEgcGhvbmUgbnVtYmVyIC0gYnJhY2tldHMgYW5kIHBsdXMgc2lnbnMuXG5cbnZhciBMRUFEX0NMQVNTX0xFQURJTkcgPSBuZXcgUmVnRXhwKCdeJyArIExFQURfQ0xBU1MpOyAvLyBMaW1pdCBvbiB0aGUgbnVtYmVyIG9mIHBhaXJzIG9mIGJyYWNrZXRzIGluIGEgcGhvbmUgbnVtYmVyLlxuXG52YXIgQlJBQ0tFVF9QQUlSX0xJTUlUID0gbGltaXQoMCwgMyk7XG4vKipcclxuICogUGF0dGVybiB0byBjaGVjayB0aGF0IGJyYWNrZXRzIG1hdGNoLiBPcGVuaW5nIGJyYWNrZXRzIHNob3VsZCBiZSBjbG9zZWQgd2l0aGluIGEgcGhvbmUgbnVtYmVyLlxyXG4gKiBUaGlzIGFsc28gY2hlY2tzIHRoYXQgdGhlcmUgaXMgc29tZXRoaW5nIGluc2lkZSB0aGUgYnJhY2tldHMuIEhhdmluZyBubyBicmFja2V0cyBhdCBhbGwgaXMgYWxzb1xyXG4gKiBmaW5lLlxyXG4gKlxyXG4gKiBBbiBvcGVuaW5nIGJyYWNrZXQgYXQgdGhlIGJlZ2lubmluZyBtYXkgbm90IGJlIGNsb3NlZCwgYnV0IHN1YnNlcXVlbnQgb25lcyBzaG91bGQgYmUuICBJdCdzXHJcbiAqIGFsc28gcG9zc2libGUgdGhhdCB0aGUgbGVhZGluZyBicmFja2V0IHdhcyBkcm9wcGVkLCBzbyB3ZSBzaG91bGRuJ3QgYmUgc3VycHJpc2VkIGlmIHdlIHNlZSBhXHJcbiAqIGNsb3NpbmcgYnJhY2tldCBmaXJzdC4gV2UgbGltaXQgdGhlIHNldHMgb2YgYnJhY2tldHMgaW4gYSBwaG9uZSBudW1iZXIgdG8gZm91ci5cclxuICovXG5cbnZhciBNQVRDSElOR19CUkFDS0VUU19FTlRJUkUgPSBuZXcgUmVnRXhwKCdeJyArIFwiKD86W1wiICsgT1BFTklOR19QQVJFTlMgKyBcIl0pP1wiICsgXCIoPzpcIiArIE5PTl9QQVJFTlMgKyBcIitcIiArIFwiW1wiICsgQ0xPU0lOR19QQVJFTlMgKyBcIl0pP1wiICsgTk9OX1BBUkVOUyArIFwiK1wiICsgXCIoPzpbXCIgKyBPUEVOSU5HX1BBUkVOUyArIFwiXVwiICsgTk9OX1BBUkVOUyArIFwiK1tcIiArIENMT1NJTkdfUEFSRU5TICsgXCJdKVwiICsgQlJBQ0tFVF9QQUlSX0xJTUlUICsgTk9OX1BBUkVOUyArIFwiKlwiICsgJyQnKTtcbi8qKlxyXG4gKiBNYXRjaGVzIHN0cmluZ3MgdGhhdCBsb29rIGxpa2UgcHVibGljYXRpb24gcGFnZXMuIEV4YW1wbGU6XHJcbiAqIDxwcmU+Q29tcHV0aW5nIENvbXBsZXRlIEFuc3dlcnMgdG8gUXVlcmllcyBpbiB0aGUgUHJlc2VuY2Ugb2YgTGltaXRlZCBBY2Nlc3MgUGF0dGVybnMuXHJcbiAqIENoZW4gTGkuIFZMREIgSi4gMTIoMyk6IDIxMS0yMjcgKDIwMDMpLjwvcHJlPlxyXG4gKlxyXG4gKiBUaGUgc3RyaW5nIFwiMjExLTIyNyAoMjAwMylcIiBpcyBub3QgYSB0ZWxlcGhvbmUgbnVtYmVyLlxyXG4gKi9cblxudmFyIFBVQl9QQUdFUyA9IC9cXGR7MSw1fS0rXFxkezEsNX1cXHN7MCw0fVxcKFxcZHsxLDR9LztcbmZ1bmN0aW9uIGlzVmFsaWRDYW5kaWRhdGUoY2FuZGlkYXRlLCBvZmZzZXQsIHRleHQsIGxlbmllbmN5KSB7XG4gIC8vIENoZWNrIHRoZSBjYW5kaWRhdGUgZG9lc24ndCBjb250YWluIGFueSBmb3JtYXR0aW5nXG4gIC8vIHdoaWNoIHdvdWxkIGluZGljYXRlIHRoYXQgaXQgcmVhbGx5IGlzbid0IGEgcGhvbmUgbnVtYmVyLlxuICBpZiAoIU1BVENISU5HX0JSQUNLRVRTX0VOVElSRS50ZXN0KGNhbmRpZGF0ZSkgfHwgUFVCX1BBR0VTLnRlc3QoY2FuZGlkYXRlKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBJZiBsZW5pZW5jeSBpcyBzZXQgdG8gVkFMSUQgb3Igc3RyaWN0ZXIsIHdlIGFsc28gd2FudCB0byBza2lwIG51bWJlcnMgdGhhdCBhcmUgc3Vycm91bmRlZFxuICAvLyBieSBMYXRpbiBhbHBoYWJldGljIGNoYXJhY3RlcnMsIHRvIHNraXAgY2FzZXMgbGlrZSBhYmM4MDA1MDAxMjM0IG9yIDgwMDUwMDEyMzRkZWYuXG5cblxuICBpZiAobGVuaWVuY3kgIT09ICdQT1NTSUJMRScpIHtcbiAgICAvLyBJZiB0aGUgY2FuZGlkYXRlIGlzIG5vdCBhdCB0aGUgc3RhcnQgb2YgdGhlIHRleHQsXG4gICAgLy8gYW5kIGRvZXMgbm90IHN0YXJ0IHdpdGggcGhvbmUtbnVtYmVyIHB1bmN0dWF0aW9uLFxuICAgIC8vIGNoZWNrIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIuXG4gICAgaWYgKG9mZnNldCA+IDAgJiYgIUxFQURfQ0xBU1NfTEVBRElORy50ZXN0KGNhbmRpZGF0ZSkpIHtcbiAgICAgIHZhciBwcmV2aW91c0NoYXIgPSB0ZXh0W29mZnNldCAtIDFdOyAvLyBXZSByZXR1cm4gbnVsbCBpZiBpdCBpcyBhIGxhdGluIGxldHRlciBvciBhbiBpbnZhbGlkIHB1bmN0dWF0aW9uIHN5bWJvbC5cblxuICAgICAgaWYgKGlzSW52YWxpZFB1bmN0dWF0aW9uU3ltYm9sKHByZXZpb3VzQ2hhcikgfHwgaXNMYXRpbkxldHRlcihwcmV2aW91c0NoYXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFzdENoYXJJbmRleCA9IG9mZnNldCArIGNhbmRpZGF0ZS5sZW5ndGg7XG5cbiAgICBpZiAobGFzdENoYXJJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICB2YXIgbmV4dENoYXIgPSB0ZXh0W2xhc3RDaGFySW5kZXhdO1xuXG4gICAgICBpZiAoaXNJbnZhbGlkUHVuY3R1YXRpb25TeW1ib2wobmV4dENoYXIpIHx8IGlzTGF0aW5MZXR0ZXIobmV4dENoYXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzVmFsaWRDYW5kaWRhdGUuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9lczYvZmluZFBob25lTnVtYmVyc18uanNcbmZ1bmN0aW9uIGZpbmRQaG9uZU51bWJlcnNfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBmaW5kUGhvbmVOdW1iZXJzX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBmaW5kUGhvbmVOdW1iZXJzX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZmluZFBob25lTnVtYmVyc19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZmluZFBob25lTnVtYmVyc19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBmaW5kUGhvbmVOdW1iZXJzX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gVGhpcyBpcyBhIGxlZ2FjeSBmdW5jdGlvbi5cbi8vIFVzZSBgZmluZE51bWJlcnMoKWAgaW5zdGVhZC5cblxuXG5cblxuXG4gLy8gQ29weS1wYXN0ZWQgZnJvbSBgLi9wYXJzZS5qc2AuXG5cbnZhciBmaW5kUGhvbmVOdW1iZXJzX1ZBTElEX1BIT05FX05VTUJFUiA9ICdbJyArIFBMVVNfQ0hBUlMgKyAnXXswLDF9JyArICcoPzonICsgJ1snICsgVkFMSURfUFVOQ1RVQVRJT04gKyAnXSonICsgJ1snICsgVkFMSURfRElHSVRTICsgJ10nICsgJyl7Myx9JyArICdbJyArIFZBTElEX1BVTkNUVUFUSU9OICsgVkFMSURfRElHSVRTICsgJ10qJztcbnZhciBXSElURVNQQUNFX0lOX1RIRV9CRUdJTk5JTkdfUEFUVEVSTiA9IG5ldyBSZWdFeHAoJ15bJyArIFdISVRFU1BBQ0UgKyAnXSsnKTtcbnZhciBQVU5DVFVBVElPTl9JTl9USEVfRU5EX1BBVFRFUk4gPSBuZXcgUmVnRXhwKCdbJyArIFZBTElEX1BVTkNUVUFUSU9OICsgJ10rJCcpOyAvLyAvLyBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgb3BlbmluZyBicmFja2V0cyBmb3IgYSB2YWxpZCBudW1iZXJcbi8vIC8vIGZvdW5kIHVzaW5nIGBQSE9ORV9OVU1CRVJfU1RBUlRfUEFUVEVSTmAgZm9yIHByZXBlbmRpbmcgdGhvc2UgYnJhY2tldHMgdG8gdGhlIG51bWJlci5cbi8vIGNvbnN0IEJFRk9SRV9OVU1CRVJfRElHSVRTX1BVTkNUVUFUSU9OID0gbmV3IFJlZ0V4cCgnWycgKyBPUEVOSU5HX0JSQUNLRVRTICsgJ10rJyArICdbJyArIFdISVRFU1BBQ0UgKyAnXSonICsgJyQnKVxuXG52YXIgVkFMSURfUFJFQ0VESU5HX0NIQVJBQ1RFUl9QQVRURVJOID0gL1teYS16QS1aMC05XS87XG5mdW5jdGlvbiBmaW5kUGhvbmVOdW1iZXJzKHRleHQsIG9wdGlvbnMsIG1ldGFkYXRhKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IG5ldyBmaW5kUGhvbmVOdW1iZXJzX1Bob25lTnVtYmVyU2VhcmNoKHRleHQsIG9wdGlvbnMsIG1ldGFkYXRhKTtcbiAgdmFyIHBob25lcyA9IFtdO1xuXG4gIHdoaWxlIChzZWFyY2guaGFzTmV4dCgpKSB7XG4gICAgcGhvbmVzLnB1c2goc2VhcmNoLm5leHQoKSk7XG4gIH1cblxuICByZXR1cm4gcGhvbmVzO1xufVxuLyoqXHJcbiAqIEByZXR1cm4gRVM2IGBmb3IgLi4uIG9mYCBpdGVyYXRvci5cclxuICovXG5cbmZ1bmN0aW9uIHNlYXJjaFBob25lTnVtYmVycyh0ZXh0LCBvcHRpb25zLCBtZXRhZGF0YSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSBuZXcgZmluZFBob25lTnVtYmVyc19QaG9uZU51bWJlclNlYXJjaCh0ZXh0LCBvcHRpb25zLCBtZXRhZGF0YSk7XG4gIHJldHVybiBmaW5kUGhvbmVOdW1iZXJzX2RlZmluZVByb3BlcnR5KHt9LCBTeW1ib2wuaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKHNlYXJjaC5oYXNOZXh0KCkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogc2VhcmNoLm5leHQoKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cbi8qKlxyXG4gKiBFeHRyYWN0cyBhIHBhcnNlYWJsZSBwaG9uZSBudW1iZXIgaW5jbHVkaW5nIGFueSBvcGVuaW5nIGJyYWNrZXRzLCBldGMuXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCAtIElucHV0LlxyXG4gKiBAcmV0dXJuIHtvYmplY3R9IGB7ID9udW1iZXIsID9zdGFydHNBdCwgP2VuZHNBdCB9YC5cclxuICovXG5cbnZhciBmaW5kUGhvbmVOdW1iZXJzX1Bob25lTnVtYmVyU2VhcmNoID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gSXRlcmF0aW9uIHRyaXN0YXRlLlxuICBmdW5jdGlvbiBQaG9uZU51bWJlclNlYXJjaCh0ZXh0LCBvcHRpb25zLCBtZXRhZGF0YSkge1xuICAgIGZpbmRQaG9uZU51bWJlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGhvbmVOdW1iZXJTZWFyY2gpO1xuXG4gICAgZmluZFBob25lTnVtYmVyc19kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsICdOT1RfUkVBRFknKTtcblxuICAgIHRoaXMudGV4dCA9IHRleHQ7IC8vIElmIGFzc2lnbmluZyB0aGUgYHt9YCBkZWZhdWx0IHZhbHVlIGlzIG1vdmVkIHRvIHRoZSBhcmd1bWVudHMgYWJvdmUsXG4gICAgLy8gY29kZSBjb3ZlcmFnZSB3b3VsZCBkZWNyZWFzZSBmb3Igc29tZSB3ZWlyZCByZWFzb24uXG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAoZmluZFBob25lTnVtYmVyc19WQUxJRF9QSE9ORV9OVU1CRVIgKyAvLyBQaG9uZSBudW1iZXIgZXh0ZW5zaW9uc1xuICAgICcoPzonICsgRVhUTl9QQVRURVJOU19GT1JfUEFSU0lORyArICcpPycsICdpZycpOyAvLyB0aGlzLnNlYXJjaGluZ19mcm9tID0gMFxuICB9XG5cbiAgZmluZFBob25lTnVtYmVyc19jcmVhdGVDbGFzcyhQaG9uZU51bWJlclNlYXJjaCwgW3tcbiAgICBrZXk6IFwiZmluZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kKCkge1xuICAgICAgdmFyIG1hdGNoZXMgPSB0aGlzLnJlZ2V4cC5leGVjKHRoaXMudGV4dCk7XG5cbiAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBudW1iZXIgPSBtYXRjaGVzWzBdO1xuICAgICAgdmFyIHN0YXJ0c0F0ID0gbWF0Y2hlcy5pbmRleDtcbiAgICAgIG51bWJlciA9IG51bWJlci5yZXBsYWNlKFdISVRFU1BBQ0VfSU5fVEhFX0JFR0lOTklOR19QQVRURVJOLCAnJyk7XG4gICAgICBzdGFydHNBdCArPSBtYXRjaGVzWzBdLmxlbmd0aCAtIG51bWJlci5sZW5ndGg7IC8vIEZpeGVzIG5vdCBwYXJzaW5nIG51bWJlcnMgd2l0aCB3aGl0ZXNwYWNlIGluIHRoZSBlbmQuXG4gICAgICAvLyBBbHNvIGZpeGVzIG5vdCBwYXJzaW5nIG51bWJlcnMgd2l0aCBvcGVuaW5nIHBhcmVudGhlc2VzIGluIHRoZSBlbmQuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2F0YW1waGV0YW1pbmUvbGlicGhvbmVudW1iZXItanMvaXNzdWVzLzI1MlxuXG4gICAgICBudW1iZXIgPSBudW1iZXIucmVwbGFjZShQVU5DVFVBVElPTl9JTl9USEVfRU5EX1BBVFRFUk4sICcnKTtcbiAgICAgIG51bWJlciA9IHBhcnNlUHJlQ2FuZGlkYXRlKG51bWJlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZUNhbmRpZGF0ZShudW1iZXIsIHN0YXJ0c0F0KTtcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSAvLyBUYWlsIHJlY3Vyc2lvbi5cbiAgICAgIC8vIFRyeSB0aGUgbmV4dCBvbmUgaWYgdGhpcyBvbmUgaXMgbm90IGEgdmFsaWQgcGhvbmUgbnVtYmVyLlxuXG5cbiAgICAgIHJldHVybiB0aGlzLmZpbmQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VDYW5kaWRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VDYW5kaWRhdGUobnVtYmVyLCBzdGFydHNBdCkge1xuICAgICAgaWYgKCFpc1ZhbGlkUHJlQ2FuZGlkYXRlKG51bWJlciwgc3RhcnRzQXQsIHRoaXMudGV4dCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBEb24ndCBwYXJzZSBwaG9uZSBudW1iZXJzIHdoaWNoIGFyZSBub24tcGhvbmUgbnVtYmVyc1xuICAgICAgLy8gZHVlIHRvIGJlaW5nIHBhcnQgb2Ygc29tZXRoaW5nIGVsc2UgKGUuZy4gYSBVVUlEKS5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRhbXBoZXRhbWluZS9saWJwaG9uZW51bWJlci1qcy9pc3N1ZXMvMjEzXG4gICAgICAvLyBDb3B5LXBhc3RlZCBmcm9tIEdvb2dsZSdzIGBQaG9uZU51bWJlck1hdGNoZXIuanNgIChgLnBhcnNlQW5kVmFsaWRhdGUoKWApLlxuXG5cbiAgICAgIGlmICghaXNWYWxpZENhbmRpZGF0ZShudW1iZXIsIHN0YXJ0c0F0LCB0aGlzLnRleHQsIHRoaXMub3B0aW9ucy5leHRlbmRlZCA/ICdQT1NTSUJMRScgOiAnVkFMSUQnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIC8vIFByZXBlbmQgYW55IG9wZW5pbmcgYnJhY2tldHMgbGVmdCBiZWhpbmQgYnkgdGhlXG4gICAgICAvLyAvLyBgUEhPTkVfTlVNQkVSX1NUQVJUX1BBVFRFUk5gIHJlZ2V4cC5cbiAgICAgIC8vIGNvbnN0IHRleHRfYmVmb3JlX251bWJlciA9IHRleHQuc2xpY2UodGhpcy5zZWFyY2hpbmdfZnJvbSwgc3RhcnRzQXQpXG4gICAgICAvLyBjb25zdCBmdWxsX251bWJlcl9zdGFydHNfYXQgPSB0ZXh0X2JlZm9yZV9udW1iZXIuc2VhcmNoKEJFRk9SRV9OVU1CRVJfRElHSVRTX1BVTkNUVUFUSU9OKVxuICAgICAgLy8gaWYgKGZ1bGxfbnVtYmVyX3N0YXJ0c19hdCA+PSAwKVxuICAgICAgLy8ge1xuICAgICAgLy8gXHRudW1iZXIgICA9IHRleHRfYmVmb3JlX251bWJlci5zbGljZShmdWxsX251bWJlcl9zdGFydHNfYXQpICsgbnVtYmVyXG4gICAgICAvLyBcdHN0YXJ0c0F0ID0gZnVsbF9udW1iZXJfc3RhcnRzX2F0XG4gICAgICAvLyB9XG4gICAgICAvL1xuICAgICAgLy8gdGhpcy5zZWFyY2hpbmdfZnJvbSA9IG1hdGNoZXMubGFzdEluZGV4XG5cblxuICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlKG51bWJlciwgdGhpcy5vcHRpb25zLCB0aGlzLm1ldGFkYXRhKTtcblxuICAgICAgaWYgKCFyZXN1bHQucGhvbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQuc3RhcnRzQXQgPSBzdGFydHNBdDtcbiAgICAgIHJlc3VsdC5lbmRzQXQgPSBzdGFydHNBdCArIG51bWJlci5sZW5ndGg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNOZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc05leHQoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ05PVF9SRUFEWScpIHtcbiAgICAgICAgdGhpcy5sYXN0X21hdGNoID0gdGhpcy5maW5kKCk7XG5cbiAgICAgICAgaWYgKHRoaXMubGFzdF9tYXRjaCkge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAnUkVBRFknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAnRE9ORSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09ICdSRUFEWSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5leHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIC8vIENoZWNrIHRoZSBzdGF0ZSBhbmQgZmluZCB0aGUgbmV4dCBtYXRjaCBhcyBhIHNpZGUtZWZmZWN0IGlmIG5lY2Vzc2FyeS5cbiAgICAgIGlmICghdGhpcy5oYXNOZXh0KCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBuZXh0IGVsZW1lbnQnKTtcbiAgICAgIH0gLy8gRG9uJ3QgcmV0YWluIHRoYXQgbWVtb3J5IGFueSBsb25nZXIgdGhhbiBuZWNlc3NhcnkuXG5cblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubGFzdF9tYXRjaDtcbiAgICAgIHRoaXMubGFzdF9tYXRjaCA9IG51bGw7XG4gICAgICB0aGlzLnN0YXRlID0gJ05PVF9SRUFEWSc7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQaG9uZU51bWJlclNlYXJjaDtcbn0oKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmRQaG9uZU51bWJlcnNfLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvZXM2L2ZpbmRQaG9uZU51bWJlcnMuanNcbi8vIFRoaXMgaXMgYSBsZWdhY3kgZnVuY3Rpb24uXG4vLyBVc2UgYGZpbmROdW1iZXJzKClgIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZmluZFBob25lTnVtYmVyc19maW5kUGhvbmVOdW1iZXJzKCkge1xuICB2YXIgX25vcm1hbGl6ZUFyZ3VtZW50cyA9IG5vcm1hbGl6ZUFyZ3VtZW50cyhhcmd1bWVudHMpLFxuICAgICAgdGV4dCA9IF9ub3JtYWxpemVBcmd1bWVudHMudGV4dCxcbiAgICAgIG9wdGlvbnMgPSBfbm9ybWFsaXplQXJndW1lbnRzLm9wdGlvbnMsXG4gICAgICBtZXRhZGF0YSA9IF9ub3JtYWxpemVBcmd1bWVudHMubWV0YWRhdGE7XG5cbiAgcmV0dXJuIGZpbmRQaG9uZU51bWJlcnModGV4dCwgb3B0aW9ucywgbWV0YWRhdGEpO1xufVxuLyoqXHJcbiAqIEByZXR1cm4gRVM2IGBmb3IgLi4uIG9mYCBpdGVyYXRvci5cclxuICovXG5cbmZ1bmN0aW9uIGZpbmRQaG9uZU51bWJlcnNfc2VhcmNoUGhvbmVOdW1iZXJzKCkge1xuICB2YXIgX25vcm1hbGl6ZUFyZ3VtZW50czIgPSBub3JtYWxpemVBcmd1bWVudHMoYXJndW1lbnRzKSxcbiAgICAgIHRleHQgPSBfbm9ybWFsaXplQXJndW1lbnRzMi50ZXh0LFxuICAgICAgb3B0aW9ucyA9IF9ub3JtYWxpemVBcmd1bWVudHMyLm9wdGlvbnMsXG4gICAgICBtZXRhZGF0YSA9IF9ub3JtYWxpemVBcmd1bWVudHMyLm1ldGFkYXRhO1xuXG4gIHJldHVybiBzZWFyY2hQaG9uZU51bWJlcnModGV4dCwgb3B0aW9ucywgbWV0YWRhdGEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZFBob25lTnVtYmVycy5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9maW5kTnVtYmVycy9MUlVDYWNoZS5qc1xuZnVuY3Rpb24gTFJVQ2FjaGVfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIExSVUNhY2hlX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgTFJVQ2FjaGVfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIExSVUNhY2hlX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIExSVUNhY2hlX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL2RzaW5qcy9pbXBsZW1lbnRpbmctbHJ1LWNhY2hlLWluLWphdmFzY3JpcHQtOTRiYTY3NTVjZGE5XG52YXIgTm9kZSA9IGZ1bmN0aW9uIE5vZGUoa2V5LCB2YWx1ZSkge1xuICB2YXIgbmV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgdmFyIHByZXYgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgTFJVQ2FjaGVfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZSk7XG5cbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgdGhpcy5wcmV2ID0gcHJldjtcbn07XG5cbnZhciBMUlVDYWNoZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8vc2V0IGRlZmF1bHQgbGltaXQgb2YgMTAgaWYgbGltaXQgaXMgbm90IHBhc3NlZC5cbiAgZnVuY3Rpb24gTFJVQ2FjaGUoKSB7XG4gICAgdmFyIGxpbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxMDtcblxuICAgIExSVUNhY2hlX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExSVUNhY2hlKTtcblxuICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgdGhpcy5saW1pdCA9IGxpbWl0O1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmNhY2hlID0ge307XG4gIH0gLy8gV3JpdGUgTm9kZSB0byBoZWFkIG9mIExpbmtlZExpc3RcbiAgLy8gdXBkYXRlIGNhY2hlIHdpdGggTm9kZSBrZXkgYW5kIE5vZGUgcmVmZXJlbmNlXG5cblxuICBMUlVDYWNoZV9jcmVhdGVDbGFzcyhMUlVDYWNoZSwgW3tcbiAgICBrZXk6IFwicHV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1dChrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmVuc3VyZUxpbWl0KCk7XG5cbiAgICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBOb2RlKGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgTm9kZShrZXksIHZhbHVlLCB0aGlzLmhlYWQpO1xuICAgICAgICB0aGlzLmhlYWQucHJldiA9IG5vZGU7XG4gICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XG4gICAgICB9IC8vVXBkYXRlIHRoZSBjYWNoZSBtYXBcblxuXG4gICAgICB0aGlzLmNhY2hlW2tleV0gPSB0aGlzLmhlYWQ7XG4gICAgICB0aGlzLnNpemUrKztcbiAgICB9IC8vIFJlYWQgZnJvbSBjYWNoZSBtYXAgYW5kIG1ha2UgdGhhdCBub2RlIGFzIG5ldyBIZWFkIG9mIExpbmtlZExpc3RcblxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICBpZiAodGhpcy5jYWNoZVtrZXldKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuY2FjaGVba2V5XS52YWx1ZTsgLy8gbm9kZSByZW1vdmVkIGZyb20gaXQncyBwb3NpdGlvbiBhbmQgY2FjaGVcblxuICAgICAgICB0aGlzLnJlbW92ZShrZXkpOyAvLyB3cml0ZSBub2RlIGFnYWluIHRvIHRoZSBoZWFkIG9mIExpbmtlZExpc3QgdG8gbWFrZSBpdCBtb3N0IHJlY2VudGx5IHVzZWRcblxuICAgICAgICB0aGlzLnB1dChrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhcIkl0ZW0gbm90IGF2YWlsYWJsZSBpbiBjYWNoZSBmb3Iga2V5IFwiLmNvbmNhdChrZXkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5zdXJlTGltaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5zdXJlTGltaXQoKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSB0aGlzLmxpbWl0KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKHRoaXMudGFpbC5rZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmNhY2hlW2tleV07XG5cbiAgICAgIGlmIChub2RlLnByZXYgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhlYWQgPSBub2RlLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRhaWwgPSBub2RlLnByZXY7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLmNhY2hlW2tleV07XG4gICAgICB0aGlzLnNpemUtLTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgfSAvLyAvLyBJbnZva2VzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGV2ZXJ5IG5vZGUgb2YgdGhlIGNoYWluIGFuZCB0aGUgaW5kZXggb2YgdGhlIG5vZGUuXG4gICAgLy8gZm9yRWFjaChmbikge1xuICAgIC8vICAgbGV0IG5vZGUgPSB0aGlzLmhlYWQ7XG4gICAgLy8gICBsZXQgY291bnRlciA9IDA7XG4gICAgLy8gICB3aGlsZSAobm9kZSkge1xuICAgIC8vICAgICBmbihub2RlLCBjb3VudGVyKTtcbiAgICAvLyAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAvLyAgICAgY291bnRlcisrO1xuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICAvLyAvLyBUbyBpdGVyYXRlIG92ZXIgTFJVIHdpdGggYSAnZm9yLi4ub2YnIGxvb3BcbiAgICAvLyAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgLy8gICBsZXQgbm9kZSA9IHRoaXMuaGVhZDtcbiAgICAvLyAgIHdoaWxlIChub2RlKSB7XG4gICAgLy8gICAgIHlpZWxkIG5vZGU7XG4gICAgLy8gICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuXG4gIH1dKTtcblxuICByZXR1cm4gTFJVQ2FjaGU7XG59KCk7XG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TFJVQ2FjaGUuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9lczYvZmluZE51bWJlcnMvUmVnRXhwQ2FjaGUuanNcbmZ1bmN0aW9uIFJlZ0V4cENhY2hlX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gUmVnRXhwQ2FjaGVfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIFJlZ0V4cENhY2hlX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgUmVnRXhwQ2FjaGVfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIFJlZ0V4cENhY2hlX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbiAvLyBBIGNhY2hlIGZvciBmcmVxdWVudGx5IHVzZWQgY291bnRyeS1zcGVjaWZpYyByZWd1bGFyIGV4cHJlc3Npb25zLiBTZXQgdG8gMzIgdG8gY292ZXIgfjItM1xuLy8gY291bnRyaWVzIGJlaW5nIHVzZWQgZm9yIHRoZSBzYW1lIGRvYyB3aXRoIH4xMCBwYXR0ZXJucyBmb3IgZWFjaCBjb3VudHJ5LiBTb21lIHBhZ2VzIHdpbGwgaGF2ZVxuLy8gYSBsb3QgbW9yZSBjb3VudHJpZXMgaW4gdXNlLCBidXQgdHlwaWNhbGx5IGZld2VyIG51bWJlcnMgZm9yIGVhY2ggc28gZXhwYW5kaW5nIHRoZSBjYWNoZSBmb3Jcbi8vIHRoYXQgdXNlLWNhc2Ugd29uJ3QgaGF2ZSBhIGxvdCBvZiBiZW5lZml0LlxuXG52YXIgUmVnRXhwQ2FjaGVfUmVnRXhwQ2FjaGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWdFeHBDYWNoZShzaXplKSB7XG4gICAgUmVnRXhwQ2FjaGVfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVnRXhwQ2FjaGUpO1xuXG4gICAgdGhpcy5jYWNoZSA9IG5ldyBMUlVDYWNoZShzaXplKTtcbiAgfVxuXG4gIFJlZ0V4cENhY2hlX2NyZWF0ZUNsYXNzKFJlZ0V4cENhY2hlLCBbe1xuICAgIGtleTogXCJnZXRQYXR0ZXJuRm9yUmVnRXhwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhdHRlcm5Gb3JSZWdFeHAocGF0dGVybikge1xuICAgICAgdmFyIHJlZ0V4cCA9IHRoaXMuY2FjaGUuZ2V0KHBhdHRlcm4pO1xuXG4gICAgICBpZiAoIXJlZ0V4cCkge1xuICAgICAgICByZWdFeHAgPSBuZXcgUmVnRXhwKCdeJyArIHBhdHRlcm4pO1xuICAgICAgICB0aGlzLmNhY2hlLnB1dChwYXR0ZXJuLCByZWdFeHApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnRXhwO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZWdFeHBDYWNoZTtcbn0oKTtcblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWdFeHBDYWNoZS5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9maW5kTnVtYmVycy9MZW5pZW5jeS5qc1xuXG5cblxuLyoqXHJcbiAqIExlbmllbmN5IHdoZW4gZmluZGluZyBwb3RlbnRpYWwgcGhvbmUgbnVtYmVycyBpbiB0ZXh0IHNlZ21lbnRzXHJcbiAqIFRoZSBsZXZlbHMgaGVyZSBhcmUgb3JkZXJlZCBpbiBpbmNyZWFzaW5nIHN0cmljdG5lc3MuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBMZW5pZW5jeSA9ICh7XG4gIC8qKlxyXG4gICAqIFBob25lIG51bWJlcnMgYWNjZXB0ZWQgYXJlIFwicG9zc2libGVcIiwgYnV0IG5vdCBuZWNlc3NhcmlseSBcInZhbGlkXCIuXHJcbiAgICovXG4gIFBPU1NJQkxFOiBmdW5jdGlvbiBQT1NTSUJMRShudW1iZXIsIGNhbmRpZGF0ZSwgbWV0YWRhdGEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBQaG9uZSBudW1iZXJzIGFjY2VwdGVkIGFyZSBcInBvc3NpYmxlXCIgYW5kIFwidmFsaWRcIi5cclxuICAgKiBOdW1iZXJzIHdyaXR0ZW4gaW4gbmF0aW9uYWwgZm9ybWF0IG11c3QgaGF2ZSB0aGVpciBuYXRpb25hbC1wcmVmaXhcclxuICAgKiBwcmVzZW50IGlmIGl0IGlzIHVzdWFsbHkgd3JpdHRlbiBmb3IgYSBudW1iZXIgb2YgdGhpcyB0eXBlLlxyXG4gICAqL1xuICBWQUxJRDogZnVuY3Rpb24gVkFMSUQobnVtYmVyLCBjYW5kaWRhdGUsIG1ldGFkYXRhKSB7XG4gICAgaWYgKCFpc1ZhbGlkTnVtYmVyKG51bWJlciwgdW5kZWZpbmVkLCBtZXRhZGF0YSkgfHwgIWNvbnRhaW5zT25seVZhbGlkWENoYXJzKG51bWJlciwgY2FuZGlkYXRlLnRvU3RyaW5nKCksIG1ldGFkYXRhKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gU2tpcHBlZCBmb3Igc2ltcGxpY2l0eS5cbiAgICAvLyByZXR1cm4gaXNOYXRpb25hbFByZWZpeFByZXNlbnRJZlJlcXVpcmVkKG51bWJlciwgbWV0YWRhdGEpXG5cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFBob25lIG51bWJlcnMgYWNjZXB0ZWQgYXJlIFwidmFsaWRcIiBhbmRcclxuICAgKiBhcmUgZ3JvdXBlZCBpbiBhIHBvc3NpYmxlIHdheSBmb3IgdGhpcyBsb2NhbGUuIEZvciBleGFtcGxlLCBhIFVTIG51bWJlciB3cml0dGVuIGFzXHJcbiAgICogXCI2NSAwMiA1MyAwMCAwMFwiIGFuZCBcIjY1MDI1MyAwMDAwXCIgYXJlIG5vdCBhY2NlcHRlZCBhdCB0aGlzIGxlbmllbmN5IGxldmVsLCB3aGVyZWFzXHJcbiAgICogXCI2NTAgMjUzIDAwMDBcIiwgXCI2NTAgMjUzMDAwMFwiIG9yIFwiNjUwMjUzMDAwMFwiIGFyZS5cclxuICAgKiBOdW1iZXJzIHdpdGggbW9yZSB0aGFuIG9uZSAnLycgc3ltYm9sIGluIHRoZSBuYXRpb25hbCBzaWduaWZpY2FudCBudW1iZXJcclxuICAgKiBhcmUgYWxzbyBkcm9wcGVkIGF0IHRoaXMgbGV2ZWwuXHJcbiAgICpcclxuICAgKiBXYXJuaW5nOiBUaGlzIGxldmVsIG1pZ2h0IHJlc3VsdCBpbiBsb3dlciBjb3ZlcmFnZSBlc3BlY2lhbGx5IGZvciByZWdpb25zIG91dHNpZGUgb2ZcclxuICAgKiBjb3VudHJ5IGNvZGUgXCIrMVwiLiBJZiB5b3UgYXJlIG5vdCBzdXJlIGFib3V0IHdoaWNoIGxldmVsIHRvIHVzZSxcclxuICAgKiBlbWFpbCB0aGUgZGlzY3Vzc2lvbiBncm91cCBsaWJwaG9uZW51bWJlci1kaXNjdXNzQGdvb2dsZWdyb3Vwcy5jb20uXHJcbiAgICovXG4gIFNUUklDVF9HUk9VUElORzogZnVuY3Rpb24gU1RSSUNUX0dST1VQSU5HKG51bWJlciwgY2FuZGlkYXRlLCBtZXRhZGF0YSwgcmVnRXhwQ2FjaGUpIHtcbiAgICB2YXIgY2FuZGlkYXRlU3RyaW5nID0gY2FuZGlkYXRlLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAoIWlzVmFsaWROdW1iZXIobnVtYmVyLCB1bmRlZmluZWQsIG1ldGFkYXRhKSB8fCAhY29udGFpbnNPbmx5VmFsaWRYQ2hhcnMobnVtYmVyLCBjYW5kaWRhdGVTdHJpbmcsIG1ldGFkYXRhKSB8fCBjb250YWluc01vcmVUaGFuT25lU2xhc2hJbk5hdGlvbmFsTnVtYmVyKG51bWJlciwgY2FuZGlkYXRlU3RyaW5nKSB8fCAhaXNOYXRpb25hbFByZWZpeFByZXNlbnRJZlJlcXVpcmVkKG51bWJlciwgbWV0YWRhdGEpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoZWNrTnVtYmVyR3JvdXBpbmdJc1ZhbGlkKG51bWJlciwgY2FuZGlkYXRlLCBtZXRhZGF0YSwgYWxsTnVtYmVyR3JvdXBzUmVtYWluR3JvdXBlZCwgcmVnRXhwQ2FjaGUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFBob25lIG51bWJlcnMgYWNjZXB0ZWQgYXJlIHtAbGlua3BsYWluIFBob25lTnVtYmVyVXRpbCNpc1ZhbGlkTnVtYmVyKFBob25lTnVtYmVyKSB2YWxpZH0gYW5kXHJcbiAgICogYXJlIGdyb3VwZWQgaW4gdGhlIHNhbWUgd2F5IHRoYXQgd2Ugd291bGQgaGF2ZSBmb3JtYXR0ZWQgaXQsIG9yIGFzIGEgc2luZ2xlIGJsb2NrLiBGb3JcclxuICAgKiBleGFtcGxlLCBhIFVTIG51bWJlciB3cml0dGVuIGFzIFwiNjUwIDI1MzAwMDBcIiBpcyBub3QgYWNjZXB0ZWQgYXQgdGhpcyBsZW5pZW5jeSBsZXZlbCwgd2hlcmVhc1xyXG4gICAqIFwiNjUwIDI1MyAwMDAwXCIgb3IgXCI2NTAyNTMwMDAwXCIgYXJlLlxyXG4gICAqIE51bWJlcnMgd2l0aCBtb3JlIHRoYW4gb25lICcvJyBzeW1ib2wgYXJlIGFsc28gZHJvcHBlZCBhdCB0aGlzIGxldmVsLlxyXG4gICAqIDxwPlxyXG4gICAqIFdhcm5pbmc6IFRoaXMgbGV2ZWwgbWlnaHQgcmVzdWx0IGluIGxvd2VyIGNvdmVyYWdlIGVzcGVjaWFsbHkgZm9yIHJlZ2lvbnMgb3V0c2lkZSBvZiBjb3VudHJ5XHJcbiAgICogY29kZSBcIisxXCIuIElmIHlvdSBhcmUgbm90IHN1cmUgYWJvdXQgd2hpY2ggbGV2ZWwgdG8gdXNlLCBlbWFpbCB0aGUgZGlzY3Vzc2lvbiBncm91cFxyXG4gICAqIGxpYnBob25lbnVtYmVyLWRpc2N1c3NAZ29vZ2xlZ3JvdXBzLmNvbS5cclxuICAgKi9cbiAgRVhBQ1RfR1JPVVBJTkc6IGZ1bmN0aW9uIEVYQUNUX0dST1VQSU5HKG51bWJlciwgY2FuZGlkYXRlLCBtZXRhZGF0YSwgcmVnRXhwQ2FjaGUpIHtcbiAgICB2YXIgY2FuZGlkYXRlU3RyaW5nID0gY2FuZGlkYXRlLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAoIWlzVmFsaWROdW1iZXIobnVtYmVyLCB1bmRlZmluZWQsIG1ldGFkYXRhKSB8fCAhY29udGFpbnNPbmx5VmFsaWRYQ2hhcnMobnVtYmVyLCBjYW5kaWRhdGVTdHJpbmcsIG1ldGFkYXRhKSB8fCBjb250YWluc01vcmVUaGFuT25lU2xhc2hJbk5hdGlvbmFsTnVtYmVyKG51bWJlciwgY2FuZGlkYXRlU3RyaW5nKSB8fCAhaXNOYXRpb25hbFByZWZpeFByZXNlbnRJZlJlcXVpcmVkKG51bWJlciwgbWV0YWRhdGEpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoZWNrTnVtYmVyR3JvdXBpbmdJc1ZhbGlkKG51bWJlciwgY2FuZGlkYXRlLCBtZXRhZGF0YSwgYWxsTnVtYmVyR3JvdXBzQXJlRXhhY3RseVByZXNlbnQsIHJlZ0V4cENhY2hlKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNvbnRhaW5zT25seVZhbGlkWENoYXJzKG51bWJlciwgY2FuZGlkYXRlLCBtZXRhZGF0YSkge1xuICAvLyBUaGUgY2hhcmFjdGVycyAneCcgYW5kICdYJyBjYW4gYmUgKDEpIGEgY2FycmllciBjb2RlLCBpbiB3aGljaCBjYXNlIHRoZXkgYWx3YXlzIHByZWNlZGUgdGhlXG4gIC8vIG5hdGlvbmFsIHNpZ25pZmljYW50IG51bWJlciBvciAoMikgYW4gZXh0ZW5zaW9uIHNpZ24sIGluIHdoaWNoIGNhc2UgdGhleSBhbHdheXMgcHJlY2VkZSB0aGVcbiAgLy8gZXh0ZW5zaW9uIG51bWJlci4gV2UgYXNzdW1lIGEgY2FycmllciBjb2RlIGlzIG1vcmUgdGhhbiAxIGRpZ2l0LCBzbyB0aGUgZmlyc3QgY2FzZSBoYXMgdG9cbiAgLy8gaGF2ZSBtb3JlIHRoYW4gMSBjb25zZWN1dGl2ZSAneCcgb3IgJ1gnLCB3aGVyZWFzIHRoZSBzZWNvbmQgY2FzZSBjYW4gb25seSBoYXZlIGV4YWN0bHkgMSAneCdcbiAgLy8gb3IgJ1gnLiBXZSBpZ25vcmUgdGhlIGNoYXJhY3RlciBpZiBpdCBhcHBlYXJzIGFzIHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGUgc3RyaW5nLlxuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgY2FuZGlkYXRlLmxlbmd0aCAtIDE7IGluZGV4KyspIHtcbiAgICB2YXIgY2hhckF0SW5kZXggPSBjYW5kaWRhdGUuY2hhckF0KGluZGV4KTtcblxuICAgIGlmIChjaGFyQXRJbmRleCA9PT0gJ3gnIHx8IGNoYXJBdEluZGV4ID09PSAnWCcpIHtcbiAgICAgIHZhciBjaGFyQXROZXh0SW5kZXggPSBjYW5kaWRhdGUuY2hhckF0KGluZGV4ICsgMSk7XG5cbiAgICAgIGlmIChjaGFyQXROZXh0SW5kZXggPT09ICd4JyB8fCBjaGFyQXROZXh0SW5kZXggPT09ICdYJykge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBjYXJyaWVyIGNvZGUgY2FzZSwgaW4gd2hpY2ggdGhlICdYJ3MgYWx3YXlzIHByZWNlZGUgdGhlIG5hdGlvbmFsXG4gICAgICAgIC8vIHNpZ25pZmljYW50IG51bWJlci5cbiAgICAgICAgaW5kZXgrKztcblxuICAgICAgICBpZiAodXRpbC5pc051bWJlck1hdGNoKG51bWJlciwgY2FuZGlkYXRlLnN1YnN0cmluZyhpbmRleCkpICE9IE1hdGNoVHlwZS5OU05fTUFUQ0gpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gLy8gVGhpcyBpcyB0aGUgZXh0ZW5zaW9uIHNpZ24gY2FzZSwgaW4gd2hpY2ggdGhlICd4JyBvciAnWCcgc2hvdWxkIGFsd2F5cyBwcmVjZWRlIHRoZVxuICAgICAgICAvLyBleHRlbnNpb24gbnVtYmVyLlxuXG4gICAgICB9IGVsc2UgaWYgKHBhcnNlRGlnaXRzKGNhbmRpZGF0ZS5zdWJzdHJpbmcoaW5kZXgpKSAhPT0gbnVtYmVyLmV4dCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzTmF0aW9uYWxQcmVmaXhQcmVzZW50SWZSZXF1aXJlZChudW1iZXIsIF9tZXRhZGF0YSkge1xuICAvLyBGaXJzdCwgY2hlY2sgaG93IHdlIGRlZHVjZWQgdGhlIGNvdW50cnkgY29kZS4gSWYgaXQgd2FzIHdyaXR0ZW4gaW4gaW50ZXJuYXRpb25hbCBmb3JtYXQsIHRoZW5cbiAgLy8gdGhlIG5hdGlvbmFsIHByZWZpeCBpcyBub3QgcmVxdWlyZWQuXG4gIGlmIChudW1iZXIuZ2V0Q291bnRyeUNvZGVTb3VyY2UoKSAhPSAnRlJPTV9ERUZBVUxUX0NPVU5UUlknKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgcGhvbmVOdW1iZXJSZWdpb24gPSB1dGlsLmdldFJlZ2lvbkNvZGVGb3JDb3VudHJ5Q29kZShudW1iZXIuZ2V0Q291bnRyeUNvZGUoKSk7XG4gIHZhciBtZXRhZGF0YSA9IHV0aWwuZ2V0TWV0YWRhdGFGb3JSZWdpb24ocGhvbmVOdW1iZXJSZWdpb24pO1xuXG4gIGlmIChtZXRhZGF0YSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gQ2hlY2sgaWYgYSBuYXRpb25hbCBwcmVmaXggc2hvdWxkIGJlIHByZXNlbnQgd2hlbiBmb3JtYXR0aW5nIHRoaXMgbnVtYmVyLlxuXG5cbiAgdmFyIG5hdGlvbmFsTnVtYmVyID0gdXRpbC5nZXROYXRpb25hbFNpZ25pZmljYW50TnVtYmVyKG51bWJlcik7XG4gIHZhciBmb3JtYXRSdWxlID0gdXRpbC5jaG9vc2VGb3JtYXR0aW5nUGF0dGVybkZvck51bWJlcihtZXRhZGF0YS5udW1iZXJGb3JtYXRzKCksIG5hdGlvbmFsTnVtYmVyKTsgLy8gVG8gZG8gdGhpcywgd2UgY2hlY2sgdGhhdCBhIG5hdGlvbmFsIHByZWZpeCBmb3JtYXR0aW5nIHJ1bGUgd2FzIHByZXNlbnRcbiAgLy8gYW5kIHRoYXQgaXQgd2Fzbid0IGp1c3QgdGhlIGZpcnN0LWdyb3VwIHN5bWJvbCAoJDEpIHdpdGggcHVuY3R1YXRpb24uXG5cbiAgaWYgKGZvcm1hdFJ1bGUgJiYgZm9ybWF0UnVsZS5nZXROYXRpb25hbFByZWZpeEZvcm1hdHRpbmdSdWxlKCkubGVuZ3RoID4gMCkge1xuICAgIGlmIChmb3JtYXRSdWxlLmdldE5hdGlvbmFsUHJlZml4T3B0aW9uYWxXaGVuRm9ybWF0dGluZygpKSB7XG4gICAgICAvLyBUaGUgbmF0aW9uYWwtcHJlZml4IGlzIG9wdGlvbmFsIGluIHRoZXNlIGNhc2VzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIGlmIGl0IHdhc1xuICAgICAgLy8gcHJlc2VudC5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChQaG9uZU51bWJlclV0aWwuZm9ybWF0dGluZ1J1bGVIYXNGaXJzdEdyb3VwT25seShmb3JtYXRSdWxlLmdldE5hdGlvbmFsUHJlZml4Rm9ybWF0dGluZ1J1bGUoKSkpIHtcbiAgICAgIC8vIE5hdGlvbmFsIFByZWZpeCBub3QgbmVlZGVkIGZvciB0aGlzIG51bWJlci5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTm9ybWFsaXplIHRoZSByZW1haW5kZXIuXG5cblxuICAgIHZhciByYXdJbnB1dENvcHkgPSBQaG9uZU51bWJlclV0aWwubm9ybWFsaXplRGlnaXRzT25seShudW1iZXIuZ2V0UmF3SW5wdXQoKSk7IC8vIENoZWNrIGlmIHdlIGZvdW5kIGEgbmF0aW9uYWwgcHJlZml4IGFuZC9vciBjYXJyaWVyIGNvZGUgYXQgdGhlIHN0YXJ0IG9mIHRoZSByYXcgaW5wdXQsIGFuZFxuICAgIC8vIHJldHVybiB0aGUgcmVzdWx0LlxuXG4gICAgcmV0dXJuIHV0aWwubWF5YmVTdHJpcE5hdGlvbmFsUHJlZml4QW5kQ2FycmllckNvZGUocmF3SW5wdXRDb3B5LCBtZXRhZGF0YSwgbnVsbCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNNb3JlVGhhbk9uZVNsYXNoSW5OYXRpb25hbE51bWJlcihudW1iZXIsIGNhbmRpZGF0ZSkge1xuICB2YXIgZmlyc3RTbGFzaEluQm9keUluZGV4ID0gY2FuZGlkYXRlLmluZGV4T2YoJy8nKTtcblxuICBpZiAoZmlyc3RTbGFzaEluQm9keUluZGV4IDwgMCkge1xuICAgIC8vIE5vIHNsYXNoZXMsIHRoaXMgaXMgb2theS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gTm93IGxvb2sgZm9yIGEgc2Vjb25kIG9uZS5cblxuXG4gIHZhciBzZWNvbmRTbGFzaEluQm9keUluZGV4ID0gY2FuZGlkYXRlLmluZGV4T2YoJy8nLCBmaXJzdFNsYXNoSW5Cb2R5SW5kZXggKyAxKTtcblxuICBpZiAoc2Vjb25kU2xhc2hJbkJvZHlJbmRleCA8IDApIHtcbiAgICAvLyBPbmx5IG9uZSBzbGFzaCwgdGhpcyBpcyBva2F5LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJZiB0aGUgZmlyc3Qgc2xhc2ggaXMgYWZ0ZXIgdGhlIGNvdW50cnkgY2FsbGluZyBjb2RlLCB0aGlzIGlzIHBlcm1pdHRlZC5cblxuXG4gIHZhciBjYW5kaWRhdGVIYXNDb3VudHJ5Q29kZSA9IG51bWJlci5nZXRDb3VudHJ5Q29kZVNvdXJjZSgpID09PSBDb3VudHJ5Q29kZVNvdXJjZS5GUk9NX05VTUJFUl9XSVRIX1BMVVNfU0lHTiB8fCBudW1iZXIuZ2V0Q291bnRyeUNvZGVTb3VyY2UoKSA9PT0gQ291bnRyeUNvZGVTb3VyY2UuRlJPTV9OVU1CRVJfV0lUSE9VVF9QTFVTX1NJR047XG5cbiAgaWYgKGNhbmRpZGF0ZUhhc0NvdW50cnlDb2RlICYmIFBob25lTnVtYmVyVXRpbC5ub3JtYWxpemVEaWdpdHNPbmx5KGNhbmRpZGF0ZS5zdWJzdHJpbmcoMCwgZmlyc3RTbGFzaEluQm9keUluZGV4KSkgPT09IFN0cmluZyhudW1iZXIuZ2V0Q291bnRyeUNvZGUoKSkpIHtcbiAgICAvLyBBbnkgbW9yZSBzbGFzaGVzIGFuZCB0aGlzIGlzIGlsbGVnYWwuXG4gICAgcmV0dXJuIGNhbmRpZGF0ZS5zbGljZShzZWNvbmRTbGFzaEluQm9keUluZGV4ICsgMSkuaW5kZXhPZignLycpID49IDA7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tOdW1iZXJHcm91cGluZ0lzVmFsaWQobnVtYmVyLCBjYW5kaWRhdGUsIG1ldGFkYXRhLCBjaGVja0dyb3VwcywgcmVnRXhwQ2FjaGUpIHtcbiAgdmFyIG5vcm1hbGl6ZWRDYW5kaWRhdGUgPSBub3JtYWxpemVEaWdpdHMoY2FuZGlkYXRlLCB0cnVlXG4gIC8qIGtlZXAgbm9uLWRpZ2l0cyAqL1xuICApO1xuICB2YXIgZm9ybWF0dGVkTnVtYmVyR3JvdXBzID0gZ2V0TmF0aW9uYWxOdW1iZXJHcm91cHMobWV0YWRhdGEsIG51bWJlciwgbnVsbCk7XG5cbiAgaWYgKGNoZWNrR3JvdXBzKG1ldGFkYXRhLCBudW1iZXIsIG5vcm1hbGl6ZWRDYW5kaWRhdGUsIGZvcm1hdHRlZE51bWJlckdyb3VwcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJZiB0aGlzIGRpZG4ndCBwYXNzLCBzZWUgaWYgdGhlcmUgYXJlIGFueSBhbHRlcm5hdGUgZm9ybWF0cyB0aGF0IG1hdGNoLCBhbmQgdHJ5IHRoZW0gaW5zdGVhZC5cblxuXG4gIHZhciBhbHRlcm5hdGVGb3JtYXRzID0gTWV0YWRhdGFNYW5hZ2VyLmdldEFsdGVybmF0ZUZvcm1hdHNGb3JDb3VudHJ5KG51bWJlci5nZXRDb3VudHJ5Q29kZSgpKTtcbiAgdmFyIG5hdGlvbmFsU2lnbmlmaWNhbnROdW1iZXIgPSB1dGlsLmdldE5hdGlvbmFsU2lnbmlmaWNhbnROdW1iZXIobnVtYmVyKTtcblxuICBpZiAoYWx0ZXJuYXRlRm9ybWF0cykge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGFsdGVybmF0ZUZvcm1hdHMubnVtYmVyRm9ybWF0cygpLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWx0ZXJuYXRlRm9ybWF0ID0gX3JlZjtcblxuICAgICAgaWYgKGFsdGVybmF0ZUZvcm1hdC5sZWFkaW5nRGlnaXRzUGF0dGVybnMoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG9ubHkgb25lIGxlYWRpbmcgZGlnaXRzIHBhdHRlcm4gZm9yIGFsdGVybmF0ZSBmb3JtYXRzLlxuICAgICAgICB2YXIgbGVhZGluZ0RpZ2l0c1JlZ0V4cCA9IHJlZ0V4cENhY2hlLmdldFBhdHRlcm5Gb3JSZWdFeHAoJ14nICsgYWx0ZXJuYXRlRm9ybWF0LmxlYWRpbmdEaWdpdHNQYXR0ZXJucygpWzBdKTtcblxuICAgICAgICBpZiAoIWxlYWRpbmdEaWdpdHNSZWdFeHAudGVzdChuYXRpb25hbFNpZ25pZmljYW50TnVtYmVyKSkge1xuICAgICAgICAgIC8vIExlYWRpbmcgZGlnaXRzIGRvbid0IG1hdGNoOyB0cnkgYW5vdGhlciBvbmUuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9ybWF0dGVkTnVtYmVyR3JvdXBzID0gZ2V0TmF0aW9uYWxOdW1iZXJHcm91cHMobWV0YWRhdGEsIG51bWJlciwgYWx0ZXJuYXRlRm9ybWF0KTtcblxuICAgICAgaWYgKGNoZWNrR3JvdXBzKG1ldGFkYXRhLCBudW1iZXIsIG5vcm1hbGl6ZWRDYW5kaWRhdGUsIGZvcm1hdHRlZE51bWJlckdyb3VwcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXHJcbiAqIEhlbHBlciBtZXRob2QgdG8gZ2V0IHRoZSBuYXRpb25hbC1udW1iZXIgcGFydCBvZiBhIG51bWJlciwgZm9ybWF0dGVkIHdpdGhvdXQgYW55IG5hdGlvbmFsXHJcbiAqIHByZWZpeCwgYW5kIHJldHVybiBpdCBhcyBhIHNldCBvZiBkaWdpdCBibG9ja3MgdGhhdCB3b3VsZCBiZSBmb3JtYXR0ZWQgdG9nZXRoZXIgZm9sbG93aW5nXHJcbiAqIHN0YW5kYXJkIGZvcm1hdHRpbmcgcnVsZXMuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE5hdGlvbmFsTnVtYmVyR3JvdXBzKG1ldGFkYXRhLCBudW1iZXIsIGZvcm1hdHRpbmdQYXR0ZXJuKSB7XG4gIGlmIChmb3JtYXR0aW5nUGF0dGVybikge1xuICAgIC8vIFdlIGZvcm1hdCB0aGUgTlNOIG9ubHksIGFuZCBzcGxpdCB0aGF0IGFjY29yZGluZyB0byB0aGUgc2VwYXJhdG9yLlxuICAgIHZhciBuYXRpb25hbFNpZ25pZmljYW50TnVtYmVyID0gdXRpbC5nZXROYXRpb25hbFNpZ25pZmljYW50TnVtYmVyKG51bWJlcik7XG4gICAgcmV0dXJuIHV0aWwuZm9ybWF0TnNuVXNpbmdQYXR0ZXJuKG5hdGlvbmFsU2lnbmlmaWNhbnROdW1iZXIsIGZvcm1hdHRpbmdQYXR0ZXJuLCAnUkZDMzk2NicsIG1ldGFkYXRhKS5zcGxpdCgnLScpO1xuICB9IC8vIFRoaXMgd2lsbCBiZSBpbiB0aGUgZm9ybWF0ICtDQy1ERzEtREcyLURHWDtleHQ9RVhUIHdoZXJlIERHMS4uREdYIHJlcHJlc2VudHMgZ3JvdXBzIG9mIGRpZ2l0cy5cblxuXG4gIHZhciByZmMzOTY2Rm9ybWF0ID0gZm9ybWF0TnVtYmVyKG51bWJlciwgJ1JGQzM5NjYnLCBtZXRhZGF0YSk7IC8vIFdlIHJlbW92ZSB0aGUgZXh0ZW5zaW9uIHBhcnQgZnJvbSB0aGUgZm9ybWF0dGVkIHN0cmluZyBiZWZvcmUgc3BsaXR0aW5nIGl0IGludG8gZGlmZmVyZW50XG4gIC8vIGdyb3Vwcy5cblxuICB2YXIgZW5kSW5kZXggPSByZmMzOTY2Rm9ybWF0LmluZGV4T2YoJzsnKTtcblxuICBpZiAoZW5kSW5kZXggPCAwKSB7XG4gICAgZW5kSW5kZXggPSByZmMzOTY2Rm9ybWF0Lmxlbmd0aDtcbiAgfSAvLyBUaGUgY291bnRyeS1jb2RlIHdpbGwgaGF2ZSBhICctJyBmb2xsb3dpbmcgaXQuXG5cblxuICB2YXIgc3RhcnRJbmRleCA9IHJmYzM5NjZGb3JtYXQuaW5kZXhPZignLScpICsgMTtcbiAgcmV0dXJuIHJmYzM5NjZGb3JtYXQuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpLnNwbGl0KCctJyk7XG59XG5cbmZ1bmN0aW9uIGFsbE51bWJlckdyb3Vwc0FyZUV4YWN0bHlQcmVzZW50KG1ldGFkYXRhLCBudW1iZXIsIG5vcm1hbGl6ZWRDYW5kaWRhdGUsIGZvcm1hdHRlZE51bWJlckdyb3Vwcykge1xuICB2YXIgY2FuZGlkYXRlR3JvdXBzID0gbm9ybWFsaXplZENhbmRpZGF0ZS5zcGxpdChOT05fRElHSVRTX1BBVFRFUk4pOyAvLyBTZXQgdGhpcyB0byB0aGUgbGFzdCBncm91cCwgc2tpcHBpbmcgaXQgaWYgdGhlIG51bWJlciBoYXMgYW4gZXh0ZW5zaW9uLlxuXG4gIHZhciBjYW5kaWRhdGVOdW1iZXJHcm91cEluZGV4ID0gbnVtYmVyLmhhc0V4dGVuc2lvbigpID8gY2FuZGlkYXRlR3JvdXBzLmxlbmd0aCAtIDIgOiBjYW5kaWRhdGVHcm91cHMubGVuZ3RoIC0gMTsgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIG5hdGlvbmFsIHNpZ25pZmljYW50IG51bWJlciBpcyBmb3JtYXR0ZWQgYXMgYSBibG9jay5cbiAgLy8gV2UgdXNlIGNvbnRhaW5zIGFuZCBub3QgZXF1YWxzLCBzaW5jZSB0aGUgbmF0aW9uYWwgc2lnbmlmaWNhbnQgbnVtYmVyIG1heSBiZSBwcmVzZW50IHdpdGhcbiAgLy8gYSBwcmVmaXggc3VjaCBhcyBhIG5hdGlvbmFsIG51bWJlciBwcmVmaXgsIG9yIHRoZSBjb3VudHJ5IGNvZGUgaXRzZWxmLlxuXG4gIGlmIChjYW5kaWRhdGVHcm91cHMubGVuZ3RoID09IDEgfHwgY2FuZGlkYXRlR3JvdXBzW2NhbmRpZGF0ZU51bWJlckdyb3VwSW5kZXhdLmNvbnRhaW5zKHV0aWwuZ2V0TmF0aW9uYWxTaWduaWZpY2FudE51bWJlcihudW1iZXIpKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFN0YXJ0aW5nIGZyb20gdGhlIGVuZCwgZ28gdGhyb3VnaCBpbiByZXZlcnNlLCBleGNsdWRpbmcgdGhlIGZpcnN0IGdyb3VwLCBhbmQgY2hlY2sgdGhlXG4gIC8vIGNhbmRpZGF0ZSBhbmQgbnVtYmVyIGdyb3VwcyBhcmUgdGhlIHNhbWUuXG5cblxuICB2YXIgZm9ybWF0dGVkTnVtYmVyR3JvdXBJbmRleCA9IGZvcm1hdHRlZE51bWJlckdyb3Vwcy5sZW5ndGggLSAxO1xuXG4gIHdoaWxlIChmb3JtYXR0ZWROdW1iZXJHcm91cEluZGV4ID4gMCAmJiBjYW5kaWRhdGVOdW1iZXJHcm91cEluZGV4ID49IDApIHtcbiAgICBpZiAoY2FuZGlkYXRlR3JvdXBzW2NhbmRpZGF0ZU51bWJlckdyb3VwSW5kZXhdICE9PSBmb3JtYXR0ZWROdW1iZXJHcm91cHNbZm9ybWF0dGVkTnVtYmVyR3JvdXBJbmRleF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3JtYXR0ZWROdW1iZXJHcm91cEluZGV4LS07XG4gICAgY2FuZGlkYXRlTnVtYmVyR3JvdXBJbmRleC0tO1xuICB9IC8vIE5vdyBjaGVjayB0aGUgZmlyc3QgZ3JvdXAuIFRoZXJlIG1heSBiZSBhIG5hdGlvbmFsIHByZWZpeCBhdCB0aGUgc3RhcnQsIHNvIHdlIG9ubHkgY2hlY2tcbiAgLy8gdGhhdCB0aGUgY2FuZGlkYXRlIGdyb3VwIGVuZHMgd2l0aCB0aGUgZm9ybWF0dGVkIG51bWJlciBncm91cC5cblxuXG4gIHJldHVybiBjYW5kaWRhdGVOdW1iZXJHcm91cEluZGV4ID49IDAgJiYgZW5kc1dpdGgoY2FuZGlkYXRlR3JvdXBzW2NhbmRpZGF0ZU51bWJlckdyb3VwSW5kZXhdLCBmb3JtYXR0ZWROdW1iZXJHcm91cHNbMF0pO1xufVxuXG5mdW5jdGlvbiBhbGxOdW1iZXJHcm91cHNSZW1haW5Hcm91cGVkKG1ldGFkYXRhLCBudW1iZXIsIG5vcm1hbGl6ZWRDYW5kaWRhdGUsIGZvcm1hdHRlZE51bWJlckdyb3Vwcykge1xuICB2YXIgZnJvbUluZGV4ID0gMDtcblxuICBpZiAobnVtYmVyLmdldENvdW50cnlDb2RlU291cmNlKCkgIT09IENvdW50cnlDb2RlU291cmNlLkZST01fREVGQVVMVF9DT1VOVFJZKSB7XG4gICAgLy8gRmlyc3Qgc2tpcCB0aGUgY291bnRyeSBjb2RlIGlmIHRoZSBub3JtYWxpemVkIGNhbmRpZGF0ZSBjb250YWluZWQgaXQuXG4gICAgdmFyIGNvdW50cnlDb2RlID0gU3RyaW5nKG51bWJlci5nZXRDb3VudHJ5Q29kZSgpKTtcbiAgICBmcm9tSW5kZXggPSBub3JtYWxpemVkQ2FuZGlkYXRlLmluZGV4T2YoY291bnRyeUNvZGUpICsgY291bnRyeUNvZGUubGVuZ3RoKCk7XG4gIH0gLy8gQ2hlY2sgZWFjaCBncm91cCBvZiBjb25zZWN1dGl2ZSBkaWdpdHMgYXJlIG5vdCBicm9rZW4gaW50byBzZXBhcmF0ZSBncm91cGluZ3MgaW4gdGhlXG4gIC8vIHtAY29kZSBub3JtYWxpemVkQ2FuZGlkYXRlfSBzdHJpbmcuXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcm1hdHRlZE51bWJlckdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIEZhaWxzIGlmIHRoZSBzdWJzdHJpbmcgb2Yge0Bjb2RlIG5vcm1hbGl6ZWRDYW5kaWRhdGV9IHN0YXJ0aW5nIGZyb20ge0Bjb2RlIGZyb21JbmRleH1cbiAgICAvLyBkb2Vzbid0IGNvbnRhaW4gdGhlIGNvbnNlY3V0aXZlIGRpZ2l0cyBpbiBmb3JtYXR0ZWROdW1iZXJHcm91cHNbaV0uXG4gICAgZnJvbUluZGV4ID0gbm9ybWFsaXplZENhbmRpZGF0ZS5pbmRleE9mKGZvcm1hdHRlZE51bWJlckdyb3Vwc1tpXSwgZnJvbUluZGV4KTtcblxuICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBNb3ZlcyB7QGNvZGUgZnJvbUluZGV4fSBmb3J3YXJkLlxuXG5cbiAgICBmcm9tSW5kZXggKz0gZm9ybWF0dGVkTnVtYmVyR3JvdXBzW2ldLmxlbmd0aCgpO1xuXG4gICAgaWYgKGkgPT0gMCAmJiBmcm9tSW5kZXggPCBub3JtYWxpemVkQ2FuZGlkYXRlLmxlbmd0aCgpKSB7XG4gICAgICAvLyBXZSBhcmUgYXQgdGhlIHBvc2l0aW9uIHJpZ2h0IGFmdGVyIHRoZSBOREMuIFdlIGdldCB0aGUgcmVnaW9uIHVzZWQgZm9yIGZvcm1hdHRpbmdcbiAgICAgIC8vIGluZm9ybWF0aW9uIGJhc2VkIG9uIHRoZSBjb3VudHJ5IGNvZGUgaW4gdGhlIHBob25lIG51bWJlciwgcmF0aGVyIHRoYW4gdGhlIG51bWJlciBpdHNlbGYsXG4gICAgICAvLyBhcyB3ZSBkbyBub3QgbmVlZCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGRpZmZlcmVudCBjb3VudHJpZXMgd2l0aCB0aGUgc2FtZSBjb3VudHJ5XG4gICAgICAvLyBjYWxsaW5nIGNvZGUgYW5kIHRoaXMgaXMgZmFzdGVyLlxuICAgICAgdmFyIHJlZ2lvbiA9IHV0aWwuZ2V0UmVnaW9uQ29kZUZvckNvdW50cnlDb2RlKG51bWJlci5nZXRDb3VudHJ5Q29kZSgpKTtcblxuICAgICAgaWYgKHV0aWwuZ2V0TmRkUHJlZml4Rm9yUmVnaW9uKHJlZ2lvbiwgdHJ1ZSkgIT0gbnVsbCAmJiBDaGFyYWN0ZXIuaXNEaWdpdChub3JtYWxpemVkQ2FuZGlkYXRlLmNoYXJBdChmcm9tSW5kZXgpKSkge1xuICAgICAgICAvLyBUaGlzIG1lYW5zIHRoZXJlIGlzIG5vIGZvcm1hdHRpbmcgc3ltYm9sIGFmdGVyIHRoZSBOREMuIEluIHRoaXMgY2FzZSwgd2Ugb25seVxuICAgICAgICAvLyBhY2NlcHQgdGhlIG51bWJlciBpZiB0aGVyZSBpcyBubyBmb3JtYXR0aW5nIHN5bWJvbCBhdCBhbGwgaW4gdGhlIG51bWJlciwgZXhjZXB0XG4gICAgICAgIC8vIGZvciBleHRlbnNpb25zLiBUaGlzIGlzIG9ubHkgaW1wb3J0YW50IGZvciBjb3VudHJpZXMgd2l0aCBuYXRpb25hbCBwcmVmaXhlcy5cbiAgICAgICAgdmFyIG5hdGlvbmFsU2lnbmlmaWNhbnROdW1iZXIgPSB1dGlsLmdldE5hdGlvbmFsU2lnbmlmaWNhbnROdW1iZXIobnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0c1dpdGgobm9ybWFsaXplZENhbmRpZGF0ZS5zbGljZShmcm9tSW5kZXggLSBmb3JtYXR0ZWROdW1iZXJHcm91cHNbaV0ubGVuZ3RoKSwgbmF0aW9uYWxTaWduaWZpY2FudE51bWJlcik7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFRoZSBjaGVjayBoZXJlIG1ha2VzIHN1cmUgdGhhdCB3ZSBoYXZlbid0IG1pc3Rha2VubHkgYWxyZWFkeSB1c2VkIHRoZSBleHRlbnNpb24gdG9cbiAgLy8gbWF0Y2ggdGhlIGxhc3QgZ3JvdXAgb2YgdGhlIHN1YnNjcmliZXIgbnVtYmVyLiBOb3RlIHRoZSBleHRlbnNpb24gY2Fubm90IGhhdmVcbiAgLy8gZm9ybWF0dGluZyBpbi1iZXR3ZWVuIGRpZ2l0cy5cblxuXG4gIHJldHVybiBub3JtYWxpemVkQ2FuZGlkYXRlLnNsaWNlKGZyb21JbmRleCkuY29udGFpbnMobnVtYmVyLmdldEV4dGVuc2lvbigpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlbmllbmN5LmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvZXM2L1Bob25lTnVtYmVyTWF0Y2hlci5qc1xuZnVuY3Rpb24gUGhvbmVOdW1iZXJNYXRjaGVyX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBQaG9uZU51bWJlck1hdGNoZXJfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBQaG9uZU51bWJlck1hdGNoZXJfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBQaG9uZU51bWJlck1hdGNoZXJfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIFBob25lTnVtYmVyTWF0Y2hlcl9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIFBob25lTnVtYmVyTWF0Y2hlcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgUGhvbmVOdW1iZXJNYXRjaGVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIFBob25lTnVtYmVyTWF0Y2hlcl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKlxyXG4gKiBBIHBvcnQgb2YgR29vZ2xlJ3MgYFBob25lTnVtYmVyTWF0Y2hlci5qYXZhYC5cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWkxOG4vbGlicGhvbmVudW1iZXIvYmxvYi9tYXN0ZXIvamF2YS9saWJwaG9uZW51bWJlci9zcmMvY29tL2dvb2dsZS9pMThuL3Bob25lbnVtYmVycy9QaG9uZU51bWJlck1hdGNoZXIuamF2YVxyXG4gKiBEYXRlOiAwOC4wMy4yMDE4LlxyXG4gKi9cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qKlxyXG4gKiBQYXR0ZXJucyB1c2VkIHRvIGV4dHJhY3QgcGhvbmUgbnVtYmVycyBmcm9tIGEgbGFyZ2VyIHBob25lLW51bWJlci1saWtlIHBhdHRlcm4uIFRoZXNlIGFyZVxyXG4gKiBvcmRlcmVkIGFjY29yZGluZyB0byBzcGVjaWZpY2l0eS4gRm9yIGV4YW1wbGUsIHdoaXRlLXNwYWNlIGlzIGxhc3Qgc2luY2UgdGhhdCBpcyBmcmVxdWVudGx5XHJcbiAqIHVzZWQgaW4gbnVtYmVycywgbm90IGp1c3QgdG8gc2VwYXJhdGUgdHdvIG51bWJlcnMuIFdlIGhhdmUgc2VwYXJhdGUgcGF0dGVybnMgc2luY2Ugd2UgZG9uJ3RcclxuICogd2FudCB0byBicmVhayB1cCB0aGUgcGhvbmUtbnVtYmVyLWxpa2UgdGV4dCBvbiBtb3JlIHRoYW4gb25lIGRpZmZlcmVudCBraW5kIG9mIHN5bWJvbCBhdCBvbmVcclxuICogdGltZSwgYWx0aG91Z2ggc3ltYm9scyBvZiB0aGUgc2FtZSB0eXBlIChlLmcuIHNwYWNlKSBjYW4gYmUgc2FmZWx5IGdyb3VwZWQgdG9nZXRoZXIuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBpZiB0aGVyZSBpcyBhIG1hdGNoLCB3ZSB3aWxsIGFsd2F5cyBjaGVjayBhbnkgdGV4dCBmb3VuZCB1cCB0byB0aGUgZmlyc3QgbWF0Y2ggYXNcclxuICogd2VsbC5cclxuICovXG5cbnZhciBJTk5FUl9NQVRDSEVTID0gWy8vIEJyZWFrcyBvbiB0aGUgc2xhc2ggLSBlLmcuIFwiNjUxLTIzNC0yMzQ1LzMzMi00NDUtMTIzNFwiXG4nXFxcXC8rKC4qKS8nLCAvLyBOb3RlIHRoYXQgdGhlIGJyYWNrZXQgaGVyZSBpcyBpbnNpZGUgdGhlIGNhcHR1cmluZyBncm91cCwgc2luY2Ugd2UgY29uc2lkZXIgaXQgcGFydCBvZiB0aGVcbi8vIHBob25lIG51bWJlci4gV2lsbCBtYXRjaCBhIHBhdHRlcm4gbGlrZSBcIig2NTApIDIyMyAzMzQ1ICg3NTQpIDIyMyAzMzIxXCIuXG4nKFxcXFwoW14oXSopJywgLy8gQnJlYWtzIG9uIGEgaHlwaGVuIC0gZS5nLiBcIjEyMzQ1IC0gMzMyLTQ0NS0xMjM0IGlzIG15IG51bWJlci5cIlxuLy8gV2UgcmVxdWlyZSBhIHNwYWNlIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBoeXBoZW4gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSBzZXBhcmF0b3IuXG5cIig/OlwiLmNvbmNhdChwWiwgXCItfC1cIikuY29uY2F0KHBaLCBcIilcIikuY29uY2F0KHBaLCBcIiooLispXCIpLCAvLyBWYXJpb3VzIHR5cGVzIG9mIHdpZGUgaHlwaGVucy4gTm90ZSB3ZSBoYXZlIGRlY2lkZWQgbm90IHRvIGVuZm9yY2UgYSBzcGFjZSBoZXJlLCBzaW5jZSBpdCdzXG4vLyBwb3NzaWJsZSB0aGF0IGl0J3Mgc3VwcG9zZWQgdG8gYmUgdXNlZCB0byBicmVhayB0d28gbnVtYmVycyB3aXRob3V0IHNwYWNlcywgYW5kIHdlIGhhdmVuJ3Rcbi8vIHNlZW4gbWFueSBpbnN0YW5jZXMgb2YgaXQgdXNlZCB3aXRoaW4gYSBudW1iZXIuXG5cIltcXHUyMDEyLVxcdTIwMTVcXHVGRjBEXVwiLmNvbmNhdChwWiwgXCIqKC4rKVwiKSwgLy8gQnJlYWtzIG9uIGEgZnVsbCBzdG9wIC0gZS5nLiBcIjEyMzQ1LiAzMzItNDQ1LTEyMzQgaXMgbXkgbnVtYmVyLlwiXG5cIlxcXFwuK1wiLmNvbmNhdChwWiwgXCIqKFteLl0rKVwiKSwgLy8gQnJlYWtzIG9uIHNwYWNlIC0gZS5nLiBcIjMzMjQ0NTEyMzQgODAwMjM0MTIzNFwiXG5cIlwiLmNvbmNhdChwWiwgXCIrKFwiKS5jb25jYXQoUFosIFwiKylcIildOyAvLyBMaW1pdCBvbiB0aGUgbnVtYmVyIG9mIGxlYWRpbmcgKHBsdXMpIGNoYXJhY3RlcnMuXG5cbnZhciBsZWFkTGltaXQgPSBsaW1pdCgwLCAyKTsgLy8gTGltaXQgb24gdGhlIG51bWJlciBvZiBjb25zZWN1dGl2ZSBwdW5jdHVhdGlvbiBjaGFyYWN0ZXJzLlxuXG52YXIgcHVuY3R1YXRpb25MaW1pdCA9IGxpbWl0KDAsIDQpO1xuLyogVGhlIG1heGltdW0gbnVtYmVyIG9mIGRpZ2l0cyBhbGxvd2VkIGluIGEgZGlnaXQtc2VwYXJhdGVkIGJsb2NrLiBBcyB3ZSBhbGxvdyBhbGwgZGlnaXRzIGluIGFcclxuICogc2luZ2xlIGJsb2NrLCBzZXQgaGlnaCBlbm91Z2ggdG8gYWNjb21tb2RhdGUgdGhlIGVudGlyZSBuYXRpb25hbCBudW1iZXIgYW5kIHRoZSBpbnRlcm5hdGlvbmFsXHJcbiAqIGNvdW50cnkgY29kZS4gKi9cblxudmFyIGRpZ2l0QmxvY2tMaW1pdCA9IE1BWF9MRU5HVEhfRk9SX05TTiArIE1BWF9MRU5HVEhfQ09VTlRSWV9DT0RFOyAvLyBMaW1pdCBvbiB0aGUgbnVtYmVyIG9mIGJsb2NrcyBzZXBhcmF0ZWQgYnkgcHVuY3R1YXRpb24uXG4vLyBVc2VzIGRpZ2l0QmxvY2tMaW1pdCBzaW5jZSBzb21lIGZvcm1hdHMgdXNlIHNwYWNlcyB0byBzZXBhcmF0ZSBlYWNoIGRpZ2l0LlxuXG52YXIgYmxvY2tMaW1pdCA9IGxpbWl0KDAsIGRpZ2l0QmxvY2tMaW1pdCk7XG4vKiBBIHB1bmN0dWF0aW9uIHNlcXVlbmNlIGFsbG93aW5nIHdoaXRlIHNwYWNlLiAqL1xuXG52YXIgcHVuY3R1YXRpb24gPSBcIltcIi5jb25jYXQoVkFMSURfUFVOQ1RVQVRJT04sIFwiXVwiKSArIHB1bmN0dWF0aW9uTGltaXQ7IC8vIEEgZGlnaXRzIGJsb2NrIHdpdGhvdXQgcHVuY3R1YXRpb24uXG5cbnZhciBkaWdpdFNlcXVlbmNlID0gcE5kICsgbGltaXQoMSwgZGlnaXRCbG9ja0xpbWl0KTtcbi8qKlxyXG4gKiBQaG9uZSBudW1iZXIgcGF0dGVybiBhbGxvd2luZyBvcHRpb25hbCBwdW5jdHVhdGlvbi5cclxuICogVGhlIHBob25lIG51bWJlciBwYXR0ZXJuIHVzZWQgYnkgYGZpbmQoKWAsIHNpbWlsYXIgdG9cclxuICogVkFMSURfUEhPTkVfTlVNQkVSLCBidXQgd2l0aCB0aGUgZm9sbG93aW5nIGRpZmZlcmVuY2VzOlxyXG4gKiA8dWw+XHJcbiAqICAgPGxpPkFsbCBjYXB0dXJlcyBhcmUgbGltaXRlZCBpbiBvcmRlciB0byBwbGFjZSBhbiB1cHBlciBib3VuZCB0byB0aGUgdGV4dCBtYXRjaGVkIGJ5IHRoZVxyXG4gKiAgICAgICBwYXR0ZXJuLlxyXG4gKiA8dWw+XHJcbiAqICAgPGxpPkxlYWRpbmcgcHVuY3R1YXRpb24gLyBwbHVzIHNpZ25zIGFyZSBsaW1pdGVkLlxyXG4gKiAgIDxsaT5Db25zZWN1dGl2ZSBvY2N1cnJlbmNlcyBvZiBwdW5jdHVhdGlvbiBhcmUgbGltaXRlZC5cclxuICogICA8bGk+TnVtYmVyIG9mIGRpZ2l0cyBpcyBsaW1pdGVkLlxyXG4gKiA8L3VsPlxyXG4gKiAgIDxsaT5ObyB3aGl0ZXNwYWNlIGlzIGFsbG93ZWQgYXQgdGhlIHN0YXJ0IG9yIGVuZC5cclxuICogICA8bGk+Tm8gYWxwaGEgZGlnaXRzICh2YW5pdHkgbnVtYmVycyBzdWNoIGFzIDEtODAwLVNJWC1GTEFHUykgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQuXHJcbiAqIDwvdWw+XHJcbiAqL1xuXG52YXIgUEFUVEVSTiA9ICcoPzonICsgTEVBRF9DTEFTUyArIHB1bmN0dWF0aW9uICsgJyknICsgbGVhZExpbWl0ICsgZGlnaXRTZXF1ZW5jZSArICcoPzonICsgcHVuY3R1YXRpb24gKyBkaWdpdFNlcXVlbmNlICsgJyknICsgYmxvY2tMaW1pdCArICcoPzonICsgRVhUTl9QQVRURVJOU19GT1JfTUFUQ0hJTkcgKyAnKT8nOyAvLyBSZWd1bGFyIGV4cHJlc3Npb24gb2YgdHJhaWxpbmcgY2hhcmFjdGVycyB0aGF0IHdlIHdhbnQgdG8gcmVtb3ZlLlxuLy8gV2UgcmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBhbHBoYSBvciBudW1lcmljYWwgY2hhcmFjdGVycy5cbi8vIFRoZSBoYXNoIGNoYXJhY3RlciBpcyByZXRhaW5lZCBoZXJlLCBhcyBpdCBtYXkgc2lnbmlmeVxuLy8gdGhlIHByZXZpb3VzIGJsb2NrIHdhcyBhbiBleHRlbnNpb24uXG4vL1xuLy8gLy8gRG9uJ3Qga25vdyB3aGF0IGRvZXMgJyYmJyBtZWFuIGhlcmUuXG4vLyBjb25zdCBVTldBTlRFRF9FTkRfQ0hBUl9QQVRURVJOID0gbmV3IFJlZ0V4cChgW1tcXFxcUHtOfSYmXFxcXFB7TH1dJiZbXiNdXSskYClcbi8vXG5cbnZhciBVTldBTlRFRF9FTkRfQ0hBUl9QQVRURVJOID0gbmV3IFJlZ0V4cChcIlteXCIuY29uY2F0KF9wTikuY29uY2F0KF9wTCwgXCIjXSskXCIpKTtcbnZhciBQaG9uZU51bWJlck1hdGNoZXJfTk9OX0RJR0lUU19QQVRURVJOID0gLyhcXEQrKS87XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IE1hdGgucG93KDIsIDUzKSAtIDE7XG4vKipcclxuICogQSBzdGF0ZWZ1bCBjbGFzcyB0aGF0IGZpbmRzIGFuZCBleHRyYWN0cyB0ZWxlcGhvbmUgbnVtYmVycyBmcm9tIHtAbGlua3BsYWluIENoYXJTZXF1ZW5jZSB0ZXh0fS5cclxuICogSW5zdGFuY2VzIGNhbiBiZSBjcmVhdGVkIHVzaW5nIHRoZSB7QGxpbmtwbGFpbiBQaG9uZU51bWJlclV0aWwjZmluZE51bWJlcnMgZmFjdG9yeSBtZXRob2RzfSBpblxyXG4gKiB7QGxpbmsgUGhvbmVOdW1iZXJVdGlsfS5cclxuICpcclxuICogPHA+VmFuaXR5IG51bWJlcnMgKHBob25lIG51bWJlcnMgdXNpbmcgYWxwaGFiZXRpYyBkaWdpdHMgc3VjaCBhcyA8dHQ+MS04MDAtU0lYLUZMQUdTPC90dD4gYXJlXHJcbiAqIG5vdCBmb3VuZC5cclxuICpcclxuICogPHA+VGhpcyBjbGFzcyBpcyBub3QgdGhyZWFkLXNhZmUuXHJcbiAqL1xuXG52YXIgUGhvbmVOdW1iZXJNYXRjaGVyX1Bob25lTnVtYmVyTWF0Y2hlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKiBUaGUgaXRlcmF0aW9uIHRyaXN0YXRlLiAqL1xuXG4gIC8qKiBUaGUgbmV4dCBpbmRleCB0byBzdGFydCBzZWFyY2hpbmcgYXQuIFVuZGVmaW5lZCBpbiB7QGxpbmsgU3RhdGUjRE9ORX0uICovXG4gIC8vIEEgY2FjaGUgZm9yIGZyZXF1ZW50bHkgdXNlZCBjb3VudHJ5LXNwZWNpZmljIHJlZ3VsYXIgZXhwcmVzc2lvbnMuIFNldCB0byAzMiB0byBjb3ZlciB+Mi0zXG4gIC8vIGNvdW50cmllcyBiZWluZyB1c2VkIGZvciB0aGUgc2FtZSBkb2Mgd2l0aCB+MTAgcGF0dGVybnMgZm9yIGVhY2ggY291bnRyeS4gU29tZSBwYWdlcyB3aWxsIGhhdmVcbiAgLy8gYSBsb3QgbW9yZSBjb3VudHJpZXMgaW4gdXNlLCBidXQgdHlwaWNhbGx5IGZld2VyIG51bWJlcnMgZm9yIGVhY2ggc28gZXhwYW5kaW5nIHRoZSBjYWNoZSBmb3JcbiAgLy8gdGhhdCB1c2UtY2FzZSB3b24ndCBoYXZlIGEgbG90IG9mIGJlbmVmaXQuXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZS4gU2VlIHRoZSBmYWN0b3J5IG1ldGhvZHMgaW4ge0BsaW5rIFBob25lTnVtYmVyVXRpbH0gb24gaG93IHRvIG9idGFpbiBhXHJcbiAgICogbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHV0aWwgIHRoZSBwaG9uZSBudW1iZXIgdXRpbCB0byB1c2VcclxuICAgKiBAcGFyYW0gdGV4dCAgdGhlIGNoYXJhY3RlciBzZXF1ZW5jZSB0aGF0IHdlIHdpbGwgc2VhcmNoLCBudWxsIGZvciBubyB0ZXh0XHJcbiAgICogQHBhcmFtIGNvdW50cnkgIHRoZSBjb3VudHJ5IHRvIGFzc3VtZSBmb3IgcGhvbmUgbnVtYmVycyBub3Qgd3JpdHRlbiBpbiBpbnRlcm5hdGlvbmFsIGZvcm1hdFxyXG4gICAqICAgICAod2l0aCBhIGxlYWRpbmcgcGx1cywgb3Igd2l0aCB0aGUgaW50ZXJuYXRpb25hbCBkaWFsaW5nIHByZWZpeCBvZiB0aGUgc3BlY2lmaWVkIHJlZ2lvbikuXHJcbiAgICogICAgIE1heSBiZSBudWxsIG9yIFwiWlpcIiBpZiBvbmx5IG51bWJlcnMgd2l0aCBhIGxlYWRpbmcgcGx1cyBzaG91bGQgYmVcclxuICAgKiAgICAgY29uc2lkZXJlZC5cclxuICAgKiBAcGFyYW0gbGVuaWVuY3kgIHRoZSBsZW5pZW5jeSB0byB1c2Ugd2hlbiBldmFsdWF0aW5nIGNhbmRpZGF0ZSBwaG9uZSBudW1iZXJzXHJcbiAgICogQHBhcmFtIG1heFRyaWVzICB0aGUgbWF4aW11bSBudW1iZXIgb2YgaW52YWxpZCBudW1iZXJzIHRvIHRyeSBiZWZvcmUgZ2l2aW5nIHVwIG9uIHRoZSB0ZXh0LlxyXG4gICAqICAgICBUaGlzIGlzIHRvIGNvdmVyIGRlZ2VuZXJhdGUgY2FzZXMgd2hlcmUgdGhlIHRleHQgaGFzIGEgbG90IG9mIGZhbHNlIHBvc2l0aXZlcyBpbiBpdC4gTXVzdFxyXG4gICAqICAgICBiZSB7QGNvZGUgPj0gMH0uXHJcbiAgICovXG4gIGZ1bmN0aW9uIFBob25lTnVtYmVyTWF0Y2hlcigpIHtcbiAgICB2YXIgdGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBtZXRhZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgUGhvbmVOdW1iZXJNYXRjaGVyX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBob25lTnVtYmVyTWF0Y2hlcik7XG5cbiAgICBQaG9uZU51bWJlck1hdGNoZXJfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCAnTk9UX1JFQURZJyk7XG5cbiAgICBQaG9uZU51bWJlck1hdGNoZXJfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZWFyY2hJbmRleFwiLCAwKTtcblxuICAgIFBob25lTnVtYmVyTWF0Y2hlcl9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZ0V4cENhY2hlXCIsIG5ldyBSZWdFeHBDYWNoZV9SZWdFeHBDYWNoZSgzMikpO1xuXG4gICAgb3B0aW9ucyA9IFBob25lTnVtYmVyTWF0Y2hlcl9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGRlZmF1bHRDYWxsaW5nQ29kZTogb3B0aW9ucy5kZWZhdWx0Q2FsbGluZ0NvZGUsXG4gICAgICBkZWZhdWx0Q291bnRyeTogb3B0aW9ucy5kZWZhdWx0Q291bnRyeSAmJiBpc1N1cHBvcnRlZENvdW50cnkob3B0aW9ucy5kZWZhdWx0Q291bnRyeSwgbWV0YWRhdGEpID8gb3B0aW9ucy5kZWZhdWx0Q291bnRyeSA6IHVuZGVmaW5lZCxcbiAgICAgIGxlbmllbmN5OiBvcHRpb25zLmxlbmllbmN5IHx8IG9wdGlvbnMuZXh0ZW5kZWQgPyAnUE9TU0lCTEUnIDogJ1ZBTElEJyxcbiAgICAgIG1heFRyaWVzOiBvcHRpb25zLm1heFRyaWVzIHx8IE1BWF9TQUZFX0lOVEVHRVJcbiAgICB9KTtcblxuICAgIGlmICghb3B0aW9ucy5sZW5pZW5jeSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYExlbmllbmN5YCBub3Qgc3VwcGxpZWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5tYXhUcmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BtYXhUcmllc2Agbm90IHN1cHBsaWVkJyk7XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAvKiogVGhlIGRlZ3JlZSBvZiB2YWxpZGF0aW9uIHJlcXVlc3RlZC4gKi9cblxuICAgIHRoaXMubGVuaWVuY3kgPSBMZW5pZW5jeVtvcHRpb25zLmxlbmllbmN5XTtcblxuICAgIGlmICghdGhpcy5sZW5pZW5jeSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gbGVuaWVuY3k6IFwiLmNvbmNhdChvcHRpb25zLmxlbmllbmN5LCBcIi5cIikpO1xuICAgIH1cbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMgYWZ0ZXIgbWF0Y2hpbmcgYW4gaW52YWxpZCBudW1iZXIuICovXG5cblxuICAgIHRoaXMubWF4VHJpZXMgPSBvcHRpb25zLm1heFRyaWVzO1xuICAgIHRoaXMuUEFUVEVSTiA9IG5ldyBSZWdFeHAoUEFUVEVSTiwgJ2lnJyk7XG4gIH1cbiAgLyoqXHJcbiAgICogQXR0ZW1wdHMgdG8gZmluZCB0aGUgbmV4dCBzdWJzZXF1ZW5jZSBpbiB0aGUgc2VhcmNoZWQgc2VxdWVuY2Ugb24gb3IgYWZ0ZXIge0Bjb2RlIHNlYXJjaEluZGV4fVxyXG4gICAqIHRoYXQgcmVwcmVzZW50cyBhIHBob25lIG51bWJlci4gUmV0dXJucyB0aGUgbmV4dCBtYXRjaCwgbnVsbCBpZiBub25lIHdhcyBmb3VuZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBpbmRleCAgdGhlIHNlYXJjaCBpbmRleCB0byBzdGFydCBzZWFyY2hpbmcgYXRcclxuICAgKiBAcmV0dXJuICB0aGUgcGhvbmUgbnVtYmVyIG1hdGNoIGZvdW5kLCBudWxsIGlmIG5vbmUgY2FuIGJlIGZvdW5kXHJcbiAgICovXG5cblxuICBQaG9uZU51bWJlck1hdGNoZXJfY3JlYXRlQ2xhc3MoUGhvbmVOdW1iZXJNYXRjaGVyLCBbe1xuICAgIGtleTogXCJmaW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmQoKSAvLyAoaW5kZXgpXG4gICAge1xuICAgICAgLy8gLy8gUmVzZXQgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgIC8vIHRoaXMuUEFUVEVSTi5sYXN0SW5kZXggPSBpbmRleFxuICAgICAgdmFyIG1hdGNoZXM7XG5cbiAgICAgIHdoaWxlICh0aGlzLm1heFRyaWVzID4gMCAmJiAobWF0Y2hlcyA9IHRoaXMuUEFUVEVSTi5leGVjKHRoaXMudGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSBtYXRjaGVzWzBdO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gbWF0Y2hlcy5pbmRleDtcbiAgICAgICAgY2FuZGlkYXRlID0gcGFyc2VQcmVDYW5kaWRhdGUoY2FuZGlkYXRlKTtcblxuICAgICAgICBpZiAoaXNWYWxpZFByZUNhbmRpZGF0ZShjYW5kaWRhdGUsIG9mZnNldCwgdGhpcy50ZXh0KSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IC8vIFRyeSB0byBjb21lIHVwIHdpdGggYSB2YWxpZCBtYXRjaCBnaXZlbiB0aGUgZW50aXJlIGNhbmRpZGF0ZS5cbiAgICAgICAgICB0aGlzLnBhcnNlQW5kVmVyaWZ5KGNhbmRpZGF0ZSwgb2Zmc2V0LCB0aGlzLnRleHQpIC8vIElmIHRoYXQgZmFpbGVkLCB0cnkgdG8gZmluZCBhbiBcImlubmVyIG1hdGNoXCIgLVxuICAgICAgICAgIC8vIHRoZXJlIG1pZ2h0IGJlIGEgcGhvbmUgbnVtYmVyIHdpdGhpbiB0aGlzIGNhbmRpZGF0ZS5cbiAgICAgICAgICB8fCB0aGlzLmV4dHJhY3RJbm5lck1hdGNoKGNhbmRpZGF0ZSwgb2Zmc2V0LCB0aGlzLnRleHQpO1xuXG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnYyKSB7XG4gICAgICAgICAgICAgIHZhciBwaG9uZU51bWJlciA9IG5ldyBQaG9uZU51bWJlcl9QaG9uZU51bWJlcihtYXRjaC5jb3VudHJ5IHx8IG1hdGNoLmNvdW50cnlDYWxsaW5nQ29kZSwgbWF0Y2gucGhvbmUsIHRoaXMubWV0YWRhdGEpO1xuXG4gICAgICAgICAgICAgIGlmIChtYXRjaC5leHQpIHtcbiAgICAgICAgICAgICAgICBwaG9uZU51bWJlci5leHQgPSBtYXRjaC5leHQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0c0F0OiBtYXRjaC5zdGFydHNBdCxcbiAgICAgICAgICAgICAgICBlbmRzQXQ6IG1hdGNoLmVuZHNBdCxcbiAgICAgICAgICAgICAgICBudW1iZXI6IHBob25lTnVtYmVyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1heFRyaWVzLS07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gZXh0cmFjdCBhIG1hdGNoIGZyb20gYGNhbmRpZGF0ZWBcclxuICAgICAqIGlmIHRoZSB3aG9sZSBjYW5kaWRhdGUgZG9lcyBub3QgcXVhbGlmeSBhcyBhIG1hdGNoLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJleHRyYWN0SW5uZXJNYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0SW5uZXJNYXRjaChjYW5kaWRhdGUsIG9mZnNldCwgdGV4dCkge1xuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfSU5ORVJfTUFUQ0hFUyA9IElOTkVSX01BVENIRVM7IF9pIDwgX0lOTkVSX01BVENIRVMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBpbm5lck1hdGNoUGF0dGVybiA9IF9JTk5FUl9NQVRDSEVTW19pXTtcbiAgICAgICAgdmFyIGlzRmlyc3RNYXRjaCA9IHRydWU7XG4gICAgICAgIHZhciBtYXRjaGVzID0gdm9pZCAwO1xuICAgICAgICB2YXIgcG9zc2libGVJbm5lck1hdGNoID0gbmV3IFJlZ0V4cChpbm5lck1hdGNoUGF0dGVybiwgJ2cnKTtcblxuICAgICAgICB3aGlsZSAoKG1hdGNoZXMgPSBwb3NzaWJsZUlubmVyTWF0Y2guZXhlYyhjYW5kaWRhdGUpKSAhPT0gbnVsbCAmJiB0aGlzLm1heFRyaWVzID4gMCkge1xuICAgICAgICAgIGlmIChpc0ZpcnN0TWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBoYW5kbGUgYW55IGdyb3VwIGJlZm9yZSB0aGlzIG9uZSB0b28uXG4gICAgICAgICAgICB2YXIgX2dyb3VwID0gdHJpbUFmdGVyRmlyc3RNYXRjaChVTldBTlRFRF9FTkRfQ0hBUl9QQVRURVJOLCBjYW5kaWRhdGUuc2xpY2UoMCwgbWF0Y2hlcy5pbmRleCkpO1xuXG4gICAgICAgICAgICB2YXIgX21hdGNoID0gdGhpcy5wYXJzZUFuZFZlcmlmeShfZ3JvdXAsIG9mZnNldCwgdGV4dCk7XG5cbiAgICAgICAgICAgIGlmIChfbWF0Y2gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9tYXRjaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5tYXhUcmllcy0tO1xuICAgICAgICAgICAgaXNGaXJzdE1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGdyb3VwID0gdHJpbUFmdGVyRmlyc3RNYXRjaChVTldBTlRFRF9FTkRfQ0hBUl9QQVRURVJOLCBtYXRjaGVzWzFdKTsgLy8gSmF2YSBjb2RlIGRvZXMgYGdyb3VwTWF0Y2hlci5zdGFydCgxKWAgaGVyZSxcbiAgICAgICAgICAvLyBidXQgdGhlcmUncyBubyB3YXkgaW4gamF2YXNjcmlwdCB0byBnZXQgYSBncm91cCBtYXRjaCBzdGFydCBpbmRleCxcbiAgICAgICAgICAvLyB0aGVyZWZvcmUgdXNpbmcgdGhlIG92ZXJhbGwgbWF0Y2ggc3RhcnQgaW5kZXggYG1hdGNoZXMuaW5kZXhgLlxuXG4gICAgICAgICAgdmFyIG1hdGNoID0gdGhpcy5wYXJzZUFuZFZlcmlmeShncm91cCwgb2Zmc2V0ICsgbWF0Y2hlcy5pbmRleCwgdGV4dCk7XG5cbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm1heFRyaWVzLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYSBwaG9uZSBudW1iZXIgZnJvbSB0aGUgYGNhbmRpZGF0ZWAgdXNpbmcgYHBhcnNlTnVtYmVyYCBhbmRcclxuICAgICAqIHZlcmlmaWVzIGl0IG1hdGNoZXMgdGhlIHJlcXVlc3RlZCBgbGVuaWVuY3lgLiBJZiBwYXJzaW5nIGFuZCB2ZXJpZmljYXRpb24gc3VjY2VlZCxcclxuICAgICAqIGEgY29ycmVzcG9uZGluZyBgUGhvbmVOdW1iZXJNYXRjaGAgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSB0aGlzIG1ldGhvZCByZXR1cm5zIGBudWxsYC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FuZGlkYXRlICB0aGUgY2FuZGlkYXRlIG1hdGNoXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0ICB0aGUgb2Zmc2V0IG9mIHtAY29kZSBjYW5kaWRhdGV9IHdpdGhpbiB7QGxpbmsgI3RleHR9XHJcbiAgICAgKiBAcmV0dXJuICB0aGUgcGFyc2VkIGFuZCB2YWxpZGF0ZWQgcGhvbmUgbnVtYmVyIG1hdGNoLCBvciBudWxsXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlQW5kVmVyaWZ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlQW5kVmVyaWZ5KGNhbmRpZGF0ZSwgb2Zmc2V0LCB0ZXh0KSB7XG4gICAgICBpZiAoIWlzVmFsaWRDYW5kaWRhdGUoY2FuZGlkYXRlLCBvZmZzZXQsIHRleHQsIHRoaXMub3B0aW9ucy5sZW5pZW5jeSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbnVtYmVyID0gcGFyc2UoY2FuZGlkYXRlLCB7XG4gICAgICAgIGV4dGVuZGVkOiB0cnVlLFxuICAgICAgICBkZWZhdWx0Q291bnRyeTogdGhpcy5vcHRpb25zLmRlZmF1bHRDb3VudHJ5LFxuICAgICAgICBkZWZhdWx0Q2FsbGluZ0NvZGU6IHRoaXMub3B0aW9ucy5kZWZhdWx0Q2FsbGluZ0NvZGVcbiAgICAgIH0sIHRoaXMubWV0YWRhdGEpO1xuXG4gICAgICBpZiAoIW51bWJlci5wb3NzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmxlbmllbmN5KG51bWJlciwgY2FuZGlkYXRlLCB0aGlzLm1ldGFkYXRhLCB0aGlzLnJlZ0V4cENhY2hlKSkge1xuICAgICAgICAvLyAvLyBXZSB1c2VkIHBhcnNlQW5kS2VlcFJhd0lucHV0IHRvIGNyZWF0ZSB0aGlzIG51bWJlcixcbiAgICAgICAgLy8gLy8gYnV0IGZvciBub3cgd2UgZG9uJ3QgcmV0dXJuIHRoZSBleHRyYSB2YWx1ZXMgcGFyc2VkLlxuICAgICAgICAvLyAvLyBUT0RPOiBzdG9wIGNsZWFyaW5nIGFsbCB2YWx1ZXMgaGVyZSBhbmQgc3dpdGNoIGFsbCB1c2VycyBvdmVyXG4gICAgICAgIC8vIC8vIHRvIHVzaW5nIHJhd0lucHV0KCkgcmF0aGVyIHRoYW4gdGhlIHJhd1N0cmluZygpIG9mIFBob25lTnVtYmVyTWF0Y2guXG4gICAgICAgIC8vIG51bWJlci5jbGVhckNvdW50cnlDb2RlU291cmNlKClcbiAgICAgICAgLy8gbnVtYmVyLmNsZWFyUmF3SW5wdXQoKVxuICAgICAgICAvLyBudW1iZXIuY2xlYXJQcmVmZXJyZWREb21lc3RpY0NhcnJpZXJDb2RlKClcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICBzdGFydHNBdDogb2Zmc2V0LFxuICAgICAgICAgIGVuZHNBdDogb2Zmc2V0ICsgY2FuZGlkYXRlLmxlbmd0aCxcbiAgICAgICAgICBwaG9uZTogbnVtYmVyLnBob25lXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG51bWJlci5jb3VudHJ5ICYmIG51bWJlci5jb3VudHJ5ICE9PSAnMDAxJykge1xuICAgICAgICAgIHJlc3VsdC5jb3VudHJ5ID0gbnVtYmVyLmNvdW50cnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LmNvdW50cnlDYWxsaW5nQ29kZSA9IG51bWJlci5jb3VudHJ5Q2FsbGluZ0NvZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVtYmVyLmV4dCkge1xuICAgICAgICAgIHJlc3VsdC5leHQgPSBudW1iZXIuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzTmV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNOZXh0KCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdOT1RfUkVBRFknKSB7XG4gICAgICAgIHRoaXMubGFzdE1hdGNoID0gdGhpcy5maW5kKCk7IC8vICh0aGlzLnNlYXJjaEluZGV4KVxuXG4gICAgICAgIGlmICh0aGlzLmxhc3RNYXRjaCkge1xuICAgICAgICAgIC8vIHRoaXMuc2VhcmNoSW5kZXggPSB0aGlzLmxhc3RNYXRjaC5lbmRzQXRcbiAgICAgICAgICB0aGlzLnN0YXRlID0gJ1JFQURZJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gJ0RPTkUnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSAnUkVBRFknO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAvLyBDaGVjayB0aGUgc3RhdGUgYW5kIGZpbmQgdGhlIG5leHQgbWF0Y2ggYXMgYSBzaWRlLWVmZmVjdCBpZiBuZWNlc3NhcnkuXG4gICAgICBpZiAoIXRoaXMuaGFzTmV4dCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbmV4dCBlbGVtZW50Jyk7XG4gICAgICB9IC8vIERvbid0IHJldGFpbiB0aGF0IG1lbW9yeSBhbnkgbG9uZ2VyIHRoYW4gbmVjZXNzYXJ5LlxuXG5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmxhc3RNYXRjaDtcbiAgICAgIHRoaXMubGFzdE1hdGNoID0gbnVsbDtcbiAgICAgIHRoaXMuc3RhdGUgPSAnTk9UX1JFQURZJztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBob25lTnVtYmVyTWF0Y2hlcjtcbn0oKTtcblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QaG9uZU51bWJlck1hdGNoZXIuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9lczYvZmluZE51bWJlcnNfLmpzXG5cbmZ1bmN0aW9uIGZpbmROdW1iZXJzKHRleHQsIG9wdGlvbnMsIG1ldGFkYXRhKSB7XG4gIHZhciBtYXRjaGVyID0gbmV3IFBob25lTnVtYmVyTWF0Y2hlcl9QaG9uZU51bWJlck1hdGNoZXIodGV4dCwgb3B0aW9ucywgbWV0YWRhdGEpO1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gIHdoaWxlIChtYXRjaGVyLmhhc05leHQoKSkge1xuICAgIHJlc3VsdHMucHVzaChtYXRjaGVyLm5leHQoKSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmROdW1iZXJzXy5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9maW5kTnVtYmVycy5qc1xuXG5cbmZ1bmN0aW9uIGZpbmROdW1iZXJzX2ZpbmROdW1iZXJzKCkge1xuICB2YXIgX25vcm1hbGl6ZUFyZ3VtZW50cyA9IG5vcm1hbGl6ZUFyZ3VtZW50cyhhcmd1bWVudHMpLFxuICAgICAgdGV4dCA9IF9ub3JtYWxpemVBcmd1bWVudHMudGV4dCxcbiAgICAgIG9wdGlvbnMgPSBfbm9ybWFsaXplQXJndW1lbnRzLm9wdGlvbnMsXG4gICAgICBtZXRhZGF0YSA9IF9ub3JtYWxpemVBcmd1bWVudHMubWV0YWRhdGE7XG5cbiAgcmV0dXJuIGZpbmROdW1iZXJzKHRleHQsIG9wdGlvbnMsIG1ldGFkYXRhKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmROdW1iZXJzLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvZXM2L3NlYXJjaE51bWJlcnMuanNcbmZ1bmN0aW9uIHNlYXJjaE51bWJlcnNfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5cblxuLyoqXHJcbiAqIEByZXR1cm4gRVM2IGBmb3IgLi4uIG9mYCBpdGVyYXRvci5cclxuICovXG5cbmZ1bmN0aW9uIHNlYXJjaE51bWJlcnMoKSB7XG4gIHZhciBfbm9ybWFsaXplQXJndW1lbnRzID0gbm9ybWFsaXplQXJndW1lbnRzKGFyZ3VtZW50cyksXG4gICAgICB0ZXh0ID0gX25vcm1hbGl6ZUFyZ3VtZW50cy50ZXh0LFxuICAgICAgb3B0aW9ucyA9IF9ub3JtYWxpemVBcmd1bWVudHMub3B0aW9ucyxcbiAgICAgIG1ldGFkYXRhID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5tZXRhZGF0YTtcblxuICB2YXIgbWF0Y2hlciA9IG5ldyBQaG9uZU51bWJlck1hdGNoZXJfUGhvbmVOdW1iZXJNYXRjaGVyKHRleHQsIG9wdGlvbnMsIG1ldGFkYXRhKTtcbiAgcmV0dXJuIHNlYXJjaE51bWJlcnNfZGVmaW5lUHJvcGVydHkoe30sIFN5bWJvbC5pdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAobWF0Y2hlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogbWF0Y2hlci5uZXh0KClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWFyY2hOdW1iZXJzLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvZXM2L2ZpbmRQaG9uZU51bWJlcnNJblRleHQuanNcbmZ1bmN0aW9uIGZpbmRQaG9uZU51bWJlcnNJblRleHRfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgZmluZFBob25lTnVtYmVyc0luVGV4dF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgZmluZFBob25lTnVtYmVyc0luVGV4dF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gZmluZFBob25lTnVtYmVyc0luVGV4dF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBmaW5kUGhvbmVOdW1iZXJzSW5UZXh0X29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBmaW5kUGhvbmVOdW1iZXJzSW5UZXh0X2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gZmluZFBob25lTnVtYmVyc0luVGV4dF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cblxuZnVuY3Rpb24gZmluZFBob25lTnVtYmVyc0luVGV4dCh0ZXh0LCBkZWZhdWx0Q291bnRyeSwgb3B0aW9ucywgbWV0YWRhdGEpIHtcbiAgdmFyIGFyZ3MgPSBnZXRBcmd1bWVudHMoZGVmYXVsdENvdW50cnksIG9wdGlvbnMsIG1ldGFkYXRhKTtcbiAgcmV0dXJuIGZpbmROdW1iZXJzX2ZpbmROdW1iZXJzKHRleHQsIGFyZ3Mub3B0aW9ucywgYXJncy5tZXRhZGF0YSk7XG59XG5mdW5jdGlvbiBnZXRBcmd1bWVudHMoZGVmYXVsdENvdW50cnksIG9wdGlvbnMsIG1ldGFkYXRhKSB7XG4gIGlmIChtZXRhZGF0YSkge1xuICAgIGlmIChkZWZhdWx0Q291bnRyeSkge1xuICAgICAgb3B0aW9ucyA9IGZpbmRQaG9uZU51bWJlcnNJblRleHRfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGRlZmF1bHRDb3VudHJ5OiBkZWZhdWx0Q291bnRyeVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBtZXRhZGF0YSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmIChkZWZhdWx0Q291bnRyeSkge1xuICAgICAgICBpZiAoZmluZFBob25lTnVtYmVyc0luVGV4dF9pc19vYmplY3QoZGVmYXVsdENvdW50cnkpKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRDb3VudHJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBkZWZhdWx0Q291bnRyeTogZGVmYXVsdENvdW50cnlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXRhZGF0YSA9IGRlZmF1bHRDb3VudHJ5O1xuICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9wdGlvbnM6IGZpbmRQaG9uZU51bWJlcnNJblRleHRfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICB2MjogdHJ1ZVxuICAgIH0pLFxuICAgIG1ldGFkYXRhOiBtZXRhZGF0YVxuICB9O1xufSAvLyBCYWJlbCB0cmFuc2Zvcm1zIGB0eXBlb2ZgIGludG8gc29tZSBcImJyYW5jaGVzXCJcbi8vIHNvIGlzdGFuYnVsIHdpbGwgc2hvdyB0aGlzIGFzIFwiYnJhbmNoIG5vdCBjb3ZlcmVkXCIuXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbnZhciBmaW5kUGhvbmVOdW1iZXJzSW5UZXh0X2lzX29iamVjdCA9IGZ1bmN0aW9uIGlzX29iamVjdChfKSB7XG4gIHJldHVybiBmaW5kUGhvbmVOdW1iZXJzSW5UZXh0X3R5cGVvZihfKSA9PT0gJ29iamVjdCc7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZFBob25lTnVtYmVyc0luVGV4dC5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9zZWFyY2hQaG9uZU51bWJlcnNJblRleHQuanNcblxuXG5mdW5jdGlvbiBzZWFyY2hQaG9uZU51bWJlcnNJblRleHQodGV4dCwgZGVmYXVsdENvdW50cnksIG9wdGlvbnMsIG1ldGFkYXRhKSB7XG4gIHZhciBhcmdzID0gZ2V0QXJndW1lbnRzKGRlZmF1bHRDb3VudHJ5LCBvcHRpb25zLCBtZXRhZGF0YSk7XG4gIHJldHVybiBzZWFyY2hOdW1iZXJzKHRleHQsIGFyZ3Mub3B0aW9ucywgYXJncy5tZXRhZGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWFyY2hQaG9uZU51bWJlcnNJblRleHQuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9lczYvQXNZb3VUeXBlLmpzXG5mdW5jdGlvbiBBc1lvdVR5cGVfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgQXNZb3VUeXBlX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBBc1lvdVR5cGVfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIEFzWW91VHlwZV90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBBc1lvdVR5cGVfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBBc1lvdVR5cGVfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIEFzWW91VHlwZV9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIEFzWW91VHlwZV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgQXNZb3VUeXBlX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIEFzWW91VHlwZV9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIFRoaXMgaXMgYW4gZW5oYW5jZWQgcG9ydCBvZiBHb29nbGUgQW5kcm9pZCBgbGlicGhvbmVudW1iZXJgJ3Ncbi8vIGBhc3lvdXR5cGVmb3JtYXR0ZXIuanNgIG9mIERlY2VtYmVyIDMxdGgsIDIwMTguXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWkxOG4vbGlicGhvbmVudW1iZXIvYmxvYi84ZDIxYTM2NTA2MWRlMmJhMDY3NWM4NzhhNzEwYTdiMjRmNzRkMmFlL2phdmFzY3JpcHQvaTE4bi9waG9uZW51bWJlcnMvYXN5b3V0eXBlZm9ybWF0dGVyLmpzXG4vL1xuLy8gU2ltcGxpZmllZDogZG9lcyBub3QgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIFwibG9jYWwtb25seVwiIG51bWJlcnNcbi8vIGFuZCBcImludGVybmF0aW9uYWxseSBkaWFsYWJsZVwiIG51bWJlcnMuXG4vLyBGb3IgZXhhbXBsZSwgZG9lc24ndCBpbmNsdWRlIGNoYW5nZXMgbGlrZSB0aGlzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWkxOG4vbGlicGhvbmVudW1iZXIvY29tbWl0Lzg2NWRhNjA1ZGExMmIwMTA1M2M0ZjA1MzMxMGJhYzdjNWZiYjc5MzVcblxuXG5cblxuXG5cblxuXG4gLy8gVXNlZCBpbiBwaG9uZSBudW1iZXIgZm9ybWF0IHRlbXBsYXRlIGNyZWF0aW9uLlxuLy8gQ291bGQgYmUgYW55IGRpZ2l0LCBJIGd1ZXNzLlxuXG52YXIgRFVNTVlfRElHSVQgPSAnOSc7IC8vIEkgZG9uJ3Qga25vdyB3aHkgaXMgaXQgZXhhY3RseSBgMTVgXG5cbnZhciBMT05HRVNUX05BVElPTkFMX1BIT05FX05VTUJFUl9MRU5HVEggPSAxNTsgLy8gQ3JlYXRlIGEgcGhvbmUgbnVtYmVyIGNvbnNpc3Rpbmcgb25seSBvZiB0aGUgZGlnaXQgOSB0aGF0IG1hdGNoZXMgdGhlXG4vLyBgbnVtYmVyX3BhdHRlcm5gIGJ5IGFwcGx5aW5nIHRoZSBwYXR0ZXJuIHRvIHRoZSBcImxvbmdlc3QgcGhvbmUgbnVtYmVyXCIgc3RyaW5nLlxuXG52YXIgTE9OR0VTVF9EVU1NWV9QSE9ORV9OVU1CRVIgPSByZXBlYXQoRFVNTVlfRElHSVQsIExPTkdFU1RfTkFUSU9OQUxfUEhPTkVfTlVNQkVSX0xFTkdUSCk7IC8vIFRoZSBkaWdpdHMgdGhhdCBoYXZlIG5vdCBiZWVuIGVudGVyZWQgeWV0IHdpbGwgYmUgcmVwcmVzZW50ZWQgYnkgYSBcXHUyMDA4LFxuLy8gdGhlIHB1bmN0dWF0aW9uIHNwYWNlLlxuXG52YXIgRElHSVRfUExBQ0VIT0xERVIgPSAneCc7IC8vICdcXHUyMDA4JyAocHVuY3R1YXRpb24gc3BhY2UpXG5cbnZhciBESUdJVF9QTEFDRUhPTERFUl9NQVRDSEVSID0gbmV3IFJlZ0V4cChESUdJVF9QTEFDRUhPTERFUik7IC8vIEEgc2V0IG9mIGNoYXJhY3RlcnMgdGhhdCwgaWYgZm91bmQgaW4gYSBuYXRpb25hbCBwcmVmaXggZm9ybWF0dGluZyBydWxlcywgYXJlIGFuIGluZGljYXRvciB0b1xuLy8gdXMgdGhhdCB3ZSBzaG91bGQgc2VwYXJhdGUgdGhlIG5hdGlvbmFsIHByZWZpeCBmcm9tIHRoZSBudW1iZXIgd2hlbiBmb3JtYXR0aW5nLlxuXG52YXIgTkFUSU9OQUxfUFJFRklYX1NFUEFSQVRPUlNfUEFUVEVSTiA9IC9bLSBdLzsgLy8gRGVwcmVjYXRlZDogR29vZ2xlIGhhcyByZW1vdmVkIHNvbWUgZm9ybWF0dGluZyBwYXR0ZXJuIHJlbGF0ZWQgY29kZSBmcm9tIHRoZWlyIHJlcG8uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlaTE4bi9saWJwaG9uZW51bWJlci9jb21taXQvYTM5NWI0ZmVmM2NhZjU3YzRiYzVmMDgyZTExNTJhNGQyYmQwYmE0Y1xuLy8gXCJXZSBubyBsb25nZXIgaGF2ZSBudW1iZXJzIGluIGZvcm1hdHRpbmcgbWF0Y2hpbmcgcGF0dGVybnMsIG9ubHkgXFxkLlwiXG4vLyBCZWNhdXNlIHRoaXMgbGlicmFyeSBzdXBwb3J0cyBnZW5lcmF0aW5nIGN1c3RvbSBtZXRhZGF0YVxuLy8gc29tZSB1c2VycyBtYXkgc3RpbGwgYmUgdXNpbmcgb2xkIG1ldGFkYXRhIHNvIHRoZSByZWxldmFudFxuLy8gY29kZSBzZWVtcyB0byBzdGF5IHVudGlsIHNvbWUgbmV4dCBtYWpvciB2ZXJzaW9uIHVwZGF0ZS5cblxudmFyIFNVUFBPUlRfTEVHQUNZX0ZPUk1BVFRJTkdfUEFUVEVSTlMgPSB0cnVlOyAvLyBBIHBhdHRlcm4gdGhhdCBpcyB1c2VkIHRvIG1hdGNoIGNoYXJhY3RlciBjbGFzc2VzIGluIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4vLyBBbiBleGFtcGxlIG9mIGEgY2hhcmFjdGVyIGNsYXNzIGlzIFwiWzEtNF1cIi5cblxudmFyIENSRUFURV9DSEFSQUNURVJfQ0xBU1NfUEFUVEVSTiA9IFNVUFBPUlRfTEVHQUNZX0ZPUk1BVFRJTkdfUEFUVEVSTlMgJiYgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gL1xcWyhbXlxcW1xcXV0pKlxcXS9nO1xufTsgLy8gQW55IGRpZ2l0IGluIGEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgYWN0dWFsbHkgZGVub3RlcyBhIGRpZ2l0LiBGb3Jcbi8vIGV4YW1wbGUsIGluIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gXCI4MFswLTJdXFxkezYsMTB9XCIsIHRoZSBmaXJzdCAyIGRpZ2l0c1xuLy8gKDggYW5kIDApIGFyZSBzdGFuZGFsb25lIGRpZ2l0cywgYnV0IHRoZSByZXN0IGFyZSBub3QuXG4vLyBUd28gbG9vay1haGVhZHMgYXJlIG5lZWRlZCBiZWNhdXNlIHRoZSBudW1iZXIgZm9sbG93aW5nIFxcXFxkIGNvdWxkIGJlIGFcbi8vIHR3by1kaWdpdCBudW1iZXIsIHNpbmNlIHRoZSBwaG9uZSBudW1iZXIgY2FuIGJlIGFzIGxvbmcgYXMgMTUgZGlnaXRzLlxuXG5cbnZhciBDUkVBVEVfU1RBTkRBTE9ORV9ESUdJVF9QQVRURVJOID0gU1VQUE9SVF9MRUdBQ1lfRk9STUFUVElOR19QQVRURVJOUyAmJiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAvXFxkKD89W14sfV1bXix9XSkvZztcbn07IC8vIEEgcGF0dGVybiB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgYGZvcm1hdGAgaXMgZWxpZ2libGVcbi8vIHRvIGJlIHVzZWQgYnkgdGhlIFwiYXMgeW91IHR5cGUgZm9ybWF0dGVyXCIuXG4vLyBJdCBpcyBlbGlnaWJsZSB3aGVuIHRoZSBgZm9ybWF0YCBjb250YWlucyBncm91cHMgb2YgdGhlIGRvbGxhciBzaWduXG4vLyBmb2xsb3dlZCBieSBhIHNpbmdsZSBkaWdpdCwgc2VwYXJhdGVkIGJ5IHZhbGlkIHBob25lIG51bWJlciBwdW5jdHVhdGlvbi5cbi8vIFRoaXMgcHJldmVudHMgaW52YWxpZCBwdW5jdHVhdGlvbiAoc3VjaCBhcyB0aGUgc3RhciBzaWduIGluIElzcmFlbGkgc3RhciBudW1iZXJzKVxuLy8gZ2V0dGluZyBpbnRvIHRoZSBvdXRwdXQgb2YgdGhlIFwiYXMgeW91IHR5cGUgZm9ybWF0dGVyXCIuXG5cblxudmFyIEVMSUdJQkxFX0ZPUk1BVF9QQVRURVJOID0gbmV3IFJlZ0V4cCgnXicgKyAnWycgKyBWQUxJRF9QVU5DVFVBVElPTiArICddKicgKyAnKFxcXFwkXFxcXGRbJyArIFZBTElEX1BVTkNUVUFUSU9OICsgJ10qKSsnICsgJyQnKTsgLy8gVGhpcyBpcyB0aGUgbWluaW11bSBsZW5ndGggb2YgdGhlIGxlYWRpbmcgZGlnaXRzIG9mIGEgcGhvbmUgbnVtYmVyXG4vLyB0byBndWFyYW50ZWUgdGhlIGZpcnN0IFwibGVhZGluZyBkaWdpdHMgcGF0dGVyblwiIGZvciBhIHBob25lIG51bWJlciBmb3JtYXRcbi8vIHRvIGJlIHByZWVtcHRpdmUuXG5cbnZhciBNSU5fTEVBRElOR19ESUdJVFNfTEVOR1RIID0gMztcbnZhciBWQUxJRF9GT1JNQVRURURfUEhPTkVfTlVNQkVSX1BBUlQgPSAnWycgKyBWQUxJRF9QVU5DVFVBVElPTiArIFZBTElEX0RJR0lUUyArICddKyc7XG52YXIgVkFMSURfRk9STUFUVEVEX1BIT05FX05VTUJFUl9QQVJUX1BBVFRFUk4gPSBuZXcgUmVnRXhwKCdeJyArIFZBTElEX0ZPUk1BVFRFRF9QSE9ORV9OVU1CRVJfUEFSVCArICckJywgJ2knKTtcbnZhciBBc1lvdVR5cGVfVkFMSURfUEhPTkVfTlVNQkVSID0gJyg/OicgKyAnWycgKyBQTFVTX0NIQVJTICsgJ10nICsgJ1snICsgVkFMSURfUFVOQ1RVQVRJT04gKyBWQUxJRF9ESUdJVFMgKyAnXSonICsgJ3wnICsgJ1snICsgVkFMSURfUFVOQ1RVQVRJT04gKyBWQUxJRF9ESUdJVFMgKyAnXSsnICsgJyknO1xudmFyIEFGVEVSX1BIT05FX05VTUJFUl9ESUdJVFNfRU5EX1BBVFRFUk4gPSBuZXcgUmVnRXhwKCdbXicgKyBWQUxJRF9QVU5DVFVBVElPTiArIFZBTElEX0RJR0lUUyArICddKycgKyAnLionICsgJyQnKTtcbnZhciBBc1lvdVR5cGVfVVNFX05PTl9HRU9HUkFQSElDX0NPVU5UUllfQ09ERSA9IGZhbHNlO1xuXG52YXIgQXNZb3VUeXBlX0FzWW91VHlwZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8vIE5vdCBzZXR0aW5nIGBvcHRpb25zYCB0byBhIGNvbnN0cnVjdG9yIGFyZ3VtZW50XG4gIC8vIG5vdCB0byBicmVhayBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAvLyBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkuXG5cbiAgLyoqXHJcbiAgICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCk/fSBbb3B0aW9uc09yRGVmYXVsdENvdW50cnldIC0gVGhlIGRlZmF1bHQgY291bnRyeSB1c2VkIGZvciBwYXJzaW5nIG5vbi1pbnRlcm5hdGlvbmFsIHBob25lIG51bWJlcnMuIENhbiBhbHNvIGJlIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFkYXRhXHJcbiAgICovXG4gIGZ1bmN0aW9uIEFzWW91VHlwZShvcHRpb25zT3JEZWZhdWx0Q291bnRyeSwgbWV0YWRhdGEpIHtcbiAgICBBc1lvdVR5cGVfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXNZb3VUeXBlKTtcblxuICAgIEFzWW91VHlwZV9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9wdGlvbnNcIiwge30pO1xuXG4gICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBNZXRhZGF0YShtZXRhZGF0YSk7IC8vIFNldCBgZGVmYXVsdENvdW50cnlgIGFuZCBgZGVmYXVsdENhbGxpbmdDb2RlYCBvcHRpb25zLlxuXG4gICAgdmFyIGRlZmF1bHRDb3VudHJ5O1xuICAgIHZhciBkZWZhdWx0Q2FsbGluZ0NvZGU7IC8vIFR1cm5zIG91dCBgbnVsbGAgYWxzbyBoYXMgdHlwZSBcIm9iamVjdFwiLiBXZWlyZC5cblxuICAgIGlmIChvcHRpb25zT3JEZWZhdWx0Q291bnRyeSkge1xuICAgICAgaWYgKEFzWW91VHlwZV90eXBlb2Yob3B0aW9uc09yRGVmYXVsdENvdW50cnkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBkZWZhdWx0Q291bnRyeSA9IG9wdGlvbnNPckRlZmF1bHRDb3VudHJ5LmRlZmF1bHRDb3VudHJ5O1xuICAgICAgICBkZWZhdWx0Q2FsbGluZ0NvZGUgPSBvcHRpb25zT3JEZWZhdWx0Q291bnRyeS5kZWZhdWx0Q2FsbGluZ0NvZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZhdWx0Q291bnRyeSA9IG9wdGlvbnNPckRlZmF1bHRDb3VudHJ5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkZWZhdWx0Q291bnRyeSAmJiB0aGlzLm1ldGFkYXRhLmhhc0NvdW50cnkoZGVmYXVsdENvdW50cnkpKSB7XG4gICAgICB0aGlzLmRlZmF1bHRDb3VudHJ5ID0gZGVmYXVsdENvdW50cnk7XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRDYWxsaW5nQ29kZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoQXNZb3VUeXBlX1VTRV9OT05fR0VPR1JBUEhJQ19DT1VOVFJZX0NPREUpIHtcbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEuaXNOb25HZW9ncmFwaGljQ2FsbGluZ0NvZGUoZGVmYXVsdENhbGxpbmdDb2RlKSkge1xuICAgICAgICAgIHRoaXMuZGVmYXVsdENvdW50cnkgPSAnMDAxJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmRlZmF1bHRDYWxsaW5nQ29kZSA9IGRlZmF1bHRDYWxsaW5nQ29kZTtcbiAgICB9IC8vIFJlc2V0LlxuXG5cbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICBBc1lvdVR5cGVfY3JlYXRlQ2xhc3MoQXNZb3VUeXBlLCBbe1xuICAgIGtleTogXCJyZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuZm9ybWF0dGVkT3V0cHV0ID0gJyc7XG4gICAgICB0aGlzLmludGVybmF0aW9uYWwgPSBmYWxzZTtcbiAgICAgIHRoaXMuaW50ZXJuYXRpb25hbFByZWZpeCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuY291bnRyeUNhbGxpbmdDb2RlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kaWdpdHMgPSAnJztcbiAgICAgIHRoaXMubmF0aW9uYWxOdW1iZXJEaWdpdHMgPSAnJztcbiAgICAgIHRoaXMubmF0aW9uYWxQcmVmaXggPSAnJztcbiAgICAgIHRoaXMuY2FycmllckNvZGUgPSAnJztcbiAgICAgIHRoaXMuc2V0Q291bnRyeSh0aGlzLmRlZmF1bHRDb3VudHJ5LCB0aGlzLmRlZmF1bHRDYWxsaW5nQ29kZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRGb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRGb3JtYXQoKSB7XG4gICAgICB0aGlzLmNob3NlbkZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudGVtcGxhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnBvcHVsYXRlZE5hdGlvbmFsTnVtYmVyVGVtcGxhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnBvcHVsYXRlZE5hdGlvbmFsTnVtYmVyVGVtcGxhdGVQb3NpdGlvbiA9IC0xO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBwaG9uZSBudW1iZXIgaXMgYmVpbmcgaW5wdXQgaW4gaW50ZXJuYXRpb25hbCBmb3JtYXQuXHJcbiAgICAgKiBJbiBvdGhlciB3b3JkcywgcmV0dXJucyBgdHJ1ZWAgaWYgYW5kIG9ubHkgaWYgdGhlIHBhcnNlZCBwaG9uZSBudW1iZXIgc3RhcnRzIHdpdGggYSBgXCIrXCJgLlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJbnRlcm5hdGlvbmFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzSW50ZXJuYXRpb25hbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludGVybmF0aW9uYWw7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgXCJjb3VudHJ5IGNhbGxpbmcgY29kZVwiIHBhcnQgb2YgdGhlIHBob25lIG51bWJlci5cclxuICAgICAqIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIG51bWJlciBpcyBub3QgYmVpbmcgaW5wdXQgaW4gaW50ZXJuYXRpb25hbCBmb3JtYXQuXHJcbiAgICAgKiBSZXR1cm5zIFwiY291bnRyeSBjYWxsaW5nIGNvZGVcIiBmb3IgXCJub24tZ2VvZ3JhcGhpY1wiIHBob25lIG51bWJlcmluZyBwbGFucyB0b28uXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFtjb3VudHJ5Q2FsbGluZ0NvZGVdXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldENvdW50cnlDYWxsaW5nQ29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb3VudHJ5Q2FsbGluZ0NvZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb3VudHJ5Q2FsbGluZ0NvZGU7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHR3by1sZXR0ZXIgY291bnRyeSBjb2RlIG9mIHRoZSBwaG9uZSBudW1iZXIuXHJcbiAgICAgKiBSZXR1cm5zIGB1bmRlZmluZWRgIGZvciBcIm5vbi1nZW9ncmFwaGljXCIgcGhvbmUgbnVtYmVyaW5nIHBsYW5zLlxyXG4gICAgICogUmV0dXJucyBgdW5kZWZpbmVkYCBpZiBubyBwaG9uZSBudW1iZXIgaGFzIGJlZW4gaW5wdXQgeWV0LlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBbY291bnRyeV1cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q291bnRyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb3VudHJ5KCkge1xuICAgICAgLy8gSWYgbm8gZGlnaXRzIGhhdmUgYmVlbiBpbnB1dCB5ZXQsXG4gICAgICAvLyB0aGVuIGB0aGlzLmNvdW50cnlgIGlzIHRoZSBgZGVmYXVsdENvdW50cnlgLlxuICAgICAgLy8gV29uJ3QgcmV0dXJuIHRoZSBgZGVmYXVsdENvdW50cnlgIGluIHN1Y2ggY2FzZS5cbiAgICAgIGlmICghdGhpcy5kaWdpdHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY291bnRyeUNvZGUgPSB0aGlzLmNvdW50cnk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuICAgICAgaWYgKEFzWW91VHlwZV9VU0VfTk9OX0dFT0dSQVBISUNfQ09VTlRSWV9DT0RFKSB7XG4gICAgICAgIGlmICh0aGlzLmNvdW50cnkgPT09ICcwMDEnKSB7XG4gICAgICAgICAgY291bnRyeUNvZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvdW50cnlDb2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRDb3VudHJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvdW50cnkoY291bnRyeSwgY2FsbGluZ0NvZGUpIHtcbiAgICAgIHRoaXMuY291bnRyeSA9IGNvdW50cnk7XG4gICAgICB0aGlzLm1ldGFkYXRhLnNlbGVjdE51bWJlcmluZ1BsYW4oY291bnRyeSwgY2FsbGluZ0NvZGUpO1xuXG4gICAgICBpZiAodGhpcy5tZXRhZGF0YS5oYXNTZWxlY3RlZE51bWJlcmluZ1BsYW4oKSkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVQaG9uZU51bWJlckZvcm1hdHNGb3JDb3VudHJ5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1hdGNoaW5nRm9ybWF0cyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc2V0Rm9ybWF0KCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogSW5wdXRzIFwibmV4dFwiIHBob25lIG51bWJlciBjaGFyYWN0ZXJzLlxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEZvcm1hdHRlZCBwaG9uZSBudW1iZXIgY2hhcmFjdGVycyB0aGF0IGhhdmUgYmVlbiBpbnB1dCBzbyBmYXIuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlucHV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlucHV0KHRleHQpIHtcbiAgICAgIHZhciBmb3JtYXR0ZWREaWdpdHMgPSB0aGlzLmV4dHJhY3RGb3JtYXR0ZWREaWdpdHModGV4dCk7IC8vIElmIHRoZSBleHRyYWN0ZWQgcGhvbmUgbnVtYmVyIHBhcnRcbiAgICAgIC8vIGNhbiBwb3NzaWJseSBiZSBhIHBhcnQgb2Ygc29tZSB2YWxpZCBwaG9uZSBudW1iZXJcbiAgICAgIC8vIHRoZW4gcGFyc2UgcGhvbmUgbnVtYmVyIGNoYXJhY3RlcnMgZnJvbSBhIGZvcm1hdHRlZCBwaG9uZSBudW1iZXIuXG5cbiAgICAgIGlmIChWQUxJRF9GT1JNQVRURURfUEhPTkVfTlVNQkVSX1BBUlRfUEFUVEVSTi50ZXN0KGZvcm1hdHRlZERpZ2l0cykpIHtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZWRPdXRwdXQgPSB0aGlzLmdldEZ1bGxOdW1iZXIodGhpcy5pbnB1dERpZ2l0cyhwYXJzZURpZ2l0cyhmb3JtYXR0ZWREaWdpdHMpKSB8fCB0aGlzLmdldE5vbkZvcm1hdHRlZE5hdGlvbmFsTnVtYmVyKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZWRPdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRXh0cmFjdHMgZm9ybWF0dGVkIHBob25lIG51bWJlciBkaWdpdHMgZnJvbSB0ZXh0IChpZiB0aGVyZSdyZSBhbnkpLlxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImV4dHJhY3RGb3JtYXR0ZWREaWdpdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdEZvcm1hdHRlZERpZ2l0cyh0ZXh0KSB7XG4gICAgICAvLyBFeHRyYWN0IGEgZm9ybWF0dGVkIHBob25lIG51bWJlciBwYXJ0IGZyb20gdGV4dC5cbiAgICAgIHZhciBleHRyYWN0ZWROdW1iZXIgPSBBc1lvdVR5cGVfZXh0cmFjdEZvcm1hdHRlZFBob25lTnVtYmVyKHRleHQpIHx8ICcnOyAvLyBUcmltIGEgYCtgLlxuXG4gICAgICBpZiAoZXh0cmFjdGVkTnVtYmVyWzBdID09PSAnKycpIHtcbiAgICAgICAgLy8gVHJpbSB0aGUgYCtgLlxuICAgICAgICBleHRyYWN0ZWROdW1iZXIgPSBleHRyYWN0ZWROdW1iZXIuc2xpY2UoJysnLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGlnaXRzKSB7Ly8gSWYgYW4gb3V0IG9mIHBvc2l0aW9uIGArYCBpcyBkZXRlY3RlZFxuICAgICAgICAgIC8vIChvciBhIHNlY29uZCBgK2ApIHRoZW4ganVzdCBpZ25vcmUgaXQuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZWRPdXRwdXQgPSAnKyc7XG4gICAgICAgICAgdGhpcy5zdGFydEludGVybmF0aW9uYWxOdW1iZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXh0cmFjdGVkTnVtYmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydEludGVybmF0aW9uYWxOdW1iZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRJbnRlcm5hdGlvbmFsTnVtYmVyKCkge1xuICAgICAgLy8gUHJlcGVuZCB0aGUgYCtgIHRvIHBhcnNlZCBpbnB1dC5cbiAgICAgIHRoaXMuaW50ZXJuYXRpb25hbCA9IHRydWU7IC8vIElmIGEgZGVmYXVsdCBjb3VudHJ5IHdhcyBzZXQgdGhlbiByZXNldCBpdFxuICAgICAgLy8gYmVjYXVzZSBhbiBleHBsaWNpdGx5IGludGVybmF0aW9uYWwgcGhvbmVcbiAgICAgIC8vIG51bWJlciBpcyBiZWluZyBlbnRlcmVkLlxuXG4gICAgICB0aGlzLnNldENvdW50cnkoKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBJbnB1dHMgXCJuZXh0XCIgcGhvbmUgbnVtYmVyIGRpZ2l0cy5cclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gZGlnaXRzXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFtmb3JtYXR0ZWROdW1iZXJdIEZvcm1hdHRlZCBuYXRpb25hbCBwaG9uZSBudW1iZXIgKGlmIGl0IGNhbiBiZSBmb3JtYXR0ZWQgYXQgdGhpcyBzdGFnZSkuIFJldHVybmluZyBgdW5kZWZpbmVkYCBtZWFucyBcImRvbid0IGZvcm1hdCB0aGUgbmF0aW9uYWwgcGhvbmUgbnVtYmVyIGF0IHRoaXMgc3RhZ2VcIi5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5wdXREaWdpdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5wdXREaWdpdHMobmV4dERpZ2l0cykge1xuICAgICAgLy8gU29tZSB1c2VycyBpbnB1dCB0aGVpciBwaG9uZSBudW1iZXIgaW4gXCJvdXQtb2YtY291bnRyeVwiXG4gICAgICAvLyBkaWFsaW5nIGZvcm1hdCBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBsZWFkaW5nIGArYC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRhbXBoZXRhbWluZS9saWJwaG9uZW51bWJlci1qcy9pc3N1ZXMvMTg1XG4gICAgICAvLyBEZXRlY3Qgc3VjaCBudW1iZXJzLlxuICAgICAgaWYgKCF0aGlzLmRpZ2l0cykge1xuICAgICAgICB2YXIgbnVtYmVyV2l0aG91dElERCA9IHN0cmlwSUREUHJlZml4KG5leHREaWdpdHMsIHRoaXMuZGVmYXVsdENvdW50cnksIHRoaXMuZGVmYXVsdENhbGxpbmdDb2RlLCB0aGlzLm1ldGFkYXRhLm1ldGFkYXRhKTtcblxuICAgICAgICBpZiAobnVtYmVyV2l0aG91dElERCAmJiBudW1iZXJXaXRob3V0SUREICE9PSBuZXh0RGlnaXRzKSB7XG4gICAgICAgICAgLy8gSWYgYW4gSUREIHByZWZpeCB3YXMgc3RyaXBwZWQgdGhlblxuICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIG51bWJlciB0byBpbnRlcm5hdGlvbmFsIG9uZVxuICAgICAgICAgIC8vIGZvciBzdWJzZXF1ZW50IHBhcnNpbmcuXG4gICAgICAgICAgdGhpcy5pbnRlcm5hdGlvbmFsUHJlZml4ID0gbmV4dERpZ2l0cy5zbGljZSgwLCBuZXh0RGlnaXRzLmxlbmd0aCAtIG51bWJlcldpdGhvdXRJREQubGVuZ3RoKTtcbiAgICAgICAgICBuZXh0RGlnaXRzID0gbnVtYmVyV2l0aG91dElERDtcbiAgICAgICAgICB0aGlzLnN0YXJ0SW50ZXJuYXRpb25hbE51bWJlcigpO1xuICAgICAgICB9XG4gICAgICB9IC8vIEFwcGVuZCBwaG9uZSBudW1iZXIgZGlnaXRzLlxuXG5cbiAgICAgIHRoaXMuZGlnaXRzICs9IG5leHREaWdpdHM7IC8vIFRyeSB0byBmb3JtYXQgdGhlIHBhcnNlZCBpbnB1dFxuXG4gICAgICBpZiAodGhpcy5pc0ludGVybmF0aW9uYWwoKSkge1xuICAgICAgICBpZiAodGhpcy5jb3VudHJ5Q2FsbGluZ0NvZGUpIHtcbiAgICAgICAgICB0aGlzLm5hdGlvbmFsTnVtYmVyRGlnaXRzICs9IG5leHREaWdpdHM7IC8vIGB0aGlzLmNvdW50cnlgIGNvdWxkIGJlIGB1bmRlZmluZWRgLCBmb3IgZXhhbXBsZSwgd2hlbiB0aGVyZSBpc1xuICAgICAgICAgIC8vIGFtYmlndWl0eSBpbiBhIGZvcm0gb2Ygc2V2ZXJhbCBkaWZmZXJlbnQgY291bnRyaWVzLFxuICAgICAgICAgIC8vIGVhY2ggY29ycmVzcG9uZGluZyB0byB0aGUgc2FtZSBjb3VudHJ5IHBob25lIGNvZGVcbiAgICAgICAgICAvLyAoZS5nLiBOQU5QQTogVVNBLCBDYW5hZGEsIGV0YyksIGFuZCB0aGVyZSdzIG5vdCBlbm91Z2ggZGlnaXRzXG4gICAgICAgICAgLy8gdG8gcmVsaWFibHkgZGV0ZXJtaW5lIHRoZSBjb3VudHJ5IHRoZSBwaG9uZSBudW1iZXIgYmVsb25ncyB0by5cbiAgICAgICAgICAvLyBUaGVyZWZvcmUsIGluIGNhc2VzIG9mIHN1Y2ggYW1iaWd1aXR5LCBlYWNoIHRpbWUgc29tZXRoaW5nIGlzIGlucHV0LFxuICAgICAgICAgIC8vIHRyeSB0byBkZXRlcm1pbmUgdGhlIGNvdW50cnkgKGlmIGl0IGhhc24ndCBiZWVuIGRldGVybWluZWQgeWV0KS5cblxuICAgICAgICAgIGlmICghdGhpcy5jb3VudHJ5IHx8IHRoaXMuaXNDb3VudHJ5Q2FsbGluZ0NvZGVBbWJpZ3VvdXMoKSkge1xuICAgICAgICAgICAgdGhpcy5kZXRlcm1pbmVUaGVDb3VudHJ5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEV4dHJhY3QgY291bnRyeSBjYWxsaW5nIGNvZGUgZnJvbSB0aGUgZGlnaXRzIGVudGVyZWQgc28gZmFyLlxuICAgICAgICAgIC8vIFRoZXJlIG11c3QgYmUgc29tZSBkaWdpdHMgaW4gb3JkZXIgdG8gZXh0cmFjdCBhbnl0aGluZyBmcm9tIHRoZW0uXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBJZiBvbmUgbG9va3MgYXQgY291bnRyeSBwaG9uZSBjb2Rlc1xuICAgICAgICAgIC8vIHRoZW4gdGhleSBjYW4gbm90aWNlIHRoYXQgbm8gb25lIGNvdW50cnkgcGhvbmUgY29kZVxuICAgICAgICAgIC8vIGlzIGV2ZXIgYSAobGVmdG1vc3QpIHN1YnN0cmluZyBvZiBhbm90aGVyIGNvdW50cnkgcGhvbmUgY29kZS5cbiAgICAgICAgICAvLyBTbyBpZiBhIHZhbGlkIGNvdW50cnkgY29kZSBpcyBleHRyYWN0ZWQgc28gZmFyXG4gICAgICAgICAgLy8gdGhlbiBpdCBtZWFucyB0aGF0IHRoaXMgaXMgdGhlIGNvdW50cnkgY29kZS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIG5vIGNvdW50cnkgcGhvbmUgY29kZSBjb3VsZCBiZSBleHRyYWN0ZWQgc28gZmFyLFxuICAgICAgICAgIC8vIHRoZW4gZG9uJ3QgZm9ybWF0IHRoZSBwaG9uZSBudW1iZXIuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoIXRoaXMuZXh0cmFjdENvdW50cnlDYWxsaW5nQ29kZSgpKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBmb3JtYXQgdGhlIHBob25lIG51bWJlci5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIFBvc3NpYmx5IGV4dHJhY3QgYSBuYXRpb25hbCBwcmVmaXguXG4gICAgICAgICAgLy8gU29tZSBwZW9wbGUgaW5jb3JyZWN0bHkgaW5wdXQgbmF0aW9uYWwgcHJlZml4XG4gICAgICAgICAgLy8gaW4gYW4gaW50ZXJuYXRpb25hbCBwaG9uZSBudW1iZXIuXG4gICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIHNvbWUgcGVvcGxlIHdyaXRlIEJyaXRpc2ggcGhvbmUgbnVtYmVycyBhcyBgKzQ0KDApLi4uYC5cbiAgICAgICAgICAvLyBBbHNvLCBtb2JpbGUgcGhvbmUgbnVtYmVycyBpbiBNZXhpY28gYXJlIHN1cHBvc2VkIHRvIGJlIGRpYWxsZWRcbiAgICAgICAgICAvLyBpbnRlcm5hdGlvbmFsbHkgdXNpbmcgYSBgMTVgIG5hdGlvbmFsIHByZWZpeC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIGh0dHBzOi8vd3d3Lm1leHBlcmllbmNlLmNvbS9kaWFsaW5nLWNlbGwtcGhvbmVzLWluLW1leGljby9cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFwiRGlhbGluZyBhIE1leGljYW4gY2VsbCBwaG9uZSBmcm9tIGFicm9hZFxuICAgICAgICAgIC8vIFdoZW4geW91IGFyZSBjYWxsaW5nIGEgY2VsbCBwaG9uZSBudW1iZXIgaW4gTWV4aWNvIGZyb20gb3V0c2lkZSBNZXhpY28sXG4gICAgICAgICAgLy8gaXTigJlzIG5lY2Vzc2FyeSB0byBkaWFsIGFuIGFkZGl0aW9uYWwg4oCcMeKAnSBhZnRlciBNZXhpY2/igJlzIGNvdW50cnkgY29kZVxuICAgICAgICAgIC8vICh3aGljaCBpcyDigJw1MuKAnSkgYW5kIGJlZm9yZSB0aGUgYXJlYSBjb2RlLlxuICAgICAgICAgIC8vIFlvdSBhbHNvIGlnbm9yZSB0aGUgMDQ1LCBhbmQgc2ltcGx5IGRpYWwgdGhlIGFyZWEgY29kZSBhbmQgdGhlXG4gICAgICAgICAgLy8gY2VsbCBwaG9uZeKAmXMgbnVtYmVyLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSWYgeW91IGRvbuKAmXQgYWRkIHRoZSDigJwx4oCdLCB5b3XigJlsbCByZWNlaXZlIGEgcmVjb3JkZWQgYW5ub3VuY2VtZW50XG4gICAgICAgICAgLy8gYXNraW5nIHlvdSB0byByZWRpYWwgdXNpbmcgaXQuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgaWYgeW91IGFyZSBjYWxsaW5nIGZyb20gdGhlIFVTQSB0byBhIGNlbGwgcGhvbmVcbiAgICAgICAgICAvLyBpbiBNZXhpY28gQ2l0eSwgeW91IHdvdWxkIGRpYWwgKzUyIOKAkyAxIOKAkyA1NSDigJMgMTIzNCA1Njc4LlxuICAgICAgICAgIC8vIChOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgdG8gY2FsbGluZyBhIGxhbmQgbGluZSBpbiBNZXhpY28gQ2l0eVxuICAgICAgICAgIC8vIGZyb20gYWJyb2FkLCB3aGVyZSB0aGUgbnVtYmVyIGRpYWxlZCB3b3VsZCBiZSArNTIg4oCTIDU1IOKAkyAxMjM0IDU2NzgpXCIuXG4gICAgICAgICAgLy9cblxuXG4gICAgICAgICAgdGhpcy5uYXRpb25hbE51bWJlckRpZ2l0cyA9IHRoaXMuZGlnaXRzLnNsaWNlKHRoaXMuY291bnRyeUNhbGxpbmdDb2RlLmxlbmd0aCk7IC8vIHRoaXMuZXh0cmFjdE5hdGlvbmFsUHJlZml4KClcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIERldGVybWluZSB0aGUgY291bnRyeSBmcm9tIGNvdW50cnkgY2FsbGluZyBjb2RlIGFuZCBuYXRpb25hbCBudW1iZXIuXG5cbiAgICAgICAgICB0aGlzLmRldGVybWluZVRoZUNvdW50cnkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5uYXRpb25hbE51bWJlckRpZ2l0cyArPSBuZXh0RGlnaXRzOyAvLyBJZiBgZGVmYXVsdENhbGxpbmdDb2RlYCBpcyBzZXQsXG4gICAgICAgIC8vIHNlZSBpZiB0aGUgYGNvdW50cnlgIGNvdWxkIGJlIGRlcml2ZWQuXG5cbiAgICAgICAgaWYgKCF0aGlzLmNvdW50cnkpIHtcbiAgICAgICAgICB0aGlzLmRldGVybWluZVRoZUNvdW50cnkoKTtcbiAgICAgICAgfSAvLyBTb21lIG5hdGlvbmFsIHByZWZpeGVzIGFyZSBzdWJzdHJpbmdzIG9mIG90aGVyIG5hdGlvbmFsIHByZWZpeGVzXG4gICAgICAgIC8vIChmb3IgdGhlIHNhbWUgY291bnRyeSksIHRoZXJlZm9yZSB0cnkgdG8gZXh0cmFjdCBuYXRpb25hbCBwcmVmaXggZWFjaCB0aW1lXG4gICAgICAgIC8vIGJlY2F1c2UgYSBsb25nZXIgbmF0aW9uYWwgcHJlZml4IG1pZ2h0IGJlIGF2YWlsYWJsZSBhdCBzb21lIHBvaW50IGluIHRpbWUuXG5cblxuICAgICAgICB2YXIgcHJldmlvdXNOYXRpb25hbFByZWZpeCA9IHRoaXMubmF0aW9uYWxQcmVmaXg7XG4gICAgICAgIHRoaXMubmF0aW9uYWxOdW1iZXJEaWdpdHMgPSB0aGlzLm5hdGlvbmFsUHJlZml4ICsgdGhpcy5uYXRpb25hbE51bWJlckRpZ2l0czsgLy8gUmUtZXh0cmFjdCBuYXRpb25hbCBwcmVmaXguXG5cbiAgICAgICAgdGhpcy5leHRyYWN0TmF0aW9uYWxQcmVmaXgoKTsgLy8gSWYgYW5vdGhlciBuYXRpb25hbCBwcmVmaXggaGFzIGJlZW4gZXh0cmFjdGVkLlxuXG4gICAgICAgIGlmICh0aGlzLm5hdGlvbmFsUHJlZml4ICE9PSBwcmV2aW91c05hdGlvbmFsUHJlZml4KSB7XG4gICAgICAgICAgLy8gTmF0aW9uYWwgbnVtYmVyIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgLy8gKGR1ZSB0byBhbm90aGVyIG5hdGlvbmFsIHByZWZpeCBiZWVuIGV4dHJhY3RlZClcbiAgICAgICAgICAvLyB0aGVyZWZvcmUgbmF0aW9uYWwgbnVtYmVyIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgLy8gdGhlcmVmb3JlIHJlc2V0IGFsbCBwcmV2aW91cyBmb3JtYXR0aW5nIGRhdGEuXG4gICAgICAgICAgLy8gKGFuZCBsZWFkaW5nIGRpZ2l0cyBtYXRjaGluZyBzdGF0ZSlcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemVQaG9uZU51bWJlckZvcm1hdHNGb3JDb3VudHJ5KCk7XG4gICAgICAgICAgdGhpcy5yZXNldEZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm5hdGlvbmFsTnVtYmVyRGlnaXRzKSB7XG4gICAgICAgIC8vIE1hdGNoIHRoZSBhdmFpbGFibGUgZm9ybWF0cyBieSB0aGUgY3VycmVudGx5IGF2YWlsYWJsZSBsZWFkaW5nIGRpZ2l0cy5cbiAgICAgICAgdGhpcy5tYXRjaEZvcm1hdHModGhpcy5uYXRpb25hbE51bWJlckRpZ2l0cyk7XG4gICAgICB9IC8vIEZvcm1hdCB0aGUgcGhvbmUgbnVtYmVyIChnaXZlbiB0aGUgbmV4dCBkaWdpdHMpXG5cblxuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0TmF0aW9uYWxOdW1iZXJXaXRoTmV4dERpZ2l0cyhuZXh0RGlnaXRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0TmF0aW9uYWxOdW1iZXJXaXRoTmV4dERpZ2l0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXROYXRpb25hbE51bWJlcldpdGhOZXh0RGlnaXRzKG5leHREaWdpdHMpIHtcbiAgICAgIC8vIFNlZSBpZiB0aGUgcGhvbmUgbnVtYmVyIGRpZ2l0cyBjYW4gYmUgZm9ybWF0dGVkIGFzIGEgY29tcGxldGUgcGhvbmUgbnVtYmVyLlxuICAgICAgLy8gSWYgbm90LCB1c2UgdGhlIHJlc3VsdHMgZnJvbSBgZm9ybWF0TmV4dE5hdGlvbmFsTnVtYmVyRGlnaXRzKClgLFxuICAgICAgLy8gd2hpY2ggZm9ybWF0cyBiYXNlZCBvbiB0aGUgY2hvc2VuIGZvcm1hdHRpbmcgcGF0dGVybi5cbiAgICAgIC8vIEF0dGVtcHRpbmcgdG8gZm9ybWF0IGNvbXBsZXRlIHBob25lIG51bWJlciBmaXJzdCBpcyBob3cgaXQncyBkb25lXG4gICAgICAvLyBpbiBHb29nbGUncyBgbGlicGhvbmVudW1iZXJgLlxuICAgICAgdmFyIGZvcm1hdHRlZE51bWJlciA9IHRoaXMuYXR0ZW1wdFRvRm9ybWF0Q29tcGxldGVQaG9uZU51bWJlcigpOyAvLyBKdXN0IGJlY2F1c2UgYSBwaG9uZSBudW1iZXIgZG9lc24ndCBoYXZlIGEgc3VpdGFibGUgZm9ybWF0XG4gICAgICAvLyB0aGF0IGRvZXNuJ3QgbWVhbiB0aGF0IHRoZSBwaG9uZSBudW1iZXIgaXMgaW52YWxpZCxcbiAgICAgIC8vIGJlY2F1c2UgcGhvbmUgbnVtYmVyIGZvcm1hdHMgb25seSBmb3JtYXQgcGhvbmUgbnVtYmVycyxcbiAgICAgIC8vIHRoZXkgZG9uJ3QgdmFsaWRhdGUgdGhlbSBhbmQgc29tZSAocmFyZSkgcGhvbmUgbnVtYmVyc1xuICAgICAgLy8gYXJlIG1lYW50IHRvIHN0YXkgbm9uLWZvcm1hdHRlZC5cblxuICAgICAgaWYgKGZvcm1hdHRlZE51bWJlcikge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVkTnVtYmVyO1xuICAgICAgfSAvLyBGb3JtYXQgdGhlIG5leHQgcGhvbmUgbnVtYmVyIGRpZ2l0c1xuICAgICAgLy8gdXNpbmcgdGhlIHByZXZpb3VzbHkgY2hvc2VuIHBob25lIG51bWJlciBmb3JtYXQuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBpcyBkb25lIGhlcmUgYmVjYXVzZSBpZiBgYXR0ZW1wdFRvRm9ybWF0Q29tcGxldGVQaG9uZU51bWJlcmBcbiAgICAgIC8vIHdhcyBwbGFjZWQgYmVmb3JlIHRoaXMgY2FsbCB0aGVuIHRoZSBgdGVtcGxhdGVgXG4gICAgICAvLyB3b3VsZG4ndCByZWZsZWN0IHRoZSBzaXR1YXRpb24gY29ycmVjdGx5IChhbmQgd291bGQgdGhlcmVmb3JlIGJlIGluY29uc2lzdGVudClcbiAgICAgIC8vXG5cblxuICAgICAgdmFyIHByZXZpb3VzbHlDaG9zZW5Gb3JtYXQgPSB0aGlzLmNob3NlbkZvcm1hdDsgLy8gQ2hvb3NlIGEgZm9ybWF0IGZyb20gdGhlIGxpc3Qgb2YgbWF0Y2hpbmcgb25lcy5cblxuICAgICAgdmFyIG5ld2x5Q2hvc2VuRm9ybWF0ID0gdGhpcy5jaG9vc2VGb3JtYXQoKTtcblxuICAgICAgaWYgKG5ld2x5Q2hvc2VuRm9ybWF0KSB7XG4gICAgICAgIGlmIChuZXdseUNob3NlbkZvcm1hdCA9PT0gcHJldmlvdXNseUNob3NlbkZvcm1hdCkge1xuICAgICAgICAgIC8vIElmIGNvdWxkIGZvcm1hdCB0aGUgbmV4dCAoY3VycmVudCkgZGlnaXRcbiAgICAgICAgICAvLyB1c2luZyB0aGUgcHJldmlvdXNseSBjaG9zZW4gcGhvbmUgbnVtYmVyIGZvcm1hdFxuICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSBmb3JtYXR0ZWQgbnVtYmVyIHNvIGZhci5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIG5vIG5ldyBwaG9uZSBudW1iZXIgZm9ybWF0IGNvdWxkIGJlIGNob3NlbixcbiAgICAgICAgICAvLyBhbmQgY291bGRuJ3QgZm9ybWF0IHRoZSBzdXBwbGllZCBuYXRpb25hbCBudW1iZXJcbiAgICAgICAgICAvLyB1c2luZyB0aGUgcHJldmlvdXNseSBjaG9zZW4gcGhvbmUgbnVtYmVyIHBhdHRlcm4sXG4gICAgICAgICAgLy8gdGhlbiByZXR1cm4gYHVuZGVmaW5lZGAuXG4gICAgICAgICAgLy9cbiAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXROZXh0TmF0aW9uYWxOdW1iZXJEaWdpdHMobmV4dERpZ2l0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgYSBtb3JlIGFwcHJvcHJpYXRlIHBob25lIG51bWJlciBmb3JtYXRcbiAgICAgICAgICAvLyBoYXMgYmVlbiBjaG9zZW4gZm9yIHRoZXNlIFwibGVhZGluZyBkaWdpdHNcIixcbiAgICAgICAgICAvLyB0aGVuIGZvcm1hdCB0aGUgbmF0aW9uYWwgcGhvbmUgbnVtYmVyIChzbyBmYXIpXG4gICAgICAgICAgLy8gdXNpbmcgdGhlIG5ld2x5IHNlbGVjdGVkIGZvcm1hdC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmIGl0IGNvdWxkbid0IGZvcm1hdFxuICAgICAgICAgIC8vIHRoZSBzdXBwbGllZCBuYXRpb25hbCBudW1iZXJcbiAgICAgICAgICAvLyB1c2luZyB0aGUgc2VsZWN0ZWQgcGhvbmUgbnVtYmVyIHBhdHRlcm4uXG4gICAgICAgICAgLy9cbiAgICAgICAgICByZXR1cm4gdGhpcy5yZWZvcm1hdE5hdGlvbmFsTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hvb3NlRm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNob29zZUZvcm1hdCgpIHtcbiAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGF2YWlsYWJsZSBmb3JtYXRzLCB0aGUgZm9ybWF0dGVyIHVzZXMgdGhlIGZpcnN0XG4gICAgICAvLyBmb3JtYXQgd2hlcmUgYSBmb3JtYXR0aW5nIHRlbXBsYXRlIGNvdWxkIGJlIGNyZWF0ZWQuXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0aGlzLm1hdGNoaW5nRm9ybWF0cywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgdmFyIF9yZWY7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm9ybWF0ID0gX3JlZjtcblxuICAgICAgICAvLyBJZiB0aGlzIGZvcm1hdCBpcyBjdXJyZW50bHkgYmVpbmcgdXNlZFxuICAgICAgICAvLyBhbmQgaXMgc3RpbGwgcG9zc2libGUsIHRoZW4gc3RpY2sgdG8gaXQuXG4gICAgICAgIGlmICh0aGlzLmNob3NlbkZvcm1hdCA9PT0gZm9ybWF0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuY3JlYXRlRm9ybWF0dGluZ1RlbXBsYXRlKGZvcm1hdCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2hvc2VuRm9ybWF0ID0gZm9ybWF0OyAvLyBXaXRoIGEgbmV3IGZvcm1hdHRpbmcgdGVtcGxhdGUsIHRoZSBtYXRjaGVkIHBvc2l0aW9uXG4gICAgICAgIC8vIHVzaW5nIHRoZSBvbGQgdGVtcGxhdGUgbmVlZHMgdG8gYmUgcmVzZXQuXG5cbiAgICAgICAgdGhpcy5wb3B1bGF0ZWROYXRpb25hbE51bWJlclRlbXBsYXRlUG9zaXRpb24gPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jaG9zZW5Gb3JtYXQpIHtcbiAgICAgICAgLy8gTm8gZm9ybWF0IG1hdGNoZXMgdGhlIG5hdGlvbmFsIHBob25lIG51bWJlciBlbnRlcmVkLlxuICAgICAgICB0aGlzLnJlc2V0Rm9ybWF0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNob3NlbkZvcm1hdDtcbiAgICB9IC8vIEZvcm1hdHMgZWFjaCBkaWdpdCBvZiB0aGUgbmF0aW9uYWwgcGhvbmUgbnVtYmVyIChzbyBmYXIpXG4gICAgLy8gdXNpbmcgdGhlIHNlbGVjdGVkIGZvcm1hdC5cblxuICB9LCB7XG4gICAga2V5OiBcInJlZm9ybWF0TmF0aW9uYWxOdW1iZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmb3JtYXROYXRpb25hbE51bWJlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdE5leHROYXRpb25hbE51bWJlckRpZ2l0cyh0aGlzLm5hdGlvbmFsUHJlZml4ICsgdGhpcy5uYXRpb25hbE51bWJlckRpZ2l0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxpemVQaG9uZU51bWJlckZvcm1hdHNGb3JDb3VudHJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVQaG9uZU51bWJlckZvcm1hdHNGb3JDb3VudHJ5KCkge1xuICAgICAgLy8gR2V0IGFsbCBcImVsaWdpYmxlXCIgcGhvbmUgbnVtYmVyIGZvcm1hdHMgZm9yIHRoaXMgY291bnRyeVxuICAgICAgdGhpcy5tYXRjaGluZ0Zvcm1hdHMgPSB0aGlzLm1ldGFkYXRhLmZvcm1hdHMoKS5maWx0ZXIoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAvLyBDb21wYXJlZCB0byBgbGlicGhvbmVudW1iZXJgJ3MgY29kZSwgdGhlIHR3byBcIkRpc2NhcmQgYSBmZXcgZm9ybWF0c1xuICAgICAgICAvLyB0aGF0IHdlIGtub3cgYXJlIG5vdCByZWxldmFudCBiYXNlZCBvbiB0aGUgcHJlc2VuY2Ugb2YgdGhlIG5hdGlvbmFsIHByZWZpeFwiXG4gICAgICAgIC8vIGNoZWNrcyBoYXZlIGNoYW5nZWQ6IHRoZSBmaXJzdCBvbmUgaGFzIGJlZW4gbW92ZWQgdG8gYC5tYXRjaEZvcm1hdHMoKWAsXG4gICAgICAgIC8vIGFuZCB0aGUgc2Vjb25kIG9uZSBkb2Vzbid0IGFwcGx5IHRvIHRoaXMgbGlicmFyeSBiZWNhdXNlIGl0IGRvZXNuJ3QgZGVhbCB3aXRoXG4gICAgICAgIC8vIFwiaW5jb21wbGV0ZVwiIHBob25lIG51bWJlcnMgKGZvciBleGFtcGxlLCBwaG9uZSBudW1iZXJzLCBlbnRlcmVkIHdpdGhvdXQgXCJhcmVhIGNvZGVcIikuXG4gICAgICAgIHJldHVybiBFTElHSUJMRV9GT1JNQVRfUEFUVEVSTi50ZXN0KGZvcm1hdC5pbnRlcm5hdGlvbmFsRm9ybWF0KCkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoRm9ybWF0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaEZvcm1hdHMobGVhZGluZ0RpZ2l0cykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gXCJsZWFkaW5nIGRpZ2l0c1wiIHBhdHRlcm4gbGlzdCBzdGFydHMgd2l0aCBhXG4gICAgICAvLyBcImxlYWRpbmcgZGlnaXRzXCIgcGF0dGVybiBmaXR0aW5nIGEgbWF4aW11bSBvZiAzIGxlYWRpbmcgZGlnaXRzLlxuICAgICAgLy8gU28sIGFmdGVyIGEgdXNlciBpbnB1dHMgMyBkaWdpdHMgb2YgYSBuYXRpb25hbCAoc2lnbmlmaWNhbnQpIHBob25lIG51bWJlclxuICAgICAgLy8gdGhpcyBuYXRpb25hbCAoc2lnbmlmaWNhbnQpIG51bWJlciBjYW4gYWxyZWFkeSBiZSBmb3JtYXR0ZWQuXG4gICAgICAvLyBUaGUgbmV4dCBcImxlYWRpbmcgZGlnaXRzXCIgcGF0dGVybiBpcyBmb3IgNCBsZWFkaW5nIGRpZ2l0cyBtYXgsXG4gICAgICAvLyBhbmQgdGhlIFwibGVhZGluZyBkaWdpdHNcIiBwYXR0ZXJuIGFmdGVyIGl0IGlzIGZvciA1IGxlYWRpbmcgZGlnaXRzIG1heCwgZXRjLlxuICAgICAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBkaWZmZXJlbnQgZnJvbSBHb29nbGUnc1xuICAgICAgLy8gaW4gdGhhdCBpdCBzZWFyY2hlcyBmb3IgYSBmaXR0aW5nIGZvcm1hdFxuICAgICAgLy8gZXZlbiBpZiB0aGUgdXNlciBoYXMgZW50ZXJlZCBsZXNzIHRoYW5cbiAgICAgIC8vIGBNSU5fTEVBRElOR19ESUdJVFNfTEVOR1RIYCBkaWdpdHMgb2YgYSBuYXRpb25hbCBudW1iZXIuXG4gICAgICAvLyBCZWNhdXNlIHNvbWUgbGVhZGluZyBkaWdpdCBwYXR0ZXJucyBhbHJlYWR5IG1hdGNoIGZvciBhIHNpbmdsZSBmaXJzdCBkaWdpdC5cbiAgICAgIHZhciBsZWFkaW5nRGlnaXRzUGF0dGVybkluZGV4ID0gbGVhZGluZ0RpZ2l0cy5sZW5ndGggLSBNSU5fTEVBRElOR19ESUdJVFNfTEVOR1RIO1xuXG4gICAgICBpZiAobGVhZGluZ0RpZ2l0c1BhdHRlcm5JbmRleCA8IDApIHtcbiAgICAgICAgbGVhZGluZ0RpZ2l0c1BhdHRlcm5JbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWF0Y2hpbmdGb3JtYXRzID0gdGhpcy5tYXRjaGluZ0Zvcm1hdHMuZmlsdGVyKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgLy8gSWYgbmF0aW9uYWwgcHJlZml4IGlzIG1hbmRhdG9yeSBmb3IgdGhpcyBwaG9uZSBudW1iZXIgZm9ybWF0XG4gICAgICAgIC8vIGFuZCB0aGUgdXNlciBkaWRuJ3QgaW5wdXQgdGhlIG5hdGlvbmFsIHByZWZpeFxuICAgICAgICAvLyB0aGVuIHRoaXMgcGhvbmUgbnVtYmVyIGZvcm1hdCBpc24ndCBzdWl0YWJsZS5cbiAgICAgICAgaWYgKCFfdGhpcy5pc0ludGVybmF0aW9uYWwoKSAmJiAhX3RoaXMubmF0aW9uYWxQcmVmaXggJiYgZm9ybWF0Lm5hdGlvbmFsUHJlZml4SXNNYW5kYXRvcnlXaGVuRm9ybWF0dGluZ0luTmF0aW9uYWxGb3JtYXQoKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWFkaW5nRGlnaXRzUGF0dGVybnNDb3VudCA9IGZvcm1hdC5sZWFkaW5nRGlnaXRzUGF0dGVybnMoKS5sZW5ndGg7IC8vIElmIHRoaXMgZm9ybWF0IGlzIG5vdCByZXN0cmljdGVkIHRvIGEgY2VydGFpblxuICAgICAgICAvLyBsZWFkaW5nIGRpZ2l0cyBwYXR0ZXJuIHRoZW4gaXQgZml0cy5cblxuICAgICAgICBpZiAobGVhZGluZ0RpZ2l0c1BhdHRlcm5zQ291bnQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBTdGFydCBleGNsdWRpbmcgYW55IG5vbi1tYXRjaGluZyBmb3JtYXRzIG9ubHkgd2hlbiB0aGVcbiAgICAgICAgLy8gbmF0aW9uYWwgbnVtYmVyIGVudGVyZWQgc28gZmFyIGlzIGF0IGxlYXN0IDMgZGlnaXRzIGxvbmcsXG4gICAgICAgIC8vIG90aGVyd2lzZSBmb3JtYXQgbWF0Y2hpbmcgd291bGQgZ2l2ZSBmYWxzZSBuZWdhdGl2ZXMuXG4gICAgICAgIC8vIEZvciBleGFtcGxlLCB3aGVuIHRoZSBkaWdpdHMgZW50ZXJlZCBzbyBmYXIgYXJlIGAyYFxuICAgICAgICAvLyBhbmQgdGhlIGxlYWRpbmcgZGlnaXRzIHBhdHRlcm4gaXMgYDIxYCDigJNcbiAgICAgICAgLy8gaXQncyBxdWl0ZSBvYnZpb3VzIGluIHRoaXMgY2FzZSB0aGF0IHRoZSBmb3JtYXQgY291bGQgYmUgdGhlIG9uZVxuICAgICAgICAvLyBidXQgZHVlIHRvIHRoZSBhYnNlbmNlIG9mIGZ1cnRoZXIgZGlnaXRzIGl0IHdvdWxkIGdpdmUgZmFsc2UgbmVnYXRpdmUuXG5cblxuICAgICAgICBpZiAobGVhZGluZ0RpZ2l0cy5sZW5ndGggPCBNSU5fTEVBRElOR19ESUdJVFNfTEVOR1RIKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gSWYgYXQgbGVhc3QgYE1JTl9MRUFESU5HX0RJR0lUU19MRU5HVEhgIGRpZ2l0cyBvZiBhIG5hdGlvbmFsIG51bWJlciBhcmUgYXZhaWxhYmxlXG4gICAgICAgIC8vIHRoZW4gZm9ybWF0IG1hdGNoaW5nIHN0YXJ0cyBuYXJyb3dpbmcgZG93biB0aGUgbGlzdCBvZiBwb3NzaWJsZSBmb3JtYXRzXG4gICAgICAgIC8vIChvbmx5IHByZXZpb3VzbHkgbWF0Y2hlZCBmb3JtYXRzIGFyZSBjb25zaWRlcmVkIGZvciBuZXh0IGRpZ2l0cykuXG5cblxuICAgICAgICBsZWFkaW5nRGlnaXRzUGF0dGVybkluZGV4ID0gTWF0aC5taW4obGVhZGluZ0RpZ2l0c1BhdHRlcm5JbmRleCwgbGVhZGluZ0RpZ2l0c1BhdHRlcm5zQ291bnQgLSAxKTtcbiAgICAgICAgdmFyIGxlYWRpbmdEaWdpdHNQYXR0ZXJuID0gZm9ybWF0LmxlYWRpbmdEaWdpdHNQYXR0ZXJucygpW2xlYWRpbmdEaWdpdHNQYXR0ZXJuSW5kZXhdOyAvLyBCcmFja2V0cyBhcmUgcmVxdWlyZWQgZm9yIGBeYCB0byBiZSBhcHBsaWVkIHRvXG4gICAgICAgIC8vIGFsbCBvci1lZCAoYHxgKSBwYXJ0cywgbm90IGp1c3QgdGhlIGZpcnN0IG9uZS5cblxuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oXCIuY29uY2F0KGxlYWRpbmdEaWdpdHNQYXR0ZXJuLCBcIilcIikpLnRlc3QobGVhZGluZ0RpZ2l0cyk7XG4gICAgICB9KTsgLy8gSWYgdGhlcmUgd2FzIGEgcGhvbmUgbnVtYmVyIGZvcm1hdCBjaG9zZW5cbiAgICAgIC8vIGFuZCBpdCBubyBsb25nZXIgaG9sZHMgZ2l2ZW4gdGhlIG5ldyBsZWFkaW5nIGRpZ2l0cyB0aGVuIHJlc2V0IGl0LlxuICAgICAgLy8gVGhlIHRlc3QgZm9yIHRoaXMgYGlmYCBjb25kaXRpb24gaXMgbWFya2VkIGFzOlxuICAgICAgLy8gXCJSZXNldCBhIGNob3NlbiBmb3JtYXQgd2hlbiBpdCBubyBsb25nZXIgaG9sZHMgZ2l2ZW4gdGhlIG5ldyBsZWFkaW5nIGRpZ2l0c1wiLlxuICAgICAgLy8gVG8gY29uc3RydWN0IGEgdmFsaWQgdGVzdCBjYXNlIGZvciB0aGlzIG9uZSBjYW4gZmluZCBhIGNvdW50cnlcbiAgICAgIC8vIGluIGBQaG9uZU51bWJlck1ldGFkYXRhLnhtbGAgeWllbGRpbmcgb25lIGZvcm1hdCBmb3IgMyBgPGxlYWRpbmdEaWdpdHM+YFxuICAgICAgLy8gYW5kIHlpZWxkaW5nIGFub3RoZXIgZm9ybWF0IGZvciA0IGA8bGVhZGluZ0RpZ2l0cz5gIChBdXN0cmFsaWEgaW4gdGhpcyBjYXNlKS5cblxuICAgICAgaWYgKHRoaXMuY2hvc2VuRm9ybWF0ICYmIHRoaXMubWF0Y2hpbmdGb3JtYXRzLmluZGV4T2YodGhpcy5jaG9zZW5Gb3JtYXQpID09PSAtMSkge1xuICAgICAgICB0aGlzLnJlc2V0Rm9ybWF0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNlcGFyYXRvckFmdGVyTmF0aW9uYWxQcmVmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VwYXJhdG9yQWZ0ZXJOYXRpb25hbFByZWZpeChmb3JtYXQpIHtcbiAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmNvdW50cnlDYWxsaW5nQ29kZSgpID09PSAnMScpIHtcbiAgICAgICAgcmV0dXJuICcgJztcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcm1hdCAmJiBmb3JtYXQubmF0aW9uYWxQcmVmaXhGb3JtYXR0aW5nUnVsZSgpICYmIE5BVElPTkFMX1BSRUZJWF9TRVBBUkFUT1JTX1BBVFRFUk4udGVzdChmb3JtYXQubmF0aW9uYWxQcmVmaXhGb3JtYXR0aW5nUnVsZSgpKSkge1xuICAgICAgICByZXR1cm4gJyAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyc7XG4gICAgfSAvLyBUaGlzIGlzIGluIGFjY29yZGFuY2UgdG8gaG93IEdvb2dsZSdzIGBsaWJwaG9uZW51bWJlcmAgZG9lcyBpdC5cbiAgICAvLyBcIkNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhbiBleGFjdCBwYXR0ZXJuIG1hdGNoIGZvciB0aGVzZSBkaWdpdHMuXG4gICAgLy8gSWYgc28sIHdlIHNob3VsZCB1c2UgdGhpcyBpbnN0ZWFkIG9mIGFueSBvdGhlciBmb3JtYXR0aW5nIHRlbXBsYXRlXG4gICAgLy8gd2hvc2UgYGxlYWRpbmdEaWdpdHNQYXR0ZXJuYCBhbHNvIG1hdGNoZXMgdGhlIGlucHV0LlwiXG5cbiAgfSwge1xuICAgIGtleTogXCJhdHRlbXB0VG9Gb3JtYXRDb21wbGV0ZVBob25lTnVtYmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGVtcHRUb0Zvcm1hdENvbXBsZXRlUGhvbmVOdW1iZXIoKSB7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gdGhpcy5tYXRjaGluZ0Zvcm1hdHMsIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgICB2YXIgX3JlZjI7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCk7XG4gICAgICAgICAgaWYgKF9pMi5kb25lKSBicmVhaztcbiAgICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmb3JtYXQgPSBfcmVmMjtcbiAgICAgICAgdmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFwiXig/OlwiLmNvbmNhdChmb3JtYXQucGF0dGVybigpLCBcIikkXCIpKTtcblxuICAgICAgICBpZiAoIW1hdGNoZXIudGVzdCh0aGlzLm5hdGlvbmFsTnVtYmVyRGlnaXRzKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIEhlcmUsIG5hdGlvbmFsIG51bWJlciBpcyBmb3JtYXR0ZWQgd2l0aG91dCBcIm5hdGlvbmFsIHByZWZpeFxuICAgICAgICAvLyBmb3JtYXR0aW5nIHJ1bGVcIiwgYmVjYXVzZSBvdGhlcndpc2UgdGhlcmUnZCBiZSBhIGJ1Z1xuICAgICAgICAvLyB3aGVuIFwiYXJlYSBjb2RlXCIgaXMgXCJkdXBsaWNhdGVkXCIgZHVyaW5nIGlucHV0OlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2F0YW1waGV0YW1pbmUvbGlicGhvbmVudW1iZXItanMvaXNzdWVzLzMxOFxuXG5cbiAgICAgICAgdmFyIGZvcm1hdHRlZE5hdGlvbmFsTnVtYmVyID0gZm9ybWF0TmF0aW9uYWxOdW1iZXJVc2luZ0Zvcm1hdCh0aGlzLm5hdGlvbmFsTnVtYmVyRGlnaXRzLCBmb3JtYXQsIHRoaXMuaXNJbnRlcm5hdGlvbmFsKCksIGZhbHNlLCAvLyBEb24ndCBwcmVwZW5kIG5hdGlvbmFsIHByZWZpeCAoaXQgd2lsbCBiZSBwcmVwZW5kZWQgbWFudWFsbHkpLlxuICAgICAgICB0aGlzLm1ldGFkYXRhKTsgLy8gQ2hlY2sgaWYgdGhpcyBgZm9ybWF0YCBwcmVzZXJ2ZXMgYWxsIGRpZ2l0cy5cbiAgICAgICAgLy8gVGhpcyBpcyBob3cgaXQncyBkb25lIGluIEdvb2dsZSdzIGBsaWJwaG9uZW51bWJlcmAuXG4gICAgICAgIC8vIEFsc28sIGl0IGZpeGVzIHRoZSBidWcgd2hlbiBcImFyZWEgY29kZVwiIGlzIFwiZHVwbGljYXRlZFwiIGR1cmluZyBpbnB1dDpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NhdGFtcGhldGFtaW5lL2xpYnBob25lbnVtYmVyLWpzL2lzc3Vlcy8zMThcbiAgICAgICAgLy9cbiAgICAgICAgLy8gXCJDaGVjayB0aGF0IHdlIGRpZG4ndCByZW1vdmUgbm9yIGFkZCBhbnkgZXh0cmEgZGlnaXRzIHdoZW4gd2UgbWF0Y2hlZFxuICAgICAgICAvLyB0aGlzIGZvcm1hdHRpbmcgcGF0dGVybi4gVGhpcyB1c3VhbGx5IGhhcHBlbnMgYWZ0ZXIgd2UgZW50ZXJlZCB0aGUgbGFzdFxuICAgICAgICAvLyBkaWdpdCBkdXJpbmcgQVlURi4gRWc6IEluIGNhc2Ugb2YgTVgsIHdlIHN3YWxsb3cgbW9iaWxlIHRva2VuICgxKSB3aGVuXG4gICAgICAgIC8vIGZvcm1hdHRlZCBidXQgQVlURiBzaG91bGQgcmV0YWluIGFsbCB0aGUgbnVtYmVyIGVudGVyZWQgYW5kIG5vdCBjaGFuZ2VcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gbWF0Y2ggYSBmb3JtYXQgKG9mIHNhbWUgbGVhZGluZyBkaWdpdHMgYW5kIGxlbmd0aCkgZGlzcGxheVxuICAgICAgICAvLyBpbiB0aGF0IHdheS5cIlxuICAgICAgICAvLyBcIklmIGl0J3MgdGhlIHNhbWUgKGkuZSBlbnRlcmVkIG51bWJlciBhbmQgZm9ybWF0IGlzIHNhbWUpLCB0aGVuIGl0J3NcbiAgICAgICAgLy8gc2FmZSB0byByZXR1cm4gdGhpcyBpbiBmb3JtYXR0ZWQgbnVtYmVyIGFzIG5vdGhpbmcgaXMgbG9zdCAvIGFkZGVkLlwiXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZG9uJ3QgdXNlIHRoaXMgZm9ybWF0LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2xpYnBob25lbnVtYmVyL2NvbW1pdC8zZTdjMWYwNGY1ZTcyMDBmODdmYjEzMWU2Zjg1YzZlOTlkNjBmNTEwI2RpZmYtOTE0OTQ1N2ZhOWY1ZDYwOGExMWJiOTc1YzZlZjRiYzVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9saWJwaG9uZW51bWJlci9jb21taXQvM2FjODhjNzEwNmU3ZGNiNTUzYmNjNzk0YjE1ZjE5MTg1OTI4YTFjNiNkaWZmLTJkY2I3N2U4MzM0MjJlZTMwNGRhMzQ4YjkwNWNkZTBiXG4gICAgICAgIC8vXG5cbiAgICAgICAgaWYgKHBhcnNlRGlnaXRzKGZvcm1hdHRlZE5hdGlvbmFsTnVtYmVyKSAhPT0gdGhpcy5uYXRpb25hbE51bWJlckRpZ2l0cykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIFByZXBlbmQgbmF0aW9uYWwgcHJlZml4IChpZiBhbnkpLlxuXG5cbiAgICAgICAgaWYgKHRoaXMubmF0aW9uYWxQcmVmaXgpIHtcbiAgICAgICAgICAvLyBIZXJlLCBuYXRpb25hbCBudW1iZXIgaXMgZm9ybWF0dGVkIHdpdGggXCJuYXRpb25hbCBwcmVmaXhcbiAgICAgICAgICAvLyBmb3JtYXR0aW5nIHJ1bGVcIi4gVGhlIHJlYXNvbiBpcyB0aGF0IFwibmF0aW9uYWwgcHJlZml4XG4gICAgICAgICAgLy8gZm9ybWF0dGluZyBydWxlXCIgb2Z0ZW4gYWRkcyBwYXJlbnRoZXNlcywgYW5kIHdoaWxlIEdvb2dsZSdzXG4gICAgICAgICAgLy8gYGxpYnBob25lbnVtYmVyYCBkaXNtaXNzZXMgdGhvc2UgcHJlZmVycmluZyBzaW1wbHkgcHJlcGVuZGluZ1xuICAgICAgICAgIC8vIG5hdGlvbmFsIHByZWZpeCBmb2xsb3dlZCBieSBhIFwiIFwiIGNoYXJhY3RlciwgdGhpcyBsaWJyYXJ5XG4gICAgICAgICAgLy8gbG9va3MgaWYgdGhlIG5hdGlvbmFsIHByZWZpeCBjb3VsZCBiZSBmb3JtYXR0ZWQgYmV0dGVyLlxuICAgICAgICAgIHZhciBmb3JtYXR0ZWROYXRpb25hbE51bWJlcldpdGhOYXRpb25hbFByZWZpeCA9IGZvcm1hdE5hdGlvbmFsTnVtYmVyVXNpbmdGb3JtYXQodGhpcy5uYXRpb25hbE51bWJlckRpZ2l0cywgZm9ybWF0LCB0aGlzLmlzSW50ZXJuYXRpb25hbCgpLCB0cnVlLCAvLyBQcmVwZW5kIG5hdGlvbmFsIHByZWZpeC5cbiAgICAgICAgICB0aGlzLm1ldGFkYXRhKTtcblxuICAgICAgICAgIGlmIChwYXJzZURpZ2l0cyhmb3JtYXR0ZWROYXRpb25hbE51bWJlcldpdGhOYXRpb25hbFByZWZpeCkgPT09IHRoaXMubmF0aW9uYWxQcmVmaXggKyB0aGlzLm5hdGlvbmFsTnVtYmVyRGlnaXRzKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWROYXRpb25hbE51bWJlciA9IGZvcm1hdHRlZE5hdGlvbmFsTnVtYmVyV2l0aE5hdGlvbmFsUHJlZml4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWROYXRpb25hbE51bWJlciA9IHRoaXMubmF0aW9uYWxQcmVmaXggKyB0aGlzLmdldFNlcGFyYXRvckFmdGVyTmF0aW9uYWxQcmVmaXgoZm9ybWF0KSArIGZvcm1hdHRlZE5hdGlvbmFsTnVtYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBmb3JtYXRzIG5hdGlvbmFsIG51bWJlciAocHJvYmFibHkpIHdpdGhvdXQgbmF0aW9uYWwgcHJlZml4LlxuICAgICAgICAvLyBGb3JtYXR0aW5nIGEgbmF0aW9uYWwgbnVtYmVyIHdpdGggbmF0aW9uYWwgcHJlZml4IGNvdWxkIHJlc3VsdCBpblxuICAgICAgICAvLyBidWdzIHdoZW4gXCJhcmVhIGNvZGVcIiBpcyBcImR1cGxpY2F0ZWRcIiBkdXJpbmcgaW5wdXQ6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRhbXBoZXRhbWluZS9saWJwaG9uZW51bWJlci1qcy9pc3N1ZXMvMzE4XG4gICAgICAgIC8vIFRoZSBcImFyZSBhbGwgZGlnaXRzIHByZXNlcnZlZFwiIGNoZWNrIGZpeGVzIHRoYXQgdHlwZSBvZiBidWcuXG4gICAgICAgIC8vIFRvIGxlYXZlIHRoZSBmb3JtYXR0ZXIgaW4gYSBjb25zaXN0ZW50IHN0YXRlXG5cblxuICAgICAgICB0aGlzLnJlc2V0Rm9ybWF0KCk7XG4gICAgICAgIHRoaXMuY2hvc2VuRm9ybWF0ID0gZm9ybWF0OyAvLyBTZXQgYHRoaXMudGVtcGxhdGVgIGFuZCBgdGhpcy5wb3B1bGF0ZWROYXRpb25hbE51bWJlclRlbXBsYXRlYC5cblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXG4gICAgICAgIGlmICh0aGlzLmNyZWF0ZUZvcm1hdHRpbmdUZW1wbGF0ZShmb3JtYXQpKSB7XG4gICAgICAgICAgLy8gUG9wdWxhdGUgYHRoaXMucG9wdWxhdGVkTmF0aW9uYWxOdW1iZXJUZW1wbGF0ZWAgd2l0aCBwaG9uZSBudW1iZXIgZGlnaXRzLlxuICAgICAgICAgIHRoaXMucmVmb3JtYXROYXRpb25hbE51bWJlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZSBmb3JtYXR0aW5nIHRlbXBsYXRlIGNvdWxkbid0IGJlIGNyZWF0ZWQgZm9yIGEgZm9ybWF0LFxuICAgICAgICAgIC8vIGNyZWF0ZSBpdCBtYW51YWxseSBmcm9tIHRoZSBmb3JtYXR0ZWQgcGhvbmUgbnVtYmVyLlxuICAgICAgICAgIC8vIFRoaXMgY2FzZSBkb2Vzbid0IGV2ZXIgaGFwcGVuIHdpdGggdGhlIGN1cnJlbnQgbWV0YWRhdGEuXG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRoaXMuZ2V0RnVsbE51bWJlcihmb3JtYXR0ZWROYXRpb25hbE51bWJlcikucmVwbGFjZSgvW1xcZFxcK10vZywgRElHSVRfUExBQ0VIT0xERVIpO1xuICAgICAgICAgIHRoaXMucG9wdWxhdGVkTmF0aW9uYWxOdW1iZXJUZW1wbGF0ZSA9IGZvcm1hdHRlZE5hdGlvbmFsTnVtYmVyO1xuICAgICAgICAgIHRoaXMucG9wdWxhdGVkTmF0aW9uYWxOdW1iZXJUZW1wbGF0ZVBvc2l0aW9uID0gdGhpcy5wb3B1bGF0ZWROYXRpb25hbE51bWJlclRlbXBsYXRlLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkTmF0aW9uYWxOdW1iZXI7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEludGVybmF0aW9uYWxQcmVmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW50ZXJuYXRpb25hbFByZWZpeChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcm5hdGlvbmFsUHJlZml4ID8gb3B0aW9ucyAmJiBvcHRpb25zLnNwYWNpbmcgPT09IGZhbHNlID8gdGhpcy5pbnRlcm5hdGlvbmFsUHJlZml4IDogdGhpcy5pbnRlcm5hdGlvbmFsUHJlZml4ICsgJyAnIDogJysnO1xuICAgIH0gLy8gUHJlcGVuZHMgYCtDb3VudHJ5Q29kZSBgIGluIGNhc2Ugb2YgYW4gaW50ZXJuYXRpb25hbCBwaG9uZSBudW1iZXJcblxuICB9LCB7XG4gICAga2V5OiBcImdldEZ1bGxOdW1iZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnVsbE51bWJlcihmb3JtYXR0ZWROYXRpb25hbE51bWJlcikge1xuICAgICAgaWYgKHRoaXMuaXNJbnRlcm5hdGlvbmFsKCkpIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IHRoaXMuZ2V0SW50ZXJuYXRpb25hbFByZWZpeCgpO1xuXG4gICAgICAgIGlmICghdGhpcy5jb3VudHJ5Q2FsbGluZ0NvZGUpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQocHJlZml4KS5jb25jYXQodGhpcy5kaWdpdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmb3JtYXR0ZWROYXRpb25hbE51bWJlcikge1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwcmVmaXgpLmNvbmNhdCh0aGlzLmNvdW50cnlDYWxsaW5nQ29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQocHJlZml4KS5jb25jYXQodGhpcy5jb3VudHJ5Q2FsbGluZ0NvZGUsIFwiIFwiKS5jb25jYXQoZm9ybWF0dGVkTmF0aW9uYWxOdW1iZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9ybWF0dGVkTmF0aW9uYWxOdW1iZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE5vbkZvcm1hdHRlZE5hdGlvbmFsTnVtYmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vbkZvcm1hdHRlZE5hdGlvbmFsTnVtYmVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmF0aW9uYWxQcmVmaXggKyAodGhpcy5uYXRpb25hbFByZWZpeCAmJiB0aGlzLm5hdGlvbmFsTnVtYmVyRGlnaXRzICYmIHRoaXMuZ2V0U2VwYXJhdG9yQWZ0ZXJOYXRpb25hbFByZWZpeCgpKSArIHRoaXMubmF0aW9uYWxOdW1iZXJEaWdpdHM7XG4gICAgfSAvLyBFeHRyYWN0cyB0aGUgY291bnRyeSBjYWxsaW5nIGNvZGUgZnJvbSB0aGUgYmVnaW5uaW5nXG4gICAgLy8gb2YgdGhlIGVudGVyZWQgYG5hdGlvbmFsX251bWJlcmAgKHNvIGZhciksXG4gICAgLy8gYW5kIHBsYWNlcyB0aGUgcmVtYWluaW5nIGlucHV0IGludG8gdGhlIGBuYXRpb25hbF9udW1iZXJgLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0cmFjdENvdW50cnlDYWxsaW5nQ29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0Q291bnRyeUNhbGxpbmdDb2RlKCkge1xuICAgICAgdmFyIF9leHRyYWN0Q291bnRyeUNhbGxpbiA9IHBhcnNlX2V4dHJhY3RDb3VudHJ5Q2FsbGluZ0NvZGUoJysnICsgdGhpcy5kaWdpdHMsIHRoaXMuZGVmYXVsdENvdW50cnksIHRoaXMuZGVmYXVsdENhbGxpbmdDb2RlLCB0aGlzLm1ldGFkYXRhLm1ldGFkYXRhKSxcbiAgICAgICAgICBjb3VudHJ5Q2FsbGluZ0NvZGUgPSBfZXh0cmFjdENvdW50cnlDYWxsaW4uY291bnRyeUNhbGxpbmdDb2RlLFxuICAgICAgICAgIG51bWJlciA9IF9leHRyYWN0Q291bnRyeUNhbGxpbi5udW1iZXI7XG5cbiAgICAgIGlmICghY291bnRyeUNhbGxpbmdDb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5uYXRpb25hbE51bWJlckRpZ2l0cyA9IG51bWJlcjtcbiAgICAgIHRoaXMuY291bnRyeUNhbGxpbmdDb2RlID0gY291bnRyeUNhbGxpbmdDb2RlO1xuICAgICAgdGhpcy5tZXRhZGF0YS5jaG9vc2VDb3VudHJ5QnlDb3VudHJ5Q2FsbGluZ0NvZGUoY291bnRyeUNhbGxpbmdDb2RlKTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVBob25lTnVtYmVyRm9ybWF0c0ZvckNvdW50cnkoKTtcbiAgICAgIHRoaXMucmVzZXRGb3JtYXQoKTtcbiAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhLmhhc1NlbGVjdGVkTnVtYmVyaW5nUGxhbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHRyYWN0TmF0aW9uYWxQcmVmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdE5hdGlvbmFsUHJlZml4KCkge1xuICAgICAgdGhpcy5uYXRpb25hbFByZWZpeCA9ICcnO1xuXG4gICAgICBpZiAoIXRoaXMubWV0YWRhdGEuaGFzU2VsZWN0ZWROdW1iZXJpbmdQbGFuKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBPbmx5IHN0cmlwIG5hdGlvbmFsIHByZWZpeGVzIGZvciBub24taW50ZXJuYXRpb25hbCBwaG9uZSBudW1iZXJzXG4gICAgICAvLyBiZWNhdXNlIG5hdGlvbmFsIHByZWZpeGVzIGNhbid0IGJlIHByZXNlbnQgaW4gaW50ZXJuYXRpb25hbCBwaG9uZSBudW1iZXJzLlxuICAgICAgLy8gV2hpbGUgYHBhcnNlTnVtYmVyKClgIGlzIGZvcmdpdmluZyBpcyBzdWNoIGNhc2VzLCBgQXNZb3VUeXBlYCBpcyBub3QuXG5cblxuICAgICAgdmFyIF9zdHJpcE5hdGlvbmFsUHJlZml4QSA9IHN0cmlwTmF0aW9uYWxQcmVmaXhBbmRDYXJyaWVyQ29kZSh0aGlzLm5hdGlvbmFsTnVtYmVyRGlnaXRzLCB0aGlzLm1ldGFkYXRhKSxcbiAgICAgICAgICBuYXRpb25hbE51bWJlciA9IF9zdHJpcE5hdGlvbmFsUHJlZml4QS5uYXRpb25hbE51bWJlcixcbiAgICAgICAgICBjYXJyaWVyQ29kZSA9IF9zdHJpcE5hdGlvbmFsUHJlZml4QS5jYXJyaWVyQ29kZTsgLy8gU29tZXRpbWVzIGBzdHJpcE5hdGlvbmFsUHJlZml4QW5kQ2FycmllckNvZGUoKWAgd29uJ3QgYWN0dWFsbHlcbiAgICAgIC8vIHN0cmlwIG5hdGlvbmFsIHByZWZpeCBhbmQgd2lsbCBpbnN0ZWFkIHByZXBlbmQgc29tZSBkaWdpdHMgdG8gdGhlIGBudW1iZXJgOlxuICAgICAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gbnVtYmVyIGAyMzQ1Njc4YCBpcyBwYXNzZWQgd2l0aCBgVklgIGNvdW50cnkgc2VsZWN0ZWQsXG4gICAgICAvLyBpdCB3aWxsIHJldHVybiBgeyBudW1iZXI6IFwiMzQwMjM0NTY3OFwiIH1gLCBiZWNhdXNlIGAzNDBgIGFyZWEgY29kZSBpcyBwcmVwZW5kZWQuXG4gICAgICAvLyBTbyBjaGVjayBpZiB0aGUgYG5hdGlvbmFsTnVtYmVyYCBpcyBhY3R1YWxseSBhdCB0aGUgZW5kIG9mIGB0aGlzLm5hdGlvbmFsTnVtYmVyRGlnaXRzYC5cblxuXG4gICAgICBpZiAobmF0aW9uYWxOdW1iZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5uYXRpb25hbE51bWJlckRpZ2l0cy5pbmRleE9mKG5hdGlvbmFsTnVtYmVyKTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ICE9PSB0aGlzLm5hdGlvbmFsTnVtYmVyRGlnaXRzLmxlbmd0aCAtIG5hdGlvbmFsTnVtYmVyLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FycmllckNvZGUpIHtcbiAgICAgICAgdGhpcy5jYXJyaWVyQ29kZSA9IGNhcnJpZXJDb2RlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5hdGlvbmFsUHJlZml4ID0gdGhpcy5uYXRpb25hbE51bWJlckRpZ2l0cy5zbGljZSgwLCB0aGlzLm5hdGlvbmFsTnVtYmVyRGlnaXRzLmxlbmd0aCAtIG5hdGlvbmFsTnVtYmVyLmxlbmd0aCk7XG4gICAgICB0aGlzLm5hdGlvbmFsTnVtYmVyRGlnaXRzID0gbmF0aW9uYWxOdW1iZXI7XG4gICAgICByZXR1cm4gdGhpcy5uYXRpb25hbFByZWZpeDtcbiAgICB9IC8vIGlzUG9zc2libGVOdW1iZXIobnVtYmVyKSB7XG4gICAgLy8gXHRzd2l0Y2ggKGNoZWNrTnVtYmVyTGVuZ3RoRm9yVHlwZShudW1iZXIsIHVuZGVmaW5lZCwgdGhpcy5tZXRhZGF0YSkpIHtcbiAgICAvLyBcdFx0Y2FzZSAnSVNfUE9TU0lCTEUnOlxuICAgIC8vIFx0XHRcdHJldHVybiB0cnVlXG4gICAgLy8gXHRcdC8vIGNhc2UgJ0lTX1BPU1NJQkxFX0xPQ0FMX09OTFknOlxuICAgIC8vIFx0XHQvLyBcdHJldHVybiAhdGhpcy5pc0ludGVybmF0aW9uYWwoKVxuICAgIC8vIFx0XHRkZWZhdWx0OlxuICAgIC8vIFx0XHRcdHJldHVybiBmYWxzZVxuICAgIC8vIFx0fVxuICAgIC8vIH1cblxuICB9LCB7XG4gICAga2V5OiBcImlzQ291bnRyeUNhbGxpbmdDb2RlQW1iaWd1b3VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQ291bnRyeUNhbGxpbmdDb2RlQW1iaWd1b3VzKCkge1xuICAgICAgdmFyIGNvdW50cnlDb2RlcyA9IHRoaXMubWV0YWRhdGEuZ2V0Q291bnRyeUNvZGVzRm9yQ2FsbGluZ0NvZGUodGhpcy5jb3VudHJ5Q2FsbGluZ0NvZGUpO1xuICAgICAgcmV0dXJuIGNvdW50cnlDb2RlcyAmJiBjb3VudHJ5Q29kZXMubGVuZ3RoID4gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlRm9ybWF0dGluZ1RlbXBsYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUZvcm1hdHRpbmdUZW1wbGF0ZShmb3JtYXQpIHtcbiAgICAgIC8vIFRoZSBmb3JtYXR0ZXIgZG9lc24ndCBmb3JtYXQgbnVtYmVycyB3aGVuIG51bWJlclBhdHRlcm4gY29udGFpbnMgJ3wnLCBlLmcuXG4gICAgICAvLyAoMjB8MylcXGR7NH0uIEluIHRob3NlIGNhc2VzIHdlIHF1aWNrbHkgcmV0dXJuLlxuICAgICAgLy8gKFRob3VnaCB0aGVyZSdzIG5vIHN1Y2ggZm9ybWF0IGluIGN1cnJlbnQgbWV0YWRhdGEpXG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKFNVUFBPUlRfTEVHQUNZX0ZPUk1BVFRJTkdfUEFUVEVSTlMgJiYgZm9ybWF0LnBhdHRlcm4oKS5pbmRleE9mKCd8JykgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEdldCBmb3JtYXR0aW5nIHRlbXBsYXRlIGZvciB0aGlzIHBob25lIG51bWJlciBmb3JtYXRcblxuXG4gICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLmdldFRlbXBsYXRlRm9yTnVtYmVyRm9ybWF0UGF0dGVybihmb3JtYXQsIHRoaXMubmF0aW9uYWxQcmVmaXgpOyAvLyBJZiB0aGUgbmF0aW9uYWwgbnVtYmVyIGVudGVyZWQgaXMgdG9vIGxvbmdcbiAgICAgIC8vIGZvciBhbnkgcGhvbmUgbnVtYmVyIGZvcm1hdCwgdGhlbiBhYm9ydC5cblxuICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgIHRoaXMucG9wdWxhdGVkTmF0aW9uYWxOdW1iZXJUZW1wbGF0ZSA9IHRlbXBsYXRlOyAvLyBGb3IgY29udmVuaWVuY2UsIHRoZSBwdWJsaWMgYC50ZW1wbGF0ZWAgcHJvcGVydHlcbiAgICAgIC8vIGNvbnRhaW5zIHRoZSB3aG9sZSBpbnRlcm5hdGlvbmFsIG51bWJlclxuICAgICAgLy8gaWYgdGhlIHBob25lIG51bWJlciBiZWluZyBpbnB1dCBpcyBpbnRlcm5hdGlvbmFsOlxuICAgICAgLy8gJ3gnIGZvciB0aGUgJysnIHNpZ24sICd4J2VzIGZvciB0aGUgY291bnRyeSBwaG9uZSBjb2RlLFxuICAgICAgLy8gYSBzcGFjZWJhciBhbmQgdGhlbiB0aGUgdGVtcGxhdGUgZm9yIHRoZSBmb3JtYXR0ZWQgbmF0aW9uYWwgbnVtYmVyLlxuXG4gICAgICBpZiAodGhpcy5pc0ludGVybmF0aW9uYWwoKSkge1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy5nZXRJbnRlcm5hdGlvbmFsUHJlZml4KCkucmVwbGFjZSgvW1xcZFxcK10vZywgRElHSVRfUExBQ0VIT0xERVIpICsgcmVwZWF0KERJR0lUX1BMQUNFSE9MREVSLCB0aGlzLmNvdW50cnlDYWxsaW5nQ29kZS5sZW5ndGgpICsgJyAnICsgdGVtcGxhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBmb3JtYXR0aW5nIHRlbXBsYXRlIGZvciBhIG5hdGlvbmFsIHBob25lIG51bWJlcixcclxuICAgICAqIG9wdGlvbmFsbHkgY29udGFpbmluZyBhIG5hdGlvbmFsIHByZWZpeCwgZm9yIGEgZm9ybWF0LlxyXG4gICAgICogQHBhcmFtICB7Rm9ybWF0fSBmb3JtYXRcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gbmF0aW9uYWxQcmVmaXhcclxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGVtcGxhdGVGb3JOdW1iZXJGb3JtYXRQYXR0ZXJuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRlbXBsYXRlRm9yTnVtYmVyRm9ybWF0UGF0dGVybihmb3JtYXQsIG5hdGlvbmFsUHJlZml4KSB7XG4gICAgICB2YXIgcGF0dGVybiA9IGZvcm1hdC5wYXR0ZXJuKCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXG4gICAgICBpZiAoU1VQUE9SVF9MRUdBQ1lfRk9STUFUVElOR19QQVRURVJOUykge1xuICAgICAgICBwYXR0ZXJuID0gcGF0dGVybiAvLyBSZXBsYWNlIGFueXRoaW5nIGluIHRoZSBmb3JtIG9mIFsuLl0gd2l0aCBcXGRcbiAgICAgICAgLnJlcGxhY2UoQ1JFQVRFX0NIQVJBQ1RFUl9DTEFTU19QQVRURVJOKCksICdcXFxcZCcpIC8vIFJlcGxhY2UgYW55IHN0YW5kYWxvbmUgZGlnaXQgKG5vdCB0aGUgb25lIGluIGB7fWApIHdpdGggXFxkXG4gICAgICAgIC5yZXBsYWNlKENSRUFURV9TVEFOREFMT05FX0RJR0lUX1BBVFRFUk4oKSwgJ1xcXFxkJyk7XG4gICAgICB9IC8vIEdlbmVyYXRlIGEgZHVtbXkgbmF0aW9uYWwgbnVtYmVyIChjb25zaXN0aW5nIG9mIGA5YHMpXG4gICAgICAvLyB0aGF0IGZpdHMgdGhpcyBmb3JtYXQncyBgcGF0dGVybmAuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBtYXRjaCB3aWxsIGFsd2F5cyBzdWNjZWVkLFxuICAgICAgLy8gYmVjYXVzZSB0aGUgXCJsb25nZXN0IGR1bW15IHBob25lIG51bWJlclwiXG4gICAgICAvLyBoYXMgZW5vdWdoIGxlbmd0aCB0byBhY2NvbW9kYXRlIGFueSBwb3NzaWJsZVxuICAgICAgLy8gbmF0aW9uYWwgcGhvbmUgbnVtYmVyIGZvcm1hdCBwYXR0ZXJuLlxuICAgICAgLy9cblxuXG4gICAgICB2YXIgZGlnaXRzID0gTE9OR0VTVF9EVU1NWV9QSE9ORV9OVU1CRVIubWF0Y2gocGF0dGVybilbMF07IC8vIElmIHRoZSBuYXRpb25hbCBudW1iZXIgZW50ZXJlZCBpcyB0b28gbG9uZ1xuICAgICAgLy8gZm9yIGFueSBwaG9uZSBudW1iZXIgZm9ybWF0LCB0aGVuIGFib3J0LlxuXG4gICAgICBpZiAodGhpcy5uYXRpb25hbE51bWJlckRpZ2l0cy5sZW5ndGggPiBkaWdpdHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gR2V0IGEgZm9ybWF0dGluZyB0ZW1wbGF0ZSB3aGljaCBjYW4gYmUgdXNlZCB0byBlZmZpY2llbnRseSBmb3JtYXRcbiAgICAgIC8vIGEgcGFydGlhbCBudW1iZXIgd2hlcmUgZGlnaXRzIGFyZSBhZGRlZCBvbmUgYnkgb25lLlxuICAgICAgLy8gQmVsb3cgYHN0cmljdFBhdHRlcm5gIGlzIHVzZWQgZm9yIHRoZVxuICAgICAgLy8gcmVndWxhciBleHByZXNzaW9uICh3aXRoIGBeYCBhbmQgYCRgKS5cbiAgICAgIC8vIFRoaXMgd2Fzbid0IG9yaWdpbmFsbHkgaW4gR29vZ2xlJ3MgYGxpYnBob25lbnVtYmVyYFxuICAgICAgLy8gYW5kIEkgZ3Vlc3MgdGhleSBkb24ndCByZWFsbHkgbmVlZCBpdFxuICAgICAgLy8gYmVjYXVzZSB0aGV5J3JlIG5vdCB1c2luZyBcInRlbXBsYXRlc1wiIHRvIGZvcm1hdCBwaG9uZSBudW1iZXJzXG4gICAgICAvLyBidXQgSSBhZGRlZCBgc3RyaWN0UGF0dGVybmAgYWZ0ZXIgZW5jb3VudGVyaW5nXG4gICAgICAvLyBTb3V0aCBLb3JlYW4gcGhvbmUgbnVtYmVyIGZvcm1hdHRpbmcgYnVnLlxuICAgICAgLy9cbiAgICAgIC8vIE5vbi1zdHJpY3QgcmVndWxhciBleHByZXNzaW9uIGJ1ZyBkZW1vbnN0cmF0aW9uOlxuICAgICAgLy9cbiAgICAgIC8vIHRoaXMubmF0aW9uYWxOdW1iZXJEaWdpdHMgOiBgMTExMTExMTExYCAoOSBkaWdpdHMpXG4gICAgICAvL1xuICAgICAgLy8gcGF0dGVybiA6IChcXGR7Mn0pKFxcZHszLDR9KShcXGR7NH0pXG4gICAgICAvLyBmb3JtYXQgOiBgJDEgJDIgJDNgXG4gICAgICAvLyBkaWdpdHMgOiBgOTk5OTk5OTk5OWAgKDEwIGRpZ2l0cylcbiAgICAgIC8vXG4gICAgICAvLyAnOTk5OTk5OTk5OScucmVwbGFjZShuZXcgUmVnRXhwKC8oXFxkezJ9KShcXGR7Myw0fSkoXFxkezR9KS9nKSwgJyQxICQyICQzJykgPSBcIjk5IDk5OTkgOTk5OVwiXG4gICAgICAvL1xuICAgICAgLy8gdGVtcGxhdGUgOiB4eCB4eHh4IHh4eHhcbiAgICAgIC8vXG4gICAgICAvLyBCdXQgdGhlIGNvcnJlY3QgdGVtcGxhdGUgaW4gdGhpcyBjYXNlIGlzIGB4eCB4eHggeHh4eGAuXG4gICAgICAvLyBUaGUgdGVtcGxhdGUgd2FzIGdlbmVyYXRlZCBpbmNvcnJlY3RseSBiZWNhdXNlIG9mIHRoZVxuICAgICAgLy8gYHszLDR9YCB2YXJpYWJpbGl0eSBpbiB0aGUgYHBhdHRlcm5gLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBmaXggaXMsIGlmIGB0aGlzLm5hdGlvbmFsTnVtYmVyRGlnaXRzYCBoYXMgYWxyZWFkeSBzdWZmaWNpZW50IGxlbmd0aFxuICAgICAgLy8gdG8gc2F0aXNmeSB0aGUgYHBhdHRlcm5gIGNvbXBsZXRlbHkgdGhlbiBgdGhpcy5uYXRpb25hbE51bWJlckRpZ2l0c2BcbiAgICAgIC8vIGlzIHVzZWQgaW5zdGVhZCBvZiBgZGlnaXRzYC5cblxuXG4gICAgICB2YXIgc3RyaWN0UGF0dGVybiA9IG5ldyBSZWdFeHAoJ14nICsgcGF0dGVybiArICckJyk7XG4gICAgICB2YXIgbmF0aW9uYWxOdW1iZXJEdW1teURpZ2l0cyA9IHRoaXMubmF0aW9uYWxOdW1iZXJEaWdpdHMucmVwbGFjZSgvXFxkL2csIERVTU1ZX0RJR0lUKTsgLy8gSWYgYHRoaXMubmF0aW9uYWxOdW1iZXJEaWdpdHNgIGhhcyBhbHJlYWR5IHN1ZmZpY2llbnQgbGVuZ3RoXG4gICAgICAvLyB0byBzYXRpc2Z5IHRoZSBgcGF0dGVybmAgY29tcGxldGVseSB0aGVuIHVzZSBpdFxuICAgICAgLy8gaW5zdGVhZCBvZiBgZGlnaXRzYC5cblxuICAgICAgaWYgKHN0cmljdFBhdHRlcm4udGVzdChuYXRpb25hbE51bWJlckR1bW15RGlnaXRzKSkge1xuICAgICAgICBkaWdpdHMgPSBuYXRpb25hbE51bWJlckR1bW15RGlnaXRzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbnVtYmVyRm9ybWF0ID0gdGhpcy5nZXRGb3JtYXRGb3JtYXQoZm9ybWF0KTtcbiAgICAgIHZhciBpbmNsdWRlc05hdGlvbmFsUHJlZml4O1xuXG4gICAgICBpZiAobmF0aW9uYWxQcmVmaXgpIHtcbiAgICAgICAgaWYgKGZvcm1hdC5uYXRpb25hbFByZWZpeEZvcm1hdHRpbmdSdWxlKCkpIHtcbiAgICAgICAgICB2YXIgbnVtYmVyRm9ybWF0V2l0aE5hdGlvbmFsUHJlZml4ID0gbnVtYmVyRm9ybWF0LnJlcGxhY2UoRklSU1RfR1JPVVBfUEFUVEVSTiwgZm9ybWF0Lm5hdGlvbmFsUHJlZml4Rm9ybWF0dGluZ1J1bGUoKSk7XG5cbiAgICAgICAgICBpZiAocGFyc2VEaWdpdHMobnVtYmVyRm9ybWF0V2l0aE5hdGlvbmFsUHJlZml4KSA9PT0gbmF0aW9uYWxQcmVmaXggKyBwYXJzZURpZ2l0cyhudW1iZXJGb3JtYXQpKSB7XG4gICAgICAgICAgICBudW1iZXJGb3JtYXQgPSBudW1iZXJGb3JtYXRXaXRoTmF0aW9uYWxQcmVmaXg7XG4gICAgICAgICAgICBpbmNsdWRlc05hdGlvbmFsUHJlZml4ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBpID0gbmF0aW9uYWxQcmVmaXgubGVuZ3RoO1xuXG4gICAgICAgICAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgICAgICAgICAgbnVtYmVyRm9ybWF0ID0gbnVtYmVyRm9ybWF0LnJlcGxhY2UoL1xcZC8sIERJR0lUX1BMQUNFSE9MREVSKTtcbiAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBHZW5lcmF0ZSBmb3JtYXR0aW5nIHRlbXBsYXRlIGZvciB0aGlzIHBob25lIG51bWJlciBmb3JtYXQuXG5cblxuICAgICAgdmFyIHRlbXBsYXRlID0gZGlnaXRzIC8vIEZvcm1hdCB0aGUgZHVtbXkgcGhvbmUgbnVtYmVyIGFjY29yZGluZyB0byB0aGUgZm9ybWF0LlxuICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChwYXR0ZXJuKSwgbnVtYmVyRm9ybWF0KSAvLyBSZXBsYWNlIGVhY2ggZHVtbXkgZGlnaXQgd2l0aCBhIERJR0lUX1BMQUNFSE9MREVSLlxuICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChEVU1NWV9ESUdJVCwgJ2cnKSwgRElHSVRfUExBQ0VIT0xERVIpO1xuXG4gICAgICBpZiAobmF0aW9uYWxQcmVmaXgpIHtcbiAgICAgICAgaWYgKCFpbmNsdWRlc05hdGlvbmFsUHJlZml4KSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBuYXRpb25hbCBwcmVmaXggdG8gdGhlIHRlbXBsYXRlIG1hbnVhbGx5LlxuICAgICAgICAgIHRlbXBsYXRlID0gcmVwZWF0KERJR0lUX1BMQUNFSE9MREVSLCBuYXRpb25hbFByZWZpeC5sZW5ndGgpICsgdGhpcy5nZXRTZXBhcmF0b3JBZnRlck5hdGlvbmFsUHJlZml4KGZvcm1hdCkgKyB0ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdE5leHROYXRpb25hbE51bWJlckRpZ2l0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXROZXh0TmF0aW9uYWxOdW1iZXJEaWdpdHMoZGlnaXRzKSB7XG4gICAgICAvLyBVc2luZyBgLnNwbGl0KCcnKWAgdG8gaXRlcmF0ZSB0aHJvdWdoIGEgc3RyaW5nIGhlcmVcbiAgICAgIC8vIHRvIGF2b2lkIHJlcXVpcmluZyBgU3ltYm9sLml0ZXJhdG9yYCBwb2x5ZmlsbC5cbiAgICAgIC8vIGAuc3BsaXQoJycpYCBpcyBnZW5lcmFsbHkgbm90IHNhZmUgZm9yIFVuaWNvZGUsXG4gICAgICAvLyBidXQgaW4gdGhpcyBwYXJ0aWN1bGFyIGNhc2UgZm9yIGBkaWdpdHNgIGl0IGlzIHNhZmUuXG4gICAgICAvLyBmb3IgKGNvbnN0IGRpZ2l0IG9mIGRpZ2l0cylcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBkaWdpdHMuc3BsaXQoJycpLCBfaXNBcnJheTMgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjMpLCBfaTMgPSAwLCBfaXRlcmF0b3IzID0gX2lzQXJyYXkzID8gX2l0ZXJhdG9yMyA6IF9pdGVyYXRvcjNbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgdmFyIF9yZWYzO1xuXG4gICAgICAgIGlmIChfaXNBcnJheTMpIHtcbiAgICAgICAgICBpZiAoX2kzID49IF9pdGVyYXRvcjMubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICBfcmVmMyA9IF9pdGVyYXRvcjNbX2kzKytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9pMyA9IF9pdGVyYXRvcjMubmV4dCgpO1xuICAgICAgICAgIGlmIChfaTMuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgX3JlZjMgPSBfaTMudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlnaXQgPSBfcmVmMztcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyByb29tIGZvciBtb3JlIGRpZ2l0cyBpbiBjdXJyZW50IGB0ZW1wbGF0ZWAsXG4gICAgICAgIC8vIHRoZW4gc2V0IHRoZSBuZXh0IGRpZ2l0IGluIHRoZSBgdGVtcGxhdGVgLFxuICAgICAgICAvLyBhbmQgcmV0dXJuIHRoZSBmb3JtYXR0ZWQgZGlnaXRzIHNvIGZhci5cbiAgICAgICAgLy8gSWYgbW9yZSBkaWdpdHMgYXJlIGVudGVyZWQgdGhhbiB0aGUgY3VycmVudCBmb3JtYXQgY291bGQgaGFuZGxlLlxuICAgICAgICBpZiAodGhpcy5wb3B1bGF0ZWROYXRpb25hbE51bWJlclRlbXBsYXRlLnNsaWNlKHRoaXMucG9wdWxhdGVkTmF0aW9uYWxOdW1iZXJUZW1wbGF0ZVBvc2l0aW9uICsgMSkuc2VhcmNoKERJR0lUX1BMQUNFSE9MREVSX01BVENIRVIpIDwgMCkge1xuICAgICAgICAgIC8vIFJlc2V0IHRoZSBmb3JtYXQuXG4gICAgICAgICAgdGhpcy5yZXNldEZvcm1hdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucG9wdWxhdGVkTmF0aW9uYWxOdW1iZXJUZW1wbGF0ZVBvc2l0aW9uID0gdGhpcy5wb3B1bGF0ZWROYXRpb25hbE51bWJlclRlbXBsYXRlLnNlYXJjaChESUdJVF9QTEFDRUhPTERFUl9NQVRDSEVSKTtcbiAgICAgICAgdGhpcy5wb3B1bGF0ZWROYXRpb25hbE51bWJlclRlbXBsYXRlID0gdGhpcy5wb3B1bGF0ZWROYXRpb25hbE51bWJlclRlbXBsYXRlLnJlcGxhY2UoRElHSVRfUExBQ0VIT0xERVJfTUFUQ0hFUiwgZGlnaXQpO1xuICAgICAgfSAvLyBSZXR1cm4gdGhlIGZvcm1hdHRlZCBwaG9uZSBudW1iZXIgc28gZmFyLlxuXG5cbiAgICAgIHJldHVybiBjdXRBbmRTdHJpcE5vblBhaXJlZFBhcmVucyh0aGlzLnBvcHVsYXRlZE5hdGlvbmFsTnVtYmVyVGVtcGxhdGUsIHRoaXMucG9wdWxhdGVkTmF0aW9uYWxOdW1iZXJUZW1wbGF0ZVBvc2l0aW9uICsgMSk7IC8vIFRoZSBvbGQgd2F5IHdoaWNoIHdhcyBnb29kIGZvciBgaW5wdXQtZm9ybWF0YCBidXQgaXMgbm90IHNvIGdvb2RcbiAgICAgIC8vIGZvciBgcmVhY3QtcGhvbmUtbnVtYmVyLWlucHV0YCdzIGRlZmF1bHQgaW5wdXQgKGBJbnB1dEJhc2ljYCkuXG4gICAgICAvLyByZXR1cm4gY2xvc2VOb25QYWlyZWRQYXJlbnModGhpcy5wb3B1bGF0ZWROYXRpb25hbE51bWJlclRlbXBsYXRlLCB0aGlzLnBvcHVsYXRlZE5hdGlvbmFsTnVtYmVyVGVtcGxhdGVQb3NpdGlvbiArIDEpXG4gICAgICAvLyBcdC5yZXBsYWNlKG5ldyBSZWdFeHAoRElHSVRfUExBQ0VIT0xERVIsICdnJyksICcgJylcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9ybWF0Rm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvcm1hdEZvcm1hdChmb3JtYXQpIHtcbiAgICAgIGlmICh0aGlzLmlzSW50ZXJuYXRpb25hbCgpKSB7XG4gICAgICAgIHJldHVybiBhcHBseUludGVybmF0aW9uYWxTZXBhcmF0b3JTdHlsZShmb3JtYXQuaW50ZXJuYXRpb25hbEZvcm1hdCgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvcm1hdC5mb3JtYXQoKTtcbiAgICB9IC8vIERldGVybWluZXMgdGhlIGNvdW50cnkgb2YgdGhlIHBob25lIG51bWJlclxuICAgIC8vIGVudGVyZWQgc28gZmFyIGJhc2VkIG9uIHRoZSBjb3VudHJ5IHBob25lIGNvZGVcbiAgICAvLyBhbmQgdGhlIG5hdGlvbmFsIHBob25lIG51bWJlci5cblxuICB9LCB7XG4gICAga2V5OiBcImRldGVybWluZVRoZUNvdW50cnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lVGhlQ291bnRyeSgpIHtcbiAgICAgIHRoaXMuY291bnRyeSA9IGZpbmRDb3VudHJ5Q29kZSh0aGlzLmlzSW50ZXJuYXRpb25hbCgpID8gdGhpcy5jb3VudHJ5Q2FsbGluZ0NvZGUgOiB0aGlzLmRlZmF1bHRDYWxsaW5nQ29kZSwgdGhpcy5uYXRpb25hbE51bWJlckRpZ2l0cywgdGhpcy5tZXRhZGF0YSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBgUGhvbmVOdW1iZXJgIGNsYXNzLlxyXG4gICAgICogV2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaWYgbm8gbmF0aW9uYWwgKHNpZ25pZmljYW50KSBudW1iZXJcclxuICAgICAqIGRpZ2l0cyBoYXZlIGJlZW4gZW50ZXJlZCBzbyBmYXIsIG9yIGlmIG5vIGBkZWZhdWx0Q291bnRyeWAgaGFzIGJlZW5cclxuICAgICAqIHNldCBhbmQgdGhlIHVzZXIgZW50ZXJzIGEgcGhvbmUgbnVtYmVyIG5vdCBpbiBpbnRlcm5hdGlvbmFsIGZvcm1hdC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TnVtYmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE51bWJlcigpIHtcbiAgICAgIGlmICh0aGlzLmlzSW50ZXJuYXRpb25hbCgpKSB7XG4gICAgICAgIGlmICghdGhpcy5jb3VudHJ5Q2FsbGluZ0NvZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5jb3VudHJ5ICYmICF0aGlzLmRlZmF1bHRDYWxsaW5nQ29kZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMubmF0aW9uYWxOdW1iZXJEaWdpdHMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvdW50cnlDb2RlID0gdGhpcy5nZXRDb3VudHJ5KCk7XG4gICAgICB2YXIgY2FsbGluZ0NvZGUgPSB0aGlzLmdldENvdW50cnlDYWxsaW5nQ29kZSgpIHx8IHRoaXMuZGVmYXVsdENhbGxpbmdDb2RlO1xuICAgICAgdmFyIG5hdGlvbmFsTnVtYmVyID0gdGhpcy5uYXRpb25hbE51bWJlckRpZ2l0cztcbiAgICAgIHZhciBjYXJyaWVyQ29kZSA9IHRoaXMuY2FycmllckNvZGU7IC8vIFdoZW4gYW4gaW50ZXJuYXRpb25hbCBudW1iZXIgd2l0aG91dCBhIGxlYWRpbmcgYCtgIGhhcyBiZWVuIGF1dG9jb3JyZWN0ZWQsXG4gICAgICAvLyBleHRyYWN0IGNvdW50cnkgY2FsbGluZyBjb2RlLCBiZWNhdXNlIG5vcm1hbGx5IGl0J3Mgb25seSBleHRyYWN0ZWRcbiAgICAgIC8vIGZvciBpbnRlcm5hdGlvbmFsIG51bWJlcnMgd2l0aCBhIGxlYWRpbmcgYCtgLlxuICAgICAgLy8gQ291bGQgYWxzbyBqdXN0IHVzZSBgcGFyc2VQaG9uZU51bWJlckZyb21TdHJpbmcoKWAgaGVyZVxuICAgICAgLy8gaW5zdGVhZCBvZiBoYWNraW5nIGFyb3VuZCB0aGlzIHNpbmdsZSBjYXNlLlxuXG4gICAgICBpZiAoIXRoaXMuaXNJbnRlcm5hdGlvbmFsKCkgJiYgdGhpcy5uYXRpb25hbE51bWJlckRpZ2l0cyA9PT0gdGhpcy5kaWdpdHMpIHtcbiAgICAgICAgdmFyIF9leHRyYWN0Q291bnRyeUNhbGxpbjIgPSBleHRyYWN0Q291bnRyeUNhbGxpbmdDb2RlRnJvbUludGVybmF0aW9uYWxOdW1iZXJXaXRob3V0UGx1c1NpZ24odGhpcy5kaWdpdHMsIGNvdW50cnlDb2RlLCBjYWxsaW5nQ29kZSwgdGhpcy5tZXRhZGF0YS5tZXRhZGF0YSksXG4gICAgICAgICAgICBjb3VudHJ5Q2FsbGluZ0NvZGUgPSBfZXh0cmFjdENvdW50cnlDYWxsaW4yLmNvdW50cnlDYWxsaW5nQ29kZSxcbiAgICAgICAgICAgIG51bWJlciA9IF9leHRyYWN0Q291bnRyeUNhbGxpbjIubnVtYmVyO1xuXG4gICAgICAgIGlmIChjb3VudHJ5Q2FsbGluZ0NvZGUpIHtcbiAgICAgICAgICB2YXIgX3N0cmlwTmF0aW9uYWxQcmVmaXhBMiA9IHN0cmlwTmF0aW9uYWxQcmVmaXhBbmRDYXJyaWVyQ29kZUZyb21Db21wbGV0ZU51bWJlcihudW1iZXIsIHRoaXMubWV0YWRhdGEpLFxuICAgICAgICAgICAgICBzaG9ydGVyTmF0aW9uYWxOdW1iZXIgPSBfc3RyaXBOYXRpb25hbFByZWZpeEEyLm5hdGlvbmFsTnVtYmVyLFxuICAgICAgICAgICAgICBuZXdDYXJyaWVyQ29kZSA9IF9zdHJpcE5hdGlvbmFsUHJlZml4QTIuY2FycmllckNvZGU7XG5cbiAgICAgICAgICBuYXRpb25hbE51bWJlciA9IHNob3J0ZXJOYXRpb25hbE51bWJlcjtcbiAgICAgICAgICBjYXJyaWVyQ29kZSA9IG5ld0NhcnJpZXJDb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwaG9uZU51bWJlciA9IG5ldyBQaG9uZU51bWJlcl9QaG9uZU51bWJlcihjb3VudHJ5Q29kZSB8fCBjYWxsaW5nQ29kZSwgbmF0aW9uYWxOdW1iZXIsIHRoaXMubWV0YWRhdGEubWV0YWRhdGEpO1xuXG4gICAgICBpZiAoY2FycmllckNvZGUpIHtcbiAgICAgICAgcGhvbmVOdW1iZXIuY2FycmllckNvZGUgPSBjYXJyaWVyQ29kZTtcbiAgICAgIH0gLy8gUGhvbmUgbnVtYmVyIGV4dGVuc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgXCJBcyBZb3UgVHlwZVwiIGZvcm1hdHRlci5cblxuXG4gICAgICByZXR1cm4gcGhvbmVOdW1iZXI7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBob25lIG51bWJlciBpcyBcInBvc3NpYmxlXCIuXHJcbiAgICAgKiBJcyBqdXN0IGEgc2hvcnRjdXQgZm9yIGBQaG9uZU51bWJlci5pc1Bvc3NpYmxlKClgLlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNQb3NzaWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Bvc3NpYmxlKCkge1xuICAgICAgdmFyIHBob25lTnVtYmVyID0gdGhpcy5nZXROdW1iZXIoKTtcblxuICAgICAgaWYgKCFwaG9uZU51bWJlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwaG9uZU51bWJlci5pc1Bvc3NpYmxlKCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBob25lIG51bWJlciBpcyBcInZhbGlkXCIuXHJcbiAgICAgKiBJcyBqdXN0IGEgc2hvcnRjdXQgZm9yIGBQaG9uZU51bWJlci5pc1ZhbGlkKClgLlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNWYWxpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkKCkge1xuICAgICAgdmFyIHBob25lTnVtYmVyID0gdGhpcy5nZXROdW1iZXIoKTtcblxuICAgICAgaWYgKCFwaG9uZU51bWJlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwaG9uZU51bWJlci5pc1ZhbGlkKCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgaW4gYHJlYWN0LXBob25lLW51bWJlci1pbnB1dC9zb3VyY2UvaW5wdXQtY29udHJvbC5qc2BcclxuICAgICAqIGluIHZlcnNpb25zIGJlZm9yZSBgMy4wLjE2YC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TmF0aW9uYWxOdW1iZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmF0aW9uYWxOdW1iZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYXRpb25hbE51bWJlckRpZ2l0cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Tm9uRm9ybWF0dGVkVGVtcGxhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9uRm9ybWF0dGVkVGVtcGxhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGdWxsTnVtYmVyKHRoaXMuZ2V0Tm9uRm9ybWF0dGVkTmF0aW9uYWxOdW1iZXIoKSkucmVwbGFjZSgvW1xcK1xcZF0vZywgRElHSVRfUExBQ0VIT0xERVIpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJldHVybnMgZm9ybWF0dGVkIHBob25lIG51bWJlciB0ZW1wbGF0ZS5cclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gW3RlbXBsYXRlXVxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUZW1wbGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZW1wbGF0ZSgpIHtcbiAgICAgIGlmICghdGhpcy50ZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROb25Gb3JtYXR0ZWRUZW1wbGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCAodGhpcy5pc0ludGVybmF0aW9uYWwoKSA/IHRoaXMuZ2V0SW50ZXJuYXRpb25hbFByZWZpeCh7XG4gICAgICAgIHNwYWNpbmc6IGZhbHNlXG4gICAgICB9KS5sZW5ndGggOiAwKSArIHRoaXMuZGlnaXRzLmxlbmd0aCkge1xuICAgICAgICBpbmRleCA9IHRoaXMudGVtcGxhdGUuaW5kZXhPZihESUdJVF9QTEFDRUhPTERFUiwgaW5kZXggKyAxKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3V0QW5kU3RyaXBOb25QYWlyZWRQYXJlbnModGhpcy50ZW1wbGF0ZSwgaW5kZXggKyAxKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXNZb3VUeXBlO1xufSgpO1xuXG5cbmZ1bmN0aW9uIHN0cmlwTm9uUGFpcmVkUGFyZW5zKHN0cmluZykge1xuICB2YXIgZGFuZ2xpbmdfYnJhY2VzID0gW107XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICBpZiAoc3RyaW5nW2ldID09PSAnKCcpIHtcbiAgICAgIGRhbmdsaW5nX2JyYWNlcy5wdXNoKGkpO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nW2ldID09PSAnKScpIHtcbiAgICAgIGRhbmdsaW5nX2JyYWNlcy5wb3AoKTtcbiAgICB9XG5cbiAgICBpKys7XG4gIH1cblxuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgY2xlYXJlZF9zdHJpbmcgPSAnJztcbiAgZGFuZ2xpbmdfYnJhY2VzLnB1c2goc3RyaW5nLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgX2k0ID0gMCwgX2RhbmdsaW5nX2JyYWNlcyA9IGRhbmdsaW5nX2JyYWNlczsgX2k0IDwgX2RhbmdsaW5nX2JyYWNlcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIGluZGV4ID0gX2RhbmdsaW5nX2JyYWNlc1tfaTRdO1xuICAgIGNsZWFyZWRfc3RyaW5nICs9IHN0cmluZy5zbGljZShzdGFydCwgaW5kZXgpO1xuICAgIHN0YXJ0ID0gaW5kZXggKyAxO1xuICB9XG5cbiAgcmV0dXJuIGNsZWFyZWRfc3RyaW5nO1xufVxuZnVuY3Rpb24gY3V0QW5kU3RyaXBOb25QYWlyZWRQYXJlbnMoc3RyaW5nLCBjdXRCZWZvcmVJbmRleCkge1xuICBpZiAoc3RyaW5nW2N1dEJlZm9yZUluZGV4XSA9PT0gJyknKSB7XG4gICAgY3V0QmVmb3JlSW5kZXgrKztcbiAgfVxuXG4gIHJldHVybiBzdHJpcE5vblBhaXJlZFBhcmVucyhzdHJpbmcuc2xpY2UoMCwgY3V0QmVmb3JlSW5kZXgpKTtcbn1cbmZ1bmN0aW9uIGNsb3NlTm9uUGFpcmVkUGFyZW5zKHRlbXBsYXRlLCBjdXRfYmVmb3JlKSB7XG4gIHZhciByZXRhaW5lZF90ZW1wbGF0ZSA9IHRlbXBsYXRlLnNsaWNlKDAsIGN1dF9iZWZvcmUpO1xuICB2YXIgb3BlbmluZ19icmFjZXMgPSBjb3VudE9jY3VyZW5jZXMoJygnLCByZXRhaW5lZF90ZW1wbGF0ZSk7XG4gIHZhciBjbG9zaW5nX2JyYWNlcyA9IGNvdW50T2NjdXJlbmNlcygnKScsIHJldGFpbmVkX3RlbXBsYXRlKTtcbiAgdmFyIGRhbmdsaW5nX2JyYWNlcyA9IG9wZW5pbmdfYnJhY2VzIC0gY2xvc2luZ19icmFjZXM7XG5cbiAgd2hpbGUgKGRhbmdsaW5nX2JyYWNlcyA+IDAgJiYgY3V0X2JlZm9yZSA8IHRlbXBsYXRlLmxlbmd0aCkge1xuICAgIGlmICh0ZW1wbGF0ZVtjdXRfYmVmb3JlXSA9PT0gJyknKSB7XG4gICAgICBkYW5nbGluZ19icmFjZXMtLTtcbiAgICB9XG5cbiAgICBjdXRfYmVmb3JlKys7XG4gIH1cblxuICByZXR1cm4gdGVtcGxhdGUuc2xpY2UoMCwgY3V0X2JlZm9yZSk7XG59IC8vIENvdW50cyBhbGwgb2NjdXJlbmNlcyBvZiBhIHN5bWJvbCBpbiBhIHN0cmluZy5cbi8vIFVuaWNvZGUtdW5zYWZlIChiZWNhdXNlIHVzaW5nIGAuc3BsaXQoKWApLlxuXG5mdW5jdGlvbiBjb3VudE9jY3VyZW5jZXMoc3ltYm9sLCBzdHJpbmcpIHtcbiAgdmFyIGNvdW50ID0gMDsgLy8gVXNpbmcgYC5zcGxpdCgnJylgIHRvIGl0ZXJhdGUgdGhyb3VnaCBhIHN0cmluZyBoZXJlXG4gIC8vIHRvIGF2b2lkIHJlcXVpcmluZyBgU3ltYm9sLml0ZXJhdG9yYCBwb2x5ZmlsbC5cbiAgLy8gYC5zcGxpdCgnJylgIGlzIGdlbmVyYWxseSBub3Qgc2FmZSBmb3IgVW5pY29kZSxcbiAgLy8gYnV0IGluIHRoaXMgcGFydGljdWxhciBjYXNlIGZvciBjb3VudGluZyBicmFja2V0cyBpdCBpcyBzYWZlLlxuICAvLyBmb3IgKGNvbnN0IGNoYXJhY3RlciBvZiBzdHJpbmcpXG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IHN0cmluZy5zcGxpdCgnJyksIF9pc0FycmF5NCA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yNCksIF9pNSA9IDAsIF9pdGVyYXRvcjQgPSBfaXNBcnJheTQgPyBfaXRlcmF0b3I0IDogX2l0ZXJhdG9yNFtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgIHZhciBfcmVmNDtcblxuICAgIGlmIChfaXNBcnJheTQpIHtcbiAgICAgIGlmIChfaTUgPj0gX2l0ZXJhdG9yNC5sZW5ndGgpIGJyZWFrO1xuICAgICAgX3JlZjQgPSBfaXRlcmF0b3I0W19pNSsrXTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2k1ID0gX2l0ZXJhdG9yNC5uZXh0KCk7XG4gICAgICBpZiAoX2k1LmRvbmUpIGJyZWFrO1xuICAgICAgX3JlZjQgPSBfaTUudmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJhY3RlciA9IF9yZWY0O1xuXG4gICAgaWYgKGNoYXJhY3RlciA9PT0gc3ltYm9sKSB7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3VudDtcbn0gLy8gUmVwZWF0cyBhIHN0cmluZyAob3IgYSBzeW1ib2wpIE4gdGltZXMuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwMjYwNS9yZXBlYXQtc3RyaW5nLWphdmFzY3JpcHRcblxuZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgdGltZXMpIHtcbiAgaWYgKHRpbWVzIDwgMSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciByZXN1bHQgPSAnJztcblxuICB3aGlsZSAodGltZXMgPiAxKSB7XG4gICAgaWYgKHRpbWVzICYgMSkge1xuICAgICAgcmVzdWx0ICs9IHN0cmluZztcbiAgICB9XG5cbiAgICB0aW1lcyA+Pj0gMTtcbiAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCArIHN0cmluZztcbn1cbi8qKlxyXG4gKiBFeHRyYWN0cyBmb3JtYXR0ZWQgcGhvbmUgbnVtYmVyIGZyb20gdGV4dCAoaWYgdGhlcmUncyBhbnkpLlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcclxuICogQHJldHVybiB7c3RyaW5nfSBbZm9ybWF0dGVkUGhvbmVOdW1iZXJdXHJcbiAqL1xuXG5mdW5jdGlvbiBBc1lvdVR5cGVfZXh0cmFjdEZvcm1hdHRlZFBob25lTnVtYmVyKHRleHQpIHtcbiAgLy8gQXR0ZW1wdCB0byBleHRyYWN0IGEgcG9zc2libGUgbnVtYmVyIGZyb20gdGhlIHN0cmluZyBwYXNzZWQgaW4uXG4gIHZhciBzdGFydHNBdCA9IHRleHQuc2VhcmNoKEFzWW91VHlwZV9WQUxJRF9QSE9ORV9OVU1CRVIpO1xuXG4gIGlmIChzdGFydHNBdCA8IDApIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVHJpbSBldmVyeXRoaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBwaG9uZSBudW1iZXIuXG5cblxuICB0ZXh0ID0gdGV4dC5zbGljZShzdGFydHNBdCk7IC8vIFRyaW0gdGhlIGArYC5cblxuICB2YXIgaGFzUGx1cztcblxuICBpZiAodGV4dFswXSA9PT0gJysnKSB7XG4gICAgaGFzUGx1cyA9IHRydWU7XG4gICAgdGV4dCA9IHRleHQuc2xpY2UoJysnLmxlbmd0aCk7XG4gIH0gLy8gVHJpbSBldmVyeXRoaW5nIHRvIHRoZSByaWdodCBvZiB0aGUgcGhvbmUgbnVtYmVyLlxuXG5cbiAgdGV4dCA9IHRleHQucmVwbGFjZShBRlRFUl9QSE9ORV9OVU1CRVJfRElHSVRTX0VORF9QQVRURVJOLCAnJyk7IC8vIFJlLWFkZCB0aGUgcHJldmlvdXNseSB0cmltbWVkIGArYC5cblxuICBpZiAoaGFzUGx1cykge1xuICAgIHRleHQgPSAnKycgKyB0ZXh0O1xuICB9XG5cbiAgcmV0dXJuIHRleHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc1lvdVR5cGUuanMubWFwXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9saWJwaG9uZW51bWJlci1qcy9lczYvZ2V0Q291bnRyaWVzLmpzXG5cbmZ1bmN0aW9uIGdldENvdW50cmllcyhtZXRhZGF0YSkge1xuICByZXR1cm4gbmV3IE1ldGFkYXRhKG1ldGFkYXRhKS5nZXRDb3VudHJpZXMoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldENvdW50cmllcy5qcy5tYXBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xpYnBob25lbnVtYmVyLWpzL2VzNi9mb3JtYXRJbmNvbXBsZXRlUGhvbmVOdW1iZXIuanNcblxuLyoqXHJcbiAqIEZvcm1hdHMgYSAocG9zc2libHkgaW5jb21wbGV0ZSkgcGhvbmUgbnVtYmVyLlxyXG4gKiBUaGUgcGhvbmUgbnVtYmVyIGNhbiBiZSBlaXRoZXIgaW4gRS4xNjQgZm9ybWF0XHJcbiAqIG9yIGluIGEgZm9ybSBvZiBuYXRpb25hbCBudW1iZXIgZGlnaXRzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBBIHBvc3NpYmx5IGluY29tcGxldGUgcGhvbmUgbnVtYmVyLiBFaXRoZXIgaW4gRS4xNjQgZm9ybWF0IG9yIGluIGEgZm9ybSBvZiBuYXRpb25hbCBudW1iZXIgZGlnaXRzLlxyXG4gKiBAcGFyYW0ge3N0cmluZz99IGNvdW50cnkgLSBUd28tbGV0dGVyIChcIklTTyAzMTY2LTEgYWxwaGEtMlwiKSBjb3VudHJ5IGNvZGUuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gRm9ybWF0dGVkIChwb3NzaWJseSBpbmNvbXBsZXRlKSBwaG9uZSBudW1iZXIuXHJcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRJbmNvbXBsZXRlUGhvbmVOdW1iZXIodmFsdWUsIGNvdW50cnksIG1ldGFkYXRhKSB7XG4gIGlmICghbWV0YWRhdGEpIHtcbiAgICBtZXRhZGF0YSA9IGNvdW50cnk7XG4gICAgY291bnRyeSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBuZXcgQXNZb3VUeXBlX0FzWW91VHlwZShjb3VudHJ5LCBtZXRhZGF0YSkuaW5wdXQodmFsdWUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0SW5jb21wbGV0ZVBob25lTnVtYmVyLmpzLm1hcFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbGlicGhvbmVudW1iZXItanMvaW5kZXguZXM2LmpzXG4vLyBEZXByZWNhdGVkLlxyXG4vLyBVc2UgYGxpYnBob25lbnVtYmVyLWpzL21pbmAgb3IgYGxpYnBob25lbnVtYmVyLWpzL21heGAgb3IgYGxpYnBob25lbnVtYmVyLWpzL2NvcmVgIGluc3RlYWQuXHJcblxyXG4vLyBJbXBvcnRpbmcgZnJvbSBgLmpzb24uanNgIGEgd29ya2Fyb3VuZCBmb3IgYSBidWcgaW4gd2ViIGJyb3dzZXJzJyBcIm5hdGl2ZVwiXHJcbi8vIEVTNiBpbXBvcnRpbmcgc3lzdGVtIHdoaWNoIGlzIHVuY2FwYWJsZSBvZiBpbXBvcnRpbmcgXCIqLmpzb25cIiBmaWxlcy5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NhdGFtcGhldGFtaW5lL2xpYnBob25lbnVtYmVyLWpzL2lzc3Vlcy8yMzlcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8vIERlcHJlY2F0ZWRcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLy8gRGVwcmVjYXRlZDogcmVtb3ZlIERJR0lUUyBleHBvcnQgaW4gMi4wLjAuXHJcbi8vIChpdCB3YXMgdXNlZCBpbiBgcmVhY3QtcGhvbmUtbnVtYmVyLWlucHV0YClcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gaW5kZXhfZXM2X3BhcnNlUGhvbmVOdW1iZXIoKVxyXG57XHJcblx0dmFyIHBhcmFtZXRlcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXHJcblx0cGFyYW1ldGVycy5wdXNoKG1ldGFkYXRhX21pbl9qc29uKVxyXG5cdHJldHVybiBlczZfcGFyc2VQaG9uZU51bWJlcl9wYXJzZVBob25lTnVtYmVyLmFwcGx5KHRoaXMsIHBhcmFtZXRlcnMpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluZGV4X2VzNl9wYXJzZVBob25lTnVtYmVyRnJvbVN0cmluZygpXHJcbntcclxuXHR2YXIgcGFyYW1ldGVycyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuXHRwYXJhbWV0ZXJzLnB1c2gobWV0YWRhdGFfbWluX2pzb24pXHJcblx0cmV0dXJuIHBhcnNlUGhvbmVOdW1iZXJGcm9tU3RyaW5nX3BhcnNlUGhvbmVOdW1iZXJGcm9tU3RyaW5nLmFwcGx5KHRoaXMsIHBhcmFtZXRlcnMpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluZGV4X2VzNl9wYXJzZU51bWJlcigpXHJcbntcclxuXHR2YXIgcGFyYW1ldGVycyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuXHRwYXJhbWV0ZXJzLnB1c2gobWV0YWRhdGFfbWluX2pzb24pXHJcblx0cmV0dXJuIHBhcnNlTnVtYmVyLmFwcGx5KHRoaXMsIHBhcmFtZXRlcnMpXHJcbn1cclxuXHJcbi8vIERlcHJlY2F0ZWQ6IHJlbW92ZSBgcGFyc2UoKWAgZXhwb3J0IGluIDIuMC4wLlxyXG4vLyAocmVuYW1lZCB0byBgcGFyc2VOdW1iZXIoKWApXHJcbmZ1bmN0aW9uIGluZGV4X2VzNl9wYXJzZSgpXHJcbntcclxuXHR2YXIgcGFyYW1ldGVycyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuXHRwYXJhbWV0ZXJzLnB1c2gobWV0YWRhdGFfbWluX2pzb24pXHJcblx0cmV0dXJuIHBhcnNlTnVtYmVyLmFwcGx5KHRoaXMsIHBhcmFtZXRlcnMpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluZGV4X2VzNl9mb3JtYXROdW1iZXIoKVxyXG57XHJcblx0dmFyIHBhcmFtZXRlcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXHJcblx0cGFyYW1ldGVycy5wdXNoKG1ldGFkYXRhX21pbl9qc29uKVxyXG5cdHJldHVybiBlczZfZm9ybWF0X2Zvcm1hdE51bWJlci5hcHBseSh0aGlzLCBwYXJhbWV0ZXJzKVxyXG59XHJcblxyXG4vLyBEZXByZWNhdGVkOiByZW1vdmUgYGZvcm1hdCgpYCBleHBvcnQgaW4gMi4wLjAuXHJcbi8vIChyZW5hbWVkIHRvIGBmb3JtYXROdW1iZXIoKWApXHJcbmZ1bmN0aW9uIGluZGV4X2VzNl9mb3JtYXQoKVxyXG57XHJcblx0dmFyIHBhcmFtZXRlcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXHJcblx0cGFyYW1ldGVycy5wdXNoKG1ldGFkYXRhX21pbl9qc29uKVxyXG5cdHJldHVybiBlczZfZm9ybWF0X2Zvcm1hdE51bWJlci5hcHBseSh0aGlzLCBwYXJhbWV0ZXJzKVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbmRleF9lczZfZ2V0TnVtYmVyVHlwZSgpXHJcbntcclxuXHR2YXIgcGFyYW1ldGVycyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuXHRwYXJhbWV0ZXJzLnB1c2gobWV0YWRhdGFfbWluX2pzb24pXHJcblx0cmV0dXJuIGdldE51bWJlclR5cGVfZ2V0TnVtYmVyVHlwZS5hcHBseSh0aGlzLCBwYXJhbWV0ZXJzKVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbmRleF9lczZfZ2V0RXhhbXBsZU51bWJlcigpXHJcbntcclxuXHR2YXIgcGFyYW1ldGVycyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuXHRwYXJhbWV0ZXJzLnB1c2gobWV0YWRhdGFfbWluX2pzb24pXHJcblx0cmV0dXJuIGdldEV4YW1wbGVOdW1iZXIuYXBwbHkodGhpcywgcGFyYW1ldGVycylcclxufVxyXG5cclxuZnVuY3Rpb24gaW5kZXhfZXM2X2lzUG9zc2libGVOdW1iZXIoKVxyXG57XHJcblx0dmFyIHBhcmFtZXRlcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXHJcblx0cGFyYW1ldGVycy5wdXNoKG1ldGFkYXRhX21pbl9qc29uKVxyXG5cdHJldHVybiBpc1Bvc3NpYmxlTnVtYmVyX2lzUG9zc2libGVOdW1iZXIuYXBwbHkodGhpcywgcGFyYW1ldGVycylcclxufVxyXG5cclxuZnVuY3Rpb24gaW5kZXhfZXM2X2lzVmFsaWROdW1iZXIoKVxyXG57XHJcblx0dmFyIHBhcmFtZXRlcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXHJcblx0cGFyYW1ldGVycy5wdXNoKG1ldGFkYXRhX21pbl9qc29uKVxyXG5cdHJldHVybiB2YWxpZGF0ZV9pc1ZhbGlkTnVtYmVyLmFwcGx5KHRoaXMsIHBhcmFtZXRlcnMpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluZGV4X2VzNl9pc1ZhbGlkTnVtYmVyRm9yUmVnaW9uKClcclxue1xyXG5cdHZhciBwYXJhbWV0ZXJzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxyXG5cdHBhcmFtZXRlcnMucHVzaChtZXRhZGF0YV9taW5fanNvbilcclxuXHRyZXR1cm4gaXNWYWxpZE51bWJlckZvclJlZ2lvbl9pc1ZhbGlkTnVtYmVyRm9yUmVnaW9uLmFwcGx5KHRoaXMsIHBhcmFtZXRlcnMpXHJcbn1cclxuXHJcbi8vIERlcHJlY2F0ZWQuXHJcbmZ1bmN0aW9uIGluZGV4X2VzNl9maW5kUGhvbmVOdW1iZXJzKClcclxue1xyXG5cdHZhciBwYXJhbWV0ZXJzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxyXG5cdHBhcmFtZXRlcnMucHVzaChtZXRhZGF0YV9taW5fanNvbilcclxuXHRyZXR1cm4gZmluZFBob25lTnVtYmVyc19maW5kUGhvbmVOdW1iZXJzLmFwcGx5KHRoaXMsIHBhcmFtZXRlcnMpXHJcbn1cclxuXHJcbi8vIERlcHJlY2F0ZWQuXHJcbmZ1bmN0aW9uIGluZGV4X2VzNl9zZWFyY2hQaG9uZU51bWJlcnMoKVxyXG57XHJcblx0dmFyIHBhcmFtZXRlcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXHJcblx0cGFyYW1ldGVycy5wdXNoKG1ldGFkYXRhX21pbl9qc29uKVxyXG5cdHJldHVybiBmaW5kUGhvbmVOdW1iZXJzX3NlYXJjaFBob25lTnVtYmVycy5hcHBseSh0aGlzLCBwYXJhbWV0ZXJzKVxyXG59XHJcblxyXG4vLyBEZXByZWNhdGVkLlxyXG5mdW5jdGlvbiBpbmRleF9lczZfUGhvbmVOdW1iZXJTZWFyY2godGV4dCwgb3B0aW9ucylcclxue1xyXG5cdGZpbmRQaG9uZU51bWJlcnNfUGhvbmVOdW1iZXJTZWFyY2guY2FsbCh0aGlzLCB0ZXh0LCBvcHRpb25zLCBtZXRhZGF0YV9taW5fanNvbilcclxufVxyXG5cclxuLy8gRGVwcmVjYXRlZC5cclxuaW5kZXhfZXM2X1Bob25lTnVtYmVyU2VhcmNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZmluZFBob25lTnVtYmVyc19QaG9uZU51bWJlclNlYXJjaC5wcm90b3R5cGUsIHt9KVxyXG5pbmRleF9lczZfUGhvbmVOdW1iZXJTZWFyY2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gaW5kZXhfZXM2X1Bob25lTnVtYmVyU2VhcmNoXHJcblxyXG5mdW5jdGlvbiBpbmRleF9lczZfZmluZE51bWJlcnMoKVxyXG57XHJcblx0dmFyIHBhcmFtZXRlcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXHJcblx0cGFyYW1ldGVycy5wdXNoKG1ldGFkYXRhX21pbl9qc29uKVxyXG5cdHJldHVybiBmaW5kTnVtYmVyc19maW5kTnVtYmVycy5hcHBseSh0aGlzLCBwYXJhbWV0ZXJzKVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbmRleF9lczZfc2VhcmNoTnVtYmVycygpXHJcbntcclxuXHR2YXIgcGFyYW1ldGVycyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuXHRwYXJhbWV0ZXJzLnB1c2gobWV0YWRhdGFfbWluX2pzb24pXHJcblx0cmV0dXJuIHNlYXJjaE51bWJlcnMuYXBwbHkodGhpcywgcGFyYW1ldGVycylcclxufVxyXG5cclxuZnVuY3Rpb24gaW5kZXhfZXM2X2ZpbmRQaG9uZU51bWJlcnNJblRleHQoKVxyXG57XHJcblx0dmFyIHBhcmFtZXRlcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXHJcblx0cGFyYW1ldGVycy5wdXNoKG1ldGFkYXRhX21pbl9qc29uKVxyXG5cdHJldHVybiBmaW5kUGhvbmVOdW1iZXJzSW5UZXh0LmFwcGx5KHRoaXMsIHBhcmFtZXRlcnMpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluZGV4X2VzNl9zZWFyY2hQaG9uZU51bWJlcnNJblRleHQoKVxyXG57XHJcblx0dmFyIHBhcmFtZXRlcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXHJcblx0cGFyYW1ldGVycy5wdXNoKG1ldGFkYXRhX21pbl9qc29uKVxyXG5cdHJldHVybiBzZWFyY2hQaG9uZU51bWJlcnNJblRleHQuYXBwbHkodGhpcywgcGFyYW1ldGVycylcclxufVxyXG5cclxuZnVuY3Rpb24gaW5kZXhfZXM2X1Bob25lTnVtYmVyTWF0Y2hlcih0ZXh0LCBvcHRpb25zKVxyXG57XHJcblx0UGhvbmVOdW1iZXJNYXRjaGVyX1Bob25lTnVtYmVyTWF0Y2hlci5jYWxsKHRoaXMsIHRleHQsIG9wdGlvbnMsIG1ldGFkYXRhX21pbl9qc29uKVxyXG59XHJcblxyXG5pbmRleF9lczZfUGhvbmVOdW1iZXJNYXRjaGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGhvbmVOdW1iZXJNYXRjaGVyX1Bob25lTnVtYmVyTWF0Y2hlci5wcm90b3R5cGUsIHt9KVxyXG5pbmRleF9lczZfUGhvbmVOdW1iZXJNYXRjaGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGluZGV4X2VzNl9QaG9uZU51bWJlck1hdGNoZXJcclxuXHJcbmZ1bmN0aW9uIGluZGV4X2VzNl9Bc1lvdVR5cGUoY291bnRyeSlcclxue1xyXG5cdEFzWW91VHlwZV9Bc1lvdVR5cGUuY2FsbCh0aGlzLCBjb3VudHJ5LCBtZXRhZGF0YV9taW5fanNvbilcclxufVxyXG5cclxuaW5kZXhfZXM2X0FzWW91VHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFzWW91VHlwZV9Bc1lvdVR5cGUucHJvdG90eXBlLCB7fSlcclxuaW5kZXhfZXM2X0FzWW91VHlwZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBpbmRleF9lczZfQXNZb3VUeXBlXHJcblxyXG5mdW5jdGlvbiBpbmRleF9lczZfaXNTdXBwb3J0ZWRDb3VudHJ5KClcclxue1xyXG5cdHZhciBwYXJhbWV0ZXJzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxyXG5cdHBhcmFtZXRlcnMucHVzaChtZXRhZGF0YV9taW5fanNvbilcclxuXHRyZXR1cm4gaXNTdXBwb3J0ZWRDb3VudHJ5LmFwcGx5KHRoaXMsIHBhcmFtZXRlcnMpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluZGV4X2VzNl9nZXRFeHRQcmVmaXgoKVxyXG57XHJcblx0dmFyIHBhcmFtZXRlcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXHJcblx0cGFyYW1ldGVycy5wdXNoKG1ldGFkYXRhX21pbl9qc29uKVxyXG5cdHJldHVybiBnZXRFeHRQcmVmaXguYXBwbHkodGhpcywgcGFyYW1ldGVycylcclxufVxyXG5cclxuZnVuY3Rpb24gaW5kZXhfZXM2X3BhcnNlUkZDMzk2NigpXHJcbntcclxuXHR2YXIgcGFyYW1ldGVycyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuXHRwYXJhbWV0ZXJzLnB1c2gobWV0YWRhdGFfbWluX2pzb24pXHJcblx0cmV0dXJuIHBhcnNlUkZDMzk2Ni5hcHBseSh0aGlzLCBwYXJhbWV0ZXJzKVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbmRleF9lczZfZm9ybWF0UkZDMzk2NigpXHJcbntcclxuXHR2YXIgcGFyYW1ldGVycyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuXHRwYXJhbWV0ZXJzLnB1c2gobWV0YWRhdGFfbWluX2pzb24pXHJcblx0cmV0dXJuIGZvcm1hdFJGQzM5NjYuYXBwbHkodGhpcywgcGFyYW1ldGVycylcclxufVxyXG5cclxuZnVuY3Rpb24gaW5kZXhfZXM2X2Zvcm1hdEluY29tcGxldGVQaG9uZU51bWJlcigpXHJcbntcclxuXHR2YXIgcGFyYW1ldGVycyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuXHRwYXJhbWV0ZXJzLnB1c2gobWV0YWRhdGFfbWluX2pzb24pXHJcblx0cmV0dXJuIGZvcm1hdEluY29tcGxldGVQaG9uZU51bWJlci5hcHBseSh0aGlzLCBwYXJhbWV0ZXJzKVxyXG59XHJcblxyXG4vLyBEZXByZWNhdGVkOiByZW1vdmUgdGhpcyBpbiAyLjAuMCBhbmQgbWFrZSBgY3VzdG9tLmpzYCBpbiBFUzZcclxuLy8gKHRoZSBvbGQgYGN1c3RvbS5qc2AgYmVjb21lcyBgY3VzdG9tLmNvbW1vbmpzLmpzYCkuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gaW5kZXhfZXM2X2dldENvdW50cmllcygpXHJcbntcclxuXHRyZXR1cm4gZ2V0Q291bnRyaWVzKG1ldGFkYXRhX21pbl9qc29uKVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbmRleF9lczZfZ2V0Q291bnRyeUNhbGxpbmdDb2RlKGNvdW50cnkpXHJcbntcclxuXHRyZXR1cm4gZ2V0Q291bnRyeUNhbGxpbmdDb2RlKGNvdW50cnksIG1ldGFkYXRhX21pbl9qc29uKVxyXG59XHJcblxyXG4vLyBgZ2V0UGhvbmVDb2RlYCBuYW1lIGlzIGRlcHJlY2F0ZWQsIHVzZSBgZ2V0Q291bnRyeUNhbGxpbmdDb2RlYCBpbnN0ZWFkLlxyXG5mdW5jdGlvbiBnZXRQaG9uZUNvZGUoY291bnRyeSlcclxue1xyXG5cdHJldHVybiBpbmRleF9lczZfZ2V0Q291bnRyeUNhbGxpbmdDb2RlKGNvdW50cnkpXHJcbn1cclxuXHJcbi8vIGBnZXRQaG9uZUNvZGVDdXN0b21gIG5hbWUgaXMgZGVwcmVjYXRlZCwgdXNlIGBnZXRDb3VudHJ5Q2FsbGluZ0NvZGVDdXN0b21gIGluc3RlYWQuXHJcbmZ1bmN0aW9uIGdldFBob25lQ29kZUN1c3RvbShjb3VudHJ5LCBtZXRhZGF0YSlcclxue1xyXG5cdHJldHVybiBnZXRDb3VudHJ5Q2FsbGluZ0NvZGUoY291bnRyeSwgbWV0YWRhdGEpXHJcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz97XCJjYWNoZURpcmVjdG9yeVwiOlwibm9kZV9tb2R1bGVzLy5jYWNoZS92dWUtbG9hZGVyXCIsXCJjYWNoZUlkZW50aWZpZXJcIjpcImUzODc5MTA0LXZ1ZS1sb2FkZXItdGVtcGxhdGVcIn0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9WdWVQaG9uZU51bWJlcklucHV0L0lucHV0VGVsL2luZGV4LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1lNTliZTNiNCZzY29wZWQ9dHJ1ZSZcbnZhciBJbnB1dFRlbHZ1ZV90eXBlX3RlbXBsYXRlX2lkX2U1OWJlM2I0X3Njb3BlZF90cnVlX3JlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3JlZjpcInBhcmVudFwiLHN0YXRpY0NsYXNzOlwiaW5wdXQtdGVsXCIsY2xhc3M6W3tcbiAgICAnaXMtZm9jdXNlZCc6IF92bS5pc0ZvY3VzLFxuICAgICdpcy12YWxpZCc6IF92bS52YWxpZCxcbiAgICAnaGFzLXZhbHVlJzogX3ZtLnZhbHVlLFxuICAgICdoYXMtZXJyb3InOiBfdm0uZXJyb3IsXG4gICAgJ2lzLWRpc2FibGVkJzogX3ZtLmRpc2FibGVkLFxuICAgICdpcy1kYXJrJzogX3ZtLmRhcmssXG4gICAgJ2hhcy1oaW50JzogX3ZtLmhpbnRcbiAgfSwgX3ZtLnNpemVdLG9uOntcImNsaWNrXCI6X3ZtLmZvY3VzSW5wdXQsXCJtb3VzZWVudGVyXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLnVwZGF0ZUhvdmVyU3RhdGUodHJ1ZSl9LFwibW91c2VsZWF2ZVwiOmZ1bmN0aW9uKCRldmVudCl7cmV0dXJuIF92bS51cGRhdGVIb3ZlclN0YXRlKGZhbHNlKX19fSxbKChfdm0udHlwZSk9PT0nY2hlY2tib3gnKT9fYygnaW5wdXQnLF92bS5fYih7ZGlyZWN0aXZlczpbe25hbWU6XCJtb2RlbFwiLHJhd05hbWU6XCJ2LW1vZGVsXCIsdmFsdWU6KF92bS5pbnB1dFZhbHVlKSxleHByZXNzaW9uOlwiaW5wdXRWYWx1ZVwifV0scmVmOlwiSW5wdXRUZWxcIixzdGF0aWNDbGFzczpcImlucHV0LXRlbF9faW5wdXRcIixjbGFzczp7ICduby1jb3VudHJ5LXNlbGVjdG9yJzogX3ZtLm5vQ291bnRyeVNlbGVjdG9yIH0sc3R5bGU6KFtcbiAgICAgIF92bS5ub0NvdW50cnlTZWxlY3RvciA/IF92bS5yYWRpdXNTdHlsZSA6IF92bS5yYWRpdXNSaWdodFN0eWxlLFxuICAgICAgX3ZtLmlucHV0Q2FyZXRTdHlsZSxcbiAgICAgIF92bS5pbnB1dEJvcmRlclN0eWxlLFxuICAgICAgX3ZtLmlucHV0Qm94U2hhZG93U3R5bGUsXG4gICAgICBfdm0uaW5wdXRCZ0NvbG9yLFxuICAgICAgX3ZtLnRleHRDb2xvclxuICAgIF0pLGF0dHJzOntcImlkXCI6X3ZtLmlkLFwicGxhY2Vob2xkZXJcIjpfdm0ubGFiZWxWYWx1ZSxcImRpc2FibGVkXCI6X3ZtLmRpc2FibGVkLFwicmVxdWlyZWRcIjpfdm0ucmVxdWlyZWQsXCJ0eXBlXCI6XCJjaGVja2JveFwifSxkb21Qcm9wczp7XCJjaGVja2VkXCI6QXJyYXkuaXNBcnJheShfdm0uaW5wdXRWYWx1ZSk/X3ZtLl9pKF92bS5pbnB1dFZhbHVlLG51bGwpPi0xOihfdm0uaW5wdXRWYWx1ZSl9LG9uOntcImtleWRvd25cIjpfdm0ua2V5RG93bixcImtleXVwXCI6X3ZtLmtleVVwLFwiZm9jdXNcIjpfdm0ub25Gb2N1cyxcImJsdXJcIjpfdm0ub25CbHVyLFwiY2xpY2tcIjpmdW5jdGlvbigkZXZlbnQpe3JldHVybiBfdm0uJGVtaXQoJ2NsaWNrJywgJGV2ZW50KX0sXCJjaGFuZ2VcIjpmdW5jdGlvbigkZXZlbnQpe3ZhciAkJGE9X3ZtLmlucHV0VmFsdWUsJCRlbD0kZXZlbnQudGFyZ2V0LCQkYz0kJGVsLmNoZWNrZWQ/KHRydWUpOihmYWxzZSk7aWYoQXJyYXkuaXNBcnJheSgkJGEpKXt2YXIgJCR2PW51bGwsJCRpPV92bS5faSgkJGEsJCR2KTtpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoX3ZtLmlucHV0VmFsdWU9JCRhLmNvbmNhdChbJCR2XSkpfWVsc2V7JCRpPi0xJiYoX3ZtLmlucHV0VmFsdWU9JCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSkpfX1lbHNle192bS5pbnB1dFZhbHVlPSQkY319fX0sJ2lucHV0Jyxfdm0uJGF0dHJzLGZhbHNlKSk6KChfdm0udHlwZSk9PT0ncmFkaW8nKT9fYygnaW5wdXQnLF92bS5fYih7ZGlyZWN0aXZlczpbe25hbWU6XCJtb2RlbFwiLHJhd05hbWU6XCJ2LW1vZGVsXCIsdmFsdWU6KF92bS5pbnB1dFZhbHVlKSxleHByZXNzaW9uOlwiaW5wdXRWYWx1ZVwifV0scmVmOlwiSW5wdXRUZWxcIixzdGF0aWNDbGFzczpcImlucHV0LXRlbF9faW5wdXRcIixjbGFzczp7ICduby1jb3VudHJ5LXNlbGVjdG9yJzogX3ZtLm5vQ291bnRyeVNlbGVjdG9yIH0sc3R5bGU6KFtcbiAgICAgIF92bS5ub0NvdW50cnlTZWxlY3RvciA/IF92bS5yYWRpdXNTdHlsZSA6IF92bS5yYWRpdXNSaWdodFN0eWxlLFxuICAgICAgX3ZtLmlucHV0Q2FyZXRTdHlsZSxcbiAgICAgIF92bS5pbnB1dEJvcmRlclN0eWxlLFxuICAgICAgX3ZtLmlucHV0Qm94U2hhZG93U3R5bGUsXG4gICAgICBfdm0uaW5wdXRCZ0NvbG9yLFxuICAgICAgX3ZtLnRleHRDb2xvclxuICAgIF0pLGF0dHJzOntcImlkXCI6X3ZtLmlkLFwicGxhY2Vob2xkZXJcIjpfdm0ubGFiZWxWYWx1ZSxcImRpc2FibGVkXCI6X3ZtLmRpc2FibGVkLFwicmVxdWlyZWRcIjpfdm0ucmVxdWlyZWQsXCJ0eXBlXCI6XCJyYWRpb1wifSxkb21Qcm9wczp7XCJjaGVja2VkXCI6X3ZtLl9xKF92bS5pbnB1dFZhbHVlLG51bGwpfSxvbjp7XCJrZXlkb3duXCI6X3ZtLmtleURvd24sXCJrZXl1cFwiOl92bS5rZXlVcCxcImZvY3VzXCI6X3ZtLm9uRm9jdXMsXCJibHVyXCI6X3ZtLm9uQmx1cixcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLiRlbWl0KCdjbGljaycsICRldmVudCl9LFwiY2hhbmdlXCI6ZnVuY3Rpb24oJGV2ZW50KXtfdm0uaW5wdXRWYWx1ZT1udWxsfX19LCdpbnB1dCcsX3ZtLiRhdHRycyxmYWxzZSkpOl9jKCdpbnB1dCcsX3ZtLl9iKHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTooX3ZtLmlucHV0VmFsdWUpLGV4cHJlc3Npb246XCJpbnB1dFZhbHVlXCJ9XSxyZWY6XCJJbnB1dFRlbFwiLHN0YXRpY0NsYXNzOlwiaW5wdXQtdGVsX19pbnB1dFwiLGNsYXNzOnsgJ25vLWNvdW50cnktc2VsZWN0b3InOiBfdm0ubm9Db3VudHJ5U2VsZWN0b3IgfSxzdHlsZTooW1xuICAgICAgX3ZtLm5vQ291bnRyeVNlbGVjdG9yID8gX3ZtLnJhZGl1c1N0eWxlIDogX3ZtLnJhZGl1c1JpZ2h0U3R5bGUsXG4gICAgICBfdm0uaW5wdXRDYXJldFN0eWxlLFxuICAgICAgX3ZtLmlucHV0Qm9yZGVyU3R5bGUsXG4gICAgICBfdm0uaW5wdXRCb3hTaGFkb3dTdHlsZSxcbiAgICAgIF92bS5pbnB1dEJnQ29sb3IsXG4gICAgICBfdm0udGV4dENvbG9yXG4gICAgXSksYXR0cnM6e1wiaWRcIjpfdm0uaWQsXCJwbGFjZWhvbGRlclwiOl92bS5sYWJlbFZhbHVlLFwiZGlzYWJsZWRcIjpfdm0uZGlzYWJsZWQsXCJyZXF1aXJlZFwiOl92bS5yZXF1aXJlZCxcInR5cGVcIjpfdm0udHlwZX0sZG9tUHJvcHM6e1widmFsdWVcIjooX3ZtLmlucHV0VmFsdWUpfSxvbjp7XCJrZXlkb3duXCI6X3ZtLmtleURvd24sXCJrZXl1cFwiOl92bS5rZXlVcCxcImZvY3VzXCI6X3ZtLm9uRm9jdXMsXCJibHVyXCI6X3ZtLm9uQmx1cixcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLiRlbWl0KCdjbGljaycsICRldmVudCl9LFwiaW5wdXRcIjpmdW5jdGlvbigkZXZlbnQpe2lmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXsgcmV0dXJuOyB9X3ZtLmlucHV0VmFsdWU9JGV2ZW50LnRhcmdldC52YWx1ZX19fSwnaW5wdXQnLF92bS4kYXR0cnMsZmFsc2UpKSxfYygnbGFiZWwnLHtyZWY6XCJsYWJlbFwiLHN0YXRpY0NsYXNzOlwiaW5wdXQtdGVsX19sYWJlbFwiLGNsYXNzOl92bS5lcnJvciA/ICd0ZXh0LWRhbmdlcicgOiBudWxsLHN0eWxlOihbX3ZtLmxhYmVsQ29sb3JTdHlsZV0pLGF0dHJzOntcImZvclwiOl92bS5pZH0sb246e1wiY2xpY2tcIjpfdm0uZm9jdXNJbnB1dH19LFtfdm0uX3YoXCIgXCIrX3ZtLl9zKF92bS5oaW50VmFsdWUgfHwgX3ZtLmxhYmVsVmFsdWUpK1wiIFwiKV0pLChfdm0uY2xlYXJhYmxlICYmIF92bS5pbnB1dFZhbHVlKT9fYygnYnV0dG9uJyx7c3RhdGljQ2xhc3M6XCJpbnB1dC10ZWxfX2NsZWFyXCIsYXR0cnM6e1widGl0bGVcIjpcImNsZWFyXCIsXCJ0eXBlXCI6XCJidXR0b25cIixcInRhYmluZGV4XCI6XCItMVwifSxvbjp7XCJjbGlja1wiOl92bS5jbGVhcn19LFtfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwiaW5wdXQtdGVsX19jbGVhcl9fZWZmZWN0XCJ9KSxfYygnc3BhbicsW192bS5fdihcIiDinJUgXCIpXSldKTpfdm0uX2UoKSwoX3ZtLmxvYWRlcik/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiaW5wdXQtdGVsX19sb2FkZXJcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImlucHV0LXRlbF9fbG9hZGVyX19wcm9ncmVzcy1iYXJcIixzdHlsZTooW192bS5sb2FkZXJCZ0NvbG9yXSl9KV0pOl92bS5fZSgpXSl9XG52YXIgSW5wdXRUZWx2dWVfdHlwZV90ZW1wbGF0ZV9pZF9lNTliZTNiNF9zY29wZWRfdHJ1ZV9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1Z1ZVBob25lTnVtYmVySW5wdXQvSW5wdXRUZWwvaW5kZXgudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWU1OWJlM2I0JnNjb3BlZD10cnVlJlxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9WdWVQaG9uZU51bWJlcklucHV0L21peGlucy9TdHlsZXNIYW5kbGVyLmpzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBTdHlsZXNIYW5kbGVyID0gKHtcbiAgcHJvcHM6IHtcbiAgICB0aGVtZToge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgbGFiZWxDb2xvclN0eWxlOiBmdW5jdGlvbiBsYWJlbENvbG9yU3R5bGUoKSB7XG4gICAgICBpZiAodGhpcy5lcnJvcikgcmV0dXJuIHRoaXMudGhlbWUuZXJyb3JDb2xvcjtlbHNlIGlmICh0aGlzLnZhbGlkKSByZXR1cm4gdGhpcy50aGVtZS52YWxpZENvbG9yO2Vsc2UgaWYgKHRoaXMuaXNGb2N1cykgcmV0dXJuIHRoaXMudGhlbWUuY29sb3I7ZWxzZSBpZiAodGhpcy5kYXJrKSByZXR1cm4gdGhpcy50aGVtZS50ZXh0RGFya0NvbG9yO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBpbnB1dEJvcmRlclN0eWxlOiBmdW5jdGlvbiBpbnB1dEJvcmRlclN0eWxlKCkge1xuICAgICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiB0aGlzLnRoZW1lLmJvcmRlckVycm9yQ29sb3I7ZWxzZSBpZiAodGhpcy52YWxpZCkgcmV0dXJuIHRoaXMudGhlbWUuYm9yZGVyVmFsaWRDb2xvcjtlbHNlIGlmICh0aGlzLmlzSG92ZXIgfHwgdGhpcy5pc0ZvY3VzKSByZXR1cm4gdGhpcy50aGVtZS5ib3JkZXJDb2xvcjtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgaW5wdXRCb3hTaGFkb3dTdHlsZTogZnVuY3Rpb24gaW5wdXRCb3hTaGFkb3dTdHlsZSgpIHtcbiAgICAgIGlmICh0aGlzLmlzRm9jdXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiB0aGlzLnRoZW1lLmJveFNoYWRvd0Vycm9yO2Vsc2UgaWYgKHRoaXMudmFsaWQpIHJldHVybiB0aGlzLnRoZW1lLmJveFNoYWRvd1ZhbGlkO1xuICAgICAgICByZXR1cm4gdGhpcy50aGVtZS5ib3hTaGFkb3dDb2xvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBpbnB1dEJnQ29sb3I6IGZ1bmN0aW9uIGlucHV0QmdDb2xvcigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5kYXJrID8gbnVsbCA6IHRoaXMudGhlbWUuYmdEYXJrQ29sb3I7XG4gICAgfSxcbiAgICB0ZXh0Q29sb3I6IGZ1bmN0aW9uIHRleHRDb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhcmsgPyB0aGlzLnRoZW1lLnRleHREYXJrQ29sb3IgOiBudWxsO1xuICAgIH0sXG4gICAgaW5wdXRDYXJldFN0eWxlOiBmdW5jdGlvbiBpbnB1dENhcmV0U3R5bGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYXJldENvbG9yOiB0aGlzLnRoZW1lLmNvbG9yVmFsdWVcbiAgICAgIH07XG4gICAgfSxcbiAgICByYWRpdXNTdHlsZTogZnVuY3Rpb24gcmFkaXVzU3R5bGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVtZS5ib3JkZXJSYWRpdXM7XG4gICAgfSxcbiAgICByYWRpdXNMZWZ0U3R5bGU6IGZ1bmN0aW9uIHJhZGl1c0xlZnRTdHlsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW1lLmJvcmRlckxlZnRSYWRpdXM7XG4gICAgfSxcbiAgICByYWRpdXNSaWdodFN0eWxlOiBmdW5jdGlvbiByYWRpdXNSaWdodFN0eWxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbWUuYm9yZGVyUmlnaHRSYWRpdXM7XG4gICAgfSxcbiAgICBiZ0l0ZW1TZWxlY3RlZFN0eWxlOiBmdW5jdGlvbiBiZ0l0ZW1TZWxlY3RlZFN0eWxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbWUuYmdDb2xvcjtcbiAgICB9LFxuICAgIGxvYWRlckJnQ29sb3I6IGZ1bmN0aW9uIGxvYWRlckJnQ29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVtZS5iZ0NvbG9yO1xuICAgIH1cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL1Z1ZVBob25lTnVtYmVySW5wdXQvSW5wdXRUZWwvaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBJbnB1dFRlbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdJbnB1dFRlbCcsXG4gIG1peGluczogW1N0eWxlc0hhbmRsZXJdLFxuICBwcm9wczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgbGFiZWw6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdFbnRlciB0ZXh0J1xuICAgIH0sXG4gICAgaGludDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgZXJyb3I6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBCb29sZWFuXG4gICAgfSxcbiAgICBkaXNhYmxlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBkYXJrOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGlkOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnSW5wdXRUZWwnXG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAndGVsJ1xuICAgIH0sXG4gICAgcmVhZG9ubHk6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgdmFsaWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgcmVxdWlyZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgbG9hZGVyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGNsZWFyYWJsZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBub0NvdW50cnlTZWxlY3Rvcjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0ZvY3VzOiBmYWxzZSxcbiAgICAgIGlzSG92ZXI6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpbnB1dFZhbHVlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsYWJlbFZhbHVlOiBmdW5jdGlvbiBsYWJlbFZhbHVlKCkge1xuICAgICAgdmFyIGxhYmVsID0gdGhpcy5sYWJlbDtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVkICYmIGxhYmVsID8gXCJcIi5jb25jYXQobGFiZWwsIFwiICpcIikgOiBsYWJlbDtcbiAgICB9LFxuICAgIGhpbnRWYWx1ZTogZnVuY3Rpb24gaGludFZhbHVlKCkge1xuICAgICAgdmFyIGhpbnQgPSB0aGlzLmhpbnQ7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1aXJlZCAmJiBoaW50ID8gXCJcIi5jb25jYXQoaGludCwgXCIgKlwiKSA6IGhpbnQ7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdXBkYXRlSG92ZXJTdGF0ZTogZnVuY3Rpb24gdXBkYXRlSG92ZXJTdGF0ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5pc0hvdmVyID0gdmFsdWU7XG4gICAgfSxcbiAgICBmb2N1c0lucHV0OiBmdW5jdGlvbiBmb2N1c0lucHV0KCkge1xuICAgICAgdGhpcy4kcmVmcy5JbnB1dFRlbC5mb2N1cygpO1xuICAgIH0sXG4gICAgb25Gb2N1czogZnVuY3Rpb24gb25Gb2N1cygpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2ZvY3VzJyk7XG4gICAgICB0aGlzLmlzRm9jdXMgPSB0cnVlO1xuICAgIH0sXG4gICAgb25CbHVyOiBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICB0aGlzLiRlbWl0KCdibHVyJyk7XG4gICAgICB0aGlzLmlzRm9jdXMgPSBmYWxzZTtcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgbnVsbCk7XG4gICAgICB0aGlzLiRlbWl0KCdjbGVhcicpO1xuICAgIH0sXG4gICAga2V5VXA6IGZ1bmN0aW9uIGtleVVwKGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2tleXVwJywgZSk7XG4gICAgfSxcbiAgICBrZXlEb3duOiBmdW5jdGlvbiBrZXlEb3duKGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2tleWRvd24nLCBlKTtcbiAgICB9XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvVnVlUGhvbmVOdW1iZXJJbnB1dC9JbnB1dFRlbC9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgVnVlUGhvbmVOdW1iZXJJbnB1dF9JbnB1dFRlbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChJbnB1dFRlbHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9WdWVQaG9uZU51bWJlcklucHV0L0lucHV0VGVsL2luZGV4LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWU1OWJlM2I0Jmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcbnZhciBJbnB1dFRlbHZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfZTU5YmUzYjRfbGFuZ19zY3NzX3Njb3BlZF90cnVlXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiOGFjXCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcbi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHsgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgdGhpcy4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290KSB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9WdWVQaG9uZU51bWJlcklucHV0L0lucHV0VGVsL2luZGV4LnZ1ZVxuXG5cblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBWdWVQaG9uZU51bWJlcklucHV0X0lucHV0VGVsdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBJbnB1dFRlbHZ1ZV90eXBlX3RlbXBsYXRlX2lkX2U1OWJlM2I0X3Njb3BlZF90cnVlX3JlbmRlcixcbiAgSW5wdXRUZWx2dWVfdHlwZV90ZW1wbGF0ZV9pZF9lNTliZTNiNF9zY29wZWRfdHJ1ZV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcImU1OWJlM2I0XCIsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIElucHV0VGVsID0gKGNvbXBvbmVudC5leHBvcnRzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz97XCJjYWNoZURpcmVjdG9yeVwiOlwibm9kZV9tb2R1bGVzLy5jYWNoZS92dWUtbG9hZGVyXCIsXCJjYWNoZUlkZW50aWZpZXJcIjpcImUzODc5MTA0LXZ1ZS1sb2FkZXItdGVtcGxhdGVcIn0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9WdWVQaG9uZU51bWJlcklucHV0L0NvdW50cnlTZWxlY3Rvci9pbmRleC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NDZlMTA1ZGUmc2NvcGVkPXRydWUmXG52YXIgQ291bnRyeVNlbGVjdG9ydnVlX3R5cGVfdGVtcGxhdGVfaWRfNDZlMTA1ZGVfc2NvcGVkX3RydWVfcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7cmVmOlwicGFyZW50XCIsc3RhdGljQ2xhc3M6XCJjb3VudHJ5LXNlbGVjdG9yXCIsY2xhc3M6W3tcbiAgICAnaXMtZm9jdXNlZCc6IF92bS5pc0ZvY3VzLFxuICAgICdoYXMtdmFsdWUnOiBfdm0udmFsdWUsXG4gICAgJ2hhcy1oaW50JzogX3ZtLmhpbnQsXG4gICAgJ2hhcy1lcnJvcic6IF92bS5lcnJvcixcbiAgICAnaXMtZGlzYWJsZWQnOiBfdm0uZGlzYWJsZWQsXG4gICAgJ2lzLWRhcmsnOiBfdm0uZGFyayxcbiAgICAnbm8tZmxhZ3MnOiBfdm0ubm9GbGFncyxcbiAgICAnaGFzLWxpc3Qtb3Blbic6IF92bS5oYXNMaXN0T3BlbixcbiAgICAnaXMtdmFsaWQnOiBfdm0udmFsaWRcbiAgfSwgX3ZtLnNpemVdLG9uOntcIiFibHVyXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLmhhbmRsZUJsdXIoJGV2ZW50KX0sXCJtb3VzZWVudGVyXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLnVwZGF0ZUhvdmVyU3RhdGUodHJ1ZSl9LFwibW91c2VsZWF2ZVwiOmZ1bmN0aW9uKCRldmVudCl7cmV0dXJuIF92bS51cGRhdGVIb3ZlclN0YXRlKGZhbHNlKX19fSxbKF92bS52YWx1ZSAmJiAhX3ZtLm5vRmxhZ3MpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvdW50cnktc2VsZWN0b3JfX2NvdW50cnktZmxhZ1wiLG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7cmV0dXJuIF92bS50b2dnbGVMaXN0KCRldmVudCl9fX0sW19jKCdkaXYnLHtjbGFzczooXCJpdGktZmxhZy1zbWFsbCBpdGktZmxhZyBcIiArIChfdm0udmFsdWUudG9Mb3dlckNhc2UoKSkpfSldKTpfdm0uX2UoKSxfYygnaW5wdXQnLHtyZWY6XCJDb3VudHJ5U2VsZWN0b3JcIixzdGF0aWNDbGFzczpcImNvdW50cnktc2VsZWN0b3JfX2lucHV0XCIsc3R5bGU6KFtfdm0ucmFkaXVzTGVmdFN0eWxlLCBfdm0uaW5wdXRCb3JkZXJTdHlsZSwgX3ZtLmlucHV0Qm94U2hhZG93U3R5bGUsIF92bS5pbnB1dEJnQ29sb3JdKSxhdHRyczp7XCJpZFwiOl92bS5pZCxcInBsYWNlaG9sZGVyXCI6X3ZtLmxhYmVsLFwiZGlzYWJsZWRcIjpfdm0uZGlzYWJsZWQsXCJyZWFkb25seVwiOlwiXCJ9LGRvbVByb3BzOntcInZhbHVlXCI6X3ZtLmNhbGxpbmdDb2RlfSxvbjp7XCJmb2N1c1wiOmZ1bmN0aW9uKCRldmVudCl7X3ZtLmlzRm9jdXMgPSB0cnVlfSxcImtleWRvd25cIjpfdm0ua2V5Ym9hcmROYXYsXCJjbGlja1wiOmZ1bmN0aW9uKCRldmVudCl7JGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO3JldHVybiBfdm0udG9nZ2xlTGlzdCgkZXZlbnQpfX19KSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjb3VudHJ5LXNlbGVjdG9yX190b2dnbGVcIixvbjp7XCJjbGlja1wiOmZ1bmN0aW9uKCRldmVudCl7JGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO3JldHVybiBfdm0udG9nZ2xlTGlzdCgkZXZlbnQpfX19LFtfdm0uX3QoXCJhcnJvd1wiLFtfYygnc3ZnJyx7c3RhdGljQ2xhc3M6XCJjb3VudHJ5LXNlbGVjdG9yX190b2dnbGVfX2Fycm93XCIsYXR0cnM6e1wibWxuc1wiOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcIndpZHRoXCI6XCIyNFwiLFwiaGVpZ2h0XCI6XCIyNFwiLFwidmlld0JveFwiOlwiMCAwIDI0IDI0XCJ9fSxbX2MoJ3BhdGgnLHtzdGF0aWNDbGFzczpcImFycm93XCIsYXR0cnM6e1wiZFwiOlwiTTcuNDEgOC41OUwxMiAxMy4xN2w0LjU5LTQuNThMMTggMTBsLTYgNi02LTYgMS40MS0xLjQxelwifX0pLF9jKCdwYXRoJyx7YXR0cnM6e1wiZmlsbFwiOlwibm9uZVwiLFwiZFwiOlwiTTAgMGgyNHYyNEgwVjB6XCJ9fSldKV0pXSwyKSxfYygnbGFiZWwnLHtyZWY6XCJsYWJlbFwiLHN0YXRpY0NsYXNzOlwiY291bnRyeS1zZWxlY3Rvcl9fbGFiZWxcIixzdHlsZTooW192bS5sYWJlbENvbG9yU3R5bGVdKSxvbjp7XCJjbGlja1wiOmZ1bmN0aW9uKCRldmVudCl7JGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO3JldHVybiBfdm0udG9nZ2xlTGlzdCgkZXZlbnQpfX19LFtfdm0uX3YoXCIgXCIrX3ZtLl9zKF92bS5oaW50IHx8IF92bS5sYWJlbCkrXCIgXCIpXSksX2MoJ1RyYW5zaXRpb24nLHthdHRyczp7XCJuYW1lXCI6XCJzbGlkZVwifX0sW19jKCdkaXYnLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KF92bS5oYXNMaXN0T3BlbiksZXhwcmVzc2lvbjpcImhhc0xpc3RPcGVuXCJ9XSxyZWY6XCJjb3VudHJpZXNMaXN0XCIsc3RhdGljQ2xhc3M6XCJjb3VudHJ5LXNlbGVjdG9yX19saXN0XCIsY2xhc3M6eyAnaGFzLWNhbGxpbmctY29kZSc6IF92bS5zaG93Q29kZU9uTGlzdCB9LHN0eWxlOihbX3ZtLnJhZGl1c1N0eWxlLCBfdm0ubGlzdEhlaWdodCwgX3ZtLmlucHV0QmdDb2xvcl0pfSxbX2MoJ1JlY3ljbGVTY3JvbGxlcicse2F0dHJzOntcIml0ZW1zXCI6X3ZtLmNvdW50cmllc1NvcnRlZCxcIml0ZW0tc2l6ZVwiOjEsXCJrZXktZmllbGRcIjpcImlzbzJcIn0sc2NvcGVkU2xvdHM6X3ZtLl91KFt7a2V5OlwiZGVmYXVsdFwiLGZuOmZ1bmN0aW9uKHJlZil7XG4gIHZhciBpdGVtID0gcmVmLml0ZW07XG5yZXR1cm4gW19jKCdidXR0b24nLHtrZXk6KFwiaXRlbS1cIiArIChpdGVtLmNvZGUpKSxzdGF0aWNDbGFzczpcImZsZXggYWxpZ24tY2VudGVyIGNvdW50cnktc2VsZWN0b3JfX2xpc3RfX2l0ZW1cIixjbGFzczpbXG4gICAgICAgICAgICB7ICdzZWxlY3RlZCc6IF92bS52YWx1ZSA9PT0gaXRlbS5pc28yIH0sXG4gICAgICAgICAgICB7ICdrZXlib2FyZC1zZWxlY3RlZCc6IF92bS52YWx1ZSAhPT0gaXRlbS5pc28yICYmIF92bS50bXBWYWx1ZSA9PT0gaXRlbS5pc28yIH1cbiAgICAgICAgICBdLHN0eWxlOihbXG4gICAgICAgICAgICBfdm0uaXRlbUhlaWdodCxcbiAgICAgICAgICAgIF92bS52YWx1ZSA9PT0gaXRlbS5pc28yID8gX3ZtLmJnSXRlbVNlbGVjdGVkU3R5bGUgOiBudWxsXG4gICAgICAgICAgXSksYXR0cnM6e1widGFiaW5kZXhcIjpcIi0xXCIsXCJ0eXBlXCI6XCJidXR0b25cIn0sb246e1wiY2xpY2tcIjpmdW5jdGlvbigkZXZlbnQpeyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtyZXR1cm4gX3ZtLnVwZGF0ZVZhbHVlKGl0ZW0uaXNvMil9fX0sWyghX3ZtLm5vRmxhZ3MpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvdW50cnktc2VsZWN0b3JfX2xpc3RfX2l0ZW1fX2ZsYWctY29udGFpbmVyXCJ9LFtfYygnZGl2Jyx7Y2xhc3M6KFwiaXRpLWZsYWctc21hbGwgaXRpLWZsYWcgXCIgKyAoaXRlbS5pc28yLnRvTG93ZXJDYXNlKCkpKX0pXSk6X3ZtLl9lKCksKF92bS5zaG93Q29kZU9uTGlzdCk/X2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcImNvdW50cnktc2VsZWN0b3JfX2xpc3RfX2l0ZW1fX2NhbGxpbmctY29kZSBmbGV4LWZpeGVkXCJ9LFtfdm0uX3YoXCIrXCIrX3ZtLl9zKGl0ZW0uZGlhbENvZGUpKV0pOl92bS5fZSgpLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImRvdHMtdGV4dFwifSxbX3ZtLl92KFwiIFwiK192bS5fcyhpdGVtLm5hbWUpK1wiIFwiKV0pXSldfX1dKX0pXSwxKV0pXSwxKX1cbnZhciBDb3VudHJ5U2VsZWN0b3J2dWVfdHlwZV90ZW1wbGF0ZV9pZF80NmUxMDVkZV9zY29wZWRfdHJ1ZV9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1Z1ZVBob25lTnVtYmVySW5wdXQvQ291bnRyeVNlbGVjdG9yL2luZGV4LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00NmUxMDVkZSZzY29wZWQ9dHJ1ZSZcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanNcbnZhciBlczZfZnVuY3Rpb25fbmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3ZjdmXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoLmpzXG52YXIgZXM2X3N0cmluZ19zdGFydHNfd2l0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNTU5XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qc1xudmFyIGVzNl9hcnJheV9maW5kX2luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIwZDZcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9jb3JlLWpzL2FycmF5L2lzLWFycmF5LmpzXG52YXIgaXNfYXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYTc0NVwiKTtcbnZhciBpc19hcnJheV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc19hcnJheSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheS5qc1xuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qc1xuXG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKGlzX2FycmF5X2RlZmF1bHQoKShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9jb3JlLWpzL2FycmF5L2Zyb20uanNcbnZhciBmcm9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc3NGVcIik7XG52YXIgZnJvbV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihmcm9tKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2NvcmUtanMvaXMtaXRlcmFibGUuanNcbnZhciBpc19pdGVyYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjOGJiXCIpO1xudmFyIGlzX2l0ZXJhYmxlX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlzX2l0ZXJhYmxlKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2NvcmUtanMvc3ltYm9sLmpzXG52YXIgc3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY3YmJcIik7XG52YXIgc3ltYm9sX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHN5bWJvbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5LmpzXG5cblxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBzeW1ib2xfZGVmYXVsdC5hICE9PSBcInVuZGVmaW5lZFwiICYmIGlzX2l0ZXJhYmxlX2RlZmF1bHQoKShPYmplY3QoaXRlcikpKSByZXR1cm4gZnJvbV9kZWZhdWx0KCkoaXRlcik7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXG5cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gZnJvbV9kZWZhdWx0KCkobik7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWQuanNcbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5LmpzXG5cblxuXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzXG52YXIgZXM2X2FycmF5X2ZpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzUxNFwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtdmlydHVhbC1zY3JvbGxlci9kaXN0L3Z1ZS12aXJ0dWFsLXNjcm9sbGVyLmVzbS5qc1xudmFyIHZ1ZV92aXJ0dWFsX3Njcm9sbGVyX2VzbSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlNTA4XCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL1Z1ZVBob25lTnVtYmVySW5wdXQvQ291bnRyeVNlbGVjdG9yL2luZGV4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuXG5cblxuXG5cblxuXG5cblxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBDb3VudHJ5U2VsZWN0b3J2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQ291bnRyeVNlbGVjdG9yJyxcbiAgY29tcG9uZW50czoge1xuICAgIFJlY3ljbGVTY3JvbGxlcjogdnVlX3ZpcnR1YWxfc2Nyb2xsZXJfZXNtW1wiYVwiIC8qIFJlY3ljbGVTY3JvbGxlciAqL11cbiAgfSxcbiAgbWl4aW5zOiBbU3R5bGVzSGFuZGxlcl0sXG4gIHByb3BzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdDb3VudHJ5U2VsZWN0b3InXG4gICAgfSxcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogW1N0cmluZywgT2JqZWN0XSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnQ2hvb3NlIGNvdW50cnknXG4gICAgfSxcbiAgICBoaW50OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBTdHJpbmdcbiAgICB9LFxuICAgIHNpemU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFN0cmluZ1xuICAgIH0sXG4gICAgZXJyb3I6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgZGlzYWJsZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgdmFsaWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgZGFyazoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBpdGVtczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiBBcnJheSxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBwcmVmZXJyZWRDb3VudHJpZXM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgb25seUNvdW50cmllczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBpZ25vcmVkQ291bnRyaWVzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIG5vRmxhZ3M6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgY291bnRyaWVzSGVpZ2h0OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiAzNVxuICAgIH0sXG4gICAgc2hvd0NvZGVPbkxpc3Q6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNGb2N1czogZmFsc2UsXG4gICAgICBoYXNMaXN0T3BlbjogZmFsc2UsXG4gICAgICBzZWxlY3RlZEluZGV4OiBudWxsLFxuICAgICAgdG1wVmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICBxdWVyeTogJycsXG4gICAgICBpbmRleEl0ZW1Ub1Nob3c6IDAsXG4gICAgICBpc0hvdmVyOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaXRlbUhlaWdodDogZnVuY3Rpb24gaXRlbUhlaWdodCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQodGhpcy5jb3VudHJpZXNIZWlnaHQsIFwicHhcIilcbiAgICAgIH07XG4gICAgfSxcbiAgICBsaXN0SGVpZ2h0OiBmdW5jdGlvbiBsaXN0SGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdCgodGhpcy5jb3VudHJpZXNIZWlnaHQgKyAxKSAqIDcsIFwicHhcIiksXG4gICAgICAgIG1heEhlaWdodDogXCJcIi5jb25jYXQoKHRoaXMuY291bnRyaWVzSGVpZ2h0ICsgMSkgKiA3LCBcInB4XCIpXG4gICAgICB9O1xuICAgIH0sXG4gICAgY291bnRyaWVzTGlzdDogZnVuY3Rpb24gY291bnRyaWVzTGlzdCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gIV90aGlzLmlnbm9yZWRDb3VudHJpZXMuaW5jbHVkZXMoaXRlbS5pc28yKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY291bnRyaWVzRmlsdGVyZWQ6IGZ1bmN0aW9uIGNvdW50cmllc0ZpbHRlcmVkKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjb3VudHJpZXMgPSB0aGlzLm9ubHlDb3VudHJpZXMgfHwgdGhpcy5wcmVmZXJyZWRDb3VudHJpZXM7XG4gICAgICByZXR1cm4gY291bnRyaWVzLm1hcChmdW5jdGlvbiAoY291bnRyeSkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmNvdW50cmllc0xpc3QuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpdGVtLmlzbzIuaW5jbHVkZXMoY291bnRyeSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBvdGhlckNvdW50cmllczogZnVuY3Rpb24gb3RoZXJDb3VudHJpZXMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuY291bnRyaWVzTGlzdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICFfdGhpczMucHJlZmVycmVkQ291bnRyaWVzLmluY2x1ZGVzKGl0ZW0uaXNvMik7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNvdW50cmllc1NvcnRlZDogZnVuY3Rpb24gY291bnRyaWVzU29ydGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZmVycmVkQ291bnRyaWVzID8gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmNvdW50cmllc0ZpbHRlcmVkKSwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMub3RoZXJDb3VudHJpZXMpKSA6IHRoaXMub25seUNvdW50cmllcyA/IHRoaXMuY291bnRyaWVzRmlsdGVyZWQgOiB0aGlzLmNvdW50cmllc0xpc3Q7XG4gICAgfSxcbiAgICBzZWxlY3RlZFZhbHVlSW5kZXg6IGZ1bmN0aW9uIHNlbGVjdGVkVmFsdWVJbmRleCgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMuY291bnRyaWVzU29ydGVkLmZpbmRJbmRleChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5pc28yID09PSBfdGhpczQudmFsdWU7XG4gICAgICB9KSA6IG51bGw7XG4gICAgfSxcbiAgICB0bXBWYWx1ZUluZGV4OiBmdW5jdGlvbiB0bXBWYWx1ZUluZGV4KCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLmNvdW50cmllc1NvcnRlZC5maW5kSW5kZXgoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMuaXNvMiA9PT0gX3RoaXM1LnRtcFZhbHVlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBjYWxsaW5nQ29kZTogZnVuY3Rpb24gY2FsbGluZ0NvZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSA/IFwiK1wiLmNvbmNhdChpbmRleF9lczZfZ2V0Q291bnRyeUNhbGxpbmdDb2RlKHRoaXMudmFsdWUpKSA6IG51bGw7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdXBkYXRlSG92ZXJTdGF0ZTogZnVuY3Rpb24gdXBkYXRlSG92ZXJTdGF0ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5pc0hvdmVyID0gdmFsdWU7XG4gICAgfSxcbiAgICBoYW5kbGVCbHVyOiBmdW5jdGlvbiBoYW5kbGVCbHVyKGUpIHtcbiAgICAgIGlmICh0aGlzLiRlbC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSByZXR1cm47XG4gICAgICB0aGlzLmlzRm9jdXMgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2xvc2VMaXN0KCk7XG4gICAgfSxcbiAgICB0b2dnbGVMaXN0OiBmdW5jdGlvbiB0b2dnbGVMaXN0KCkge1xuICAgICAgdGhpcy4kcmVmcy5jb3VudHJpZXNMaXN0Lm9mZnNldFBhcmVudCA/IHRoaXMuY2xvc2VMaXN0KCkgOiB0aGlzLm9wZW5MaXN0KCk7XG4gICAgfSxcbiAgICBvcGVuTGlzdDogZnVuY3Rpb24gb3Blbkxpc3QoKSB7XG4gICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy4kcmVmcy5Db3VudHJ5U2VsZWN0b3IuZm9jdXMoKTtcbiAgICAgICAgdGhpcy4kZW1pdCgnb3BlbicpO1xuICAgICAgICB0aGlzLmlzRm9jdXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmhhc0xpc3RPcGVuID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUpIHRoaXMuc2Nyb2xsVG9TZWxlY3RlZE9uRm9jdXModGhpcy5zZWxlY3RlZFZhbHVlSW5kZXgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xvc2VMaXN0OiBmdW5jdGlvbiBjbG9zZUxpc3QoKSB7XG4gICAgICB0aGlzLiRlbWl0KCdjbG9zZScpO1xuICAgICAgdGhpcy5oYXNMaXN0T3BlbiA9IGZhbHNlO1xuICAgIH0sXG4gICAgdXBkYXRlVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdXBkYXRlVmFsdWUgPSBfYXN5bmNUb0dlbmVyYXRvcihcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUodmFsKSB7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLnRtcFZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdmFsIHx8IG51bGwpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRuZXh0VGljaygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlTGlzdCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gdXBkYXRlVmFsdWUoX3gpIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVWYWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlVmFsdWU7XG4gICAgfSgpLFxuICAgIHNjcm9sbFRvU2VsZWN0ZWRPbkZvY3VzOiBmdW5jdGlvbiBzY3JvbGxUb1NlbGVjdGVkT25Gb2N1cyhhcnJheUluZGV4KSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0aGlzLmluZGV4SXRlbVRvU2hvdyA9IGFycmF5SW5kZXggLSAzXG4gICAgICAgIF90aGlzNi4kcmVmcy5jb3VudHJpZXNMaXN0LnNjcm9sbFRvcCA9IGFycmF5SW5kZXggKiAoX3RoaXM2LmNvdW50cmllc0hlaWdodCArIDEpIC0gKF90aGlzNi5jb3VudHJpZXNIZWlnaHQgKyAxKSAqIDM7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGtleWJvYXJkTmF2OiBmdW5jdGlvbiBrZXlib2FyZE5hdihlKSB7XG4gICAgICB2YXIgY29kZSA9IGUua2V5Q29kZTtcblxuICAgICAgaWYgKGNvZGUgPT09IDQwIHx8IGNvZGUgPT09IDM4KSB7XG4gICAgICAgIC8vIGFycm93IHVwIGRvd25cbiAgICAgICAgaWYgKGUudmlldyAmJiBlLnZpZXcuZXZlbnQpIHtcbiAgICAgICAgICAvLyBUT0RPIDogSXQncyBub3QgY29tcGF0aWJsZSB3aXRoIEZpcmVGb3hcbiAgICAgICAgICBlLnZpZXcuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5oYXNMaXN0T3BlbikgdGhpcy5vcGVuTGlzdCgpO1xuICAgICAgICB2YXIgaW5kZXggPSBjb2RlID09PSA0MCA/IHRoaXMudG1wVmFsdWVJbmRleCArIDEgOiB0aGlzLnRtcFZhbHVlSW5kZXggLSAxO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEgfHwgaW5kZXggPj0gdGhpcy5jb3VudHJpZXNTb3J0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgaW5kZXggPSBpbmRleCA9PT0gLTEgPyB0aGlzLmNvdW50cmllc1NvcnRlZC5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG1wVmFsdWUgPSB0aGlzLmNvdW50cmllc1NvcnRlZFtpbmRleF0uaXNvMjtcbiAgICAgICAgdGhpcy5zY3JvbGxUb1NlbGVjdGVkT25Gb2N1cyhpbmRleCk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDEzKSB7XG4gICAgICAgIC8vIGVudGVyXG4gICAgICAgIHRoaXMuaGFzTGlzdE9wZW4gPyB0aGlzLnVwZGF0ZVZhbHVlKHRoaXMudG1wVmFsdWUpIDogdGhpcy5vcGVuTGlzdCgpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAyNykge1xuICAgICAgICAvLyBlc2NhcGVcbiAgICAgICAgdGhpcy5jbG9zZUxpc3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHR5cGluZyBhIGNvdW50cnkncyBuYW1lXG4gICAgICAgIHRoaXMuc2VhcmNoaW5nKGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2VhcmNoaW5nOiBmdW5jdGlvbiBzZWFyY2hpbmcoZSkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHZhciBjb2RlID0gZS5rZXlDb2RlO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucXVlcnlUaW1lcik7XG4gICAgICB0aGlzLnF1ZXJ5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM3LnF1ZXJ5ID0gJyc7XG4gICAgICB9LCAxMDAwKTtcbiAgICAgIHZhciBxID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcblxuICAgICAgaWYgKGNvZGUgPT09IDggJiYgdGhpcy5xdWVyeSAhPT0gJycpIHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkuc3Vic3RyaW5nKDAsIHRoaXMucXVlcnkubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKC9bYS16QS1aLWUgXS8udGVzdChxKSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzTGlzdE9wZW4pIHRoaXMub3Blbkxpc3QoKTtcbiAgICAgICAgdGhpcy5xdWVyeSArPSBlLmtleTtcbiAgICAgICAgdmFyIGNvdW50cmllcyA9IHRoaXMucHJlZmVycmVkQ291bnRyaWVzID8gdGhpcy5jb3VudHJpZXNTb3J0ZWQuc2xpY2UodGhpcy5wcmVmZXJyZWRDb3VudHJpZXMubGVuZ3RoKSA6IHRoaXMuY291bnRyaWVzU29ydGVkO1xuICAgICAgICB2YXIgcmVzdWx0SW5kZXggPSBjb3VudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgX3RoaXM3LnRtcFZhbHVlID0gYy5pc28yO1xuICAgICAgICAgIHJldHVybiBjLm5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKF90aGlzNy5xdWVyeSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZXN1bHRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLnNjcm9sbFRvU2VsZWN0ZWRPbkZvY3VzKHJlc3VsdEluZGV4ICsgKHRoaXMucHJlZmVycmVkQ291bnRyaWVzID8gdGhpcy5wcmVmZXJyZWRDb3VudHJpZXMubGVuZ3RoIDogMCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1Z1ZVBob25lTnVtYmVySW5wdXQvQ291bnRyeVNlbGVjdG9yL2luZGV4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBWdWVQaG9uZU51bWJlcklucHV0X0NvdW50cnlTZWxlY3RvcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChDb3VudHJ5U2VsZWN0b3J2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvVnVlUGhvbmVOdW1iZXJJbnB1dC9Db3VudHJ5U2VsZWN0b3IvaW5kZXgudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NDZlMTA1ZGUmbGFuZz1zY3NzJnNjb3BlZD10cnVlJlxudmFyIENvdW50cnlTZWxlY3RvcnZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfNDZlMTA1ZGVfbGFuZ19zY3NzX3Njb3BlZF90cnVlXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzMzE0XCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9WdWVQaG9uZU51bWJlcklucHV0L0NvdW50cnlTZWxlY3Rvci9pbmRleC52dWVcblxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIENvdW50cnlTZWxlY3Rvcl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIFZ1ZVBob25lTnVtYmVySW5wdXRfQ291bnRyeVNlbGVjdG9ydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBDb3VudHJ5U2VsZWN0b3J2dWVfdHlwZV90ZW1wbGF0ZV9pZF80NmUxMDVkZV9zY29wZWRfdHJ1ZV9yZW5kZXIsXG4gIENvdW50cnlTZWxlY3RvcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzQ2ZTEwNWRlX3Njb3BlZF90cnVlX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiNDZlMTA1ZGVcIixcbiAgbnVsbFxuICBcbilcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgQ291bnRyeVNlbGVjdG9yID0gKENvdW50cnlTZWxlY3Rvcl9jb21wb25lbnQuZXhwb3J0cyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9WdWVQaG9uZU51bWJlcklucHV0L2Fzc2V0cy9sb2NhbGVzL2luZGV4LmpzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBsb2NhbGVzID0gKHtcbiAgY291bnRyeVNlbGVjdG9yTGFiZWw6ICdDb3VudHJ5IGNvZGUnLFxuICBjb3VudHJ5U2VsZWN0b3JFcnJvcjogJ0Nob29zZSBjb3VudHJ5JyxcbiAgcGhvbmVOdW1iZXJMYWJlbDogJ1Bob25lIG51bWJlcicsXG4gIGV4YW1wbGU6ICdFeGFtcGxlOidcbn0pO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb2xvci10cmFuc2Zvcm1lci11aS9saWIvaW5kZXgubWluLmpzXG52YXIgaW5kZXhfbWluID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ4ODNcIik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvVnVlUGhvbmVOdW1iZXJJbnB1dC9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBWdWVQaG9uZU51bWJlcklucHV0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cblxuXG5cblxuXG5cbnZhciBWdWVQaG9uZU51bWJlcklucHV0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfZ2V0U2hhZG93Q29sb3IgPSBmdW5jdGlvbiBnZXRTaGFkb3dDb2xvcihjb2xvcikge1xuICByZXR1cm4gT2JqZWN0KGluZGV4X21pbltcImlzQ29sb3JOYW1lXCJdKShjb2xvcikgPyBPYmplY3QoaW5kZXhfbWluW1wiSGV4VG9SZ2JhXCJdKShPYmplY3QoaW5kZXhfbWluW1wiY29sb3JOYW1lVG9IZXhcIl0pKGNvbG9yKSwgMC43KSA6IE9iamVjdChpbmRleF9taW5bXCJIZXhUb1JnYmFcIl0pKGNvbG9yLCAwLjcpO1xufTtcblxudmFyIGJyb3dzZXJMb2NhbGUgPSBmdW5jdGlvbiBicm93c2VyTG9jYWxlKCkge1xuICBpZiAoIXdpbmRvdykgcmV0dXJuIG51bGw7XG4gIHZhciBicm93c2VyTG9jYWxlID0gd2luZG93Lm5hdmlnYXRvci51c2VyTGFuZ3VhZ2UgfHwgd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZTtcbiAgdmFyIGxvY2FsZSA9IGJyb3dzZXJMb2NhbGUgPyBicm93c2VyTG9jYWxlLnN1YnN0cigzLCA0KS50b1VwcGVyQ2FzZSgpIDogbnVsbDtcbiAgaWYgKGxvY2FsZSA9PT0gJycpIGxvY2FsZSA9IGJyb3dzZXJMb2NhbGUuc3Vic3RyKDAsIDIpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiBsb2NhbGU7XG59O1xuXG52YXIgVnVlUGhvbmVOdW1iZXJJbnB1dHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2lzQ291bnRyeUF2YWlsYWJsZSA9IGZ1bmN0aW9uIGlzQ291bnRyeUF2YWlsYWJsZShsb2NhbGUpIHtcbiAgcmV0dXJuIGNvdW50cmllc0lzby5pbmNsdWRlcyhsb2NhbGUpO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgVnVlUGhvbmVOdW1iZXJJbnB1dHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdNYXpQaG9uZU51bWJlcklucHV0JyxcbiAgY29tcG9uZW50czoge1xuICAgIElucHV0VGVsOiBJbnB1dFRlbCxcbiAgICBDb3VudHJ5U2VsZWN0b3I6IENvdW50cnlTZWxlY3RvclxuICB9LFxuICBwcm9wczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBpZDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ01helBob25lTnVtYmVySW5wdXQnXG4gICAgfSxcbiAgICBjb2xvcjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RvZGdlcmJsdWUnXG4gICAgfSxcbiAgICB2YWxpZENvbG9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAneWVsbG93Z3JlZW4nXG4gICAgfSxcbiAgICBlcnJvckNvbG9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnb3JhbmdlcmVkJ1xuICAgIH0sXG4gICAgZGFya0NvbG9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnIzQyNDI0MidcbiAgICB9LFxuICAgIGRpc2FibGVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGRlZmF1bHRDb3VudHJ5Q29kZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgcHJlZmVycmVkQ291bnRyaWVzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIG9ubHlDb3VudHJpZXM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgaWdub3JlZENvdW50cmllczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiBBcnJheVxuICAgIH0sXG4gICAgdHJhbnNsYXRpb25zOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiBudWxsXG4gICAgfSxcbiAgICBub1ZhbGlkYXRvclN0YXRlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIG5vRmxhZ3M6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgZXJyb3I6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgbm9FeGFtcGxlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHJlcXVpcmVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGNvdW50cmllc0hlaWdodDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMzBcbiAgICB9LFxuICAgIG5vVXNlQnJvd3NlckxvY2FsZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBmZXRjaENvdW50cnk6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgbm9Db3VudHJ5U2VsZWN0b3I6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgc2hvd0NvZGVPbkxpc3Q6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgZGFyazoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBib3JkZXJSYWRpdXM6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDRcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdHM6IHt9LFxuICAgICAgdXNlckxvY2FsZTogdGhpcy5kZWZhdWx0Q291bnRyeUNvZGUsXG4gICAgICBsYXN0S2V5UHJlc3NlZDogbnVsbFxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgdW5pcXVlSWQ6IGZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuaWQsIFwiLVwiKS5jb25jYXQodGhpcy5fdWlkKTtcbiAgICB9LFxuICAgIHQ6IGZ1bmN0aW9uIHQoKSB7XG4gICAgICByZXR1cm4gVnVlUGhvbmVOdW1iZXJJbnB1dHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX29iamVjdFNwcmVhZCh7fSwgbG9jYWxlcywge30sIHRoaXMudHJhbnNsYXRpb25zKTtcbiAgICB9LFxuICAgIGNvZGVzQ291bnRyaWVzOiBmdW5jdGlvbiBjb2Rlc0NvdW50cmllcygpIHtcbiAgICAgIHJldHVybiBjb3VudHJpZXM7XG4gICAgfSxcbiAgICBjb3VudHJ5Q29kZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXJMb2NhbGUgfHwgdGhpcy5yZXN1bHRzLmNvdW50cnlDb2RlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0NvdW50cnkpIHtcbiAgICAgICAgdGhpcy5zZXRMb2NhbGUobmV3Q291bnRyeSk7XG4gICAgICAgIHRoaXMuJHJlZnMuUGhvbmVOdW1iZXJJbnB1dC4kZWwucXVlcnlTZWxlY3RvcignaW5wdXQnKS5mb2N1cygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGhvbmVOdW1iZXI6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdQaG9uZSkge1xuICAgICAgICB0aGlzLmVtaXRWYWx1ZXMoe1xuICAgICAgICAgIGNvdW50cnlDb2RlOiB0aGlzLmNvdW50cnlDb2RlLFxuICAgICAgICAgIHBob25lTnVtYmVyOiBuZXdQaG9uZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3VsZENob29zZUNvdW50cnk6IGZ1bmN0aW9uIHNob3VsZENob29zZUNvdW50cnkoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuY291bnRyeUNvZGUgJiYgISF0aGlzLnBob25lTnVtYmVyO1xuICAgIH0sXG4gICAgcGhvbmVGb3JtYXR0ZWQ6IGZ1bmN0aW9uIHBob25lRm9ybWF0dGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cy5mb3JtYXRJbnRlcm5hdGlvbmFsO1xuICAgIH0sXG4gICAgaXNWYWxpZDogZnVuY3Rpb24gaXNWYWxpZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMuaXNWYWxpZDtcbiAgICB9LFxuICAgIHBob25lTnVtYmVyRXhhbXBsZTogZnVuY3Rpb24gcGhvbmVOdW1iZXJFeGFtcGxlKCkge1xuICAgICAgdmFyIHBob25lTnVtYmVyID0gdGhpcy5jb3VudHJ5Q29kZSA/IGluZGV4X2VzNl9nZXRFeGFtcGxlTnVtYmVyKHRoaXMuY291bnRyeUNvZGUsIGV4YW1wbGVzX21vYmlsZSkgOiBudWxsO1xuICAgICAgcmV0dXJuIHBob25lTnVtYmVyID8gcGhvbmVOdW1iZXIuZm9ybWF0TmF0aW9uYWwoKSA6IG51bGw7XG4gICAgfSxcbiAgICBoYXNFbXB0eVBob25lOiBmdW5jdGlvbiBoYXNFbXB0eVBob25lKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGhvbmVOdW1iZXIgPT09ICcnIHx8IHRoaXMucGhvbmVOdW1iZXIgPT09IG51bGw7XG4gICAgfSxcbiAgICBoaW50VmFsdWU6IGZ1bmN0aW9uIGhpbnRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vRXhhbXBsZSB8fCAhdGhpcy5waG9uZU51bWJlckV4YW1wbGUgPyBudWxsIDogdGhpcy5oYXNFbXB0eVBob25lIHx8IHRoaXMuaXNWYWxpZCA/IG51bGwgOiBcIlwiLmNvbmNhdCh0aGlzLnQuZXhhbXBsZSwgXCIgXCIpLmNvbmNhdCh0aGlzLnBob25lTnVtYmVyRXhhbXBsZSk7XG4gICAgfSxcbiAgICB0aGVtZTogZnVuY3Rpb24gdGhlbWUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xvclZhbHVlOiB0aGlzLmNvbG9yLFxuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yXG4gICAgICAgIH0sXG4gICAgICAgIHRleHRDb2xvcjoge1xuICAgICAgICAgIGNvbG9yOiAnIzc0NzQ3NCdcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dERhcmtDb2xvcjoge1xuICAgICAgICAgIGNvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpJ1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZENvbG9yOiB7XG4gICAgICAgICAgY29sb3I6IHRoaXMudmFsaWRDb2xvclxuICAgICAgICB9LFxuICAgICAgICBlcnJvckNvbG9yOiB7XG4gICAgICAgICAgY29sb3I6IHRoaXMuZXJyb3JDb2xvclxuICAgICAgICB9LFxuICAgICAgICBkYXJrQ29sb3I6IHtcbiAgICAgICAgICBjb2xvcjogdGhpcy5kYXJrQ29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgYmdDb2xvcjoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5jb2xvclxuICAgICAgICB9LFxuICAgICAgICBiZ1ZhbGlkQ29sb3I6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMudmFsaWRDb2xvclxuICAgICAgICB9LFxuICAgICAgICBiZ0Vycm9yQ29sb3I6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuZXJyb3JDb2xvclxuICAgICAgICB9LFxuICAgICAgICBiZ0RhcmtDb2xvcjoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5kYXJrQ29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogdGhpcy5jb2xvclxuICAgICAgICB9LFxuICAgICAgICBib3JkZXJWYWxpZENvbG9yOiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMudmFsaWRDb2xvclxuICAgICAgICB9LFxuICAgICAgICBib3JkZXJFcnJvckNvbG9yOiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMuZXJyb3JDb2xvclxuICAgICAgICB9LFxuICAgICAgICBib3JkZXJEYXJrQ29sb3I6IHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogdGhpcy5kYXJrQ29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgYm94U2hhZG93Q29sb3I6IHtcbiAgICAgICAgICBib3hTaGFkb3c6IFwiMCAwIDAgMC4xMjVyZW0gXCIuY29uY2F0KFZ1ZVBob25lTnVtYmVySW5wdXR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19nZXRTaGFkb3dDb2xvcih0aGlzLmNvbG9yKSlcbiAgICAgICAgfSxcbiAgICAgICAgYm94U2hhZG93VmFsaWQ6IHtcbiAgICAgICAgICBib3hTaGFkb3c6IFwiMCAwIDAgMC4xMjVyZW0gXCIuY29uY2F0KFZ1ZVBob25lTnVtYmVySW5wdXR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19nZXRTaGFkb3dDb2xvcih0aGlzLnZhbGlkQ29sb3IpKVxuICAgICAgICB9LFxuICAgICAgICBib3hTaGFkb3dFcnJvcjoge1xuICAgICAgICAgIGJveFNoYWRvdzogXCIwIDAgMCAwLjEyNXJlbSBcIi5jb25jYXQoVnVlUGhvbmVOdW1iZXJJbnB1dHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2dldFNoYWRvd0NvbG9yKHRoaXMuZXJyb3JDb2xvcikpXG4gICAgICAgIH0sXG4gICAgICAgIGJvcmRlclJhZGl1czoge1xuICAgICAgICAgIGJvcmRlclJhZGl1czogXCJcIi5jb25jYXQodGhpcy5ib3JkZXJSYWRpdXMsIFwicHhcIilcbiAgICAgICAgfSxcbiAgICAgICAgYm9yZGVyTGVmdFJhZGl1czoge1xuICAgICAgICAgIGJvcmRlclRvcExlZnRSYWRpdXM6IFwiXCIuY29uY2F0KHRoaXMuYm9yZGVyUmFkaXVzLCBcInB4XCIpLFxuICAgICAgICAgIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IFwiXCIuY29uY2F0KHRoaXMuYm9yZGVyUmFkaXVzLCBcInB4XCIpXG4gICAgICAgIH0sXG4gICAgICAgIGJvcmRlclJpZ2h0UmFkaXVzOiB7XG4gICAgICAgICAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IFwiXCIuY29uY2F0KHRoaXMuYm9yZGVyUmFkaXVzLCBcInB4XCIpLFxuICAgICAgICAgIGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOiBcIlwiLmNvbmNhdCh0aGlzLmJvcmRlclJhZGl1cywgXCJweFwiKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBkZWZhdWx0Q291bnRyeUNvZGU6IGZ1bmN0aW9uIGRlZmF1bHRDb3VudHJ5Q29kZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gb2xkVmFsdWUpIHJldHVybjtcbiAgICAgIHRoaXMuc2V0TG9jYWxlKG5ld1ZhbHVlKTtcbiAgICB9LFxuICAgIHBob25lTnVtYmVyOiB7XG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAvLyBpbml0IGNvbXBvbmVudCAoY291bnRyeUNvZGUgJiBwaG9uZU51bWJlcikgaWYgcGhvbmUgbnVtYmVyIGlzIHByb3ZpZGVcbiAgICAgICAgaWYgKG5ld1ZhbHVlICYmIG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICAgIHZhciBwaG9uZU51bWJlciA9IGluZGV4X2VzNl9wYXJzZVBob25lTnVtYmVyRnJvbVN0cmluZyhuZXdWYWx1ZSk7XG5cbiAgICAgICAgICBpZiAocGhvbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFZhbHVlcyh7XG4gICAgICAgICAgICAgIHBob25lTnVtYmVyOiBwaG9uZU51bWJlci5uYXRpb25hbE51bWJlcixcbiAgICAgICAgICAgICAgY291bnRyeUNvZGU6IHRoaXMuY291bnRyeUNvZGUgPyB0aGlzLmNvdW50cnlDb2RlIDogcGhvbmVOdW1iZXIuY291bnRyeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW1tZWRpYXRlOiB0cnVlXG4gICAgfVxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9tb3VudGVkID0gX2FzeW5jVG9HZW5lcmF0b3IoXG4gICAgLyojX19QVVJFX18qL1xuICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICBpZiAodGhpcy5waG9uZU51bWJlciAmJiB0aGlzLmRlZmF1bHRDb3VudHJ5Q29kZSkgdGhpcy5lbWl0VmFsdWVzKHtcbiAgICAgICAgICAgICAgICBjb3VudHJ5Q29kZTogdGhpcy5kZWZhdWx0Q291bnRyeUNvZGUsXG4gICAgICAgICAgICAgICAgcGhvbmVOdW1iZXI6IHRoaXMucGhvbmVOdW1iZXJcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKCEodGhpcy5kZWZhdWx0Q291bnRyeUNvZGUgJiYgdGhpcy5mZXRjaENvdW50cnkpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01helBob25lTnVtYmVySW5wdXQ6IERvIG5vdCB1c2UgXCJmZXRjaC1jb3VudHJ5XCIgYW5kIFwiZGVmYXVsdC1jb3VudHJ5LWNvZGVcIiBvcHRpb25zIGluIHRoZSBzYW1lIHRpbWUnKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBpZiAoISh0aGlzLmRlZmF1bHRDb3VudHJ5Q29kZSAmJiB0aGlzLm5vVXNlQnJvd3NlckxvY2FsZSkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF6UGhvbmVOdW1iZXJJbnB1dDogSWYgeW91IHVzZSBhIFwiZGVmYXVsdC1jb3VudHJ5LWNvZGVcIiwgZG8gbm90IHVzZSBcIm5vLXVzZS1icm93c2VyLWxvY2FsZVwiIG9wdGlvbnMnKTtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVmYXVsdENvdW50cnlDb2RlKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHRoaXMuZmV0Y2hDb3VudHJ5ID8gdGhpcy5mZXRjaENvdW50cnlDb2RlKCkgOiAhdGhpcy5ub1VzZUJyb3dzZXJMb2NhbGUgPyB0aGlzLnNldExvY2FsZShicm93c2VyTG9jYWxlKCkpIDogbnVsbDtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDExO1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfY29udGV4dC50MCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzAsIDExXV0pO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICByZXR1cm4gX21vdW50ZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW91bnRlZDtcbiAgfSgpLFxuICBtZXRob2RzOiB7XG4gICAgZ2V0QXNZb3VUeXBlRm9ybWF0OiBmdW5jdGlvbiBnZXRBc1lvdVR5cGVGb3JtYXQocGF5bG9hZCkge1xuICAgICAgdmFyIGNvdW50cnlDb2RlID0gcGF5bG9hZC5jb3VudHJ5Q29kZSxcbiAgICAgICAgICBwaG9uZU51bWJlciA9IHBheWxvYWQucGhvbmVOdW1iZXI7XG4gICAgICB2YXIgYXNZb3VUeXBlID0gbmV3IGluZGV4X2VzNl9Bc1lvdVR5cGUoY291bnRyeUNvZGUpO1xuICAgICAgcmV0dXJuIHBob25lTnVtYmVyID8gYXNZb3VUeXBlLmlucHV0KHBob25lTnVtYmVyKSA6IG51bGw7XG4gICAgfSxcbiAgICBnZXRQYXJzZVBob25lTnVtYmVyRnJvbVN0cmluZzogZnVuY3Rpb24gZ2V0UGFyc2VQaG9uZU51bWJlckZyb21TdHJpbmcoX3JlZikge1xuICAgICAgdmFyIHBob25lTnVtYmVyID0gX3JlZi5waG9uZU51bWJlcixcbiAgICAgICAgICBjb3VudHJ5Q29kZSA9IF9yZWYuY291bnRyeUNvZGU7XG4gICAgICB2YXIgcGFyc2luZyA9IHBob25lTnVtYmVyICYmIGNvdW50cnlDb2RlID8gaW5kZXhfZXM2X3BhcnNlUGhvbmVOdW1iZXJGcm9tU3RyaW5nKHBob25lTnVtYmVyLCBjb3VudHJ5Q29kZSkgOiBudWxsO1xuICAgICAgcmV0dXJuIFZ1ZVBob25lTnVtYmVySW5wdXR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19vYmplY3RTcHJlYWQoe1xuICAgICAgICBjb3VudHJ5Q29kZTogY291bnRyeUNvZGUsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlXG4gICAgICB9LCBwaG9uZU51bWJlciAmJiBwaG9uZU51bWJlciAhPT0gJycgPyB7XG4gICAgICAgIHBob25lTnVtYmVyOiBwaG9uZU51bWJlclxuICAgICAgfSA6IG51bGwsIHt9LCBwYXJzaW5nID8ge1xuICAgICAgICBjb3VudHJ5Q2FsbGluZ0NvZGU6IHBhcnNpbmcuY291bnRyeUNhbGxpbmdDb2RlLFxuICAgICAgICBmb3JtYXR0ZWROdW1iZXI6IHBhcnNpbmcubnVtYmVyLFxuICAgICAgICBuYXRpb25hbE51bWJlcjogcGFyc2luZy5uYXRpb25hbE51bWJlcixcbiAgICAgICAgaXNWYWxpZDogcGFyc2luZy5pc1ZhbGlkKCksXG4gICAgICAgIHR5cGU6IHBhcnNpbmcuZ2V0VHlwZSgpLFxuICAgICAgICBmb3JtYXRJbnRlcm5hdGlvbmFsOiBwYXJzaW5nLmZvcm1hdEludGVybmF0aW9uYWwoKSxcbiAgICAgICAgZm9ybWF0TmF0aW9uYWw6IHBhcnNpbmcuZm9ybWF0TmF0aW9uYWwoKSxcbiAgICAgICAgdXJpOiBwYXJzaW5nLmdldFVSSSgpLFxuICAgICAgICBlMTY0OiBwYXJzaW5nLmZvcm1hdCgnRS4xNjQnKVxuICAgICAgfSA6IG51bGwpO1xuICAgIH0sXG4gICAgZW1pdFZhbHVlczogZnVuY3Rpb24gZW1pdFZhbHVlcyhwYXlsb2FkKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgYXNZb3VUeXBlID0gdGhpcy5nZXRBc1lvdVR5cGVGb3JtYXQocGF5bG9hZCk7XG4gICAgICB2YXIgYmFja1NwYWNlUHJlc3NlZCA9IHRoaXMubGFzdEtleVByZXNzZWQgPT09IDg7XG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsYXN0Q2hhcmFjT2ZQaG9uZU51bWJlciA9IF90aGlzLnBob25lTnVtYmVyID8gX3RoaXMucGhvbmVOdW1iZXIudHJpbSgpLnNsaWNlKC0xKSA6IGZhbHNlO1xuXG4gICAgICAgIGlmIChiYWNrU3BhY2VQcmVzc2VkICYmIGxhc3RDaGFyYWNPZlBob25lTnVtYmVyICYmIGxhc3RDaGFyYWNPZlBob25lTnVtYmVyLnNsaWNlKC0xKSA9PT0gJyknKSB7XG4gICAgICAgICAgYXNZb3VUeXBlID0gX3RoaXMucGhvbmVOdW1iZXIuc2xpY2UoMCwgLTIpO1xuICAgICAgICAgIHBheWxvYWQucGhvbmVOdW1iZXIgPSBfdGhpcy5waG9uZU51bWJlci5zbGljZSgwLCAtMik7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5yZXN1bHRzID0gX3RoaXMuZ2V0UGFyc2VQaG9uZU51bWJlckZyb21TdHJpbmcocGF5bG9hZCk7XG5cbiAgICAgICAgX3RoaXMuJGVtaXQoJ3VwZGF0ZScsIF90aGlzLnJlc3VsdHMpO1xuXG4gICAgICAgIF90aGlzLiRlbWl0KCdpbnB1dCcsIGFzWW91VHlwZSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNldExvY2FsZTogZnVuY3Rpb24gc2V0TG9jYWxlKGxvY2FsZSkge1xuICAgICAgdmFyIGNvdW50cnlBdmFpbGFibGUgPSBWdWVQaG9uZU51bWJlcklucHV0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfaXNDb3VudHJ5QXZhaWxhYmxlKGxvY2FsZSk7XG5cbiAgICAgIGlmIChjb3VudHJ5QXZhaWxhYmxlICYmIGxvY2FsZSkge1xuICAgICAgICB0aGlzLnVzZXJMb2NhbGUgPSBjb3VudHJ5QXZhaWxhYmxlID8gbG9jYWxlIDogbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0VmFsdWVzKHtcbiAgICAgICAgICBjb3VudHJ5Q29kZTogbG9jYWxlLFxuICAgICAgICAgIHBob25lTnVtYmVyOiB0aGlzLnBob25lTnVtYmVyXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghY291bnRyeUF2YWlsYWJsZSAmJiBsb2NhbGUpIHtcbiAgICAgICAgd2luZG93LmNvbnNvbGUud2FybihcIlRoZSBsb2NhbGUgXCIuY29uY2F0KGxvY2FsZSwgXCIgaXMgbm90IGF2YWlsYWJsZVwiKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBmZXRjaENvdW50cnlDb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2ZldGNoQ291bnRyeUNvZGUgPSBfYXN5bmNUb0dlbmVyYXRvcihcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICB2YXIgcmVzcG9uc2UsIHJlc3BvbnNlVGV4dCwgcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoKCdodHRwczovL2lwMmMub3JnL3MnKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0ID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3BvbnNlVGV4dCB8fCAnJykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdFswXSA9PT0gJzEnKSB0aGlzLnNldExvY2FsZShyZXN1bHQuc3Vic3RyKDIsIDIpKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxMTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX2NvbnRleHQyLnQwKTtcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1swLCAxMV1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZmV0Y2hDb3VudHJ5Q29kZSgpIHtcbiAgICAgICAgcmV0dXJuIF9mZXRjaENvdW50cnlDb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmZXRjaENvdW50cnlDb2RlO1xuICAgIH0oKVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL1Z1ZVBob25lTnVtYmVySW5wdXQvaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19WdWVQaG9uZU51bWJlcklucHV0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFZ1ZVBob25lTnVtYmVySW5wdXR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvVnVlUGhvbmVOdW1iZXJJbnB1dC9pbmRleC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xOWM5YTFjNyZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXG52YXIgVnVlUGhvbmVOdW1iZXJJbnB1dHZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfMTljOWExYzdfbGFuZ19zY3NzX3Njb3BlZF90cnVlXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2OTk2XCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9WdWVQaG9uZU51bWJlcklucHV0L2luZGV4LnZ1ZVxuXG5cblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgVnVlUGhvbmVOdW1iZXJJbnB1dF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIHNyY19WdWVQaG9uZU51bWJlcklucHV0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiMTljOWExYzdcIixcbiAgbnVsbFxuICBcbilcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgVnVlUGhvbmVOdW1iZXJJbnB1dCA9IChWdWVQaG9uZU51bWJlcklucHV0X2NvbXBvbmVudC5leHBvcnRzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0B2dWUvY2xpLXNlcnZpY2UvbGliL2NvbW1hbmRzL2J1aWxkL2VudHJ5LWxpYi5qc1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGVudHJ5X2xpYiA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFZ1ZVBob25lTnVtYmVySW5wdXQpO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZmRlZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSlbXCJkZWZhdWx0XCJdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dnVlLXBob25lLW51bWJlci1pbnB1dC5jb21tb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9